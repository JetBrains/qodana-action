"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb2, mod) => function __require() {
  return mod || (0, cb2[__getOwnPropNames(cb2)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// ../common/cli.json
var version, checksum;
var init_cli = __esm({
  "../common/cli.json"() {
    version = "2024.3.4";
    checksum = {
      windows_x86_64: "247f927727bb7e5d14ae8dba4bad456728dc8b8d5baf092bf3ca3a3da9d25745",
      linux_arm64: "f0402b0a43c22efcaf35f24e2b1784f93633463d85639e86537302ff6798fd9c",
      darwin_arm64: "bf45a74f8f856d9224ab985d3b83cef6767d6c6a4a137cc57850a5a9997e5d96",
      darwin_x86_64: "41134c5baa1f2308d8e8f299bc1f145586908373c71a2730a705eab13e03bd83",
      windows_arm64: "2cbe1108e6c9c051b3ee874d5ffd808805986001b82d0835d36f60ebd818b4ad",
      linux_x86_64: "b443bcdbb0d11c77eedad082a9fa1932143ac38f31260c975111c89ea222479a"
    };
  }
});

// ../node_modules/process-nextick-args/index.js
var require_process_nextick_args = __commonJS({
  "../node_modules/process-nextick-args/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || !process.version || process.version.indexOf("v0.") === 0 || process.version.indexOf("v1.") === 0 && process.version.indexOf("v1.8.") !== 0) {
      module2.exports = { nextTick };
    } else {
      module2.exports = process;
    }
    function nextTick(fn, arg1, arg2, arg3) {
      if (typeof fn !== "function") {
        throw new TypeError('"callback" argument must be a function');
      }
      var len = arguments.length;
      var args, i;
      switch (len) {
        case 0:
        case 1:
          return process.nextTick(fn);
        case 2:
          return process.nextTick(function afterTickOne() {
            fn.call(null, arg1);
          });
        case 3:
          return process.nextTick(function afterTickTwo() {
            fn.call(null, arg1, arg2);
          });
        case 4:
          return process.nextTick(function afterTickThree() {
            fn.call(null, arg1, arg2, arg3);
          });
        default:
          args = new Array(len - 1);
          i = 0;
          while (i < args.length) {
            args[i++] = arguments[i];
          }
          return process.nextTick(function afterTick() {
            fn.apply(null, args);
          });
      }
    }
  }
});

// ../node_modules/jszip/node_modules/isarray/index.js
var require_isarray = __commonJS({
  "../node_modules/jszip/node_modules/isarray/index.js"(exports2, module2) {
    var toString2 = {}.toString;
    module2.exports = Array.isArray || function(arr) {
      return toString2.call(arr) == "[object Array]";
    };
  }
});

// ../node_modules/jszip/node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "../node_modules/jszip/node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    module2.exports = require("stream");
  }
});

// ../node_modules/jszip/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "../node_modules/jszip/node_modules/safe-buffer/index.js"(exports2, module2) {
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size2, fill, encoding) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size2);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size2);
    };
    SafeBuffer.allocUnsafeSlow = function(size2) {
      if (typeof size2 !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size2);
    };
  }
});

// ../node_modules/core-util-is/lib/util.js
var require_util = __commonJS({
  "../node_modules/core-util-is/lib/util.js"(exports2) {
    function isArray(arg) {
      if (Array.isArray) {
        return Array.isArray(arg);
      }
      return objectToString(arg) === "[object Array]";
    }
    exports2.isArray = isArray;
    function isBoolean2(arg) {
      return typeof arg === "boolean";
    }
    exports2.isBoolean = isBoolean2;
    function isNull2(arg) {
      return arg === null;
    }
    exports2.isNull = isNull2;
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports2.isNullOrUndefined = isNullOrUndefined;
    function isNumber(arg) {
      return typeof arg === "number";
    }
    exports2.isNumber = isNumber;
    function isString(arg) {
      return typeof arg === "string";
    }
    exports2.isString = isString;
    function isSymbol(arg) {
      return typeof arg === "symbol";
    }
    exports2.isSymbol = isSymbol;
    function isUndefined2(arg) {
      return arg === void 0;
    }
    exports2.isUndefined = isUndefined2;
    function isRegExp(re) {
      return objectToString(re) === "[object RegExp]";
    }
    exports2.isRegExp = isRegExp;
    function isObject2(arg) {
      return typeof arg === "object" && arg !== null;
    }
    exports2.isObject = isObject2;
    function isDate(d) {
      return objectToString(d) === "[object Date]";
    }
    exports2.isDate = isDate;
    function isError(e) {
      return objectToString(e) === "[object Error]" || e instanceof Error;
    }
    exports2.isError = isError;
    function isFunction2(arg) {
      return typeof arg === "function";
    }
    exports2.isFunction = isFunction2;
    function isPrimitive(arg) {
      return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
      typeof arg === "undefined";
    }
    exports2.isPrimitive = isPrimitive;
    exports2.isBuffer = require("buffer").Buffer.isBuffer;
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
  }
});

// ../node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "../node_modules/inherits/inherits_browser.js"(exports2, module2) {
    if (typeof Object.create === "function") {
      module2.exports = function inherits(ctor2, superCtor) {
        if (superCtor) {
          ctor2.super_ = superCtor;
          ctor2.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor2,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      };
    } else {
      module2.exports = function inherits(ctor2, superCtor) {
        if (superCtor) {
          ctor2.super_ = superCtor;
          var TempCtor = function() {
          };
          TempCtor.prototype = superCtor.prototype;
          ctor2.prototype = new TempCtor();
          ctor2.prototype.constructor = ctor2;
        }
      };
    }
  }
});

// ../node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "../node_modules/inherits/inherits.js"(exports2, module2) {
    try {
      util = require("util");
      if (typeof util.inherits !== "function") throw "";
      module2.exports = util.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util;
  }
});

// ../node_modules/jszip/node_modules/readable-stream/lib/internal/streams/BufferList.js
var require_BufferList = __commonJS({
  "../node_modules/jszip/node_modules/readable-stream/lib/internal/streams/BufferList.js"(exports2, module2) {
    "use strict";
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    var Buffer2 = require_safe_buffer().Buffer;
    var util = require("util");
    function copyBuffer(src, target, offset) {
      src.copy(target, offset);
    }
    module2.exports = function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      BufferList.prototype.push = function push2(v) {
        var entry = { data: v, next: null };
        if (this.length > 0) this.tail.next = entry;
        else this.head = entry;
        this.tail = entry;
        ++this.length;
      };
      BufferList.prototype.unshift = function unshift(v) {
        var entry = { data: v, next: this.head };
        if (this.length === 0) this.tail = entry;
        this.head = entry;
        ++this.length;
      };
      BufferList.prototype.shift = function shift() {
        if (this.length === 0) return;
        var ret = this.head.data;
        if (this.length === 1) this.head = this.tail = null;
        else this.head = this.head.next;
        --this.length;
        return ret;
      };
      BufferList.prototype.clear = function clear() {
        this.head = this.tail = null;
        this.length = 0;
      };
      BufferList.prototype.join = function join(s) {
        if (this.length === 0) return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      };
      BufferList.prototype.concat = function concat(n) {
        if (this.length === 0) return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      };
      return BufferList;
    }();
    if (util && util.inspect && util.inspect.custom) {
      module2.exports.prototype[util.inspect.custom] = function() {
        var obj = util.inspect({ length: this.length });
        return this.constructor.name + " " + obj;
      };
    }
  }
});

// ../node_modules/jszip/node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "../node_modules/jszip/node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    function destroy(err, cb2) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb2) {
          cb2(err);
        } else if (err) {
          if (!this._writableState) {
            pna.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb2 && err2) {
          if (!_this._writableState) {
            pna.nextTick(emitErrorNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            pna.nextTick(emitErrorNT, _this, err2);
          }
        } else if (cb2) {
          cb2(err2);
        }
      });
      return this;
    }
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    module2.exports = {
      destroy,
      undestroy
    };
  }
});

// ../node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "../node_modules/util-deprecate/node.js"(exports2, module2) {
    module2.exports = require("util").deprecate;
  }
});

// ../node_modules/jszip/node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "../node_modules/jszip/node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    var asyncWrite = !process.browser && ["v0.10", "v0.9."].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
    var Duplex;
    Writable.WritableState = WritableState;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk2) {
      return Buffer2.from(chunk2);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var destroyImpl = require_destroy();
    util.inherits(Writable, Stream);
    function nop() {
    }
    function WritableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      var hwm = options.highWaterMark;
      var writableHwm = options.writableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0) this.highWaterMark = hwm;
      else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;
      else this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    WritableState.prototype.getBuffer = function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    };
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(function() {
            return this.getBuffer();
          }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_3) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: function(object2) {
          if (realHasInstance.call(this, object2)) return true;
          if (this !== Writable) return false;
          return object2 && object2._writableState instanceof WritableState;
        }
      });
    } else {
      realHasInstance = function(object2) {
        return object2 instanceof this;
      };
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
        return new Writable(options);
      }
      this._writableState = new WritableState(options, this);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    Writable.prototype.pipe = function() {
      this.emit("error", new Error("Cannot pipe, not readable"));
    };
    function writeAfterEnd(stream, cb2) {
      var er = new Error("write after end");
      stream.emit("error", er);
      pna.nextTick(cb2, er);
    }
    function validChunk(stream, state, chunk2, cb2) {
      var valid = true;
      var er = false;
      if (chunk2 === null) {
        er = new TypeError("May not write null values to stream");
      } else if (typeof chunk2 !== "string" && chunk2 !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      if (er) {
        stream.emit("error", er);
        pna.nextTick(cb2, er);
        valid = false;
      }
      return valid;
    }
    Writable.prototype.write = function(chunk2, encoding, cb2) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk2);
      if (isBuf && !Buffer2.isBuffer(chunk2)) {
        chunk2 = _uint8ArrayToBuffer(chunk2);
      }
      if (typeof encoding === "function") {
        cb2 = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb2 !== "function") cb2 = nop;
      if (state.ended) writeAfterEnd(this, cb2);
      else if (isBuf || validChunk(this, state, chunk2, cb2)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk2, encoding, cb2);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      var state = this._writableState;
      state.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1)) throw new TypeError("Unknown encoding: " + encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    };
    function decodeChunk(state, chunk2, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk2 === "string") {
        chunk2 = Buffer2.from(chunk2, encoding);
      }
      return chunk2;
    }
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function writeOrBuffer(stream, state, isBuf, chunk2, encoding, cb2) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk2, encoding);
        if (chunk2 !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk2 = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk2.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last2 = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk: chunk2,
          encoding,
          isBuf,
          callback: cb2,
          next: null
        };
        if (last2) {
          last2.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk2, encoding, cb2);
      }
      return ret;
    }
    function doWrite(stream, state, writev, len, chunk2, encoding, cb2) {
      state.writelen = len;
      state.writecb = cb2;
      state.writing = true;
      state.sync = true;
      if (writev) stream._writev(chunk2, state.onwrite);
      else stream._write(chunk2, encoding, state.onwrite);
      state.sync = false;
    }
    function onwriteError(stream, state, sync, er, cb2) {
      --state.pendingcb;
      if (sync) {
        pna.nextTick(cb2, er);
        pna.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
      } else {
        cb2(er);
        stream._writableState.errorEmitted = true;
        stream.emit("error", er);
        finishMaybe(stream, state);
      }
    }
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb2 = state.writecb;
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb2);
      else {
        var finished = needFinish(state);
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          asyncWrite(afterWrite, stream, state, finished, cb2);
        } else {
          afterWrite(stream, state, finished, cb2);
        }
      }
    }
    function afterWrite(stream, state, finished, cb2) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb2();
      finishMaybe(stream, state);
    }
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk2 = entry.chunk;
          var encoding = entry.encoding;
          var cb2 = entry.callback;
          var len = state.objectMode ? 1 : chunk2.length;
          doWrite(stream, state, false, len, chunk2, encoding, cb2);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    Writable.prototype._write = function(chunk2, encoding, cb2) {
      cb2(new Error("_write() is not implemented"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk2, encoding, cb2) {
      var state = this._writableState;
      if (typeof chunk2 === "function") {
        cb2 = chunk2;
        chunk2 = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb2 = encoding;
        encoding = null;
      }
      if (chunk2 !== null && chunk2 !== void 0) this.write(chunk2, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb2);
    };
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          stream.emit("error", err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function") {
          state.pendingcb++;
          state.finalCalled = true;
          pna.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
        }
      }
      return need;
    }
    function endWritable(stream, state, cb2) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb2) {
        if (state.finished) pna.nextTick(cb2);
        else stream.once("finish", cb2);
      }
      state.ended = true;
      stream.writable = false;
    }
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb2 = entry.callback;
        state.pendingcb--;
        cb2(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    Object.defineProperty(Writable.prototype, "destroyed", {
      get: function() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      },
      set: function(value) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value;
      }
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb2) {
      this.end();
      cb2(err);
    };
  }
});

// ../node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "../node_modules/jszip/node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    var objectKeys = Object.keys || function(obj) {
      var keys3 = [];
      for (var key in obj) {
        keys3.push(key);
      }
      return keys3;
    };
    module2.exports = Duplex;
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    util.inherits(Duplex, Readable);
    {
      keys2 = objectKeys(Writable.prototype);
      for (v = 0; v < keys2.length; v++) {
        method = keys2[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys2;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      if (options && options.readable === false) this.readable = false;
      if (options && options.writable === false) this.writable = false;
      this.allowHalfOpen = true;
      if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
      this.once("end", onend);
    }
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._writableState.highWaterMark;
      }
    });
    function onend() {
      if (this.allowHalfOpen || this._writableState.ended) return;
      pna.nextTick(onEndNT, this);
    }
    function onEndNT(self2) {
      self2.end();
    }
    Object.defineProperty(Duplex.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      },
      set: function(value) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value;
        this._writableState.destroyed = value;
      }
    });
    Duplex.prototype._destroy = function(err, cb2) {
      this.push(null);
      this.end();
      pna.nextTick(cb2, err);
    };
  }
});

// ../node_modules/jszip/node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "../node_modules/jszip/node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
  }
});

// ../node_modules/jszip/node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "../node_modules/jszip/node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    var pna = require_process_nextick_args();
    module2.exports = Readable;
    var isArray = require_isarray();
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = function(emitter, type) {
      return emitter.listeners(type).length;
    };
    var Stream = require_stream();
    var Buffer2 = require_safe_buffer().Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk2) {
      return Buffer2.from(chunk2);
    }
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    var debugUtil = require("util");
    var debug = void 0;
    if (debugUtil && debugUtil.debuglog) {
      debug = debugUtil.debuglog("stream");
    } else {
      debug = function() {
      };
    }
    var BufferList = require_BufferList();
    var destroyImpl = require_destroy();
    var StringDecoder;
    util.inherits(Readable, Stream);
    var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [fn, emitter._events[event]];
    }
    function ReadableState(options, stream) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      var isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      var hwm = options.highWaterMark;
      var readableHwm = options.readableHighWaterMark;
      var defaultHwm = this.objectMode ? 16 : 16 * 1024;
      if (hwm || hwm === 0) this.highWaterMark = hwm;
      else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;
      else this.highWaterMark = defaultHwm;
      this.highWaterMark = Math.floor(this.highWaterMark);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options);
      this._readableState = new ReadableState(options, this);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    Object.defineProperty(Readable.prototype, "destroyed", {
      get: function() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      },
      set: function(value) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value;
      }
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb2) {
      this.push(null);
      cb2(err);
    };
    Readable.prototype.push = function(chunk2, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk2 === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk2 = Buffer2.from(chunk2, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk2, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk2) {
      return readableAddChunk(this, chunk2, null, true, false);
    };
    function readableAddChunk(stream, chunk2, encoding, addToFront, skipChunkCheck) {
      var state = stream._readableState;
      if (chunk2 === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk2);
        if (er) {
          stream.emit("error", er);
        } else if (state.objectMode || chunk2 && chunk2.length > 0) {
          if (typeof chunk2 !== "string" && !state.objectMode && Object.getPrototypeOf(chunk2) !== Buffer2.prototype) {
            chunk2 = _uint8ArrayToBuffer(chunk2);
          }
          if (addToFront) {
            if (state.endEmitted) stream.emit("error", new Error("stream.unshift() after end event"));
            else addChunk(stream, state, chunk2, true);
          } else if (state.ended) {
            stream.emit("error", new Error("stream.push() after EOF"));
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk2 = state.decoder.write(chunk2);
              if (state.objectMode || chunk2.length !== 0) addChunk(stream, state, chunk2, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk2, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
        }
      }
      return needMoreData(state);
    }
    function addChunk(stream, state, chunk2, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        stream.emit("data", chunk2);
        stream.read(0);
      } else {
        state.length += state.objectMode ? 1 : chunk2.length;
        if (addToFront) state.buffer.unshift(chunk2);
        else state.buffer.push(chunk2);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    function chunkInvalid(state, chunk2) {
      var er;
      if (!_isUint8Array(chunk2) && typeof chunk2 !== "string" && chunk2 !== void 0 && !state.objectMode) {
        er = new TypeError("Invalid non-string/buffer chunk");
      }
      return er;
    }
    function needMoreData(state) {
      return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
    }
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      this._readableState.decoder = new StringDecoder(enc);
      this._readableState.encoding = enc;
      return this;
    };
    var MAX_HWM = 8388608;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    Readable.prototype.read = function(n) {
      debug("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
        debug("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug("reading or ended", doRead);
      } else if (doRead) {
        debug("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = true;
        n = 0;
      } else {
        state.length -= n;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      if (state.ended) return;
      if (state.decoder) {
        var chunk2 = state.decoder.end();
        if (chunk2 && chunk2.length) {
          state.buffer.push(chunk2);
          state.length += state.objectMode ? 1 : chunk2.length;
        }
      }
      state.ended = true;
      emitReadable(stream);
    }
    function emitReadable(stream) {
      var state = stream._readableState;
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug("emitReadable", state.flowing);
        state.emittedReadable = true;
        if (state.sync) pna.nextTick(emitReadable_, stream);
        else emitReadable_(stream);
      }
    }
    function emitReadable_(stream) {
      debug("emit readable");
      stream.emit("readable");
      flow(stream);
    }
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        pna.nextTick(maybeReadMore_, stream, state);
      }
    }
    function maybeReadMore_(stream, state) {
      var len = state.length;
      while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
        debug("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length)
          break;
        else len = state.length;
      }
      state.readingMore = false;
    }
    Readable.prototype._read = function(n) {
      this.emit("error", new Error("_read() is not implemented"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [state.pipes, dest];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) pna.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      function onend() {
        debug("onend");
        dest.end();
      }
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      var increasedAwaitDrain = false;
      src.on("data", ondata);
      function ondata(chunk2) {
        debug("ondata");
        increasedAwaitDrain = false;
        var ret = dest.write(chunk2);
        if (false === ret && !increasedAwaitDrain) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
            increasedAwaitDrain = true;
          }
          src.pause();
        }
      }
      function onerror(er) {
        debug("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) dest.emit("error", er);
      }
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      dest.once("close", onclose);
      function onfinish() {
        debug("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      dest.once("finish", onfinish);
      function unpipe() {
        debug("unpipe");
        src.unpipe(dest);
      }
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return function() {
        var state = src._readableState;
        debug("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      };
    }
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = { hasUnpiped: false };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) {
          dests[i].emit("unpipe", this, { hasUnpiped: false });
        }
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      if (ev === "data") {
        if (this._readableState.flowing !== false) this.resume();
      } else if (ev === "readable") {
        var state = this._readableState;
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.emittedReadable = false;
          if (!state.reading) {
            pna.nextTick(nReadingNextTick, this);
          } else if (state.length) {
            emitReadable(this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    function nReadingNextTick(self2) {
      debug("readable nexttick read 0");
      self2.read(0);
    }
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug("resume");
        state.flowing = true;
        resume(this, state);
      }
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        pna.nextTick(resume_, stream, state);
      }
    }
    function resume_(stream, state) {
      if (!state.reading) {
        debug("resume read 0");
        stream.read(0);
      }
      state.resumeScheduled = false;
      state.awaitDrain = 0;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    Readable.prototype.pause = function() {
      debug("call pause flowing=%j", this._readableState.flowing);
      if (false !== this._readableState.flowing) {
        debug("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug("flow", state.flowing);
      while (state.flowing && stream.read() !== null) {
      }
    }
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk2 = state.decoder.end();
          if (chunk2 && chunk2.length) _this.push(chunk2);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk2) {
        debug("wrapped data");
        if (state.decoder) chunk2 = state.decoder.write(chunk2);
        if (state.objectMode && (chunk2 === null || chunk2 === void 0)) return;
        else if (!state.objectMode && (!chunk2 || !chunk2.length)) return;
        var ret = _this.push(chunk2);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = /* @__PURE__ */ function(method) {
            return function() {
              return stream[method].apply(stream, arguments);
            };
          }(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: function() {
        return this._readableState.highWaterMark;
      }
    });
    Readable._fromList = fromList;
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.head.data;
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = fromListPartial(n, state.buffer, state.decoder);
      }
      return ret;
    }
    function fromListPartial(n, list, hasStrings) {
      var ret;
      if (n < list.head.data.length) {
        ret = list.head.data.slice(0, n);
        list.head.data = list.head.data.slice(n);
      } else if (n === list.head.data.length) {
        ret = list.shift();
      } else {
        ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
      }
      return ret;
    }
    function copyFromBufferString(n, list) {
      var p = list.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;
      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;
        else ret += str.slice(0, n);
        n -= nb;
        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) list.head = p.next;
            else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = str.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function copyFromBuffer(n, list) {
      var ret = Buffer2.allocUnsafe(n);
      var p = list.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;
      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;
        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) list.head = p.next;
            else list.head = list.tail = null;
          } else {
            list.head = p;
            p.data = buf.slice(nb);
          }
          break;
        }
        ++c;
      }
      list.length -= c;
      return ret;
    }
    function endReadable(stream) {
      var state = stream._readableState;
      if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
      if (!state.endEmitted) {
        state.ended = true;
        pna.nextTick(endReadableNT, state, stream);
      }
    }
    function endReadableNT(state, stream) {
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
      }
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
  }
});

// ../node_modules/jszip/node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "../node_modules/jszip/node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var Duplex = require_stream_duplex();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb2 = ts.writecb;
      if (!cb2) {
        return this.emit("error", new Error("write callback called multiple times"));
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb2(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function") {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    Transform.prototype.push = function(chunk2, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk2, encoding);
    };
    Transform.prototype._transform = function(chunk2, encoding, cb2) {
      throw new Error("_transform() is not implemented");
    };
    Transform.prototype._write = function(chunk2, encoding, cb2) {
      var ts = this._transformState;
      ts.writecb = cb2;
      ts.writechunk = chunk2;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb2) {
      var _this2 = this;
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb2(err2);
        _this2.emit("close");
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new Error("Calling transform done when ws.length != 0");
      if (stream._transformState.transforming) throw new Error("Calling transform done when still transforming");
      return stream.push(null);
    }
  }
});

// ../node_modules/jszip/node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "../node_modules/jszip/node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    var util = Object.create(require_util());
    util.inherits = require_inherits();
    util.inherits(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    PassThrough.prototype._transform = function(chunk2, encoding, cb2) {
      cb2(null, chunk2);
    };
  }
});

// ../node_modules/jszip/node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "../node_modules/jszip/node_modules/readable-stream/readable.js"(exports2, module2) {
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream;
      exports2 = module2.exports = Stream.Readable;
      exports2.Readable = Stream.Readable;
      exports2.Writable = Stream.Writable;
      exports2.Duplex = Stream.Duplex;
      exports2.Transform = Stream.Transform;
      exports2.PassThrough = Stream.PassThrough;
      exports2.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
    }
  }
});

// ../node_modules/jszip/lib/support.js
var require_support = __commonJS({
  "../node_modules/jszip/lib/support.js"(exports2) {
    "use strict";
    exports2.base64 = true;
    exports2.array = true;
    exports2.string = true;
    exports2.arraybuffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined";
    exports2.nodebuffer = typeof Buffer !== "undefined";
    exports2.uint8array = typeof Uint8Array !== "undefined";
    if (typeof ArrayBuffer === "undefined") {
      exports2.blob = false;
    } else {
      buffer = new ArrayBuffer(0);
      try {
        exports2.blob = new Blob([buffer], {
          type: "application/zip"
        }).size === 0;
      } catch (e) {
        try {
          Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
          builder = new Builder();
          builder.append(buffer);
          exports2.blob = builder.getBlob("application/zip").size === 0;
        } catch (e2) {
          exports2.blob = false;
        }
      }
    }
    var buffer;
    var Builder;
    var builder;
    try {
      exports2.nodestream = !!require_readable().Readable;
    } catch (e) {
      exports2.nodestream = false;
    }
  }
});

// ../node_modules/jszip/lib/base64.js
var require_base64 = __commonJS({
  "../node_modules/jszip/lib/base64.js"(exports2) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    exports2.encode = function(input) {
      var output = [];
      var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
      var i = 0, len = input.length, remainingBytes = len;
      var isArray = utils.getTypeOf(input) !== "string";
      while (i < input.length) {
        remainingBytes = len - i;
        if (!isArray) {
          chr1 = input.charCodeAt(i++);
          chr2 = i < len ? input.charCodeAt(i++) : 0;
          chr3 = i < len ? input.charCodeAt(i++) : 0;
        } else {
          chr1 = input[i++];
          chr2 = i < len ? input[i++] : 0;
          chr3 = i < len ? input[i++] : 0;
        }
        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = remainingBytes > 1 ? (chr2 & 15) << 2 | chr3 >> 6 : 64;
        enc4 = remainingBytes > 2 ? chr3 & 63 : 64;
        output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
      }
      return output.join("");
    };
    exports2.decode = function(input) {
      var chr1, chr2, chr3;
      var enc1, enc2, enc3, enc4;
      var i = 0, resultIndex = 0;
      var dataUrlPrefix = "data:";
      if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) {
        throw new Error("Invalid base64 input, it looks like a data url.");
      }
      input = input.replace(/[^A-Za-z0-9+/=]/g, "");
      var totalLength = input.length * 3 / 4;
      if (input.charAt(input.length - 1) === _keyStr.charAt(64)) {
        totalLength--;
      }
      if (input.charAt(input.length - 2) === _keyStr.charAt(64)) {
        totalLength--;
      }
      if (totalLength % 1 !== 0) {
        throw new Error("Invalid base64 input, bad content length.");
      }
      var output;
      if (support.uint8array) {
        output = new Uint8Array(totalLength | 0);
      } else {
        output = new Array(totalLength | 0);
      }
      while (i < input.length) {
        enc1 = _keyStr.indexOf(input.charAt(i++));
        enc2 = _keyStr.indexOf(input.charAt(i++));
        enc3 = _keyStr.indexOf(input.charAt(i++));
        enc4 = _keyStr.indexOf(input.charAt(i++));
        chr1 = enc1 << 2 | enc2 >> 4;
        chr2 = (enc2 & 15) << 4 | enc3 >> 2;
        chr3 = (enc3 & 3) << 6 | enc4;
        output[resultIndex++] = chr1;
        if (enc3 !== 64) {
          output[resultIndex++] = chr2;
        }
        if (enc4 !== 64) {
          output[resultIndex++] = chr3;
        }
      }
      return output;
    };
  }
});

// ../node_modules/jszip/lib/nodejsUtils.js
var require_nodejsUtils = __commonJS({
  "../node_modules/jszip/lib/nodejsUtils.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      /**
       * True if this is running in Nodejs, will be undefined in a browser.
       * In a browser, browserify won't include this file and the whole module
       * will be resolved an empty object.
       */
      isNode: typeof Buffer !== "undefined",
      /**
       * Create a new nodejs Buffer from an existing content.
       * @param {Object} data the data to pass to the constructor.
       * @param {String} encoding the encoding to use.
       * @return {Buffer} a new Buffer.
       */
      newBufferFrom: function(data, encoding) {
        if (Buffer.from && Buffer.from !== Uint8Array.from) {
          return Buffer.from(data, encoding);
        } else {
          if (typeof data === "number") {
            throw new Error('The "data" argument must not be a number');
          }
          return new Buffer(data, encoding);
        }
      },
      /**
       * Create a new nodejs Buffer with the specified size.
       * @param {Integer} size the size of the buffer.
       * @return {Buffer} a new Buffer.
       */
      allocBuffer: function(size2) {
        if (Buffer.alloc) {
          return Buffer.alloc(size2);
        } else {
          var buf = new Buffer(size2);
          buf.fill(0);
          return buf;
        }
      },
      /**
       * Find out if an object is a Buffer.
       * @param {Object} b the object to test.
       * @return {Boolean} true if the object is a Buffer, false otherwise.
       */
      isBuffer: function(b) {
        return Buffer.isBuffer(b);
      },
      isStream: function(obj) {
        return obj && typeof obj.on === "function" && typeof obj.pause === "function" && typeof obj.resume === "function";
      }
    };
  }
});

// ../node_modules/immediate/lib/index.js
var require_lib = __commonJS({
  "../node_modules/immediate/lib/index.js"(exports2, module2) {
    "use strict";
    var Mutation = global.MutationObserver || global.WebKitMutationObserver;
    var scheduleDrain;
    if (process.browser) {
      if (Mutation) {
        called = 0;
        observer = new Mutation(nextTick);
        element = global.document.createTextNode("");
        observer.observe(element, {
          characterData: true
        });
        scheduleDrain = function() {
          element.data = called = ++called % 2;
        };
      } else if (!global.setImmediate && typeof global.MessageChannel !== "undefined") {
        channel = new global.MessageChannel();
        channel.port1.onmessage = nextTick;
        scheduleDrain = function() {
          channel.port2.postMessage(0);
        };
      } else if ("document" in global && "onreadystatechange" in global.document.createElement("script")) {
        scheduleDrain = function() {
          var scriptEl = global.document.createElement("script");
          scriptEl.onreadystatechange = function() {
            nextTick();
            scriptEl.onreadystatechange = null;
            scriptEl.parentNode.removeChild(scriptEl);
            scriptEl = null;
          };
          global.document.documentElement.appendChild(scriptEl);
        };
      } else {
        scheduleDrain = function() {
          setTimeout(nextTick, 0);
        };
      }
    } else {
      scheduleDrain = function() {
        process.nextTick(nextTick);
      };
    }
    var called;
    var observer;
    var element;
    var channel;
    var draining;
    var queue = [];
    function nextTick() {
      draining = true;
      var i, oldQueue;
      var len = queue.length;
      while (len) {
        oldQueue = queue;
        queue = [];
        i = -1;
        while (++i < len) {
          oldQueue[i]();
        }
        len = queue.length;
      }
      draining = false;
    }
    module2.exports = immediate;
    function immediate(task) {
      if (queue.push(task) === 1 && !draining) {
        scheduleDrain();
      }
    }
  }
});

// ../node_modules/lie/lib/index.js
var require_lib2 = __commonJS({
  "../node_modules/lie/lib/index.js"(exports2, module2) {
    "use strict";
    var immediate = require_lib();
    function INTERNAL() {
    }
    var handlers = {};
    var REJECTED = ["REJECTED"];
    var FULFILLED = ["FULFILLED"];
    var PENDING = ["PENDING"];
    if (!process.browser) {
      UNHANDLED = ["UNHANDLED"];
    }
    var UNHANDLED;
    module2.exports = Promise2;
    function Promise2(resolver) {
      if (typeof resolver !== "function") {
        throw new TypeError("resolver must be a function");
      }
      this.state = PENDING;
      this.queue = [];
      this.outcome = void 0;
      if (!process.browser) {
        this.handled = UNHANDLED;
      }
      if (resolver !== INTERNAL) {
        safelyResolveThenable(this, resolver);
      }
    }
    Promise2.prototype.finally = function(callback) {
      if (typeof callback !== "function") {
        return this;
      }
      var p = this.constructor;
      return this.then(resolve2, reject3);
      function resolve2(value) {
        function yes() {
          return value;
        }
        return p.resolve(callback()).then(yes);
      }
      function reject3(reason) {
        function no() {
          throw reason;
        }
        return p.resolve(callback()).then(no);
      }
    };
    Promise2.prototype.catch = function(onRejected) {
      return this.then(null, onRejected);
    };
    Promise2.prototype.then = function(onFulfilled, onRejected) {
      if (typeof onFulfilled !== "function" && this.state === FULFILLED || typeof onRejected !== "function" && this.state === REJECTED) {
        return this;
      }
      var promise = new this.constructor(INTERNAL);
      if (!process.browser) {
        if (this.handled === UNHANDLED) {
          this.handled = null;
        }
      }
      if (this.state !== PENDING) {
        var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
        unwrap(promise, resolver, this.outcome);
      } else {
        this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
      }
      return promise;
    };
    function QueueItem(promise, onFulfilled, onRejected) {
      this.promise = promise;
      if (typeof onFulfilled === "function") {
        this.onFulfilled = onFulfilled;
        this.callFulfilled = this.otherCallFulfilled;
      }
      if (typeof onRejected === "function") {
        this.onRejected = onRejected;
        this.callRejected = this.otherCallRejected;
      }
    }
    QueueItem.prototype.callFulfilled = function(value) {
      handlers.resolve(this.promise, value);
    };
    QueueItem.prototype.otherCallFulfilled = function(value) {
      unwrap(this.promise, this.onFulfilled, value);
    };
    QueueItem.prototype.callRejected = function(value) {
      handlers.reject(this.promise, value);
    };
    QueueItem.prototype.otherCallRejected = function(value) {
      unwrap(this.promise, this.onRejected, value);
    };
    function unwrap(promise, func, value) {
      immediate(function() {
        var returnValue;
        try {
          returnValue = func(value);
        } catch (e) {
          return handlers.reject(promise, e);
        }
        if (returnValue === promise) {
          handlers.reject(promise, new TypeError("Cannot resolve promise with itself"));
        } else {
          handlers.resolve(promise, returnValue);
        }
      });
    }
    handlers.resolve = function(self2, value) {
      var result2 = tryCatch(getThen, value);
      if (result2.status === "error") {
        return handlers.reject(self2, result2.value);
      }
      var thenable = result2.value;
      if (thenable) {
        safelyResolveThenable(self2, thenable);
      } else {
        self2.state = FULFILLED;
        self2.outcome = value;
        var i = -1;
        var len = self2.queue.length;
        while (++i < len) {
          self2.queue[i].callFulfilled(value);
        }
      }
      return self2;
    };
    handlers.reject = function(self2, error) {
      self2.state = REJECTED;
      self2.outcome = error;
      if (!process.browser) {
        if (self2.handled === UNHANDLED) {
          immediate(function() {
            if (self2.handled === UNHANDLED) {
              process.emit("unhandledRejection", error, self2);
            }
          });
        }
      }
      var i = -1;
      var len = self2.queue.length;
      while (++i < len) {
        self2.queue[i].callRejected(error);
      }
      return self2;
    };
    function getThen(obj) {
      var then = obj && obj.then;
      if (obj && (typeof obj === "object" || typeof obj === "function") && typeof then === "function") {
        return function appyThen() {
          then.apply(obj, arguments);
        };
      }
    }
    function safelyResolveThenable(self2, thenable) {
      var called = false;
      function onError(value) {
        if (called) {
          return;
        }
        called = true;
        handlers.reject(self2, value);
      }
      function onSuccess(value) {
        if (called) {
          return;
        }
        called = true;
        handlers.resolve(self2, value);
      }
      function tryToUnwrap() {
        thenable(onSuccess, onError);
      }
      var result2 = tryCatch(tryToUnwrap);
      if (result2.status === "error") {
        onError(result2.value);
      }
    }
    function tryCatch(func, value) {
      var out = {};
      try {
        out.value = func(value);
        out.status = "success";
      } catch (e) {
        out.status = "error";
        out.value = e;
      }
      return out;
    }
    Promise2.resolve = resolve;
    function resolve(value) {
      if (value instanceof this) {
        return value;
      }
      return handlers.resolve(new this(INTERNAL), value);
    }
    Promise2.reject = reject2;
    function reject2(reason) {
      var promise = new this(INTERNAL);
      return handlers.reject(promise, reason);
    }
    Promise2.all = all;
    function all(iterable) {
      var self2 = this;
      if (Object.prototype.toString.call(iterable) !== "[object Array]") {
        return this.reject(new TypeError("must be an array"));
      }
      var len = iterable.length;
      var called = false;
      if (!len) {
        return this.resolve([]);
      }
      var values2 = new Array(len);
      var resolved = 0;
      var i = -1;
      var promise = new this(INTERNAL);
      while (++i < len) {
        allResolver(iterable[i], i);
      }
      return promise;
      function allResolver(value, i2) {
        self2.resolve(value).then(resolveFromAll, function(error) {
          if (!called) {
            called = true;
            handlers.reject(promise, error);
          }
        });
        function resolveFromAll(outValue) {
          values2[i2] = outValue;
          if (++resolved === len && !called) {
            called = true;
            handlers.resolve(promise, values2);
          }
        }
      }
    }
    Promise2.race = race;
    function race(iterable) {
      var self2 = this;
      if (Object.prototype.toString.call(iterable) !== "[object Array]") {
        return this.reject(new TypeError("must be an array"));
      }
      var len = iterable.length;
      var called = false;
      if (!len) {
        return this.resolve([]);
      }
      var i = -1;
      var promise = new this(INTERNAL);
      while (++i < len) {
        resolver(iterable[i]);
      }
      return promise;
      function resolver(value) {
        self2.resolve(value).then(function(response) {
          if (!called) {
            called = true;
            handlers.resolve(promise, response);
          }
        }, function(error) {
          if (!called) {
            called = true;
            handlers.reject(promise, error);
          }
        });
      }
    }
  }
});

// ../node_modules/jszip/lib/external.js
var require_external = __commonJS({
  "../node_modules/jszip/lib/external.js"(exports2, module2) {
    "use strict";
    var ES6Promise = null;
    if (typeof Promise !== "undefined") {
      ES6Promise = Promise;
    } else {
      ES6Promise = require_lib2();
    }
    module2.exports = {
      Promise: ES6Promise
    };
  }
});

// ../node_modules/setimmediate/setImmediate.js
var require_setImmediate = __commonJS({
  "../node_modules/setimmediate/setImmediate.js"(exports2) {
    (function(global2, undefined2) {
      "use strict";
      if (global2.setImmediate) {
        return;
      }
      var nextHandle = 1;
      var tasksByHandle = {};
      var currentlyRunningATask = false;
      var doc = global2.document;
      var registerImmediate;
      function setImmediate2(callback) {
        if (typeof callback !== "function") {
          callback = new Function("" + callback);
        }
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
        }
        var task = { callback, args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
      }
      function clearImmediate(handle) {
        delete tasksByHandle[handle];
      }
      function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
          case 0:
            callback();
            break;
          case 1:
            callback(args[0]);
            break;
          case 2:
            callback(args[0], args[1]);
            break;
          case 3:
            callback(args[0], args[1], args[2]);
            break;
          default:
            callback.apply(undefined2, args);
            break;
        }
      }
      function runIfPresent(handle) {
        if (currentlyRunningATask) {
          setTimeout(runIfPresent, 0, handle);
        } else {
          var task = tasksByHandle[handle];
          if (task) {
            currentlyRunningATask = true;
            try {
              run(task);
            } finally {
              clearImmediate(handle);
              currentlyRunningATask = false;
            }
          }
        }
      }
      function installNextTickImplementation() {
        registerImmediate = function(handle) {
          process.nextTick(function() {
            runIfPresent(handle);
          });
        };
      }
      function canUsePostMessage() {
        if (global2.postMessage && !global2.importScripts) {
          var postMessageIsAsynchronous = true;
          var oldOnMessage = global2.onmessage;
          global2.onmessage = function() {
            postMessageIsAsynchronous = false;
          };
          global2.postMessage("", "*");
          global2.onmessage = oldOnMessage;
          return postMessageIsAsynchronous;
        }
      }
      function installPostMessageImplementation() {
        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
          if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
            runIfPresent(+event.data.slice(messagePrefix.length));
          }
        };
        if (global2.addEventListener) {
          global2.addEventListener("message", onGlobalMessage, false);
        } else {
          global2.attachEvent("onmessage", onGlobalMessage);
        }
        registerImmediate = function(handle) {
          global2.postMessage(messagePrefix + handle, "*");
        };
      }
      function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
          var handle = event.data;
          runIfPresent(handle);
        };
        registerImmediate = function(handle) {
          channel.port2.postMessage(handle);
        };
      }
      function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
          var script = doc.createElement("script");
          script.onreadystatechange = function() {
            runIfPresent(handle);
            script.onreadystatechange = null;
            html.removeChild(script);
            script = null;
          };
          html.appendChild(script);
        };
      }
      function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
          setTimeout(runIfPresent, 0, handle);
        };
      }
      var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
      attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
      if ({}.toString.call(global2.process) === "[object process]") {
        installNextTickImplementation();
      } else if (canUsePostMessage()) {
        installPostMessageImplementation();
      } else if (global2.MessageChannel) {
        installMessageChannelImplementation();
      } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        installReadyStateChangeImplementation();
      } else {
        installSetTimeoutImplementation();
      }
      attachTo.setImmediate = setImmediate2;
      attachTo.clearImmediate = clearImmediate;
    })(typeof self === "undefined" ? typeof global === "undefined" ? exports2 : global : self);
  }
});

// ../node_modules/jszip/lib/utils.js
var require_utils = __commonJS({
  "../node_modules/jszip/lib/utils.js"(exports2) {
    "use strict";
    var support = require_support();
    var base64 = require_base64();
    var nodejsUtils = require_nodejsUtils();
    var external = require_external();
    require_setImmediate();
    function string2binary(str) {
      var result2 = null;
      if (support.uint8array) {
        result2 = new Uint8Array(str.length);
      } else {
        result2 = new Array(str.length);
      }
      return stringToArrayLike(str, result2);
    }
    exports2.newBlob = function(part, type) {
      exports2.checkSupport("blob");
      try {
        return new Blob([part], {
          type
        });
      } catch (e) {
        try {
          var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder;
          var builder = new Builder();
          builder.append(part);
          return builder.getBlob(type);
        } catch (e2) {
          throw new Error("Bug : can't construct the Blob.");
        }
      }
    };
    function identity2(input) {
      return input;
    }
    function stringToArrayLike(str, array) {
      for (var i = 0; i < str.length; ++i) {
        array[i] = str.charCodeAt(i) & 255;
      }
      return array;
    }
    var arrayToStringHelper = {
      /**
       * Transform an array of int into a string, chunk by chunk.
       * See the performances notes on arrayLikeToString.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @param {String} type the type of the array.
       * @param {Integer} chunk the chunk size.
       * @return {String} the resulting string.
       * @throws Error if the chunk is too big for the stack.
       */
      stringifyByChunk: function(array, type, chunk2) {
        var result2 = [], k = 0, len = array.length;
        if (len <= chunk2) {
          return String.fromCharCode.apply(null, array);
        }
        while (k < len) {
          if (type === "array" || type === "nodebuffer") {
            result2.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk2, len))));
          } else {
            result2.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk2, len))));
          }
          k += chunk2;
        }
        return result2.join("");
      },
      /**
       * Call String.fromCharCode on every item in the array.
       * This is the naive implementation, which generate A LOT of intermediate string.
       * This should be used when everything else fail.
       * @param {Array|ArrayBuffer|Uint8Array|Buffer} array the array to transform.
       * @return {String} the result.
       */
      stringifyByChar: function(array) {
        var resultStr = "";
        for (var i = 0; i < array.length; i++) {
          resultStr += String.fromCharCode(array[i]);
        }
        return resultStr;
      },
      applyCanBeUsed: {
        /**
         * true if the browser accepts to use String.fromCharCode on Uint8Array
         */
        uint8array: function() {
          try {
            return support.uint8array && String.fromCharCode.apply(null, new Uint8Array(1)).length === 1;
          } catch (e) {
            return false;
          }
        }(),
        /**
         * true if the browser accepts to use String.fromCharCode on nodejs Buffer.
         */
        nodebuffer: function() {
          try {
            return support.nodebuffer && String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length === 1;
          } catch (e) {
            return false;
          }
        }()
      }
    };
    function arrayLikeToString(array) {
      var chunk2 = 65536, type = exports2.getTypeOf(array), canUseApply = true;
      if (type === "uint8array") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array;
      } else if (type === "nodebuffer") {
        canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer;
      }
      if (canUseApply) {
        while (chunk2 > 1) {
          try {
            return arrayToStringHelper.stringifyByChunk(array, type, chunk2);
          } catch (e) {
            chunk2 = Math.floor(chunk2 / 2);
          }
        }
      }
      return arrayToStringHelper.stringifyByChar(array);
    }
    exports2.applyFromCharCode = arrayLikeToString;
    function arrayLikeToArrayLike(arrayFrom, arrayTo) {
      for (var i = 0; i < arrayFrom.length; i++) {
        arrayTo[i] = arrayFrom[i];
      }
      return arrayTo;
    }
    var transform = {};
    transform["string"] = {
      "string": identity2,
      "array": function(input) {
        return stringToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["string"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return stringToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": function(input) {
        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length));
      }
    };
    transform["array"] = {
      "string": arrayLikeToString,
      "array": identity2,
      "arraybuffer": function(input) {
        return new Uint8Array(input).buffer;
      },
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
      }
    };
    transform["arraybuffer"] = {
      "string": function(input) {
        return arrayLikeToString(new Uint8Array(input));
      },
      "array": function(input) {
        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength));
      },
      "arraybuffer": identity2,
      "uint8array": function(input) {
        return new Uint8Array(input);
      },
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(new Uint8Array(input));
      }
    };
    transform["uint8array"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return input.buffer;
      },
      "uint8array": identity2,
      "nodebuffer": function(input) {
        return nodejsUtils.newBufferFrom(input);
      }
    };
    transform["nodebuffer"] = {
      "string": arrayLikeToString,
      "array": function(input) {
        return arrayLikeToArrayLike(input, new Array(input.length));
      },
      "arraybuffer": function(input) {
        return transform["nodebuffer"]["uint8array"](input).buffer;
      },
      "uint8array": function(input) {
        return arrayLikeToArrayLike(input, new Uint8Array(input.length));
      },
      "nodebuffer": identity2
    };
    exports2.transformTo = function(outputType, input) {
      if (!input) {
        input = "";
      }
      if (!outputType) {
        return input;
      }
      exports2.checkSupport(outputType);
      var inputType = exports2.getTypeOf(input);
      var result2 = transform[inputType][outputType](input);
      return result2;
    };
    exports2.resolve = function(path2) {
      var parts = path2.split("/");
      var result2 = [];
      for (var index = 0; index < parts.length; index++) {
        var part = parts[index];
        if (part === "." || part === "" && index !== 0 && index !== parts.length - 1) {
          continue;
        } else if (part === "..") {
          result2.pop();
        } else {
          result2.push(part);
        }
      }
      return result2.join("/");
    };
    exports2.getTypeOf = function(input) {
      if (typeof input === "string") {
        return "string";
      }
      if (Object.prototype.toString.call(input) === "[object Array]") {
        return "array";
      }
      if (support.nodebuffer && nodejsUtils.isBuffer(input)) {
        return "nodebuffer";
      }
      if (support.uint8array && input instanceof Uint8Array) {
        return "uint8array";
      }
      if (support.arraybuffer && input instanceof ArrayBuffer) {
        return "arraybuffer";
      }
    };
    exports2.checkSupport = function(type) {
      var supported = support[type.toLowerCase()];
      if (!supported) {
        throw new Error(type + " is not supported by this platform");
      }
    };
    exports2.MAX_VALUE_16BITS = 65535;
    exports2.MAX_VALUE_32BITS = -1;
    exports2.pretty = function(str) {
      var res = "", code, i;
      for (i = 0; i < (str || "").length; i++) {
        code = str.charCodeAt(i);
        res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
      }
      return res;
    };
    exports2.delay = function(callback, args, self2) {
      setImmediate(function() {
        callback.apply(self2 || null, args || []);
      });
    };
    exports2.inherits = function(ctor2, superCtor) {
      var Obj = function() {
      };
      Obj.prototype = superCtor.prototype;
      ctor2.prototype = new Obj();
    };
    exports2.extend = function() {
      var result2 = {}, i, attr;
      for (i = 0; i < arguments.length; i++) {
        for (attr in arguments[i]) {
          if (Object.prototype.hasOwnProperty.call(arguments[i], attr) && typeof result2[attr] === "undefined") {
            result2[attr] = arguments[i][attr];
          }
        }
      }
      return result2;
    };
    exports2.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
      var promise = external.Promise.resolve(inputData).then(function(data) {
        var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
        if (isBlob && typeof FileReader !== "undefined") {
          return new external.Promise(function(resolve, reject2) {
            var reader = new FileReader();
            reader.onload = function(e) {
              resolve(e.target.result);
            };
            reader.onerror = function(e) {
              reject2(e.target.error);
            };
            reader.readAsArrayBuffer(data);
          });
        } else {
          return data;
        }
      });
      return promise.then(function(data) {
        var dataType = exports2.getTypeOf(data);
        if (!dataType) {
          return external.Promise.reject(
            new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?")
          );
        }
        if (dataType === "arraybuffer") {
          data = exports2.transformTo("uint8array", data);
        } else if (dataType === "string") {
          if (isBase64) {
            data = base64.decode(data);
          } else if (isBinary) {
            if (isOptimizedBinaryString !== true) {
              data = string2binary(data);
            }
          }
        }
        return data;
      });
    };
  }
});

// ../node_modules/jszip/lib/stream/GenericWorker.js
var require_GenericWorker = __commonJS({
  "../node_modules/jszip/lib/stream/GenericWorker.js"(exports2, module2) {
    "use strict";
    function GenericWorker(name) {
      this.name = name || "default";
      this.streamInfo = {};
      this.generatedError = null;
      this.extraStreamInfo = {};
      this.isPaused = true;
      this.isFinished = false;
      this.isLocked = false;
      this._listeners = {
        "data": [],
        "end": [],
        "error": []
      };
      this.previous = null;
    }
    GenericWorker.prototype = {
      /**
       * Push a chunk to the next workers.
       * @param {Object} chunk the chunk to push
       */
      push: function(chunk2) {
        this.emit("data", chunk2);
      },
      /**
       * End the stream.
       * @return {Boolean} true if this call ended the worker, false otherwise.
       */
      end: function() {
        if (this.isFinished) {
          return false;
        }
        this.flush();
        try {
          this.emit("end");
          this.cleanUp();
          this.isFinished = true;
        } catch (e) {
          this.emit("error", e);
        }
        return true;
      },
      /**
       * End the stream with an error.
       * @param {Error} e the error which caused the premature end.
       * @return {Boolean} true if this call ended the worker with an error, false otherwise.
       */
      error: function(e) {
        if (this.isFinished) {
          return false;
        }
        if (this.isPaused) {
          this.generatedError = e;
        } else {
          this.isFinished = true;
          this.emit("error", e);
          if (this.previous) {
            this.previous.error(e);
          }
          this.cleanUp();
        }
        return true;
      },
      /**
       * Add a callback on an event.
       * @param {String} name the name of the event (data, end, error)
       * @param {Function} listener the function to call when the event is triggered
       * @return {GenericWorker} the current object for chainability
       */
      on: function(name, listener) {
        this._listeners[name].push(listener);
        return this;
      },
      /**
       * Clean any references when a worker is ending.
       */
      cleanUp: function() {
        this.streamInfo = this.generatedError = this.extraStreamInfo = null;
        this._listeners = [];
      },
      /**
       * Trigger an event. This will call registered callback with the provided arg.
       * @param {String} name the name of the event (data, end, error)
       * @param {Object} arg the argument to call the callback with.
       */
      emit: function(name, arg) {
        if (this._listeners[name]) {
          for (var i = 0; i < this._listeners[name].length; i++) {
            this._listeners[name][i].call(this, arg);
          }
        }
      },
      /**
       * Chain a worker with an other.
       * @param {Worker} next the worker receiving events from the current one.
       * @return {worker} the next worker for chainability
       */
      pipe: function(next) {
        return next.registerPrevious(this);
      },
      /**
       * Same as `pipe` in the other direction.
       * Using an API with `pipe(next)` is very easy.
       * Implementing the API with the point of view of the next one registering
       * a source is easier, see the ZipFileWorker.
       * @param {Worker} previous the previous worker, sending events to this one
       * @return {Worker} the current worker for chainability
       */
      registerPrevious: function(previous) {
        if (this.isLocked) {
          throw new Error("The stream '" + this + "' has already been used.");
        }
        this.streamInfo = previous.streamInfo;
        this.mergeStreamInfo();
        this.previous = previous;
        var self2 = this;
        previous.on("data", function(chunk2) {
          self2.processChunk(chunk2);
        });
        previous.on("end", function() {
          self2.end();
        });
        previous.on("error", function(e) {
          self2.error(e);
        });
        return this;
      },
      /**
       * Pause the stream so it doesn't send events anymore.
       * @return {Boolean} true if this call paused the worker, false otherwise.
       */
      pause: function() {
        if (this.isPaused || this.isFinished) {
          return false;
        }
        this.isPaused = true;
        if (this.previous) {
          this.previous.pause();
        }
        return true;
      },
      /**
       * Resume a paused stream.
       * @return {Boolean} true if this call resumed the worker, false otherwise.
       */
      resume: function() {
        if (!this.isPaused || this.isFinished) {
          return false;
        }
        this.isPaused = false;
        var withError = false;
        if (this.generatedError) {
          this.error(this.generatedError);
          withError = true;
        }
        if (this.previous) {
          this.previous.resume();
        }
        return !withError;
      },
      /**
       * Flush any remaining bytes as the stream is ending.
       */
      flush: function() {
      },
      /**
       * Process a chunk. This is usually the method overridden.
       * @param {Object} chunk the chunk to process.
       */
      processChunk: function(chunk2) {
        this.push(chunk2);
      },
      /**
       * Add a key/value to be added in the workers chain streamInfo once activated.
       * @param {String} key the key to use
       * @param {Object} value the associated value
       * @return {Worker} the current worker for chainability
       */
      withStreamInfo: function(key, value) {
        this.extraStreamInfo[key] = value;
        this.mergeStreamInfo();
        return this;
      },
      /**
       * Merge this worker's streamInfo into the chain's streamInfo.
       */
      mergeStreamInfo: function() {
        for (var key in this.extraStreamInfo) {
          if (!Object.prototype.hasOwnProperty.call(this.extraStreamInfo, key)) {
            continue;
          }
          this.streamInfo[key] = this.extraStreamInfo[key];
        }
      },
      /**
       * Lock the stream to prevent further updates on the workers chain.
       * After calling this method, all calls to pipe will fail.
       */
      lock: function() {
        if (this.isLocked) {
          throw new Error("The stream '" + this + "' has already been used.");
        }
        this.isLocked = true;
        if (this.previous) {
          this.previous.lock();
        }
      },
      /**
       *
       * Pretty print the workers chain.
       */
      toString: function() {
        var me = "Worker " + this.name;
        if (this.previous) {
          return this.previous + " -> " + me;
        } else {
          return me;
        }
      }
    };
    module2.exports = GenericWorker;
  }
});

// ../node_modules/jszip/lib/utf8.js
var require_utf8 = __commonJS({
  "../node_modules/jszip/lib/utf8.js"(exports2) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var nodejsUtils = require_nodejsUtils();
    var GenericWorker = require_GenericWorker();
    var _utf8len = new Array(256);
    for (i = 0; i < 256; i++) {
      _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
    }
    var i;
    _utf8len[254] = _utf8len[254] = 1;
    var string2buf = function(str) {
      var buf, c, c2, m_pos, i2, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      if (support.uint8array) {
        buf = new Uint8Array(buf_len);
      } else {
        buf = new Array(buf_len);
      }
      for (i2 = 0, m_pos = 0; i2 < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i2++] = c;
        } else if (c < 2048) {
          buf[i2++] = 192 | c >>> 6;
          buf[i2++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i2++] = 224 | c >>> 12;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        } else {
          buf[i2++] = 240 | c >>> 18;
          buf[i2++] = 128 | c >>> 12 & 63;
          buf[i2++] = 128 | c >>> 6 & 63;
          buf[i2++] = 128 | c & 63;
        }
      }
      return buf;
    };
    var utf8border = function(buf, max2) {
      var pos;
      max2 = max2 || buf.length;
      if (max2 > buf.length) {
        max2 = buf.length;
      }
      pos = max2 - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max2;
      }
      if (pos === 0) {
        return max2;
      }
      return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
    };
    var buf2string = function(buf) {
      var i2, out, c, c_len;
      var len = buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i2 = 0; i2 < len; ) {
        c = buf[i2++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i2 += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i2 < len) {
          c = c << 6 | buf[i2++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      if (utf16buf.length !== out) {
        if (utf16buf.subarray) {
          utf16buf = utf16buf.subarray(0, out);
        } else {
          utf16buf.length = out;
        }
      }
      return utils.applyFromCharCode(utf16buf);
    };
    exports2.utf8encode = function utf8encode(str) {
      if (support.nodebuffer) {
        return nodejsUtils.newBufferFrom(str, "utf-8");
      }
      return string2buf(str);
    };
    exports2.utf8decode = function utf8decode(buf) {
      if (support.nodebuffer) {
        return utils.transformTo("nodebuffer", buf).toString("utf-8");
      }
      buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf);
      return buf2string(buf);
    };
    function Utf8DecodeWorker() {
      GenericWorker.call(this, "utf-8 decode");
      this.leftOver = null;
    }
    utils.inherits(Utf8DecodeWorker, GenericWorker);
    Utf8DecodeWorker.prototype.processChunk = function(chunk2) {
      var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk2.data);
      if (this.leftOver && this.leftOver.length) {
        if (support.uint8array) {
          var previousData = data;
          data = new Uint8Array(previousData.length + this.leftOver.length);
          data.set(this.leftOver, 0);
          data.set(previousData, this.leftOver.length);
        } else {
          data = this.leftOver.concat(data);
        }
        this.leftOver = null;
      }
      var nextBoundary = utf8border(data);
      var usableData = data;
      if (nextBoundary !== data.length) {
        if (support.uint8array) {
          usableData = data.subarray(0, nextBoundary);
          this.leftOver = data.subarray(nextBoundary, data.length);
        } else {
          usableData = data.slice(0, nextBoundary);
          this.leftOver = data.slice(nextBoundary, data.length);
        }
      }
      this.push({
        data: exports2.utf8decode(usableData),
        meta: chunk2.meta
      });
    };
    Utf8DecodeWorker.prototype.flush = function() {
      if (this.leftOver && this.leftOver.length) {
        this.push({
          data: exports2.utf8decode(this.leftOver),
          meta: {}
        });
        this.leftOver = null;
      }
    };
    exports2.Utf8DecodeWorker = Utf8DecodeWorker;
    function Utf8EncodeWorker() {
      GenericWorker.call(this, "utf-8 encode");
    }
    utils.inherits(Utf8EncodeWorker, GenericWorker);
    Utf8EncodeWorker.prototype.processChunk = function(chunk2) {
      this.push({
        data: exports2.utf8encode(chunk2.data),
        meta: chunk2.meta
      });
    };
    exports2.Utf8EncodeWorker = Utf8EncodeWorker;
  }
});

// ../node_modules/jszip/lib/stream/ConvertWorker.js
var require_ConvertWorker = __commonJS({
  "../node_modules/jszip/lib/stream/ConvertWorker.js"(exports2, module2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    var utils = require_utils();
    function ConvertWorker(destType) {
      GenericWorker.call(this, "ConvertWorker to " + destType);
      this.destType = destType;
    }
    utils.inherits(ConvertWorker, GenericWorker);
    ConvertWorker.prototype.processChunk = function(chunk2) {
      this.push({
        data: utils.transformTo(this.destType, chunk2.data),
        meta: chunk2.meta
      });
    };
    module2.exports = ConvertWorker;
  }
});

// ../node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js
var require_NodejsStreamOutputAdapter = __commonJS({
  "../node_modules/jszip/lib/nodejs/NodejsStreamOutputAdapter.js"(exports2, module2) {
    "use strict";
    var Readable = require_readable().Readable;
    var utils = require_utils();
    utils.inherits(NodejsStreamOutputAdapter, Readable);
    function NodejsStreamOutputAdapter(helper, options, updateCb) {
      Readable.call(this, options);
      this._helper = helper;
      var self2 = this;
      helper.on("data", function(data, meta) {
        if (!self2.push(data)) {
          self2._helper.pause();
        }
        if (updateCb) {
          updateCb(meta);
        }
      }).on("error", function(e) {
        self2.emit("error", e);
      }).on("end", function() {
        self2.push(null);
      });
    }
    NodejsStreamOutputAdapter.prototype._read = function() {
      this._helper.resume();
    };
    module2.exports = NodejsStreamOutputAdapter;
  }
});

// ../node_modules/jszip/lib/stream/StreamHelper.js
var require_StreamHelper = __commonJS({
  "../node_modules/jszip/lib/stream/StreamHelper.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var ConvertWorker = require_ConvertWorker();
    var GenericWorker = require_GenericWorker();
    var base64 = require_base64();
    var support = require_support();
    var external = require_external();
    var NodejsStreamOutputAdapter = null;
    if (support.nodestream) {
      try {
        NodejsStreamOutputAdapter = require_NodejsStreamOutputAdapter();
      } catch (e) {
      }
    }
    function transformZipOutput(type, content, mimeType) {
      switch (type) {
        case "blob":
          return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
        case "base64":
          return base64.encode(content);
        default:
          return utils.transformTo(type, content);
      }
    }
    function concat(type, dataArray) {
      var i, index = 0, res = null, totalLength = 0;
      for (i = 0; i < dataArray.length; i++) {
        totalLength += dataArray[i].length;
      }
      switch (type) {
        case "string":
          return dataArray.join("");
        case "array":
          return Array.prototype.concat.apply([], dataArray);
        case "uint8array":
          res = new Uint8Array(totalLength);
          for (i = 0; i < dataArray.length; i++) {
            res.set(dataArray[i], index);
            index += dataArray[i].length;
          }
          return res;
        case "nodebuffer":
          return Buffer.concat(dataArray);
        default:
          throw new Error("concat : unsupported type '" + type + "'");
      }
    }
    function accumulate(helper, updateCallback) {
      return new external.Promise(function(resolve, reject2) {
        var dataArray = [];
        var chunkType = helper._internalType, resultType = helper._outputType, mimeType = helper._mimeType;
        helper.on("data", function(data, meta) {
          dataArray.push(data);
          if (updateCallback) {
            updateCallback(meta);
          }
        }).on("error", function(err) {
          dataArray = [];
          reject2(err);
        }).on("end", function() {
          try {
            var result2 = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
            resolve(result2);
          } catch (e) {
            reject2(e);
          }
          dataArray = [];
        }).resume();
      });
    }
    function StreamHelper(worker, outputType, mimeType) {
      var internalType = outputType;
      switch (outputType) {
        case "blob":
        case "arraybuffer":
          internalType = "uint8array";
          break;
        case "base64":
          internalType = "string";
          break;
      }
      try {
        this._internalType = internalType;
        this._outputType = outputType;
        this._mimeType = mimeType;
        utils.checkSupport(internalType);
        this._worker = worker.pipe(new ConvertWorker(internalType));
        worker.lock();
      } catch (e) {
        this._worker = new GenericWorker("error");
        this._worker.error(e);
      }
    }
    StreamHelper.prototype = {
      /**
       * Listen a StreamHelper, accumulate its content and concatenate it into a
       * complete block.
       * @param {Function} updateCb the update callback.
       * @return Promise the promise for the accumulation.
       */
      accumulate: function(updateCb) {
        return accumulate(this, updateCb);
      },
      /**
       * Add a listener on an event triggered on a stream.
       * @param {String} evt the name of the event
       * @param {Function} fn the listener
       * @return {StreamHelper} the current helper.
       */
      on: function(evt, fn) {
        var self2 = this;
        if (evt === "data") {
          this._worker.on(evt, function(chunk2) {
            fn.call(self2, chunk2.data, chunk2.meta);
          });
        } else {
          this._worker.on(evt, function() {
            utils.delay(fn, arguments, self2);
          });
        }
        return this;
      },
      /**
       * Resume the flow of chunks.
       * @return {StreamHelper} the current helper.
       */
      resume: function() {
        utils.delay(this._worker.resume, [], this._worker);
        return this;
      },
      /**
       * Pause the flow of chunks.
       * @return {StreamHelper} the current helper.
       */
      pause: function() {
        this._worker.pause();
        return this;
      },
      /**
       * Return a nodejs stream for this helper.
       * @param {Function} updateCb the update callback.
       * @return {NodejsStreamOutputAdapter} the nodejs stream.
       */
      toNodejsStream: function(updateCb) {
        utils.checkSupport("nodestream");
        if (this._outputType !== "nodebuffer") {
          throw new Error(this._outputType + " is not supported by this method");
        }
        return new NodejsStreamOutputAdapter(this, {
          objectMode: this._outputType !== "nodebuffer"
        }, updateCb);
      }
    };
    module2.exports = StreamHelper;
  }
});

// ../node_modules/jszip/lib/defaults.js
var require_defaults = __commonJS({
  "../node_modules/jszip/lib/defaults.js"(exports2) {
    "use strict";
    exports2.base64 = false;
    exports2.binary = false;
    exports2.dir = false;
    exports2.createFolders = true;
    exports2.date = null;
    exports2.compression = null;
    exports2.compressionOptions = null;
    exports2.comment = null;
    exports2.unixPermissions = null;
    exports2.dosPermissions = null;
  }
});

// ../node_modules/jszip/lib/stream/DataWorker.js
var require_DataWorker = __commonJS({
  "../node_modules/jszip/lib/stream/DataWorker.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var DEFAULT_BLOCK_SIZE = 16 * 1024;
    function DataWorker(dataP) {
      GenericWorker.call(this, "DataWorker");
      var self2 = this;
      this.dataIsReady = false;
      this.index = 0;
      this.max = 0;
      this.data = null;
      this.type = "";
      this._tickScheduled = false;
      dataP.then(function(data) {
        self2.dataIsReady = true;
        self2.data = data;
        self2.max = data && data.length || 0;
        self2.type = utils.getTypeOf(data);
        if (!self2.isPaused) {
          self2._tickAndRepeat();
        }
      }, function(e) {
        self2.error(e);
      });
    }
    utils.inherits(DataWorker, GenericWorker);
    DataWorker.prototype.cleanUp = function() {
      GenericWorker.prototype.cleanUp.call(this);
      this.data = null;
    };
    DataWorker.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (!this._tickScheduled && this.dataIsReady) {
        this._tickScheduled = true;
        utils.delay(this._tickAndRepeat, [], this);
      }
      return true;
    };
    DataWorker.prototype._tickAndRepeat = function() {
      this._tickScheduled = false;
      if (this.isPaused || this.isFinished) {
        return;
      }
      this._tick();
      if (!this.isFinished) {
        utils.delay(this._tickAndRepeat, [], this);
        this._tickScheduled = true;
      }
    };
    DataWorker.prototype._tick = function() {
      if (this.isPaused || this.isFinished) {
        return false;
      }
      var size2 = DEFAULT_BLOCK_SIZE;
      var data = null, nextIndex = Math.min(this.max, this.index + size2);
      if (this.index >= this.max) {
        return this.end();
      } else {
        switch (this.type) {
          case "string":
            data = this.data.substring(this.index, nextIndex);
            break;
          case "uint8array":
            data = this.data.subarray(this.index, nextIndex);
            break;
          case "array":
          case "nodebuffer":
            data = this.data.slice(this.index, nextIndex);
            break;
        }
        this.index = nextIndex;
        return this.push({
          data,
          meta: {
            percent: this.max ? this.index / this.max * 100 : 0
          }
        });
      }
    };
    module2.exports = DataWorker;
  }
});

// ../node_modules/jszip/lib/crc32.js
var require_crc32 = __commonJS({
  "../node_modules/jszip/lib/crc32.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc = crc ^ -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    function crc32str(crc, str, len, pos) {
      var t = crcTable, end = pos + len;
      crc = crc ^ -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ str.charCodeAt(i)) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = function crc32wrapper(input, crc) {
      if (typeof input === "undefined" || !input.length) {
        return 0;
      }
      var isArray = utils.getTypeOf(input) !== "string";
      if (isArray) {
        return crc32(crc | 0, input, input.length, 0);
      } else {
        return crc32str(crc | 0, input, input.length, 0);
      }
    };
  }
});

// ../node_modules/jszip/lib/stream/Crc32Probe.js
var require_Crc32Probe = __commonJS({
  "../node_modules/jszip/lib/stream/Crc32Probe.js"(exports2, module2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    var crc32 = require_crc32();
    var utils = require_utils();
    function Crc32Probe() {
      GenericWorker.call(this, "Crc32Probe");
      this.withStreamInfo("crc32", 0);
    }
    utils.inherits(Crc32Probe, GenericWorker);
    Crc32Probe.prototype.processChunk = function(chunk2) {
      this.streamInfo.crc32 = crc32(chunk2.data, this.streamInfo.crc32 || 0);
      this.push(chunk2);
    };
    module2.exports = Crc32Probe;
  }
});

// ../node_modules/jszip/lib/stream/DataLengthProbe.js
var require_DataLengthProbe = __commonJS({
  "../node_modules/jszip/lib/stream/DataLengthProbe.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    function DataLengthProbe(propName) {
      GenericWorker.call(this, "DataLengthProbe for " + propName);
      this.propName = propName;
      this.withStreamInfo(propName, 0);
    }
    utils.inherits(DataLengthProbe, GenericWorker);
    DataLengthProbe.prototype.processChunk = function(chunk2) {
      if (chunk2) {
        var length = this.streamInfo[this.propName] || 0;
        this.streamInfo[this.propName] = length + chunk2.data.length;
      }
      GenericWorker.prototype.processChunk.call(this, chunk2);
    };
    module2.exports = DataLengthProbe;
  }
});

// ../node_modules/jszip/lib/compressedObject.js
var require_compressedObject = __commonJS({
  "../node_modules/jszip/lib/compressedObject.js"(exports2, module2) {
    "use strict";
    var external = require_external();
    var DataWorker = require_DataWorker();
    var Crc32Probe = require_Crc32Probe();
    var DataLengthProbe = require_DataLengthProbe();
    function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
      this.compressedSize = compressedSize;
      this.uncompressedSize = uncompressedSize;
      this.crc32 = crc32;
      this.compression = compression;
      this.compressedContent = data;
    }
    CompressedObject.prototype = {
      /**
       * Create a worker to get the uncompressed content.
       * @return {GenericWorker} the worker.
       */
      getContentWorker: function() {
        var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length"));
        var that = this;
        worker.on("end", function() {
          if (this.streamInfo["data_length"] !== that.uncompressedSize) {
            throw new Error("Bug : uncompressed data size mismatch");
          }
        });
        return worker;
      },
      /**
       * Create a worker to get the compressed content.
       * @return {GenericWorker} the worker.
       */
      getCompressedWorker: function() {
        return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression);
      }
    };
    CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
      return uncompressedWorker.pipe(new Crc32Probe()).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression);
    };
    module2.exports = CompressedObject;
  }
});

// ../node_modules/jszip/lib/zipObject.js
var require_zipObject = __commonJS({
  "../node_modules/jszip/lib/zipObject.js"(exports2, module2) {
    "use strict";
    var StreamHelper = require_StreamHelper();
    var DataWorker = require_DataWorker();
    var utf8 = require_utf8();
    var CompressedObject = require_compressedObject();
    var GenericWorker = require_GenericWorker();
    var ZipObject = function(name, data, options) {
      this.name = name;
      this.dir = options.dir;
      this.date = options.date;
      this.comment = options.comment;
      this.unixPermissions = options.unixPermissions;
      this.dosPermissions = options.dosPermissions;
      this._data = data;
      this._dataBinary = options.binary;
      this.options = {
        compression: options.compression,
        compressionOptions: options.compressionOptions
      };
    };
    ZipObject.prototype = {
      /**
       * Create an internal stream for the content of this object.
       * @param {String} type the type of each chunk.
       * @return StreamHelper the stream.
       */
      internalStream: function(type) {
        var result2 = null, outputType = "string";
        try {
          if (!type) {
            throw new Error("No output type specified.");
          }
          outputType = type.toLowerCase();
          var askUnicodeString = outputType === "string" || outputType === "text";
          if (outputType === "binarystring" || outputType === "text") {
            outputType = "string";
          }
          result2 = this._decompressWorker();
          var isUnicodeString = !this._dataBinary;
          if (isUnicodeString && !askUnicodeString) {
            result2 = result2.pipe(new utf8.Utf8EncodeWorker());
          }
          if (!isUnicodeString && askUnicodeString) {
            result2 = result2.pipe(new utf8.Utf8DecodeWorker());
          }
        } catch (e) {
          result2 = new GenericWorker("error");
          result2.error(e);
        }
        return new StreamHelper(result2, outputType, "");
      },
      /**
       * Prepare the content in the asked type.
       * @param {String} type the type of the result.
       * @param {Function} onUpdate a function to call on each internal update.
       * @return Promise the promise of the result.
       */
      async: function(type, onUpdate) {
        return this.internalStream(type).accumulate(onUpdate);
      },
      /**
       * Prepare the content as a nodejs stream.
       * @param {String} type the type of each chunk.
       * @param {Function} onUpdate a function to call on each internal update.
       * @return Stream the stream.
       */
      nodeStream: function(type, onUpdate) {
        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate);
      },
      /**
       * Return a worker for the compressed content.
       * @private
       * @param {Object} compression the compression object to use.
       * @param {Object} compressionOptions the options to use when compressing.
       * @return Worker the worker.
       */
      _compressWorker: function(compression, compressionOptions) {
        if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) {
          return this._data.getCompressedWorker();
        } else {
          var result2 = this._decompressWorker();
          if (!this._dataBinary) {
            result2 = result2.pipe(new utf8.Utf8EncodeWorker());
          }
          return CompressedObject.createWorkerFrom(result2, compression, compressionOptions);
        }
      },
      /**
       * Return a worker for the decompressed content.
       * @private
       * @return Worker the worker.
       */
      _decompressWorker: function() {
        if (this._data instanceof CompressedObject) {
          return this._data.getContentWorker();
        } else if (this._data instanceof GenericWorker) {
          return this._data;
        } else {
          return new DataWorker(this._data);
        }
      }
    };
    var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"];
    var removedFn = function() {
      throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
    };
    for (i = 0; i < removedMethods.length; i++) {
      ZipObject.prototype[removedMethods[i]] = removedFn;
    }
    var i;
    module2.exports = ZipObject;
  }
});

// ../node_modules/pako/lib/utils/common.js
var require_common = __commonJS({
  "../node_modules/pako/lib/utils/common.js"(exports2) {
    "use strict";
    var TYPED_OK = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
    function _has(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    exports2.assign = function(obj) {
      var sources = Array.prototype.slice.call(arguments, 1);
      while (sources.length) {
        var source = sources.shift();
        if (!source) {
          continue;
        }
        if (typeof source !== "object") {
          throw new TypeError(source + "must be non-object");
        }
        for (var p in source) {
          if (_has(source, p)) {
            obj[p] = source[p];
          }
        }
      }
      return obj;
    };
    exports2.shrinkBuf = function(buf, size2) {
      if (buf.length === size2) {
        return buf;
      }
      if (buf.subarray) {
        return buf.subarray(0, size2);
      }
      buf.length = size2;
      return buf;
    };
    var fnTyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        if (src.subarray && dest.subarray) {
          dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
          return;
        }
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        var i, l, len, pos, chunk2, result2;
        len = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          len += chunks[i].length;
        }
        result2 = new Uint8Array(len);
        pos = 0;
        for (i = 0, l = chunks.length; i < l; i++) {
          chunk2 = chunks[i];
          result2.set(chunk2, pos);
          pos += chunk2.length;
        }
        return result2;
      }
    };
    var fnUntyped = {
      arraySet: function(dest, src, src_offs, len, dest_offs) {
        for (var i = 0; i < len; i++) {
          dest[dest_offs + i] = src[src_offs + i];
        }
      },
      // Join array of chunks to single array.
      flattenChunks: function(chunks) {
        return [].concat.apply([], chunks);
      }
    };
    exports2.setTyped = function(on) {
      if (on) {
        exports2.Buf8 = Uint8Array;
        exports2.Buf16 = Uint16Array;
        exports2.Buf32 = Int32Array;
        exports2.assign(exports2, fnTyped);
      } else {
        exports2.Buf8 = Array;
        exports2.Buf16 = Array;
        exports2.Buf32 = Array;
        exports2.assign(exports2, fnUntyped);
      }
    };
    exports2.setTyped(TYPED_OK);
  }
});

// ../node_modules/pako/lib/zlib/trees.js
var require_trees = __commonJS({
  "../node_modules/pako/lib/zlib/trees.js"(exports2) {
    "use strict";
    var utils = require_common();
    var Z_FIXED = 4;
    var Z_BINARY = 0;
    var Z_TEXT = 1;
    var Z_UNKNOWN = 2;
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    var STORED_BLOCK = 0;
    var STATIC_TREES = 1;
    var DYN_TREES = 2;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var Buf_size = 16;
    var MAX_BL_BITS = 7;
    var END_BLOCK = 256;
    var REP_3_6 = 16;
    var REPZ_3_10 = 17;
    var REPZ_11_138 = 18;
    var extra_lbits = (
      /* extra bits for each length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
    );
    var extra_dbits = (
      /* extra bits for each distance code */
      [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
    );
    var extra_blbits = (
      /* extra bits for each bit length code */
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
    );
    var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
    var DIST_CODE_LEN = 512;
    var static_ltree = new Array((L_CODES + 2) * 2);
    zero(static_ltree);
    var static_dtree = new Array(D_CODES * 2);
    zero(static_dtree);
    var _dist_code = new Array(DIST_CODE_LEN);
    zero(_dist_code);
    var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
    zero(_length_code);
    var base_length = new Array(LENGTH_CODES);
    zero(base_length);
    var base_dist = new Array(D_CODES);
    zero(base_dist);
    function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
      this.static_tree = static_tree;
      this.extra_bits = extra_bits;
      this.extra_base = extra_base;
      this.elems = elems;
      this.max_length = max_length;
      this.has_stree = static_tree && static_tree.length;
    }
    var static_l_desc;
    var static_d_desc;
    var static_bl_desc;
    function TreeDesc(dyn_tree, stat_desc) {
      this.dyn_tree = dyn_tree;
      this.max_code = 0;
      this.stat_desc = stat_desc;
    }
    function d_code(dist) {
      return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
    }
    function put_short(s, w) {
      s.pending_buf[s.pending++] = w & 255;
      s.pending_buf[s.pending++] = w >>> 8 & 255;
    }
    function send_bits(s, value, length) {
      if (s.bi_valid > Buf_size - length) {
        s.bi_buf |= value << s.bi_valid & 65535;
        put_short(s, s.bi_buf);
        s.bi_buf = value >> Buf_size - s.bi_valid;
        s.bi_valid += length - Buf_size;
      } else {
        s.bi_buf |= value << s.bi_valid & 65535;
        s.bi_valid += length;
      }
    }
    function send_code(s, c, tree) {
      send_bits(
        s,
        tree[c * 2],
        tree[c * 2 + 1]
        /*.Len*/
      );
    }
    function bi_reverse(code, len) {
      var res = 0;
      do {
        res |= code & 1;
        code >>>= 1;
        res <<= 1;
      } while (--len > 0);
      return res >>> 1;
    }
    function bi_flush(s) {
      if (s.bi_valid === 16) {
        put_short(s, s.bi_buf);
        s.bi_buf = 0;
        s.bi_valid = 0;
      } else if (s.bi_valid >= 8) {
        s.pending_buf[s.pending++] = s.bi_buf & 255;
        s.bi_buf >>= 8;
        s.bi_valid -= 8;
      }
    }
    function gen_bitlen(s, desc) {
      var tree = desc.dyn_tree;
      var max_code = desc.max_code;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var extra = desc.stat_desc.extra_bits;
      var base = desc.stat_desc.extra_base;
      var max_length = desc.stat_desc.max_length;
      var h;
      var n, m;
      var bits;
      var xbits;
      var f;
      var overflow = 0;
      for (bits = 0; bits <= MAX_BITS; bits++) {
        s.bl_count[bits] = 0;
      }
      tree[s.heap[s.heap_max] * 2 + 1] = 0;
      for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
        n = s.heap[h];
        bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
        if (bits > max_length) {
          bits = max_length;
          overflow++;
        }
        tree[n * 2 + 1] = bits;
        if (n > max_code) {
          continue;
        }
        s.bl_count[bits]++;
        xbits = 0;
        if (n >= base) {
          xbits = extra[n - base];
        }
        f = tree[n * 2];
        s.opt_len += f * (bits + xbits);
        if (has_stree) {
          s.static_len += f * (stree[n * 2 + 1] + xbits);
        }
      }
      if (overflow === 0) {
        return;
      }
      do {
        bits = max_length - 1;
        while (s.bl_count[bits] === 0) {
          bits--;
        }
        s.bl_count[bits]--;
        s.bl_count[bits + 1] += 2;
        s.bl_count[max_length]--;
        overflow -= 2;
      } while (overflow > 0);
      for (bits = max_length; bits !== 0; bits--) {
        n = s.bl_count[bits];
        while (n !== 0) {
          m = s.heap[--h];
          if (m > max_code) {
            continue;
          }
          if (tree[m * 2 + 1] !== bits) {
            s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
            tree[m * 2 + 1] = bits;
          }
          n--;
        }
      }
    }
    function gen_codes(tree, max_code, bl_count) {
      var next_code = new Array(MAX_BITS + 1);
      var code = 0;
      var bits;
      var n;
      for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = code + bl_count[bits - 1] << 1;
      }
      for (n = 0; n <= max_code; n++) {
        var len = tree[n * 2 + 1];
        if (len === 0) {
          continue;
        }
        tree[n * 2] = bi_reverse(next_code[len]++, len);
      }
    }
    function tr_static_init() {
      var n;
      var bits;
      var length;
      var code;
      var dist;
      var bl_count = new Array(MAX_BITS + 1);
      length = 0;
      for (code = 0; code < LENGTH_CODES - 1; code++) {
        base_length[code] = length;
        for (n = 0; n < 1 << extra_lbits[code]; n++) {
          _length_code[length++] = code;
        }
      }
      _length_code[length - 1] = code;
      dist = 0;
      for (code = 0; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < 1 << extra_dbits[code]; n++) {
          _dist_code[dist++] = code;
        }
      }
      dist >>= 7;
      for (; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {
          _dist_code[256 + dist++] = code;
        }
      }
      for (bits = 0; bits <= MAX_BITS; bits++) {
        bl_count[bits] = 0;
      }
      n = 0;
      while (n <= 143) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      while (n <= 255) {
        static_ltree[n * 2 + 1] = 9;
        n++;
        bl_count[9]++;
      }
      while (n <= 279) {
        static_ltree[n * 2 + 1] = 7;
        n++;
        bl_count[7]++;
      }
      while (n <= 287) {
        static_ltree[n * 2 + 1] = 8;
        n++;
        bl_count[8]++;
      }
      gen_codes(static_ltree, L_CODES + 1, bl_count);
      for (n = 0; n < D_CODES; n++) {
        static_dtree[n * 2 + 1] = 5;
        static_dtree[n * 2] = bi_reverse(n, 5);
      }
      static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
      static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
      static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
    }
    function init_block(s) {
      var n;
      for (n = 0; n < L_CODES; n++) {
        s.dyn_ltree[n * 2] = 0;
      }
      for (n = 0; n < D_CODES; n++) {
        s.dyn_dtree[n * 2] = 0;
      }
      for (n = 0; n < BL_CODES; n++) {
        s.bl_tree[n * 2] = 0;
      }
      s.dyn_ltree[END_BLOCK * 2] = 1;
      s.opt_len = s.static_len = 0;
      s.last_lit = s.matches = 0;
    }
    function bi_windup(s) {
      if (s.bi_valid > 8) {
        put_short(s, s.bi_buf);
      } else if (s.bi_valid > 0) {
        s.pending_buf[s.pending++] = s.bi_buf;
      }
      s.bi_buf = 0;
      s.bi_valid = 0;
    }
    function copy_block(s, buf, len, header) {
      bi_windup(s);
      if (header) {
        put_short(s, len);
        put_short(s, ~len);
      }
      utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);
      s.pending += len;
    }
    function smaller(tree, n, m, depth) {
      var _n2 = n * 2;
      var _m2 = m * 2;
      return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
    }
    function pqdownheap(s, tree, k) {
      var v = s.heap[k];
      var j = k << 1;
      while (j <= s.heap_len) {
        if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
          j++;
        }
        if (smaller(tree, v, s.heap[j], s.depth)) {
          break;
        }
        s.heap[k] = s.heap[j];
        k = j;
        j <<= 1;
      }
      s.heap[k] = v;
    }
    function compress_block(s, ltree, dtree) {
      var dist;
      var lc;
      var lx = 0;
      var code;
      var extra;
      if (s.last_lit !== 0) {
        do {
          dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
          lc = s.pending_buf[s.l_buf + lx];
          lx++;
          if (dist === 0) {
            send_code(s, lc, ltree);
          } else {
            code = _length_code[lc];
            send_code(s, code + LITERALS + 1, ltree);
            extra = extra_lbits[code];
            if (extra !== 0) {
              lc -= base_length[code];
              send_bits(s, lc, extra);
            }
            dist--;
            code = d_code(dist);
            send_code(s, code, dtree);
            extra = extra_dbits[code];
            if (extra !== 0) {
              dist -= base_dist[code];
              send_bits(s, dist, extra);
            }
          }
        } while (lx < s.last_lit);
      }
      send_code(s, END_BLOCK, ltree);
    }
    function build_tree(s, desc) {
      var tree = desc.dyn_tree;
      var stree = desc.stat_desc.static_tree;
      var has_stree = desc.stat_desc.has_stree;
      var elems = desc.stat_desc.elems;
      var n, m;
      var max_code = -1;
      var node;
      s.heap_len = 0;
      s.heap_max = HEAP_SIZE;
      for (n = 0; n < elems; n++) {
        if (tree[n * 2] !== 0) {
          s.heap[++s.heap_len] = max_code = n;
          s.depth[n] = 0;
        } else {
          tree[n * 2 + 1] = 0;
        }
      }
      while (s.heap_len < 2) {
        node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
        tree[node * 2] = 1;
        s.depth[node] = 0;
        s.opt_len--;
        if (has_stree) {
          s.static_len -= stree[node * 2 + 1];
        }
      }
      desc.max_code = max_code;
      for (n = s.heap_len >> 1; n >= 1; n--) {
        pqdownheap(s, tree, n);
      }
      node = elems;
      do {
        n = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[
          1
          /*SMALLEST*/
        ] = s.heap[s.heap_len--];
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
        m = s.heap[
          1
          /*SMALLEST*/
        ];
        s.heap[--s.heap_max] = n;
        s.heap[--s.heap_max] = m;
        tree[node * 2] = tree[n * 2] + tree[m * 2];
        s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
        tree[n * 2 + 1] = tree[m * 2 + 1] = node;
        s.heap[
          1
          /*SMALLEST*/
        ] = node++;
        pqdownheap(
          s,
          tree,
          1
          /*SMALLEST*/
        );
      } while (s.heap_len >= 2);
      s.heap[--s.heap_max] = s.heap[
        1
        /*SMALLEST*/
      ];
      gen_bitlen(s, desc);
      gen_codes(tree, max_code, s.bl_count);
    }
    function scan_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      tree[(max_code + 1) * 2 + 1] = 65535;
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          s.bl_tree[curlen * 2] += count;
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            s.bl_tree[curlen * 2]++;
          }
          s.bl_tree[REP_3_6 * 2]++;
        } else if (count <= 10) {
          s.bl_tree[REPZ_3_10 * 2]++;
        } else {
          s.bl_tree[REPZ_11_138 * 2]++;
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function send_tree(s, tree, max_code) {
      var n;
      var prevlen = -1;
      var curlen;
      var nextlen = tree[0 * 2 + 1];
      var count = 0;
      var max_count = 7;
      var min_count = 4;
      if (nextlen === 0) {
        max_count = 138;
        min_count = 3;
      }
      for (n = 0; n <= max_code; n++) {
        curlen = nextlen;
        nextlen = tree[(n + 1) * 2 + 1];
        if (++count < max_count && curlen === nextlen) {
          continue;
        } else if (count < min_count) {
          do {
            send_code(s, curlen, s.bl_tree);
          } while (--count !== 0);
        } else if (curlen !== 0) {
          if (curlen !== prevlen) {
            send_code(s, curlen, s.bl_tree);
            count--;
          }
          send_code(s, REP_3_6, s.bl_tree);
          send_bits(s, count - 3, 2);
        } else if (count <= 10) {
          send_code(s, REPZ_3_10, s.bl_tree);
          send_bits(s, count - 3, 3);
        } else {
          send_code(s, REPZ_11_138, s.bl_tree);
          send_bits(s, count - 11, 7);
        }
        count = 0;
        prevlen = curlen;
        if (nextlen === 0) {
          max_count = 138;
          min_count = 3;
        } else if (curlen === nextlen) {
          max_count = 6;
          min_count = 3;
        } else {
          max_count = 7;
          min_count = 4;
        }
      }
    }
    function build_bl_tree(s) {
      var max_blindex;
      scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
      scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
      build_tree(s, s.bl_desc);
      for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
        if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
          break;
        }
      }
      s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
      return max_blindex;
    }
    function send_all_trees(s, lcodes, dcodes, blcodes) {
      var rank;
      send_bits(s, lcodes - 257, 5);
      send_bits(s, dcodes - 1, 5);
      send_bits(s, blcodes - 4, 4);
      for (rank = 0; rank < blcodes; rank++) {
        send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1], 3);
      }
      send_tree(s, s.dyn_ltree, lcodes - 1);
      send_tree(s, s.dyn_dtree, dcodes - 1);
    }
    function detect_data_type(s) {
      var black_mask = 4093624447;
      var n;
      for (n = 0; n <= 31; n++, black_mask >>>= 1) {
        if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
          return Z_BINARY;
        }
      }
      if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
        return Z_TEXT;
      }
      for (n = 32; n < LITERALS; n++) {
        if (s.dyn_ltree[n * 2] !== 0) {
          return Z_TEXT;
        }
      }
      return Z_BINARY;
    }
    var static_init_done = false;
    function _tr_init(s) {
      if (!static_init_done) {
        tr_static_init();
        static_init_done = true;
      }
      s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
      s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
      s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
      s.bi_buf = 0;
      s.bi_valid = 0;
      init_block(s);
    }
    function _tr_stored_block(s, buf, stored_len, last2) {
      send_bits(s, (STORED_BLOCK << 1) + (last2 ? 1 : 0), 3);
      copy_block(s, buf, stored_len, true);
    }
    function _tr_align(s) {
      send_bits(s, STATIC_TREES << 1, 3);
      send_code(s, END_BLOCK, static_ltree);
      bi_flush(s);
    }
    function _tr_flush_block(s, buf, stored_len, last2) {
      var opt_lenb, static_lenb;
      var max_blindex = 0;
      if (s.level > 0) {
        if (s.strm.data_type === Z_UNKNOWN) {
          s.strm.data_type = detect_data_type(s);
        }
        build_tree(s, s.l_desc);
        build_tree(s, s.d_desc);
        max_blindex = build_bl_tree(s);
        opt_lenb = s.opt_len + 3 + 7 >>> 3;
        static_lenb = s.static_len + 3 + 7 >>> 3;
        if (static_lenb <= opt_lenb) {
          opt_lenb = static_lenb;
        }
      } else {
        opt_lenb = static_lenb = stored_len + 5;
      }
      if (stored_len + 4 <= opt_lenb && buf !== -1) {
        _tr_stored_block(s, buf, stored_len, last2);
      } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
        send_bits(s, (STATIC_TREES << 1) + (last2 ? 1 : 0), 3);
        compress_block(s, static_ltree, static_dtree);
      } else {
        send_bits(s, (DYN_TREES << 1) + (last2 ? 1 : 0), 3);
        send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
        compress_block(s, s.dyn_ltree, s.dyn_dtree);
      }
      init_block(s);
      if (last2) {
        bi_windup(s);
      }
    }
    function _tr_tally(s, dist, lc) {
      s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
      s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
      s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
      s.last_lit++;
      if (dist === 0) {
        s.dyn_ltree[lc * 2]++;
      } else {
        s.matches++;
        dist--;
        s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
        s.dyn_dtree[d_code(dist) * 2]++;
      }
      return s.last_lit === s.lit_bufsize - 1;
    }
    exports2._tr_init = _tr_init;
    exports2._tr_stored_block = _tr_stored_block;
    exports2._tr_flush_block = _tr_flush_block;
    exports2._tr_tally = _tr_tally;
    exports2._tr_align = _tr_align;
  }
});

// ../node_modules/pako/lib/zlib/adler32.js
var require_adler32 = __commonJS({
  "../node_modules/pako/lib/zlib/adler32.js"(exports2, module2) {
    "use strict";
    function adler32(adler, buf, len, pos) {
      var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
      while (len !== 0) {
        n = len > 2e3 ? 2e3 : len;
        len -= n;
        do {
          s1 = s1 + buf[pos++] | 0;
          s2 = s2 + s1 | 0;
        } while (--n);
        s1 %= 65521;
        s2 %= 65521;
      }
      return s1 | s2 << 16 | 0;
    }
    module2.exports = adler32;
  }
});

// ../node_modules/pako/lib/zlib/crc32.js
var require_crc322 = __commonJS({
  "../node_modules/pako/lib/zlib/crc32.js"(exports2, module2) {
    "use strict";
    function makeTable() {
      var c, table = [];
      for (var n = 0; n < 256; n++) {
        c = n;
        for (var k = 0; k < 8; k++) {
          c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
        }
        table[n] = c;
      }
      return table;
    }
    var crcTable = makeTable();
    function crc32(crc, buf, len, pos) {
      var t = crcTable, end = pos + len;
      crc ^= -1;
      for (var i = pos; i < end; i++) {
        crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
      }
      return crc ^ -1;
    }
    module2.exports = crc32;
  }
});

// ../node_modules/pako/lib/zlib/messages.js
var require_messages = __commonJS({
  "../node_modules/pako/lib/zlib/messages.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      2: "need dictionary",
      /* Z_NEED_DICT       2  */
      1: "stream end",
      /* Z_STREAM_END      1  */
      0: "",
      /* Z_OK              0  */
      "-1": "file error",
      /* Z_ERRNO         (-1) */
      "-2": "stream error",
      /* Z_STREAM_ERROR  (-2) */
      "-3": "data error",
      /* Z_DATA_ERROR    (-3) */
      "-4": "insufficient memory",
      /* Z_MEM_ERROR     (-4) */
      "-5": "buffer error",
      /* Z_BUF_ERROR     (-5) */
      "-6": "incompatible version"
      /* Z_VERSION_ERROR (-6) */
    };
  }
});

// ../node_modules/pako/lib/zlib/deflate.js
var require_deflate = __commonJS({
  "../node_modules/pako/lib/zlib/deflate.js"(exports2) {
    "use strict";
    var utils = require_common();
    var trees = require_trees();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var msg = require_messages();
    var Z_NO_FLUSH = 0;
    var Z_PARTIAL_FLUSH = 1;
    var Z_FULL_FLUSH = 3;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_BUF_ERROR = -5;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_FILTERED = 1;
    var Z_HUFFMAN_ONLY = 2;
    var Z_RLE = 3;
    var Z_FIXED = 4;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_UNKNOWN = 2;
    var Z_DEFLATED = 8;
    var MAX_MEM_LEVEL = 9;
    var MAX_WBITS = 15;
    var DEF_MEM_LEVEL = 8;
    var LENGTH_CODES = 29;
    var LITERALS = 256;
    var L_CODES = LITERALS + 1 + LENGTH_CODES;
    var D_CODES = 30;
    var BL_CODES = 19;
    var HEAP_SIZE = 2 * L_CODES + 1;
    var MAX_BITS = 15;
    var MIN_MATCH = 3;
    var MAX_MATCH = 258;
    var MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;
    var PRESET_DICT = 32;
    var INIT_STATE = 42;
    var EXTRA_STATE = 69;
    var NAME_STATE = 73;
    var COMMENT_STATE = 91;
    var HCRC_STATE = 103;
    var BUSY_STATE = 113;
    var FINISH_STATE = 666;
    var BS_NEED_MORE = 1;
    var BS_BLOCK_DONE = 2;
    var BS_FINISH_STARTED = 3;
    var BS_FINISH_DONE = 4;
    var OS_CODE = 3;
    function err(strm, errorCode) {
      strm.msg = msg[errorCode];
      return errorCode;
    }
    function rank(f) {
      return (f << 1) - (f > 4 ? 9 : 0);
    }
    function zero(buf) {
      var len = buf.length;
      while (--len >= 0) {
        buf[len] = 0;
      }
    }
    function flush_pending(strm) {
      var s = strm.state;
      var len = s.pending;
      if (len > strm.avail_out) {
        len = strm.avail_out;
      }
      if (len === 0) {
        return;
      }
      utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
      strm.next_out += len;
      s.pending_out += len;
      strm.total_out += len;
      strm.avail_out -= len;
      s.pending -= len;
      if (s.pending === 0) {
        s.pending_out = 0;
      }
    }
    function flush_block_only(s, last2) {
      trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last2);
      s.block_start = s.strstart;
      flush_pending(s.strm);
    }
    function put_byte(s, b) {
      s.pending_buf[s.pending++] = b;
    }
    function putShortMSB(s, b) {
      s.pending_buf[s.pending++] = b >>> 8 & 255;
      s.pending_buf[s.pending++] = b & 255;
    }
    function read_buf(strm, buf, start, size2) {
      var len = strm.avail_in;
      if (len > size2) {
        len = size2;
      }
      if (len === 0) {
        return 0;
      }
      strm.avail_in -= len;
      utils.arraySet(buf, strm.input, strm.next_in, len, start);
      if (strm.state.wrap === 1) {
        strm.adler = adler32(strm.adler, buf, len, start);
      } else if (strm.state.wrap === 2) {
        strm.adler = crc32(strm.adler, buf, len, start);
      }
      strm.next_in += len;
      strm.total_in += len;
      return len;
    }
    function longest_match(s, cur_match) {
      var chain_length = s.max_chain_length;
      var scan = s.strstart;
      var match;
      var len;
      var best_len = s.prev_length;
      var nice_match = s.nice_match;
      var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
      var _win = s.window;
      var wmask = s.w_mask;
      var prev = s.prev;
      var strend = s.strstart + MAX_MATCH;
      var scan_end1 = _win[scan + best_len - 1];
      var scan_end = _win[scan + best_len];
      if (s.prev_length >= s.good_match) {
        chain_length >>= 2;
      }
      if (nice_match > s.lookahead) {
        nice_match = s.lookahead;
      }
      do {
        match = cur_match;
        if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
          continue;
        }
        scan += 2;
        match++;
        do {
        } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
        len = MAX_MATCH - (strend - scan);
        scan = strend - MAX_MATCH;
        if (len > best_len) {
          s.match_start = cur_match;
          best_len = len;
          if (len >= nice_match) {
            break;
          }
          scan_end1 = _win[scan + best_len - 1];
          scan_end = _win[scan + best_len];
        }
      } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
      if (best_len <= s.lookahead) {
        return best_len;
      }
      return s.lookahead;
    }
    function fill_window(s) {
      var _w_size = s.w_size;
      var p, n, m, more, str;
      do {
        more = s.window_size - s.lookahead - s.strstart;
        if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
          utils.arraySet(s.window, s.window, _w_size, _w_size, 0);
          s.match_start -= _w_size;
          s.strstart -= _w_size;
          s.block_start -= _w_size;
          n = s.hash_size;
          p = n;
          do {
            m = s.head[--p];
            s.head[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          n = _w_size;
          p = n;
          do {
            m = s.prev[--p];
            s.prev[p] = m >= _w_size ? m - _w_size : 0;
          } while (--n);
          more += _w_size;
        }
        if (s.strm.avail_in === 0) {
          break;
        }
        n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
        s.lookahead += n;
        if (s.lookahead + s.insert >= MIN_MATCH) {
          str = s.strstart - s.insert;
          s.ins_h = s.window[str];
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
          while (s.insert) {
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
            s.prev[str & s.w_mask] = s.head[s.ins_h];
            s.head[s.ins_h] = str;
            str++;
            s.insert--;
            if (s.lookahead + s.insert < MIN_MATCH) {
              break;
            }
          }
        }
      } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
    }
    function deflate_stored(s, flush) {
      var max_block_size = 65535;
      if (max_block_size > s.pending_buf_size - 5) {
        max_block_size = s.pending_buf_size - 5;
      }
      for (; ; ) {
        if (s.lookahead <= 1) {
          fill_window(s);
          if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.strstart += s.lookahead;
        s.lookahead = 0;
        var max_start = s.block_start + max_block_size;
        if (s.strstart === 0 || s.strstart >= max_start) {
          s.lookahead = s.strstart - max_start;
          s.strstart = max_start;
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.strstart > s.block_start) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_NEED_MORE;
    }
    function deflate_fast(s, flush) {
      var hash_head;
      var bflush;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
            s.match_length--;
            do {
              s.strstart++;
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            } while (--s.match_length !== 0);
            s.strstart++;
          } else {
            s.strstart += s.match_length;
            s.match_length = 0;
            s.ins_h = s.window[s.strstart];
            s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
          }
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_slow(s, flush) {
      var hash_head;
      var bflush;
      var max_insert;
      for (; ; ) {
        if (s.lookahead < MIN_LOOKAHEAD) {
          fill_window(s);
          if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        hash_head = 0;
        if (s.lookahead >= MIN_MATCH) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
        s.prev_length = s.match_length;
        s.prev_match = s.match_start;
        s.match_length = MIN_MATCH - 1;
        if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
          s.match_length = longest_match(s, hash_head);
          if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {
            s.match_length = MIN_MATCH - 1;
          }
        }
        if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
          max_insert = s.strstart + s.lookahead - MIN_MATCH;
          bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);
          s.lookahead -= s.prev_length - 1;
          s.prev_length -= 2;
          do {
            if (++s.strstart <= max_insert) {
              s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;
              hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
              s.head[s.ins_h] = s.strstart;
            }
          } while (--s.prev_length !== 0);
          s.match_available = 0;
          s.match_length = MIN_MATCH - 1;
          s.strstart++;
          if (bflush) {
            flush_block_only(s, false);
            if (s.strm.avail_out === 0) {
              return BS_NEED_MORE;
            }
          }
        } else if (s.match_available) {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
          if (bflush) {
            flush_block_only(s, false);
          }
          s.strstart++;
          s.lookahead--;
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        } else {
          s.match_available = 1;
          s.strstart++;
          s.lookahead--;
        }
      }
      if (s.match_available) {
        bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);
        s.match_available = 0;
      }
      s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_rle(s, flush) {
      var bflush;
      var prev;
      var scan, strend;
      var _win = s.window;
      for (; ; ) {
        if (s.lookahead <= MAX_MATCH) {
          fill_window(s);
          if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {
            return BS_NEED_MORE;
          }
          if (s.lookahead === 0) {
            break;
          }
        }
        s.match_length = 0;
        if (s.lookahead >= MIN_MATCH && s.strstart > 0) {
          scan = s.strstart - 1;
          prev = _win[scan];
          if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
            strend = s.strstart + MAX_MATCH;
            do {
            } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
            s.match_length = MAX_MATCH - (strend - scan);
            if (s.match_length > s.lookahead) {
              s.match_length = s.lookahead;
            }
          }
        }
        if (s.match_length >= MIN_MATCH) {
          bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);
          s.lookahead -= s.match_length;
          s.strstart += s.match_length;
          s.match_length = 0;
        } else {
          bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
          s.lookahead--;
          s.strstart++;
        }
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function deflate_huff(s, flush) {
      var bflush;
      for (; ; ) {
        if (s.lookahead === 0) {
          fill_window(s);
          if (s.lookahead === 0) {
            if (flush === Z_NO_FLUSH) {
              return BS_NEED_MORE;
            }
            break;
          }
        }
        s.match_length = 0;
        bflush = trees._tr_tally(s, 0, s.window[s.strstart]);
        s.lookahead--;
        s.strstart++;
        if (bflush) {
          flush_block_only(s, false);
          if (s.strm.avail_out === 0) {
            return BS_NEED_MORE;
          }
        }
      }
      s.insert = 0;
      if (flush === Z_FINISH) {
        flush_block_only(s, true);
        if (s.strm.avail_out === 0) {
          return BS_FINISH_STARTED;
        }
        return BS_FINISH_DONE;
      }
      if (s.last_lit) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
      return BS_BLOCK_DONE;
    }
    function Config(good_length, max_lazy, nice_length, max_chain, func) {
      this.good_length = good_length;
      this.max_lazy = max_lazy;
      this.nice_length = nice_length;
      this.max_chain = max_chain;
      this.func = func;
    }
    var configuration_table;
    configuration_table = [
      /*      good lazy nice chain */
      new Config(0, 0, 0, 0, deflate_stored),
      /* 0 store only */
      new Config(4, 4, 8, 4, deflate_fast),
      /* 1 max speed, no lazy matches */
      new Config(4, 5, 16, 8, deflate_fast),
      /* 2 */
      new Config(4, 6, 32, 32, deflate_fast),
      /* 3 */
      new Config(4, 4, 16, 16, deflate_slow),
      /* 4 lazy matches */
      new Config(8, 16, 32, 32, deflate_slow),
      /* 5 */
      new Config(8, 16, 128, 128, deflate_slow),
      /* 6 */
      new Config(8, 32, 128, 256, deflate_slow),
      /* 7 */
      new Config(32, 128, 258, 1024, deflate_slow),
      /* 8 */
      new Config(32, 258, 258, 4096, deflate_slow)
      /* 9 max compression */
    ];
    function lm_init(s) {
      s.window_size = 2 * s.w_size;
      zero(s.head);
      s.max_lazy_match = configuration_table[s.level].max_lazy;
      s.good_match = configuration_table[s.level].good_length;
      s.nice_match = configuration_table[s.level].nice_length;
      s.max_chain_length = configuration_table[s.level].max_chain;
      s.strstart = 0;
      s.block_start = 0;
      s.lookahead = 0;
      s.insert = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      s.ins_h = 0;
    }
    function DeflateState() {
      this.strm = null;
      this.status = 0;
      this.pending_buf = null;
      this.pending_buf_size = 0;
      this.pending_out = 0;
      this.pending = 0;
      this.wrap = 0;
      this.gzhead = null;
      this.gzindex = 0;
      this.method = Z_DEFLATED;
      this.last_flush = -1;
      this.w_size = 0;
      this.w_bits = 0;
      this.w_mask = 0;
      this.window = null;
      this.window_size = 0;
      this.prev = null;
      this.head = null;
      this.ins_h = 0;
      this.hash_size = 0;
      this.hash_bits = 0;
      this.hash_mask = 0;
      this.hash_shift = 0;
      this.block_start = 0;
      this.match_length = 0;
      this.prev_match = 0;
      this.match_available = 0;
      this.strstart = 0;
      this.match_start = 0;
      this.lookahead = 0;
      this.prev_length = 0;
      this.max_chain_length = 0;
      this.max_lazy_match = 0;
      this.level = 0;
      this.strategy = 0;
      this.good_match = 0;
      this.nice_match = 0;
      this.dyn_ltree = new utils.Buf16(HEAP_SIZE * 2);
      this.dyn_dtree = new utils.Buf16((2 * D_CODES + 1) * 2);
      this.bl_tree = new utils.Buf16((2 * BL_CODES + 1) * 2);
      zero(this.dyn_ltree);
      zero(this.dyn_dtree);
      zero(this.bl_tree);
      this.l_desc = null;
      this.d_desc = null;
      this.bl_desc = null;
      this.bl_count = new utils.Buf16(MAX_BITS + 1);
      this.heap = new utils.Buf16(2 * L_CODES + 1);
      zero(this.heap);
      this.heap_len = 0;
      this.heap_max = 0;
      this.depth = new utils.Buf16(2 * L_CODES + 1);
      zero(this.depth);
      this.l_buf = 0;
      this.lit_bufsize = 0;
      this.last_lit = 0;
      this.d_buf = 0;
      this.opt_len = 0;
      this.static_len = 0;
      this.matches = 0;
      this.insert = 0;
      this.bi_buf = 0;
      this.bi_valid = 0;
    }
    function deflateResetKeep(strm) {
      var s;
      if (!strm || !strm.state) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.total_in = strm.total_out = 0;
      strm.data_type = Z_UNKNOWN;
      s = strm.state;
      s.pending = 0;
      s.pending_out = 0;
      if (s.wrap < 0) {
        s.wrap = -s.wrap;
      }
      s.status = s.wrap ? INIT_STATE : BUSY_STATE;
      strm.adler = s.wrap === 2 ? 0 : 1;
      s.last_flush = Z_NO_FLUSH;
      trees._tr_init(s);
      return Z_OK;
    }
    function deflateReset(strm) {
      var ret = deflateResetKeep(strm);
      if (ret === Z_OK) {
        lm_init(strm.state);
      }
      return ret;
    }
    function deflateSetHeader(strm, head) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      if (strm.state.wrap !== 2) {
        return Z_STREAM_ERROR;
      }
      strm.state.gzhead = head;
      return Z_OK;
    }
    function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      var wrap2 = 1;
      if (level === Z_DEFAULT_COMPRESSION) {
        level = 6;
      }
      if (windowBits < 0) {
        wrap2 = 0;
        windowBits = -windowBits;
      } else if (windowBits > 15) {
        wrap2 = 2;
        windowBits -= 16;
      }
      if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
        return err(strm, Z_STREAM_ERROR);
      }
      if (windowBits === 8) {
        windowBits = 9;
      }
      var s = new DeflateState();
      strm.state = s;
      s.strm = strm;
      s.wrap = wrap2;
      s.gzhead = null;
      s.w_bits = windowBits;
      s.w_size = 1 << s.w_bits;
      s.w_mask = s.w_size - 1;
      s.hash_bits = memLevel + 7;
      s.hash_size = 1 << s.hash_bits;
      s.hash_mask = s.hash_size - 1;
      s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);
      s.window = new utils.Buf8(s.w_size * 2);
      s.head = new utils.Buf16(s.hash_size);
      s.prev = new utils.Buf16(s.w_size);
      s.lit_bufsize = 1 << memLevel + 6;
      s.pending_buf_size = s.lit_bufsize * 4;
      s.pending_buf = new utils.Buf8(s.pending_buf_size);
      s.d_buf = 1 * s.lit_bufsize;
      s.l_buf = (1 + 2) * s.lit_bufsize;
      s.level = level;
      s.strategy = strategy;
      s.method = method;
      return deflateReset(strm);
    }
    function deflateInit(strm, level) {
      return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);
    }
    function deflate(strm, flush) {
      var old_flush, s;
      var beg, val;
      if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
        return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
      }
      s = strm.state;
      if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
        return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
      }
      s.strm = strm;
      old_flush = s.last_flush;
      s.last_flush = flush;
      if (s.status === INIT_STATE) {
        if (s.wrap === 2) {
          strm.adler = 0;
          put_byte(s, 31);
          put_byte(s, 139);
          put_byte(s, 8);
          if (!s.gzhead) {
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, 0);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, OS_CODE);
            s.status = BUSY_STATE;
          } else {
            put_byte(
              s,
              (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
            );
            put_byte(s, s.gzhead.time & 255);
            put_byte(s, s.gzhead.time >> 8 & 255);
            put_byte(s, s.gzhead.time >> 16 & 255);
            put_byte(s, s.gzhead.time >> 24 & 255);
            put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
            put_byte(s, s.gzhead.os & 255);
            if (s.gzhead.extra && s.gzhead.extra.length) {
              put_byte(s, s.gzhead.extra.length & 255);
              put_byte(s, s.gzhead.extra.length >> 8 & 255);
            }
            if (s.gzhead.hcrc) {
              strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
            }
            s.gzindex = 0;
            s.status = EXTRA_STATE;
          }
        } else {
          var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
          var level_flags = -1;
          if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
            level_flags = 0;
          } else if (s.level < 6) {
            level_flags = 1;
          } else if (s.level === 6) {
            level_flags = 2;
          } else {
            level_flags = 3;
          }
          header |= level_flags << 6;
          if (s.strstart !== 0) {
            header |= PRESET_DICT;
          }
          header += 31 - header % 31;
          s.status = BUSY_STATE;
          putShortMSB(s, header);
          if (s.strstart !== 0) {
            putShortMSB(s, strm.adler >>> 16);
            putShortMSB(s, strm.adler & 65535);
          }
          strm.adler = 1;
        }
      }
      if (s.status === EXTRA_STATE) {
        if (s.gzhead.extra) {
          beg = s.pending;
          while (s.gzindex < (s.gzhead.extra.length & 65535)) {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                break;
              }
            }
            put_byte(s, s.gzhead.extra[s.gzindex] & 255);
            s.gzindex++;
          }
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (s.gzindex === s.gzhead.extra.length) {
            s.gzindex = 0;
            s.status = NAME_STATE;
          }
        } else {
          s.status = NAME_STATE;
        }
      }
      if (s.status === NAME_STATE) {
        if (s.gzhead.name) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.name.length) {
              val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.gzindex = 0;
            s.status = COMMENT_STATE;
          }
        } else {
          s.status = COMMENT_STATE;
        }
      }
      if (s.status === COMMENT_STATE) {
        if (s.gzhead.comment) {
          beg = s.pending;
          do {
            if (s.pending === s.pending_buf_size) {
              if (s.gzhead.hcrc && s.pending > beg) {
                strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
              }
              flush_pending(strm);
              beg = s.pending;
              if (s.pending === s.pending_buf_size) {
                val = 1;
                break;
              }
            }
            if (s.gzindex < s.gzhead.comment.length) {
              val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
            } else {
              val = 0;
            }
            put_byte(s, val);
          } while (val !== 0);
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          if (val === 0) {
            s.status = HCRC_STATE;
          }
        } else {
          s.status = HCRC_STATE;
        }
      }
      if (s.status === HCRC_STATE) {
        if (s.gzhead.hcrc) {
          if (s.pending + 2 > s.pending_buf_size) {
            flush_pending(strm);
          }
          if (s.pending + 2 <= s.pending_buf_size) {
            put_byte(s, strm.adler & 255);
            put_byte(s, strm.adler >> 8 & 255);
            strm.adler = 0;
            s.status = BUSY_STATE;
          }
        } else {
          s.status = BUSY_STATE;
        }
      }
      if (s.pending !== 0) {
        flush_pending(strm);
        if (strm.avail_out === 0) {
          s.last_flush = -1;
          return Z_OK;
        }
      } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
        return err(strm, Z_BUF_ERROR);
      }
      if (s.status === FINISH_STATE && strm.avail_in !== 0) {
        return err(strm, Z_BUF_ERROR);
      }
      if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
        if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
          s.status = FINISH_STATE;
        }
        if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
          if (strm.avail_out === 0) {
            s.last_flush = -1;
          }
          return Z_OK;
        }
        if (bstate === BS_BLOCK_DONE) {
          if (flush === Z_PARTIAL_FLUSH) {
            trees._tr_align(s);
          } else if (flush !== Z_BLOCK) {
            trees._tr_stored_block(s, 0, 0, false);
            if (flush === Z_FULL_FLUSH) {
              zero(s.head);
              if (s.lookahead === 0) {
                s.strstart = 0;
                s.block_start = 0;
                s.insert = 0;
              }
            }
          }
          flush_pending(strm);
          if (strm.avail_out === 0) {
            s.last_flush = -1;
            return Z_OK;
          }
        }
      }
      if (flush !== Z_FINISH) {
        return Z_OK;
      }
      if (s.wrap <= 0) {
        return Z_STREAM_END;
      }
      if (s.wrap === 2) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        put_byte(s, strm.adler >> 16 & 255);
        put_byte(s, strm.adler >> 24 & 255);
        put_byte(s, strm.total_in & 255);
        put_byte(s, strm.total_in >> 8 & 255);
        put_byte(s, strm.total_in >> 16 & 255);
        put_byte(s, strm.total_in >> 24 & 255);
      } else {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      flush_pending(strm);
      if (s.wrap > 0) {
        s.wrap = -s.wrap;
      }
      return s.pending !== 0 ? Z_OK : Z_STREAM_END;
    }
    function deflateEnd(strm) {
      var status;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      status = strm.state.status;
      if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
        return err(strm, Z_STREAM_ERROR);
      }
      strm.state = null;
      return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
    }
    function deflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var s;
      var str, n;
      var wrap2;
      var avail;
      var next;
      var input;
      var tmpDict;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      s = strm.state;
      wrap2 = s.wrap;
      if (wrap2 === 2 || wrap2 === 1 && s.status !== INIT_STATE || s.lookahead) {
        return Z_STREAM_ERROR;
      }
      if (wrap2 === 1) {
        strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
      }
      s.wrap = 0;
      if (dictLength >= s.w_size) {
        if (wrap2 === 0) {
          zero(s.head);
          s.strstart = 0;
          s.block_start = 0;
          s.insert = 0;
        }
        tmpDict = new utils.Buf8(s.w_size);
        utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
        dictionary = tmpDict;
        dictLength = s.w_size;
      }
      avail = strm.avail_in;
      next = strm.next_in;
      input = strm.input;
      strm.avail_in = dictLength;
      strm.next_in = 0;
      strm.input = dictionary;
      fill_window(s);
      while (s.lookahead >= MIN_MATCH) {
        str = s.strstart;
        n = s.lookahead - (MIN_MATCH - 1);
        do {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;
          s.prev[str & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = str;
          str++;
        } while (--n);
        s.strstart = str;
        s.lookahead = MIN_MATCH - 1;
        fill_window(s);
      }
      s.strstart += s.lookahead;
      s.block_start = s.strstart;
      s.insert = s.lookahead;
      s.lookahead = 0;
      s.match_length = s.prev_length = MIN_MATCH - 1;
      s.match_available = 0;
      strm.next_in = next;
      strm.input = input;
      strm.avail_in = avail;
      s.wrap = wrap2;
      return Z_OK;
    }
    exports2.deflateInit = deflateInit;
    exports2.deflateInit2 = deflateInit2;
    exports2.deflateReset = deflateReset;
    exports2.deflateResetKeep = deflateResetKeep;
    exports2.deflateSetHeader = deflateSetHeader;
    exports2.deflate = deflate;
    exports2.deflateEnd = deflateEnd;
    exports2.deflateSetDictionary = deflateSetDictionary;
    exports2.deflateInfo = "pako deflate (from Nodeca project)";
  }
});

// ../node_modules/pako/lib/utils/strings.js
var require_strings = __commonJS({
  "../node_modules/pako/lib/utils/strings.js"(exports2) {
    "use strict";
    var utils = require_common();
    var STR_APPLY_OK = true;
    var STR_APPLY_UIA_OK = true;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch (__) {
      STR_APPLY_OK = false;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch (__) {
      STR_APPLY_UIA_OK = false;
    }
    var _utf8len = new utils.Buf8(256);
    for (q = 0; q < 256; q++) {
      _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
    }
    var q;
    _utf8len[254] = _utf8len[254] = 1;
    exports2.string2buf = function(str) {
      var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
      for (m_pos = 0; m_pos < str_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
      }
      buf = new utils.Buf8(buf_len);
      for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
        c = str.charCodeAt(m_pos);
        if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
          c2 = str.charCodeAt(m_pos + 1);
          if ((c2 & 64512) === 56320) {
            c = 65536 + (c - 55296 << 10) + (c2 - 56320);
            m_pos++;
          }
        }
        if (c < 128) {
          buf[i++] = c;
        } else if (c < 2048) {
          buf[i++] = 192 | c >>> 6;
          buf[i++] = 128 | c & 63;
        } else if (c < 65536) {
          buf[i++] = 224 | c >>> 12;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        } else {
          buf[i++] = 240 | c >>> 18;
          buf[i++] = 128 | c >>> 12 & 63;
          buf[i++] = 128 | c >>> 6 & 63;
          buf[i++] = 128 | c & 63;
        }
      }
      return buf;
    };
    function buf2binstring(buf, len) {
      if (len < 65534) {
        if (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK) {
          return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
        }
      }
      var result2 = "";
      for (var i = 0; i < len; i++) {
        result2 += String.fromCharCode(buf[i]);
      }
      return result2;
    }
    exports2.buf2binstring = function(buf) {
      return buf2binstring(buf, buf.length);
    };
    exports2.binstring2buf = function(str) {
      var buf = new utils.Buf8(str.length);
      for (var i = 0, len = buf.length; i < len; i++) {
        buf[i] = str.charCodeAt(i);
      }
      return buf;
    };
    exports2.buf2string = function(buf, max2) {
      var i, out, c, c_len;
      var len = max2 || buf.length;
      var utf16buf = new Array(len * 2);
      for (out = 0, i = 0; i < len; ) {
        c = buf[i++];
        if (c < 128) {
          utf16buf[out++] = c;
          continue;
        }
        c_len = _utf8len[c];
        if (c_len > 4) {
          utf16buf[out++] = 65533;
          i += c_len - 1;
          continue;
        }
        c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
        while (c_len > 1 && i < len) {
          c = c << 6 | buf[i++] & 63;
          c_len--;
        }
        if (c_len > 1) {
          utf16buf[out++] = 65533;
          continue;
        }
        if (c < 65536) {
          utf16buf[out++] = c;
        } else {
          c -= 65536;
          utf16buf[out++] = 55296 | c >> 10 & 1023;
          utf16buf[out++] = 56320 | c & 1023;
        }
      }
      return buf2binstring(utf16buf, out);
    };
    exports2.utf8border = function(buf, max2) {
      var pos;
      max2 = max2 || buf.length;
      if (max2 > buf.length) {
        max2 = buf.length;
      }
      pos = max2 - 1;
      while (pos >= 0 && (buf[pos] & 192) === 128) {
        pos--;
      }
      if (pos < 0) {
        return max2;
      }
      if (pos === 0) {
        return max2;
      }
      return pos + _utf8len[buf[pos]] > max2 ? pos : max2;
    };
  }
});

// ../node_modules/pako/lib/zlib/zstream.js
var require_zstream = __commonJS({
  "../node_modules/pako/lib/zlib/zstream.js"(exports2, module2) {
    "use strict";
    function ZStream() {
      this.input = null;
      this.next_in = 0;
      this.avail_in = 0;
      this.total_in = 0;
      this.output = null;
      this.next_out = 0;
      this.avail_out = 0;
      this.total_out = 0;
      this.msg = "";
      this.state = null;
      this.data_type = 2;
      this.adler = 0;
    }
    module2.exports = ZStream;
  }
});

// ../node_modules/pako/lib/deflate.js
var require_deflate2 = __commonJS({
  "../node_modules/pako/lib/deflate.js"(exports2) {
    "use strict";
    var zlib_deflate = require_deflate();
    var utils = require_common();
    var strings = require_strings();
    var msg = require_messages();
    var ZStream = require_zstream();
    var toString2 = Object.prototype.toString;
    var Z_NO_FLUSH = 0;
    var Z_FINISH = 4;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_SYNC_FLUSH = 2;
    var Z_DEFAULT_COMPRESSION = -1;
    var Z_DEFAULT_STRATEGY = 0;
    var Z_DEFLATED = 8;
    function Deflate(options) {
      if (!(this instanceof Deflate)) return new Deflate(options);
      this.options = utils.assign({
        level: Z_DEFAULT_COMPRESSION,
        method: Z_DEFLATED,
        chunkSize: 16384,
        windowBits: 15,
        memLevel: 8,
        strategy: Z_DEFAULT_STRATEGY,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits > 0) {
        opt.windowBits = -opt.windowBits;
      } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
        opt.windowBits += 16;
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_deflate.deflateInit2(
        this.strm,
        opt.level,
        opt.method,
        opt.windowBits,
        opt.memLevel,
        opt.strategy
      );
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
      if (opt.header) {
        zlib_deflate.deflateSetHeader(this.strm, opt.header);
      }
      if (opt.dictionary) {
        var dict;
        if (typeof opt.dictionary === "string") {
          dict = strings.string2buf(opt.dictionary);
        } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
          dict = new Uint8Array(opt.dictionary);
        } else {
          dict = opt.dictionary;
        }
        status = zlib_deflate.deflateSetDictionary(this.strm, dict);
        if (status !== Z_OK) {
          throw new Error(msg[status]);
        }
        this._dict_set = true;
      }
    }
    Deflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var status, _mode;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.string2buf(data);
      } else if (toString2.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_deflate.deflate(strm, _mode);
        if (status !== Z_STREAM_END && status !== Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
          if (this.options.to === "string") {
            this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));
          } else {
            this.onData(utils.shrinkBuf(strm.output, strm.next_out));
          }
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
      if (_mode === Z_FINISH) {
        status = zlib_deflate.deflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === Z_OK;
      }
      if (_mode === Z_SYNC_FLUSH) {
        this.onEnd(Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Deflate.prototype.onData = function(chunk2) {
      this.chunks.push(chunk2);
    };
    Deflate.prototype.onEnd = function(status) {
      if (status === Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function deflate(input, options) {
      var deflator = new Deflate(options);
      deflator.push(input, true);
      if (deflator.err) {
        throw deflator.msg || msg[deflator.err];
      }
      return deflator.result;
    }
    function deflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return deflate(input, options);
    }
    function gzip(input, options) {
      options = options || {};
      options.gzip = true;
      return deflate(input, options);
    }
    exports2.Deflate = Deflate;
    exports2.deflate = deflate;
    exports2.deflateRaw = deflateRaw;
    exports2.gzip = gzip;
  }
});

// ../node_modules/pako/lib/zlib/inffast.js
var require_inffast = __commonJS({
  "../node_modules/pako/lib/zlib/inffast.js"(exports2, module2) {
    "use strict";
    var BAD = 30;
    var TYPE = 12;
    module2.exports = function inflate_fast(strm, start) {
      var state;
      var _in;
      var last2;
      var _out;
      var beg;
      var end;
      var dmax;
      var wsize;
      var whave;
      var wnext;
      var s_window;
      var hold;
      var bits;
      var lcode;
      var dcode;
      var lmask;
      var dmask;
      var here;
      var op;
      var len;
      var dist;
      var from;
      var from_source;
      var input, output;
      state = strm.state;
      _in = strm.next_in;
      input = strm.input;
      last2 = _in + (strm.avail_in - 5);
      _out = strm.next_out;
      output = strm.output;
      beg = _out - (start - strm.avail_out);
      end = _out + (strm.avail_out - 257);
      dmax = state.dmax;
      wsize = state.wsize;
      whave = state.whave;
      wnext = state.wnext;
      s_window = state.window;
      hold = state.hold;
      bits = state.bits;
      lcode = state.lencode;
      dcode = state.distcode;
      lmask = (1 << state.lenbits) - 1;
      dmask = (1 << state.distbits) - 1;
      top:
        do {
          if (bits < 15) {
            hold += input[_in++] << bits;
            bits += 8;
            hold += input[_in++] << bits;
            bits += 8;
          }
          here = lcode[hold & lmask];
          dolen:
            for (; ; ) {
              op = here >>> 24;
              hold >>>= op;
              bits -= op;
              op = here >>> 16 & 255;
              if (op === 0) {
                output[_out++] = here & 65535;
              } else if (op & 16) {
                len = here & 65535;
                op &= 15;
                if (op) {
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                  }
                  len += hold & (1 << op) - 1;
                  hold >>>= op;
                  bits -= op;
                }
                if (bits < 15) {
                  hold += input[_in++] << bits;
                  bits += 8;
                  hold += input[_in++] << bits;
                  bits += 8;
                }
                here = dcode[hold & dmask];
                dodist:
                  for (; ; ) {
                    op = here >>> 24;
                    hold >>>= op;
                    bits -= op;
                    op = here >>> 16 & 255;
                    if (op & 16) {
                      dist = here & 65535;
                      op &= 15;
                      if (bits < op) {
                        hold += input[_in++] << bits;
                        bits += 8;
                        if (bits < op) {
                          hold += input[_in++] << bits;
                          bits += 8;
                        }
                      }
                      dist += hold & (1 << op) - 1;
                      if (dist > dmax) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                      hold >>>= op;
                      bits -= op;
                      op = _out - beg;
                      if (dist > op) {
                        op = dist - op;
                        if (op > whave) {
                          if (state.sane) {
                            strm.msg = "invalid distance too far back";
                            state.mode = BAD;
                            break top;
                          }
                        }
                        from = 0;
                        from_source = s_window;
                        if (wnext === 0) {
                          from += wsize - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        } else if (wnext < op) {
                          from += wsize + wnext - op;
                          op -= wnext;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = 0;
                            if (wnext < len) {
                              op = wnext;
                              len -= op;
                              do {
                                output[_out++] = s_window[from++];
                              } while (--op);
                              from = _out - dist;
                              from_source = output;
                            }
                          }
                        } else {
                          from += wnext - op;
                          if (op < len) {
                            len -= op;
                            do {
                              output[_out++] = s_window[from++];
                            } while (--op);
                            from = _out - dist;
                            from_source = output;
                          }
                        }
                        while (len > 2) {
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          output[_out++] = from_source[from++];
                          len -= 3;
                        }
                        if (len) {
                          output[_out++] = from_source[from++];
                          if (len > 1) {
                            output[_out++] = from_source[from++];
                          }
                        }
                      } else {
                        from = _out - dist;
                        do {
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          output[_out++] = output[from++];
                          len -= 3;
                        } while (len > 2);
                        if (len) {
                          output[_out++] = output[from++];
                          if (len > 1) {
                            output[_out++] = output[from++];
                          }
                        }
                      }
                    } else if ((op & 64) === 0) {
                      here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                      continue dodist;
                    } else {
                      strm.msg = "invalid distance code";
                      state.mode = BAD;
                      break top;
                    }
                    break;
                  }
              } else if ((op & 64) === 0) {
                here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
                continue dolen;
              } else if (op & 32) {
                state.mode = TYPE;
                break top;
              } else {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break top;
              }
              break;
            }
        } while (_in < last2 && _out < end);
      len = bits >> 3;
      _in -= len;
      bits -= len << 3;
      hold &= (1 << bits) - 1;
      strm.next_in = _in;
      strm.next_out = _out;
      strm.avail_in = _in < last2 ? 5 + (last2 - _in) : 5 - (_in - last2);
      strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
      state.hold = hold;
      state.bits = bits;
      return;
    };
  }
});

// ../node_modules/pako/lib/zlib/inftrees.js
var require_inftrees = __commonJS({
  "../node_modules/pako/lib/zlib/inftrees.js"(exports2, module2) {
    "use strict";
    var utils = require_common();
    var MAXBITS = 15;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var lbase = [
      /* Length codes 257..285 base */
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      13,
      15,
      17,
      19,
      23,
      27,
      31,
      35,
      43,
      51,
      59,
      67,
      83,
      99,
      115,
      131,
      163,
      195,
      227,
      258,
      0,
      0
    ];
    var lext = [
      /* Length codes 257..285 extra */
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      16,
      17,
      17,
      17,
      17,
      18,
      18,
      18,
      18,
      19,
      19,
      19,
      19,
      20,
      20,
      20,
      20,
      21,
      21,
      21,
      21,
      16,
      72,
      78
    ];
    var dbase = [
      /* Distance codes 0..29 base */
      1,
      2,
      3,
      4,
      5,
      7,
      9,
      13,
      17,
      25,
      33,
      49,
      65,
      97,
      129,
      193,
      257,
      385,
      513,
      769,
      1025,
      1537,
      2049,
      3073,
      4097,
      6145,
      8193,
      12289,
      16385,
      24577,
      0,
      0
    ];
    var dext = [
      /* Distance codes 0..29 extra */
      16,
      16,
      16,
      16,
      17,
      17,
      18,
      18,
      19,
      19,
      20,
      20,
      21,
      21,
      22,
      22,
      23,
      23,
      24,
      24,
      25,
      25,
      26,
      26,
      27,
      27,
      28,
      28,
      29,
      29,
      64,
      64
    ];
    module2.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
      var bits = opts.bits;
      var len = 0;
      var sym = 0;
      var min2 = 0, max2 = 0;
      var root2 = 0;
      var curr = 0;
      var drop = 0;
      var left = 0;
      var used = 0;
      var huff = 0;
      var incr;
      var fill;
      var low;
      var mask;
      var next;
      var base = null;
      var base_index = 0;
      var end;
      var count = new utils.Buf16(MAXBITS + 1);
      var offs = new utils.Buf16(MAXBITS + 1);
      var extra = null;
      var extra_index = 0;
      var here_bits, here_op, here_val;
      for (len = 0; len <= MAXBITS; len++) {
        count[len] = 0;
      }
      for (sym = 0; sym < codes; sym++) {
        count[lens[lens_index + sym]]++;
      }
      root2 = bits;
      for (max2 = MAXBITS; max2 >= 1; max2--) {
        if (count[max2] !== 0) {
          break;
        }
      }
      if (root2 > max2) {
        root2 = max2;
      }
      if (max2 === 0) {
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        table[table_index++] = 1 << 24 | 64 << 16 | 0;
        opts.bits = 1;
        return 0;
      }
      for (min2 = 1; min2 < max2; min2++) {
        if (count[min2] !== 0) {
          break;
        }
      }
      if (root2 < min2) {
        root2 = min2;
      }
      left = 1;
      for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
        left -= count[len];
        if (left < 0) {
          return -1;
        }
      }
      if (left > 0 && (type === CODES || max2 !== 1)) {
        return -1;
      }
      offs[1] = 0;
      for (len = 1; len < MAXBITS; len++) {
        offs[len + 1] = offs[len] + count[len];
      }
      for (sym = 0; sym < codes; sym++) {
        if (lens[lens_index + sym] !== 0) {
          work[offs[lens[lens_index + sym]]++] = sym;
        }
      }
      if (type === CODES) {
        base = extra = work;
        end = 19;
      } else if (type === LENS) {
        base = lbase;
        base_index -= 257;
        extra = lext;
        extra_index -= 257;
        end = 256;
      } else {
        base = dbase;
        extra = dext;
        end = -1;
      }
      huff = 0;
      sym = 0;
      len = min2;
      next = table_index;
      curr = root2;
      drop = 0;
      low = -1;
      used = 1 << root2;
      mask = used - 1;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      for (; ; ) {
        here_bits = len - drop;
        if (work[sym] < end) {
          here_op = 0;
          here_val = work[sym];
        } else if (work[sym] > end) {
          here_op = extra[extra_index + work[sym]];
          here_val = base[base_index + work[sym]];
        } else {
          here_op = 32 + 64;
          here_val = 0;
        }
        incr = 1 << len - drop;
        fill = 1 << curr;
        min2 = fill;
        do {
          fill -= incr;
          table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
        } while (fill !== 0);
        incr = 1 << len - 1;
        while (huff & incr) {
          incr >>= 1;
        }
        if (incr !== 0) {
          huff &= incr - 1;
          huff += incr;
        } else {
          huff = 0;
        }
        sym++;
        if (--count[len] === 0) {
          if (len === max2) {
            break;
          }
          len = lens[lens_index + work[sym]];
        }
        if (len > root2 && (huff & mask) !== low) {
          if (drop === 0) {
            drop = root2;
          }
          next += min2;
          curr = len - drop;
          left = 1 << curr;
          while (curr + drop < max2) {
            left -= count[curr + drop];
            if (left <= 0) {
              break;
            }
            curr++;
            left <<= 1;
          }
          used += 1 << curr;
          if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
            return 1;
          }
          low = huff & mask;
          table[low] = root2 << 24 | curr << 16 | next - table_index | 0;
        }
      }
      if (huff !== 0) {
        table[next + huff] = len - drop << 24 | 64 << 16 | 0;
      }
      opts.bits = root2;
      return 0;
    };
  }
});

// ../node_modules/pako/lib/zlib/inflate.js
var require_inflate = __commonJS({
  "../node_modules/pako/lib/zlib/inflate.js"(exports2) {
    "use strict";
    var utils = require_common();
    var adler32 = require_adler32();
    var crc32 = require_crc322();
    var inflate_fast = require_inffast();
    var inflate_table = require_inftrees();
    var CODES = 0;
    var LENS = 1;
    var DISTS = 2;
    var Z_FINISH = 4;
    var Z_BLOCK = 5;
    var Z_TREES = 6;
    var Z_OK = 0;
    var Z_STREAM_END = 1;
    var Z_NEED_DICT = 2;
    var Z_STREAM_ERROR = -2;
    var Z_DATA_ERROR = -3;
    var Z_MEM_ERROR = -4;
    var Z_BUF_ERROR = -5;
    var Z_DEFLATED = 8;
    var HEAD = 1;
    var FLAGS = 2;
    var TIME = 3;
    var OS = 4;
    var EXLEN = 5;
    var EXTRA = 6;
    var NAME = 7;
    var COMMENT = 8;
    var HCRC = 9;
    var DICTID = 10;
    var DICT = 11;
    var TYPE = 12;
    var TYPEDO = 13;
    var STORED = 14;
    var COPY_ = 15;
    var COPY = 16;
    var TABLE = 17;
    var LENLENS = 18;
    var CODELENS = 19;
    var LEN_ = 20;
    var LEN = 21;
    var LENEXT = 22;
    var DIST = 23;
    var DISTEXT = 24;
    var MATCH = 25;
    var LIT = 26;
    var CHECK = 27;
    var LENGTH = 28;
    var DONE = 29;
    var BAD = 30;
    var MEM = 31;
    var SYNC = 32;
    var ENOUGH_LENS = 852;
    var ENOUGH_DISTS = 592;
    var MAX_WBITS = 15;
    var DEF_WBITS = MAX_WBITS;
    function zswap32(q) {
      return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
    }
    function InflateState() {
      this.mode = 0;
      this.last = false;
      this.wrap = 0;
      this.havedict = false;
      this.flags = 0;
      this.dmax = 0;
      this.check = 0;
      this.total = 0;
      this.head = null;
      this.wbits = 0;
      this.wsize = 0;
      this.whave = 0;
      this.wnext = 0;
      this.window = null;
      this.hold = 0;
      this.bits = 0;
      this.length = 0;
      this.offset = 0;
      this.extra = 0;
      this.lencode = null;
      this.distcode = null;
      this.lenbits = 0;
      this.distbits = 0;
      this.ncode = 0;
      this.nlen = 0;
      this.ndist = 0;
      this.have = 0;
      this.next = null;
      this.lens = new utils.Buf16(320);
      this.work = new utils.Buf16(288);
      this.lendyn = null;
      this.distdyn = null;
      this.sane = 0;
      this.back = 0;
      this.was = 0;
    }
    function inflateResetKeep(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      strm.total_in = strm.total_out = state.total = 0;
      strm.msg = "";
      if (state.wrap) {
        strm.adler = state.wrap & 1;
      }
      state.mode = HEAD;
      state.last = 0;
      state.havedict = 0;
      state.dmax = 32768;
      state.head = null;
      state.hold = 0;
      state.bits = 0;
      state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);
      state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);
      state.sane = 1;
      state.back = -1;
      return Z_OK;
    }
    function inflateReset(strm) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      state.wsize = 0;
      state.whave = 0;
      state.wnext = 0;
      return inflateResetKeep(strm);
    }
    function inflateReset2(strm, windowBits) {
      var wrap2;
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (windowBits < 0) {
        wrap2 = 0;
        windowBits = -windowBits;
      } else {
        wrap2 = (windowBits >> 4) + 1;
        if (windowBits < 48) {
          windowBits &= 15;
        }
      }
      if (windowBits && (windowBits < 8 || windowBits > 15)) {
        return Z_STREAM_ERROR;
      }
      if (state.window !== null && state.wbits !== windowBits) {
        state.window = null;
      }
      state.wrap = wrap2;
      state.wbits = windowBits;
      return inflateReset(strm);
    }
    function inflateInit2(strm, windowBits) {
      var ret;
      var state;
      if (!strm) {
        return Z_STREAM_ERROR;
      }
      state = new InflateState();
      strm.state = state;
      state.window = null;
      ret = inflateReset2(strm, windowBits);
      if (ret !== Z_OK) {
        strm.state = null;
      }
      return ret;
    }
    function inflateInit(strm) {
      return inflateInit2(strm, DEF_WBITS);
    }
    var virgin = true;
    var lenfix;
    var distfix;
    function fixedtables(state) {
      if (virgin) {
        var sym;
        lenfix = new utils.Buf32(512);
        distfix = new utils.Buf32(32);
        sym = 0;
        while (sym < 144) {
          state.lens[sym++] = 8;
        }
        while (sym < 256) {
          state.lens[sym++] = 9;
        }
        while (sym < 280) {
          state.lens[sym++] = 7;
        }
        while (sym < 288) {
          state.lens[sym++] = 8;
        }
        inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
        sym = 0;
        while (sym < 32) {
          state.lens[sym++] = 5;
        }
        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
        virgin = false;
      }
      state.lencode = lenfix;
      state.lenbits = 9;
      state.distcode = distfix;
      state.distbits = 5;
    }
    function updatewindow(strm, src, end, copy) {
      var dist;
      var state = strm.state;
      if (state.window === null) {
        state.wsize = 1 << state.wbits;
        state.wnext = 0;
        state.whave = 0;
        state.window = new utils.Buf8(state.wsize);
      }
      if (copy >= state.wsize) {
        utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);
        state.wnext = 0;
        state.whave = state.wsize;
      } else {
        dist = state.wsize - state.wnext;
        if (dist > copy) {
          dist = copy;
        }
        utils.arraySet(state.window, src, end - copy, dist, state.wnext);
        copy -= dist;
        if (copy) {
          utils.arraySet(state.window, src, end - copy, copy, 0);
          state.wnext = copy;
          state.whave = state.wsize;
        } else {
          state.wnext += dist;
          if (state.wnext === state.wsize) {
            state.wnext = 0;
          }
          if (state.whave < state.wsize) {
            state.whave += dist;
          }
        }
      }
      return 0;
    }
    function inflate(strm, flush) {
      var state;
      var input, output;
      var next;
      var put;
      var have, left;
      var hold;
      var bits;
      var _in, _out;
      var copy;
      var from;
      var from_source;
      var here = 0;
      var here_bits, here_op, here_val;
      var last_bits, last_op, last_val;
      var len;
      var ret;
      var hbuf = new utils.Buf8(4);
      var opts;
      var n;
      var order = (
        /* permutation of code lengths */
        [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
      );
      if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.mode === TYPE) {
        state.mode = TYPEDO;
      }
      put = strm.next_out;
      output = strm.output;
      left = strm.avail_out;
      next = strm.next_in;
      input = strm.input;
      have = strm.avail_in;
      hold = state.hold;
      bits = state.bits;
      _in = have;
      _out = left;
      ret = Z_OK;
      inf_leave:
        for (; ; ) {
          switch (state.mode) {
            case HEAD:
              if (state.wrap === 0) {
                state.mode = TYPEDO;
                break;
              }
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.wrap & 2 && hold === 35615) {
                state.check = 0;
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
                hold = 0;
                bits = 0;
                state.mode = FLAGS;
                break;
              }
              state.flags = 0;
              if (state.head) {
                state.head.done = false;
              }
              if (!(state.wrap & 1) || /* check if zlib header allowed */
              (((hold & 255) << 8) + (hold >> 8)) % 31) {
                strm.msg = "incorrect header check";
                state.mode = BAD;
                break;
              }
              if ((hold & 15) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              hold >>>= 4;
              bits -= 4;
              len = (hold & 15) + 8;
              if (state.wbits === 0) {
                state.wbits = len;
              } else if (len > state.wbits) {
                strm.msg = "invalid window size";
                state.mode = BAD;
                break;
              }
              state.dmax = 1 << len;
              strm.adler = state.check = 1;
              state.mode = hold & 512 ? DICTID : TYPE;
              hold = 0;
              bits = 0;
              break;
            case FLAGS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.flags = hold;
              if ((state.flags & 255) !== Z_DEFLATED) {
                strm.msg = "unknown compression method";
                state.mode = BAD;
                break;
              }
              if (state.flags & 57344) {
                strm.msg = "unknown header flags set";
                state.mode = BAD;
                break;
              }
              if (state.head) {
                state.head.text = hold >> 8 & 1;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = TIME;
            /* falls through */
            case TIME:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.time = hold;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                hbuf[2] = hold >>> 16 & 255;
                hbuf[3] = hold >>> 24 & 255;
                state.check = crc32(state.check, hbuf, 4, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = OS;
            /* falls through */
            case OS:
              while (bits < 16) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (state.head) {
                state.head.xflags = hold & 255;
                state.head.os = hold >> 8;
              }
              if (state.flags & 512) {
                hbuf[0] = hold & 255;
                hbuf[1] = hold >>> 8 & 255;
                state.check = crc32(state.check, hbuf, 2, 0);
              }
              hold = 0;
              bits = 0;
              state.mode = EXLEN;
            /* falls through */
            case EXLEN:
              if (state.flags & 1024) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length = hold;
                if (state.head) {
                  state.head.extra_len = hold;
                }
                if (state.flags & 512) {
                  hbuf[0] = hold & 255;
                  hbuf[1] = hold >>> 8 & 255;
                  state.check = crc32(state.check, hbuf, 2, 0);
                }
                hold = 0;
                bits = 0;
              } else if (state.head) {
                state.head.extra = null;
              }
              state.mode = EXTRA;
            /* falls through */
            case EXTRA:
              if (state.flags & 1024) {
                copy = state.length;
                if (copy > have) {
                  copy = have;
                }
                if (copy) {
                  if (state.head) {
                    len = state.head.extra_len - state.length;
                    if (!state.head.extra) {
                      state.head.extra = new Array(state.head.extra_len);
                    }
                    utils.arraySet(
                      state.head.extra,
                      input,
                      next,
                      // extra field is limited to 65536 bytes
                      // - no need for additional size check
                      copy,
                      /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                      len
                    );
                  }
                  if (state.flags & 512) {
                    state.check = crc32(state.check, input, copy, next);
                  }
                  have -= copy;
                  next += copy;
                  state.length -= copy;
                }
                if (state.length) {
                  break inf_leave;
                }
              }
              state.length = 0;
              state.mode = NAME;
            /* falls through */
            case NAME:
              if (state.flags & 2048) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.name += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.name = null;
              }
              state.length = 0;
              state.mode = COMMENT;
            /* falls through */
            case COMMENT:
              if (state.flags & 4096) {
                if (have === 0) {
                  break inf_leave;
                }
                copy = 0;
                do {
                  len = input[next + copy++];
                  if (state.head && len && state.length < 65536) {
                    state.head.comment += String.fromCharCode(len);
                  }
                } while (len && copy < have);
                if (state.flags & 512) {
                  state.check = crc32(state.check, input, copy, next);
                }
                have -= copy;
                next += copy;
                if (len) {
                  break inf_leave;
                }
              } else if (state.head) {
                state.head.comment = null;
              }
              state.mode = HCRC;
            /* falls through */
            case HCRC:
              if (state.flags & 512) {
                while (bits < 16) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.check & 65535)) {
                  strm.msg = "header crc mismatch";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              if (state.head) {
                state.head.hcrc = state.flags >> 9 & 1;
                state.head.done = true;
              }
              strm.adler = state.check = 0;
              state.mode = TYPE;
              break;
            case DICTID:
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              strm.adler = state.check = zswap32(hold);
              hold = 0;
              bits = 0;
              state.mode = DICT;
            /* falls through */
            case DICT:
              if (state.havedict === 0) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                return Z_NEED_DICT;
              }
              strm.adler = state.check = 1;
              state.mode = TYPE;
            /* falls through */
            case TYPE:
              if (flush === Z_BLOCK || flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case TYPEDO:
              if (state.last) {
                hold >>>= bits & 7;
                bits -= bits & 7;
                state.mode = CHECK;
                break;
              }
              while (bits < 3) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.last = hold & 1;
              hold >>>= 1;
              bits -= 1;
              switch (hold & 3) {
                case 0:
                  state.mode = STORED;
                  break;
                case 1:
                  fixedtables(state);
                  state.mode = LEN_;
                  if (flush === Z_TREES) {
                    hold >>>= 2;
                    bits -= 2;
                    break inf_leave;
                  }
                  break;
                case 2:
                  state.mode = TABLE;
                  break;
                case 3:
                  strm.msg = "invalid block type";
                  state.mode = BAD;
              }
              hold >>>= 2;
              bits -= 2;
              break;
            case STORED:
              hold >>>= bits & 7;
              bits -= bits & 7;
              while (bits < 32) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
                strm.msg = "invalid stored block lengths";
                state.mode = BAD;
                break;
              }
              state.length = hold & 65535;
              hold = 0;
              bits = 0;
              state.mode = COPY_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case COPY_:
              state.mode = COPY;
            /* falls through */
            case COPY:
              copy = state.length;
              if (copy) {
                if (copy > have) {
                  copy = have;
                }
                if (copy > left) {
                  copy = left;
                }
                if (copy === 0) {
                  break inf_leave;
                }
                utils.arraySet(output, input, next, copy, put);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
                state.length -= copy;
                break;
              }
              state.mode = TYPE;
              break;
            case TABLE:
              while (bits < 14) {
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              state.nlen = (hold & 31) + 257;
              hold >>>= 5;
              bits -= 5;
              state.ndist = (hold & 31) + 1;
              hold >>>= 5;
              bits -= 5;
              state.ncode = (hold & 15) + 4;
              hold >>>= 4;
              bits -= 4;
              if (state.nlen > 286 || state.ndist > 30) {
                strm.msg = "too many length or distance symbols";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = LENLENS;
            /* falls through */
            case LENLENS:
              while (state.have < state.ncode) {
                while (bits < 3) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.lens[order[state.have++]] = hold & 7;
                hold >>>= 3;
                bits -= 3;
              }
              while (state.have < 19) {
                state.lens[order[state.have++]] = 0;
              }
              state.lencode = state.lendyn;
              state.lenbits = 7;
              opts = { bits: state.lenbits };
              ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid code lengths set";
                state.mode = BAD;
                break;
              }
              state.have = 0;
              state.mode = CODELENS;
            /* falls through */
            case CODELENS:
              while (state.have < state.nlen + state.ndist) {
                for (; ; ) {
                  here = state.lencode[hold & (1 << state.lenbits) - 1];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (here_val < 16) {
                  hold >>>= here_bits;
                  bits -= here_bits;
                  state.lens[state.have++] = here_val;
                } else {
                  if (here_val === 16) {
                    n = here_bits + 2;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    if (state.have === 0) {
                      strm.msg = "invalid bit length repeat";
                      state.mode = BAD;
                      break;
                    }
                    len = state.lens[state.have - 1];
                    copy = 3 + (hold & 3);
                    hold >>>= 2;
                    bits -= 2;
                  } else if (here_val === 17) {
                    n = here_bits + 3;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 3 + (hold & 7);
                    hold >>>= 3;
                    bits -= 3;
                  } else {
                    n = here_bits + 7;
                    while (bits < n) {
                      if (have === 0) {
                        break inf_leave;
                      }
                      have--;
                      hold += input[next++] << bits;
                      bits += 8;
                    }
                    hold >>>= here_bits;
                    bits -= here_bits;
                    len = 0;
                    copy = 11 + (hold & 127);
                    hold >>>= 7;
                    bits -= 7;
                  }
                  if (state.have + copy > state.nlen + state.ndist) {
                    strm.msg = "invalid bit length repeat";
                    state.mode = BAD;
                    break;
                  }
                  while (copy--) {
                    state.lens[state.have++] = len;
                  }
                }
              }
              if (state.mode === BAD) {
                break;
              }
              if (state.lens[256] === 0) {
                strm.msg = "invalid code -- missing end-of-block";
                state.mode = BAD;
                break;
              }
              state.lenbits = 9;
              opts = { bits: state.lenbits };
              ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
              state.lenbits = opts.bits;
              if (ret) {
                strm.msg = "invalid literal/lengths set";
                state.mode = BAD;
                break;
              }
              state.distbits = 6;
              state.distcode = state.distdyn;
              opts = { bits: state.distbits };
              ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
              state.distbits = opts.bits;
              if (ret) {
                strm.msg = "invalid distances set";
                state.mode = BAD;
                break;
              }
              state.mode = LEN_;
              if (flush === Z_TREES) {
                break inf_leave;
              }
            /* falls through */
            case LEN_:
              state.mode = LEN;
            /* falls through */
            case LEN:
              if (have >= 6 && left >= 258) {
                strm.next_out = put;
                strm.avail_out = left;
                strm.next_in = next;
                strm.avail_in = have;
                state.hold = hold;
                state.bits = bits;
                inflate_fast(strm, _out);
                put = strm.next_out;
                output = strm.output;
                left = strm.avail_out;
                next = strm.next_in;
                input = strm.input;
                have = strm.avail_in;
                hold = state.hold;
                bits = state.bits;
                if (state.mode === TYPE) {
                  state.back = -1;
                }
                break;
              }
              state.back = 0;
              for (; ; ) {
                here = state.lencode[hold & (1 << state.lenbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if (here_op && (here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              state.length = here_val;
              if (here_op === 0) {
                state.mode = LIT;
                break;
              }
              if (here_op & 32) {
                state.back = -1;
                state.mode = TYPE;
                break;
              }
              if (here_op & 64) {
                strm.msg = "invalid literal/length code";
                state.mode = BAD;
                break;
              }
              state.extra = here_op & 15;
              state.mode = LENEXT;
            /* falls through */
            case LENEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.length += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              state.was = state.length;
              state.mode = DIST;
            /* falls through */
            case DIST:
              for (; ; ) {
                here = state.distcode[hold & (1 << state.distbits) - 1];
                here_bits = here >>> 24;
                here_op = here >>> 16 & 255;
                here_val = here & 65535;
                if (here_bits <= bits) {
                  break;
                }
                if (have === 0) {
                  break inf_leave;
                }
                have--;
                hold += input[next++] << bits;
                bits += 8;
              }
              if ((here_op & 240) === 0) {
                last_bits = here_bits;
                last_op = here_op;
                last_val = here_val;
                for (; ; ) {
                  here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
                  here_bits = here >>> 24;
                  here_op = here >>> 16 & 255;
                  here_val = here & 65535;
                  if (last_bits + here_bits <= bits) {
                    break;
                  }
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= last_bits;
                bits -= last_bits;
                state.back += last_bits;
              }
              hold >>>= here_bits;
              bits -= here_bits;
              state.back += here_bits;
              if (here_op & 64) {
                strm.msg = "invalid distance code";
                state.mode = BAD;
                break;
              }
              state.offset = here_val;
              state.extra = here_op & 15;
              state.mode = DISTEXT;
            /* falls through */
            case DISTEXT:
              if (state.extra) {
                n = state.extra;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                state.offset += hold & (1 << state.extra) - 1;
                hold >>>= state.extra;
                bits -= state.extra;
                state.back += state.extra;
              }
              if (state.offset > state.dmax) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD;
                break;
              }
              state.mode = MATCH;
            /* falls through */
            case MATCH:
              if (left === 0) {
                break inf_leave;
              }
              copy = _out - left;
              if (state.offset > copy) {
                copy = state.offset - copy;
                if (copy > state.whave) {
                  if (state.sane) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break;
                  }
                }
                if (copy > state.wnext) {
                  copy -= state.wnext;
                  from = state.wsize - copy;
                } else {
                  from = state.wnext - copy;
                }
                if (copy > state.length) {
                  copy = state.length;
                }
                from_source = state.window;
              } else {
                from_source = output;
                from = put - state.offset;
                copy = state.length;
              }
              if (copy > left) {
                copy = left;
              }
              left -= copy;
              state.length -= copy;
              do {
                output[put++] = from_source[from++];
              } while (--copy);
              if (state.length === 0) {
                state.mode = LEN;
              }
              break;
            case LIT:
              if (left === 0) {
                break inf_leave;
              }
              output[put++] = state.length;
              left--;
              state.mode = LEN;
              break;
            case CHECK:
              if (state.wrap) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold |= input[next++] << bits;
                  bits += 8;
                }
                _out -= left;
                strm.total_out += _out;
                state.total += _out;
                if (_out) {
                  strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
                  state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
                }
                _out = left;
                if ((state.flags ? hold : zswap32(hold)) !== state.check) {
                  strm.msg = "incorrect data check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = LENGTH;
            /* falls through */
            case LENGTH:
              if (state.wrap && state.flags) {
                while (bits < 32) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                if (hold !== (state.total & 4294967295)) {
                  strm.msg = "incorrect length check";
                  state.mode = BAD;
                  break;
                }
                hold = 0;
                bits = 0;
              }
              state.mode = DONE;
            /* falls through */
            case DONE:
              ret = Z_STREAM_END;
              break inf_leave;
            case BAD:
              ret = Z_DATA_ERROR;
              break inf_leave;
            case MEM:
              return Z_MEM_ERROR;
            case SYNC:
            /* falls through */
            default:
              return Z_STREAM_ERROR;
          }
        }
      strm.next_out = put;
      strm.avail_out = left;
      strm.next_in = next;
      strm.avail_in = have;
      state.hold = hold;
      state.bits = bits;
      if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) {
        if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
          state.mode = MEM;
          return Z_MEM_ERROR;
        }
      }
      _in -= strm.avail_in;
      _out -= strm.avail_out;
      strm.total_in += _in;
      strm.total_out += _out;
      state.total += _out;
      if (state.wrap && _out) {
        strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
        state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
      }
      strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
      if ((_in === 0 && _out === 0 || flush === Z_FINISH) && ret === Z_OK) {
        ret = Z_BUF_ERROR;
      }
      return ret;
    }
    function inflateEnd(strm) {
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      var state = strm.state;
      if (state.window) {
        state.window = null;
      }
      strm.state = null;
      return Z_OK;
    }
    function inflateGetHeader(strm, head) {
      var state;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if ((state.wrap & 2) === 0) {
        return Z_STREAM_ERROR;
      }
      state.head = head;
      head.done = false;
      return Z_OK;
    }
    function inflateSetDictionary(strm, dictionary) {
      var dictLength = dictionary.length;
      var state;
      var dictid;
      var ret;
      if (!strm || !strm.state) {
        return Z_STREAM_ERROR;
      }
      state = strm.state;
      if (state.wrap !== 0 && state.mode !== DICT) {
        return Z_STREAM_ERROR;
      }
      if (state.mode === DICT) {
        dictid = 1;
        dictid = adler32(dictid, dictionary, dictLength, 0);
        if (dictid !== state.check) {
          return Z_DATA_ERROR;
        }
      }
      ret = updatewindow(strm, dictionary, dictLength, dictLength);
      if (ret) {
        state.mode = MEM;
        return Z_MEM_ERROR;
      }
      state.havedict = 1;
      return Z_OK;
    }
    exports2.inflateReset = inflateReset;
    exports2.inflateReset2 = inflateReset2;
    exports2.inflateResetKeep = inflateResetKeep;
    exports2.inflateInit = inflateInit;
    exports2.inflateInit2 = inflateInit2;
    exports2.inflate = inflate;
    exports2.inflateEnd = inflateEnd;
    exports2.inflateGetHeader = inflateGetHeader;
    exports2.inflateSetDictionary = inflateSetDictionary;
    exports2.inflateInfo = "pako inflate (from Nodeca project)";
  }
});

// ../node_modules/pako/lib/zlib/constants.js
var require_constants = __commonJS({
  "../node_modules/pako/lib/zlib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      /* Allowed flush values; see deflate() and inflate() below for details */
      Z_NO_FLUSH: 0,
      Z_PARTIAL_FLUSH: 1,
      Z_SYNC_FLUSH: 2,
      Z_FULL_FLUSH: 3,
      Z_FINISH: 4,
      Z_BLOCK: 5,
      Z_TREES: 6,
      /* Return codes for the compression/decompression functions. Negative values
      * are errors, positive values are used for special but normal events.
      */
      Z_OK: 0,
      Z_STREAM_END: 1,
      Z_NEED_DICT: 2,
      Z_ERRNO: -1,
      Z_STREAM_ERROR: -2,
      Z_DATA_ERROR: -3,
      //Z_MEM_ERROR:     -4,
      Z_BUF_ERROR: -5,
      //Z_VERSION_ERROR: -6,
      /* compression levels */
      Z_NO_COMPRESSION: 0,
      Z_BEST_SPEED: 1,
      Z_BEST_COMPRESSION: 9,
      Z_DEFAULT_COMPRESSION: -1,
      Z_FILTERED: 1,
      Z_HUFFMAN_ONLY: 2,
      Z_RLE: 3,
      Z_FIXED: 4,
      Z_DEFAULT_STRATEGY: 0,
      /* Possible values of the data_type field (though see inflate()) */
      Z_BINARY: 0,
      Z_TEXT: 1,
      //Z_ASCII:                1, // = Z_TEXT (deprecated)
      Z_UNKNOWN: 2,
      /* The deflate compression method */
      Z_DEFLATED: 8
      //Z_NULL:                 null // Use -1 or null inline, depending on var type
    };
  }
});

// ../node_modules/pako/lib/zlib/gzheader.js
var require_gzheader = __commonJS({
  "../node_modules/pako/lib/zlib/gzheader.js"(exports2, module2) {
    "use strict";
    function GZheader() {
      this.text = 0;
      this.time = 0;
      this.xflags = 0;
      this.os = 0;
      this.extra = null;
      this.extra_len = 0;
      this.name = "";
      this.comment = "";
      this.hcrc = 0;
      this.done = false;
    }
    module2.exports = GZheader;
  }
});

// ../node_modules/pako/lib/inflate.js
var require_inflate2 = __commonJS({
  "../node_modules/pako/lib/inflate.js"(exports2) {
    "use strict";
    var zlib_inflate = require_inflate();
    var utils = require_common();
    var strings = require_strings();
    var c = require_constants();
    var msg = require_messages();
    var ZStream = require_zstream();
    var GZheader = require_gzheader();
    var toString2 = Object.prototype.toString;
    function Inflate(options) {
      if (!(this instanceof Inflate)) return new Inflate(options);
      this.options = utils.assign({
        chunkSize: 16384,
        windowBits: 0,
        to: ""
      }, options || {});
      var opt = this.options;
      if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
        opt.windowBits = -opt.windowBits;
        if (opt.windowBits === 0) {
          opt.windowBits = -15;
        }
      }
      if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {
        opt.windowBits += 32;
      }
      if (opt.windowBits > 15 && opt.windowBits < 48) {
        if ((opt.windowBits & 15) === 0) {
          opt.windowBits |= 15;
        }
      }
      this.err = 0;
      this.msg = "";
      this.ended = false;
      this.chunks = [];
      this.strm = new ZStream();
      this.strm.avail_out = 0;
      var status = zlib_inflate.inflateInit2(
        this.strm,
        opt.windowBits
      );
      if (status !== c.Z_OK) {
        throw new Error(msg[status]);
      }
      this.header = new GZheader();
      zlib_inflate.inflateGetHeader(this.strm, this.header);
      if (opt.dictionary) {
        if (typeof opt.dictionary === "string") {
          opt.dictionary = strings.string2buf(opt.dictionary);
        } else if (toString2.call(opt.dictionary) === "[object ArrayBuffer]") {
          opt.dictionary = new Uint8Array(opt.dictionary);
        }
        if (opt.raw) {
          status = zlib_inflate.inflateSetDictionary(this.strm, opt.dictionary);
          if (status !== c.Z_OK) {
            throw new Error(msg[status]);
          }
        }
      }
    }
    Inflate.prototype.push = function(data, mode) {
      var strm = this.strm;
      var chunkSize = this.options.chunkSize;
      var dictionary = this.options.dictionary;
      var status, _mode;
      var next_out_utf8, tail, utf8str;
      var allowBufError = false;
      if (this.ended) {
        return false;
      }
      _mode = mode === ~~mode ? mode : mode === true ? c.Z_FINISH : c.Z_NO_FLUSH;
      if (typeof data === "string") {
        strm.input = strings.binstring2buf(data);
      } else if (toString2.call(data) === "[object ArrayBuffer]") {
        strm.input = new Uint8Array(data);
      } else {
        strm.input = data;
      }
      strm.next_in = 0;
      strm.avail_in = strm.input.length;
      do {
        if (strm.avail_out === 0) {
          strm.output = new utils.Buf8(chunkSize);
          strm.next_out = 0;
          strm.avail_out = chunkSize;
        }
        status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);
        if (status === c.Z_NEED_DICT && dictionary) {
          status = zlib_inflate.inflateSetDictionary(this.strm, dictionary);
        }
        if (status === c.Z_BUF_ERROR && allowBufError === true) {
          status = c.Z_OK;
          allowBufError = false;
        }
        if (status !== c.Z_STREAM_END && status !== c.Z_OK) {
          this.onEnd(status);
          this.ended = true;
          return false;
        }
        if (strm.next_out) {
          if (strm.avail_out === 0 || status === c.Z_STREAM_END || strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH)) {
            if (this.options.to === "string") {
              next_out_utf8 = strings.utf8border(strm.output, strm.next_out);
              tail = strm.next_out - next_out_utf8;
              utf8str = strings.buf2string(strm.output, next_out_utf8);
              strm.next_out = tail;
              strm.avail_out = chunkSize - tail;
              if (tail) {
                utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
              }
              this.onData(utf8str);
            } else {
              this.onData(utils.shrinkBuf(strm.output, strm.next_out));
            }
          }
        }
        if (strm.avail_in === 0 && strm.avail_out === 0) {
          allowBufError = true;
        }
      } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);
      if (status === c.Z_STREAM_END) {
        _mode = c.Z_FINISH;
      }
      if (_mode === c.Z_FINISH) {
        status = zlib_inflate.inflateEnd(this.strm);
        this.onEnd(status);
        this.ended = true;
        return status === c.Z_OK;
      }
      if (_mode === c.Z_SYNC_FLUSH) {
        this.onEnd(c.Z_OK);
        strm.avail_out = 0;
        return true;
      }
      return true;
    };
    Inflate.prototype.onData = function(chunk2) {
      this.chunks.push(chunk2);
    };
    Inflate.prototype.onEnd = function(status) {
      if (status === c.Z_OK) {
        if (this.options.to === "string") {
          this.result = this.chunks.join("");
        } else {
          this.result = utils.flattenChunks(this.chunks);
        }
      }
      this.chunks = [];
      this.err = status;
      this.msg = this.strm.msg;
    };
    function inflate(input, options) {
      var inflator = new Inflate(options);
      inflator.push(input, true);
      if (inflator.err) {
        throw inflator.msg || msg[inflator.err];
      }
      return inflator.result;
    }
    function inflateRaw(input, options) {
      options = options || {};
      options.raw = true;
      return inflate(input, options);
    }
    exports2.Inflate = Inflate;
    exports2.inflate = inflate;
    exports2.inflateRaw = inflateRaw;
    exports2.ungzip = inflate;
  }
});

// ../node_modules/pako/index.js
var require_pako = __commonJS({
  "../node_modules/pako/index.js"(exports2, module2) {
    "use strict";
    var assign = require_common().assign;
    var deflate = require_deflate2();
    var inflate = require_inflate2();
    var constants = require_constants();
    var pako = {};
    assign(pako, deflate, inflate, constants);
    module2.exports = pako;
  }
});

// ../node_modules/jszip/lib/flate.js
var require_flate = __commonJS({
  "../node_modules/jszip/lib/flate.js"(exports2) {
    "use strict";
    var USE_TYPEDARRAY = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Uint32Array !== "undefined";
    var pako = require_pako();
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
    exports2.magic = "\b\0";
    function FlateWorker(action, options) {
      GenericWorker.call(this, "FlateWorker/" + action);
      this._pako = null;
      this._pakoAction = action;
      this._pakoOptions = options;
      this.meta = {};
    }
    utils.inherits(FlateWorker, GenericWorker);
    FlateWorker.prototype.processChunk = function(chunk2) {
      this.meta = chunk2.meta;
      if (this._pako === null) {
        this._createPako();
      }
      this._pako.push(utils.transformTo(ARRAY_TYPE, chunk2.data), false);
    };
    FlateWorker.prototype.flush = function() {
      GenericWorker.prototype.flush.call(this);
      if (this._pako === null) {
        this._createPako();
      }
      this._pako.push([], true);
    };
    FlateWorker.prototype.cleanUp = function() {
      GenericWorker.prototype.cleanUp.call(this);
      this._pako = null;
    };
    FlateWorker.prototype._createPako = function() {
      this._pako = new pako[this._pakoAction]({
        raw: true,
        level: this._pakoOptions.level || -1
        // default compression
      });
      var self2 = this;
      this._pako.onData = function(data) {
        self2.push({
          data,
          meta: self2.meta
        });
      };
    };
    exports2.compressWorker = function(compressionOptions) {
      return new FlateWorker("Deflate", compressionOptions);
    };
    exports2.uncompressWorker = function() {
      return new FlateWorker("Inflate", {});
    };
  }
});

// ../node_modules/jszip/lib/compressions.js
var require_compressions = __commonJS({
  "../node_modules/jszip/lib/compressions.js"(exports2) {
    "use strict";
    var GenericWorker = require_GenericWorker();
    exports2.STORE = {
      magic: "\0\0",
      compressWorker: function() {
        return new GenericWorker("STORE compression");
      },
      uncompressWorker: function() {
        return new GenericWorker("STORE decompression");
      }
    };
    exports2.DEFLATE = require_flate();
  }
});

// ../node_modules/jszip/lib/signature.js
var require_signature = __commonJS({
  "../node_modules/jszip/lib/signature.js"(exports2) {
    "use strict";
    exports2.LOCAL_FILE_HEADER = "PK";
    exports2.CENTRAL_FILE_HEADER = "PK";
    exports2.CENTRAL_DIRECTORY_END = "PK";
    exports2.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK\x07";
    exports2.ZIP64_CENTRAL_DIRECTORY_END = "PK";
    exports2.DATA_DESCRIPTOR = "PK\x07\b";
  }
});

// ../node_modules/jszip/lib/generate/ZipFileWorker.js
var require_ZipFileWorker = __commonJS({
  "../node_modules/jszip/lib/generate/ZipFileWorker.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var utf8 = require_utf8();
    var crc32 = require_crc32();
    var signature = require_signature();
    var decToHex = function(dec, bytes) {
      var hex = "", i;
      for (i = 0; i < bytes; i++) {
        hex += String.fromCharCode(dec & 255);
        dec = dec >>> 8;
      }
      return hex;
    };
    var generateUnixExternalFileAttr = function(unixPermissions, isDir) {
      var result2 = unixPermissions;
      if (!unixPermissions) {
        result2 = isDir ? 16893 : 33204;
      }
      return (result2 & 65535) << 16;
    };
    var generateDosExternalFileAttr = function(dosPermissions) {
      return (dosPermissions || 0) & 63;
    };
    var generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
      var file = streamInfo["file"], compression = streamInfo["compression"], useCustomEncoding = encodeFileName !== utf8.utf8encode, encodedFileName = utils.transformTo("string", encodeFileName(file.name)), utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)), comment = file.comment, encodedComment = utils.transformTo("string", encodeFileName(comment)), utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)), useUTF8ForFileName = utfEncodedFileName.length !== file.name.length, useUTF8ForComment = utfEncodedComment.length !== comment.length, dosTime, dosDate, extraFields = "", unicodePathExtraField = "", unicodeCommentExtraField = "", dir = file.dir, date = file.date;
      var dataInfo = {
        crc32: 0,
        compressedSize: 0,
        uncompressedSize: 0
      };
      if (!streamedContent || streamingEnded) {
        dataInfo.crc32 = streamInfo["crc32"];
        dataInfo.compressedSize = streamInfo["compressedSize"];
        dataInfo.uncompressedSize = streamInfo["uncompressedSize"];
      }
      var bitflag = 0;
      if (streamedContent) {
        bitflag |= 8;
      }
      if (!useCustomEncoding && (useUTF8ForFileName || useUTF8ForComment)) {
        bitflag |= 2048;
      }
      var extFileAttr = 0;
      var versionMadeBy = 0;
      if (dir) {
        extFileAttr |= 16;
      }
      if (platform === "UNIX") {
        versionMadeBy = 798;
        extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir);
      } else {
        versionMadeBy = 20;
        extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir);
      }
      dosTime = date.getUTCHours();
      dosTime = dosTime << 6;
      dosTime = dosTime | date.getUTCMinutes();
      dosTime = dosTime << 5;
      dosTime = dosTime | date.getUTCSeconds() / 2;
      dosDate = date.getUTCFullYear() - 1980;
      dosDate = dosDate << 4;
      dosDate = dosDate | date.getUTCMonth() + 1;
      dosDate = dosDate << 5;
      dosDate = dosDate | date.getUTCDate();
      if (useUTF8ForFileName) {
        unicodePathExtraField = // Version
        decToHex(1, 1) + // NameCRC32
        decToHex(crc32(encodedFileName), 4) + // UnicodeName
        utfEncodedFileName;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "up" + // size
        decToHex(unicodePathExtraField.length, 2) + // content
        unicodePathExtraField;
      }
      if (useUTF8ForComment) {
        unicodeCommentExtraField = // Version
        decToHex(1, 1) + // CommentCRC32
        decToHex(crc32(encodedComment), 4) + // UnicodeName
        utfEncodedComment;
        extraFields += // Info-ZIP Unicode Path Extra Field
        "uc" + // size
        decToHex(unicodeCommentExtraField.length, 2) + // content
        unicodeCommentExtraField;
      }
      var header = "";
      header += "\n\0";
      header += decToHex(bitflag, 2);
      header += compression.magic;
      header += decToHex(dosTime, 2);
      header += decToHex(dosDate, 2);
      header += decToHex(dataInfo.crc32, 4);
      header += decToHex(dataInfo.compressedSize, 4);
      header += decToHex(dataInfo.uncompressedSize, 4);
      header += decToHex(encodedFileName.length, 2);
      header += decToHex(extraFields.length, 2);
      var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields;
      var dirRecord = signature.CENTRAL_FILE_HEADER + // version made by (00: DOS)
      decToHex(versionMadeBy, 2) + // file header (common to file and central directory)
      header + // file comment length
      decToHex(encodedComment.length, 2) + // disk number start
      "\0\0\0\0" + // external file attributes
      decToHex(extFileAttr, 4) + // relative offset of local header
      decToHex(offset, 4) + // file name
      encodedFileName + // extra field
      extraFields + // file comment
      encodedComment;
      return {
        fileRecord,
        dirRecord
      };
    };
    var generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
      var dirEnd = "";
      var encodedComment = utils.transformTo("string", encodeFileName(comment));
      dirEnd = signature.CENTRAL_DIRECTORY_END + // number of this disk
      "\0\0\0\0" + // total number of entries in the central directory on this disk
      decToHex(entriesCount, 2) + // total number of entries in the central directory
      decToHex(entriesCount, 2) + // size of the central directory   4 bytes
      decToHex(centralDirLength, 4) + // offset of start of central directory with respect to the starting disk number
      decToHex(localDirLength, 4) + // .ZIP file comment length
      decToHex(encodedComment.length, 2) + // .ZIP file comment
      encodedComment;
      return dirEnd;
    };
    var generateDataDescriptors = function(streamInfo) {
      var descriptor = "";
      descriptor = signature.DATA_DESCRIPTOR + // crc-32                          4 bytes
      decToHex(streamInfo["crc32"], 4) + // compressed size                 4 bytes
      decToHex(streamInfo["compressedSize"], 4) + // uncompressed size               4 bytes
      decToHex(streamInfo["uncompressedSize"], 4);
      return descriptor;
    };
    function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
      GenericWorker.call(this, "ZipFileWorker");
      this.bytesWritten = 0;
      this.zipComment = comment;
      this.zipPlatform = platform;
      this.encodeFileName = encodeFileName;
      this.streamFiles = streamFiles;
      this.accumulate = false;
      this.contentBuffer = [];
      this.dirRecords = [];
      this.currentSourceOffset = 0;
      this.entriesCount = 0;
      this.currentFile = null;
      this._sources = [];
    }
    utils.inherits(ZipFileWorker, GenericWorker);
    ZipFileWorker.prototype.push = function(chunk2) {
      var currentFilePercent = chunk2.meta.percent || 0;
      var entriesCount = this.entriesCount;
      var remainingFiles = this._sources.length;
      if (this.accumulate) {
        this.contentBuffer.push(chunk2);
      } else {
        this.bytesWritten += chunk2.data.length;
        GenericWorker.prototype.push.call(this, {
          data: chunk2.data,
          meta: {
            currentFile: this.currentFile,
            percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
          }
        });
      }
    };
    ZipFileWorker.prototype.openedSource = function(streamInfo) {
      this.currentSourceOffset = this.bytesWritten;
      this.currentFile = streamInfo["file"].name;
      var streamedContent = this.streamFiles && !streamInfo["file"].dir;
      if (streamedContent) {
        var record = generateZipParts(streamInfo, streamedContent, false, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
        this.push({
          data: record.fileRecord,
          meta: { percent: 0 }
        });
      } else {
        this.accumulate = true;
      }
    };
    ZipFileWorker.prototype.closedSource = function(streamInfo) {
      this.accumulate = false;
      var streamedContent = this.streamFiles && !streamInfo["file"].dir;
      var record = generateZipParts(streamInfo, streamedContent, true, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
      this.dirRecords.push(record.dirRecord);
      if (streamedContent) {
        this.push({
          data: generateDataDescriptors(streamInfo),
          meta: { percent: 100 }
        });
      } else {
        this.push({
          data: record.fileRecord,
          meta: { percent: 0 }
        });
        while (this.contentBuffer.length) {
          this.push(this.contentBuffer.shift());
        }
      }
      this.currentFile = null;
    };
    ZipFileWorker.prototype.flush = function() {
      var localDirLength = this.bytesWritten;
      for (var i = 0; i < this.dirRecords.length; i++) {
        this.push({
          data: this.dirRecords[i],
          meta: { percent: 100 }
        });
      }
      var centralDirLength = this.bytesWritten - localDirLength;
      var dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
      this.push({
        data: dirEnd,
        meta: { percent: 100 }
      });
    };
    ZipFileWorker.prototype.prepareNextSource = function() {
      this.previous = this._sources.shift();
      this.openedSource(this.previous.streamInfo);
      if (this.isPaused) {
        this.previous.pause();
      } else {
        this.previous.resume();
      }
    };
    ZipFileWorker.prototype.registerPrevious = function(previous) {
      this._sources.push(previous);
      var self2 = this;
      previous.on("data", function(chunk2) {
        self2.processChunk(chunk2);
      });
      previous.on("end", function() {
        self2.closedSource(self2.previous.streamInfo);
        if (self2._sources.length) {
          self2.prepareNextSource();
        } else {
          self2.end();
        }
      });
      previous.on("error", function(e) {
        self2.error(e);
      });
      return this;
    };
    ZipFileWorker.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (!this.previous && this._sources.length) {
        this.prepareNextSource();
        return true;
      }
      if (!this.previous && !this._sources.length && !this.generatedError) {
        this.end();
        return true;
      }
    };
    ZipFileWorker.prototype.error = function(e) {
      var sources = this._sources;
      if (!GenericWorker.prototype.error.call(this, e)) {
        return false;
      }
      for (var i = 0; i < sources.length; i++) {
        try {
          sources[i].error(e);
        } catch (e2) {
        }
      }
      return true;
    };
    ZipFileWorker.prototype.lock = function() {
      GenericWorker.prototype.lock.call(this);
      var sources = this._sources;
      for (var i = 0; i < sources.length; i++) {
        sources[i].lock();
      }
    };
    module2.exports = ZipFileWorker;
  }
});

// ../node_modules/jszip/lib/generate/index.js
var require_generate = __commonJS({
  "../node_modules/jszip/lib/generate/index.js"(exports2) {
    "use strict";
    var compressions = require_compressions();
    var ZipFileWorker = require_ZipFileWorker();
    var getCompression = function(fileCompression, zipCompression) {
      var compressionName = fileCompression || zipCompression;
      var compression = compressions[compressionName];
      if (!compression) {
        throw new Error(compressionName + " is not a valid compression method !");
      }
      return compression;
    };
    exports2.generateWorker = function(zip, options, comment) {
      var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName);
      var entriesCount = 0;
      try {
        zip.forEach(function(relativePath, file) {
          entriesCount++;
          var compression = getCompression(file.options.compression, options.compression);
          var compressionOptions = file.options.compressionOptions || options.compressionOptions || {};
          var dir = file.dir, date = file.date;
          file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
            name: relativePath,
            dir,
            date,
            comment: file.comment || "",
            unixPermissions: file.unixPermissions,
            dosPermissions: file.dosPermissions
          }).pipe(zipFileWorker);
        });
        zipFileWorker.entriesCount = entriesCount;
      } catch (e) {
        zipFileWorker.error(e);
      }
      return zipFileWorker;
    };
  }
});

// ../node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js
var require_NodejsStreamInputAdapter = __commonJS({
  "../node_modules/jszip/lib/nodejs/NodejsStreamInputAdapter.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    function NodejsStreamInputAdapter(filename, stream) {
      GenericWorker.call(this, "Nodejs stream input adapter for " + filename);
      this._upstreamEnded = false;
      this._bindStream(stream);
    }
    utils.inherits(NodejsStreamInputAdapter, GenericWorker);
    NodejsStreamInputAdapter.prototype._bindStream = function(stream) {
      var self2 = this;
      this._stream = stream;
      stream.pause();
      stream.on("data", function(chunk2) {
        self2.push({
          data: chunk2,
          meta: {
            percent: 0
          }
        });
      }).on("error", function(e) {
        if (self2.isPaused) {
          this.generatedError = e;
        } else {
          self2.error(e);
        }
      }).on("end", function() {
        if (self2.isPaused) {
          self2._upstreamEnded = true;
        } else {
          self2.end();
        }
      });
    };
    NodejsStreamInputAdapter.prototype.pause = function() {
      if (!GenericWorker.prototype.pause.call(this)) {
        return false;
      }
      this._stream.pause();
      return true;
    };
    NodejsStreamInputAdapter.prototype.resume = function() {
      if (!GenericWorker.prototype.resume.call(this)) {
        return false;
      }
      if (this._upstreamEnded) {
        this.end();
      } else {
        this._stream.resume();
      }
      return true;
    };
    module2.exports = NodejsStreamInputAdapter;
  }
});

// ../node_modules/jszip/lib/object.js
var require_object = __commonJS({
  "../node_modules/jszip/lib/object.js"(exports2, module2) {
    "use strict";
    var utf8 = require_utf8();
    var utils = require_utils();
    var GenericWorker = require_GenericWorker();
    var StreamHelper = require_StreamHelper();
    var defaults = require_defaults();
    var CompressedObject = require_compressedObject();
    var ZipObject = require_zipObject();
    var generate = require_generate();
    var nodejsUtils = require_nodejsUtils();
    var NodejsStreamInputAdapter = require_NodejsStreamInputAdapter();
    var fileAdd = function(name, data, originalOptions) {
      var dataType = utils.getTypeOf(data), parent;
      var o = utils.extend(originalOptions || {}, defaults);
      o.date = o.date || /* @__PURE__ */ new Date();
      if (o.compression !== null) {
        o.compression = o.compression.toUpperCase();
      }
      if (typeof o.unixPermissions === "string") {
        o.unixPermissions = parseInt(o.unixPermissions, 8);
      }
      if (o.unixPermissions && o.unixPermissions & 16384) {
        o.dir = true;
      }
      if (o.dosPermissions && o.dosPermissions & 16) {
        o.dir = true;
      }
      if (o.dir) {
        name = forceTrailingSlash(name);
      }
      if (o.createFolders && (parent = parentFolder(name))) {
        folderAdd.call(this, parent, true);
      }
      var isUnicodeString = dataType === "string" && o.binary === false && o.base64 === false;
      if (!originalOptions || typeof originalOptions.binary === "undefined") {
        o.binary = !isUnicodeString;
      }
      var isCompressedEmpty = data instanceof CompressedObject && data.uncompressedSize === 0;
      if (isCompressedEmpty || o.dir || !data || data.length === 0) {
        o.base64 = false;
        o.binary = true;
        data = "";
        o.compression = "STORE";
        dataType = "string";
      }
      var zipObjectContent = null;
      if (data instanceof CompressedObject || data instanceof GenericWorker) {
        zipObjectContent = data;
      } else if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        zipObjectContent = new NodejsStreamInputAdapter(name, data);
      } else {
        zipObjectContent = utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
      }
      var object2 = new ZipObject(name, zipObjectContent, o);
      this.files[name] = object2;
    };
    var parentFolder = function(path2) {
      if (path2.slice(-1) === "/") {
        path2 = path2.substring(0, path2.length - 1);
      }
      var lastSlash = path2.lastIndexOf("/");
      return lastSlash > 0 ? path2.substring(0, lastSlash) : "";
    };
    var forceTrailingSlash = function(path2) {
      if (path2.slice(-1) !== "/") {
        path2 += "/";
      }
      return path2;
    };
    var folderAdd = function(name, createFolders) {
      createFolders = typeof createFolders !== "undefined" ? createFolders : defaults.createFolders;
      name = forceTrailingSlash(name);
      if (!this.files[name]) {
        fileAdd.call(this, name, null, {
          dir: true,
          createFolders
        });
      }
      return this.files[name];
    };
    function isRegExp(object2) {
      return Object.prototype.toString.call(object2) === "[object RegExp]";
    }
    var out = {
      /**
       * @see loadAsync
       */
      load: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      },
      /**
       * Call a callback function for each entry at this folder level.
       * @param {Function} cb the callback function:
       * function (relativePath, file) {...}
       * It takes 2 arguments : the relative path and the file.
       */
      forEach: function(cb2) {
        var filename, relativePath, file;
        for (filename in this.files) {
          file = this.files[filename];
          relativePath = filename.slice(this.root.length, filename.length);
          if (relativePath && filename.slice(0, this.root.length) === this.root) {
            cb2(relativePath, file);
          }
        }
      },
      /**
       * Filter nested files/folders with the specified function.
       * @param {Function} search the predicate to use :
       * function (relativePath, file) {...}
       * It takes 2 arguments : the relative path and the file.
       * @return {Array} An array of matching elements.
       */
      filter: function(search) {
        var result2 = [];
        this.forEach(function(relativePath, entry) {
          if (search(relativePath, entry)) {
            result2.push(entry);
          }
        });
        return result2;
      },
      /**
       * Add a file to the zip file, or search a file.
       * @param   {string|RegExp} name The name of the file to add (if data is defined),
       * the name of the file to find (if no data) or a regex to match files.
       * @param   {String|ArrayBuffer|Uint8Array|Buffer} data  The file data, either raw or base64 encoded
       * @param   {Object} o     File options
       * @return  {JSZip|Object|Array} this JSZip object (when adding a file),
       * a file (when searching by string) or an array of files (when searching by regex).
       */
      file: function(name, data, o) {
        if (arguments.length === 1) {
          if (isRegExp(name)) {
            var regexp = name;
            return this.filter(function(relativePath, file) {
              return !file.dir && regexp.test(relativePath);
            });
          } else {
            var obj = this.files[this.root + name];
            if (obj && !obj.dir) {
              return obj;
            } else {
              return null;
            }
          }
        } else {
          name = this.root + name;
          fileAdd.call(this, name, data, o);
        }
        return this;
      },
      /**
       * Add a directory to the zip file, or search.
       * @param   {String|RegExp} arg The name of the directory to add, or a regex to search folders.
       * @return  {JSZip} an object with the new directory as the root, or an array containing matching folders.
       */
      folder: function(arg) {
        if (!arg) {
          return this;
        }
        if (isRegExp(arg)) {
          return this.filter(function(relativePath, file) {
            return file.dir && arg.test(relativePath);
          });
        }
        var name = this.root + arg;
        var newFolder = folderAdd.call(this, name);
        var ret = this.clone();
        ret.root = newFolder.name;
        return ret;
      },
      /**
       * Delete a file, or a directory and all sub-files, from the zip
       * @param {string} name the name of the file to delete
       * @return {JSZip} this JSZip object
       */
      remove: function(name) {
        name = this.root + name;
        var file = this.files[name];
        if (!file) {
          if (name.slice(-1) !== "/") {
            name += "/";
          }
          file = this.files[name];
        }
        if (file && !file.dir) {
          delete this.files[name];
        } else {
          var kids = this.filter(function(relativePath, file2) {
            return file2.name.slice(0, name.length) === name;
          });
          for (var i = 0; i < kids.length; i++) {
            delete this.files[kids[i].name];
          }
        }
        return this;
      },
      /**
       * @deprecated This method has been removed in JSZip 3.0, please check the upgrade guide.
       */
      generate: function() {
        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.");
      },
      /**
       * Generate the complete zip file as an internal stream.
       * @param {Object} options the options to generate the zip file :
       * - compression, "STORE" by default.
       * - type, "base64" by default. Values are : string, base64, uint8array, arraybuffer, blob.
       * @return {StreamHelper} the streamed zip file.
       */
      generateInternalStream: function(options) {
        var worker, opts = {};
        try {
          opts = utils.extend(options || {}, {
            streamFiles: false,
            compression: "STORE",
            compressionOptions: null,
            type: "",
            platform: "DOS",
            comment: null,
            mimeType: "application/zip",
            encodeFileName: utf8.utf8encode
          });
          opts.type = opts.type.toLowerCase();
          opts.compression = opts.compression.toUpperCase();
          if (opts.type === "binarystring") {
            opts.type = "string";
          }
          if (!opts.type) {
            throw new Error("No output type specified.");
          }
          utils.checkSupport(opts.type);
          if (opts.platform === "darwin" || opts.platform === "freebsd" || opts.platform === "linux" || opts.platform === "sunos") {
            opts.platform = "UNIX";
          }
          if (opts.platform === "win32") {
            opts.platform = "DOS";
          }
          var comment = opts.comment || this.comment || "";
          worker = generate.generateWorker(this, opts, comment);
        } catch (e) {
          worker = new GenericWorker("error");
          worker.error(e);
        }
        return new StreamHelper(worker, opts.type || "string", opts.mimeType);
      },
      /**
       * Generate the complete zip file asynchronously.
       * @see generateInternalStream
       */
      generateAsync: function(options, onUpdate) {
        return this.generateInternalStream(options).accumulate(onUpdate);
      },
      /**
       * Generate the complete zip file asynchronously.
       * @see generateInternalStream
       */
      generateNodeStream: function(options, onUpdate) {
        options = options || {};
        if (!options.type) {
          options.type = "nodebuffer";
        }
        return this.generateInternalStream(options).toNodejsStream(onUpdate);
      }
    };
    module2.exports = out;
  }
});

// ../node_modules/jszip/lib/reader/DataReader.js
var require_DataReader = __commonJS({
  "../node_modules/jszip/lib/reader/DataReader.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    function DataReader(data) {
      this.data = data;
      this.length = data.length;
      this.index = 0;
      this.zero = 0;
    }
    DataReader.prototype = {
      /**
       * Check that the offset will not go too far.
       * @param {string} offset the additional offset to check.
       * @throws {Error} an Error if the offset is out of bounds.
       */
      checkOffset: function(offset) {
        this.checkIndex(this.index + offset);
      },
      /**
       * Check that the specified index will not be too far.
       * @param {string} newIndex the index to check.
       * @throws {Error} an Error if the index is out of bounds.
       */
      checkIndex: function(newIndex) {
        if (this.length < this.zero + newIndex || newIndex < 0) {
          throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?");
        }
      },
      /**
       * Change the index.
       * @param {number} newIndex The new index.
       * @throws {Error} if the new index is out of the data.
       */
      setIndex: function(newIndex) {
        this.checkIndex(newIndex);
        this.index = newIndex;
      },
      /**
       * Skip the next n bytes.
       * @param {number} n the number of bytes to skip.
       * @throws {Error} if the new index is out of the data.
       */
      skip: function(n) {
        this.setIndex(this.index + n);
      },
      /**
       * Get the byte at the specified index.
       * @param {number} i the index to use.
       * @return {number} a byte.
       */
      byteAt: function() {
      },
      /**
       * Get the next number with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {number} the corresponding number.
       */
      readInt: function(size2) {
        var result2 = 0, i;
        this.checkOffset(size2);
        for (i = this.index + size2 - 1; i >= this.index; i--) {
          result2 = (result2 << 8) + this.byteAt(i);
        }
        this.index += size2;
        return result2;
      },
      /**
       * Get the next string with a given byte size.
       * @param {number} size the number of bytes to read.
       * @return {string} the corresponding string.
       */
      readString: function(size2) {
        return utils.transformTo("string", this.readData(size2));
      },
      /**
       * Get raw data without conversion, <size> bytes.
       * @param {number} size the number of bytes to read.
       * @return {Object} the raw data, implementation specific.
       */
      readData: function() {
      },
      /**
       * Find the last occurrence of a zip signature (4 bytes).
       * @param {string} sig the signature to find.
       * @return {number} the index of the last occurrence, -1 if not found.
       */
      lastIndexOfSignature: function() {
      },
      /**
       * Read the signature (4 bytes) at the current position and compare it with sig.
       * @param {string} sig the expected signature
       * @return {boolean} true if the signature matches, false otherwise.
       */
      readAndCheckSignature: function() {
      },
      /**
       * Get the next date.
       * @return {Date} the date.
       */
      readDate: function() {
        var dostime = this.readInt(4);
        return new Date(Date.UTC(
          (dostime >> 25 & 127) + 1980,
          // year
          (dostime >> 21 & 15) - 1,
          // month
          dostime >> 16 & 31,
          // day
          dostime >> 11 & 31,
          // hour
          dostime >> 5 & 63,
          // minute
          (dostime & 31) << 1
        ));
      }
    };
    module2.exports = DataReader;
  }
});

// ../node_modules/jszip/lib/reader/ArrayReader.js
var require_ArrayReader = __commonJS({
  "../node_modules/jszip/lib/reader/ArrayReader.js"(exports2, module2) {
    "use strict";
    var DataReader = require_DataReader();
    var utils = require_utils();
    function ArrayReader(data) {
      DataReader.call(this, data);
      for (var i = 0; i < this.data.length; i++) {
        data[i] = data[i] & 255;
      }
    }
    utils.inherits(ArrayReader, DataReader);
    ArrayReader.prototype.byteAt = function(i) {
      return this.data[this.zero + i];
    };
    ArrayReader.prototype.lastIndexOfSignature = function(sig) {
      var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3);
      for (var i = this.length - 4; i >= 0; --i) {
        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) {
          return i - this.zero;
        }
      }
      return -1;
    };
    ArrayReader.prototype.readAndCheckSignature = function(sig) {
      var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), data = this.readData(4);
      return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3];
    };
    ArrayReader.prototype.readData = function(size2) {
      this.checkOffset(size2);
      if (size2 === 0) {
        return [];
      }
      var result2 = this.data.slice(this.zero + this.index, this.zero + this.index + size2);
      this.index += size2;
      return result2;
    };
    module2.exports = ArrayReader;
  }
});

// ../node_modules/jszip/lib/reader/StringReader.js
var require_StringReader = __commonJS({
  "../node_modules/jszip/lib/reader/StringReader.js"(exports2, module2) {
    "use strict";
    var DataReader = require_DataReader();
    var utils = require_utils();
    function StringReader(data) {
      DataReader.call(this, data);
    }
    utils.inherits(StringReader, DataReader);
    StringReader.prototype.byteAt = function(i) {
      return this.data.charCodeAt(this.zero + i);
    };
    StringReader.prototype.lastIndexOfSignature = function(sig) {
      return this.data.lastIndexOf(sig) - this.zero;
    };
    StringReader.prototype.readAndCheckSignature = function(sig) {
      var data = this.readData(4);
      return sig === data;
    };
    StringReader.prototype.readData = function(size2) {
      this.checkOffset(size2);
      var result2 = this.data.slice(this.zero + this.index, this.zero + this.index + size2);
      this.index += size2;
      return result2;
    };
    module2.exports = StringReader;
  }
});

// ../node_modules/jszip/lib/reader/Uint8ArrayReader.js
var require_Uint8ArrayReader = __commonJS({
  "../node_modules/jszip/lib/reader/Uint8ArrayReader.js"(exports2, module2) {
    "use strict";
    var ArrayReader = require_ArrayReader();
    var utils = require_utils();
    function Uint8ArrayReader(data) {
      ArrayReader.call(this, data);
    }
    utils.inherits(Uint8ArrayReader, ArrayReader);
    Uint8ArrayReader.prototype.readData = function(size2) {
      this.checkOffset(size2);
      if (size2 === 0) {
        return new Uint8Array(0);
      }
      var result2 = this.data.subarray(this.zero + this.index, this.zero + this.index + size2);
      this.index += size2;
      return result2;
    };
    module2.exports = Uint8ArrayReader;
  }
});

// ../node_modules/jszip/lib/reader/NodeBufferReader.js
var require_NodeBufferReader = __commonJS({
  "../node_modules/jszip/lib/reader/NodeBufferReader.js"(exports2, module2) {
    "use strict";
    var Uint8ArrayReader = require_Uint8ArrayReader();
    var utils = require_utils();
    function NodeBufferReader(data) {
      Uint8ArrayReader.call(this, data);
    }
    utils.inherits(NodeBufferReader, Uint8ArrayReader);
    NodeBufferReader.prototype.readData = function(size2) {
      this.checkOffset(size2);
      var result2 = this.data.slice(this.zero + this.index, this.zero + this.index + size2);
      this.index += size2;
      return result2;
    };
    module2.exports = NodeBufferReader;
  }
});

// ../node_modules/jszip/lib/reader/readerFor.js
var require_readerFor = __commonJS({
  "../node_modules/jszip/lib/reader/readerFor.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var support = require_support();
    var ArrayReader = require_ArrayReader();
    var StringReader = require_StringReader();
    var NodeBufferReader = require_NodeBufferReader();
    var Uint8ArrayReader = require_Uint8ArrayReader();
    module2.exports = function(data) {
      var type = utils.getTypeOf(data);
      utils.checkSupport(type);
      if (type === "string" && !support.uint8array) {
        return new StringReader(data);
      }
      if (type === "nodebuffer") {
        return new NodeBufferReader(data);
      }
      if (support.uint8array) {
        return new Uint8ArrayReader(utils.transformTo("uint8array", data));
      }
      return new ArrayReader(utils.transformTo("array", data));
    };
  }
});

// ../node_modules/jszip/lib/zipEntry.js
var require_zipEntry = __commonJS({
  "../node_modules/jszip/lib/zipEntry.js"(exports2, module2) {
    "use strict";
    var readerFor = require_readerFor();
    var utils = require_utils();
    var CompressedObject = require_compressedObject();
    var crc32fn = require_crc32();
    var utf8 = require_utf8();
    var compressions = require_compressions();
    var support = require_support();
    var MADE_BY_DOS = 0;
    var MADE_BY_UNIX = 3;
    var findCompression = function(compressionMethod) {
      for (var method in compressions) {
        if (!Object.prototype.hasOwnProperty.call(compressions, method)) {
          continue;
        }
        if (compressions[method].magic === compressionMethod) {
          return compressions[method];
        }
      }
      return null;
    };
    function ZipEntry(options, loadOptions) {
      this.options = options;
      this.loadOptions = loadOptions;
    }
    ZipEntry.prototype = {
      /**
       * say if the file is encrypted.
       * @return {boolean} true if the file is encrypted, false otherwise.
       */
      isEncrypted: function() {
        return (this.bitFlag & 1) === 1;
      },
      /**
       * say if the file has utf-8 filename/comment.
       * @return {boolean} true if the filename/comment is in utf-8, false otherwise.
       */
      useUTF8: function() {
        return (this.bitFlag & 2048) === 2048;
      },
      /**
       * Read the local part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readLocalPart: function(reader) {
        var compression, localExtraFieldsLength;
        reader.skip(22);
        this.fileNameLength = reader.readInt(2);
        localExtraFieldsLength = reader.readInt(2);
        this.fileName = reader.readData(this.fileNameLength);
        reader.skip(localExtraFieldsLength);
        if (this.compressedSize === -1 || this.uncompressedSize === -1) {
          throw new Error("Bug or corrupted zip : didn't get enough information from the central directory (compressedSize === -1 || uncompressedSize === -1)");
        }
        compression = findCompression(this.compressionMethod);
        if (compression === null) {
          throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
        }
        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize));
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readCentralPart: function(reader) {
        this.versionMadeBy = reader.readInt(2);
        reader.skip(2);
        this.bitFlag = reader.readInt(2);
        this.compressionMethod = reader.readString(2);
        this.date = reader.readDate();
        this.crc32 = reader.readInt(4);
        this.compressedSize = reader.readInt(4);
        this.uncompressedSize = reader.readInt(4);
        var fileNameLength = reader.readInt(2);
        this.extraFieldsLength = reader.readInt(2);
        this.fileCommentLength = reader.readInt(2);
        this.diskNumberStart = reader.readInt(2);
        this.internalFileAttributes = reader.readInt(2);
        this.externalFileAttributes = reader.readInt(4);
        this.localHeaderOffset = reader.readInt(4);
        if (this.isEncrypted()) {
          throw new Error("Encrypted zip are not supported");
        }
        reader.skip(fileNameLength);
        this.readExtraFields(reader);
        this.parseZIP64ExtraField(reader);
        this.fileComment = reader.readData(this.fileCommentLength);
      },
      /**
       * Parse the external file attributes and get the unix/dos permissions.
       */
      processAttributes: function() {
        this.unixPermissions = null;
        this.dosPermissions = null;
        var madeBy = this.versionMadeBy >> 8;
        this.dir = this.externalFileAttributes & 16 ? true : false;
        if (madeBy === MADE_BY_DOS) {
          this.dosPermissions = this.externalFileAttributes & 63;
        }
        if (madeBy === MADE_BY_UNIX) {
          this.unixPermissions = this.externalFileAttributes >> 16 & 65535;
        }
        if (!this.dir && this.fileNameStr.slice(-1) === "/") {
          this.dir = true;
        }
      },
      /**
       * Parse the ZIP64 extra field and merge the info in the current ZipEntry.
       * @param {DataReader} reader the reader to use.
       */
      parseZIP64ExtraField: function() {
        if (!this.extraFields[1]) {
          return;
        }
        var extraReader = readerFor(this.extraFields[1].value);
        if (this.uncompressedSize === utils.MAX_VALUE_32BITS) {
          this.uncompressedSize = extraReader.readInt(8);
        }
        if (this.compressedSize === utils.MAX_VALUE_32BITS) {
          this.compressedSize = extraReader.readInt(8);
        }
        if (this.localHeaderOffset === utils.MAX_VALUE_32BITS) {
          this.localHeaderOffset = extraReader.readInt(8);
        }
        if (this.diskNumberStart === utils.MAX_VALUE_32BITS) {
          this.diskNumberStart = extraReader.readInt(4);
        }
      },
      /**
       * Read the central part of a zip file and add the info in this object.
       * @param {DataReader} reader the reader to use.
       */
      readExtraFields: function(reader) {
        var end = reader.index + this.extraFieldsLength, extraFieldId, extraFieldLength, extraFieldValue;
        if (!this.extraFields) {
          this.extraFields = {};
        }
        while (reader.index + 4 < end) {
          extraFieldId = reader.readInt(2);
          extraFieldLength = reader.readInt(2);
          extraFieldValue = reader.readData(extraFieldLength);
          this.extraFields[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
        reader.setIndex(end);
      },
      /**
       * Apply an UTF8 transformation if needed.
       */
      handleUTF8: function() {
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        if (this.useUTF8()) {
          this.fileNameStr = utf8.utf8decode(this.fileName);
          this.fileCommentStr = utf8.utf8decode(this.fileComment);
        } else {
          var upath = this.findExtraFieldUnicodePath();
          if (upath !== null) {
            this.fileNameStr = upath;
          } else {
            var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
            this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray);
          }
          var ucomment = this.findExtraFieldUnicodeComment();
          if (ucomment !== null) {
            this.fileCommentStr = ucomment;
          } else {
            var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
            this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray);
          }
        }
      },
      /**
       * Find the unicode path declared in the extra field, if any.
       * @return {String} the unicode path, null otherwise.
       */
      findExtraFieldUnicodePath: function() {
        var upathField = this.extraFields[28789];
        if (upathField) {
          var extraReader = readerFor(upathField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (crc32fn(this.fileName) !== extraReader.readInt(4)) {
            return null;
          }
          return utf8.utf8decode(extraReader.readData(upathField.length - 5));
        }
        return null;
      },
      /**
       * Find the unicode comment declared in the extra field, if any.
       * @return {String} the unicode comment, null otherwise.
       */
      findExtraFieldUnicodeComment: function() {
        var ucommentField = this.extraFields[25461];
        if (ucommentField) {
          var extraReader = readerFor(ucommentField.value);
          if (extraReader.readInt(1) !== 1) {
            return null;
          }
          if (crc32fn(this.fileComment) !== extraReader.readInt(4)) {
            return null;
          }
          return utf8.utf8decode(extraReader.readData(ucommentField.length - 5));
        }
        return null;
      }
    };
    module2.exports = ZipEntry;
  }
});

// ../node_modules/jszip/lib/zipEntries.js
var require_zipEntries = __commonJS({
  "../node_modules/jszip/lib/zipEntries.js"(exports2, module2) {
    "use strict";
    var readerFor = require_readerFor();
    var utils = require_utils();
    var sig = require_signature();
    var ZipEntry = require_zipEntry();
    var support = require_support();
    function ZipEntries(loadOptions) {
      this.files = [];
      this.loadOptions = loadOptions;
    }
    ZipEntries.prototype = {
      /**
       * Check that the reader is on the specified signature.
       * @param {string} expectedSignature the expected signature.
       * @throws {Error} if it is an other signature.
       */
      checkSignature: function(expectedSignature) {
        if (!this.reader.readAndCheckSignature(expectedSignature)) {
          this.reader.index -= 4;
          var signature = this.reader.readString(4);
          throw new Error("Corrupted zip or bug: unexpected signature (" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")");
        }
      },
      /**
       * Check if the given signature is at the given index.
       * @param {number} askedIndex the index to check.
       * @param {string} expectedSignature the signature to expect.
       * @return {boolean} true if the signature is here, false otherwise.
       */
      isSignature: function(askedIndex, expectedSignature) {
        var currentIndex = this.reader.index;
        this.reader.setIndex(askedIndex);
        var signature = this.reader.readString(4);
        var result2 = signature === expectedSignature;
        this.reader.setIndex(currentIndex);
        return result2;
      },
      /**
       * Read the end of the central directory.
       */
      readBlockEndOfCentral: function() {
        this.diskNumber = this.reader.readInt(2);
        this.diskWithCentralDirStart = this.reader.readInt(2);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(2);
        this.centralDirRecords = this.reader.readInt(2);
        this.centralDirSize = this.reader.readInt(4);
        this.centralDirOffset = this.reader.readInt(4);
        this.zipCommentLength = this.reader.readInt(2);
        var zipComment = this.reader.readData(this.zipCommentLength);
        var decodeParamType = support.uint8array ? "uint8array" : "array";
        var decodeContent = utils.transformTo(decodeParamType, zipComment);
        this.zipComment = this.loadOptions.decodeFileName(decodeContent);
      },
      /**
       * Read the end of the Zip 64 central directory.
       * Not merged with the method readEndOfCentral :
       * The end of central can coexist with its Zip64 brother,
       * I don't want to read the wrong number of bytes !
       */
      readBlockZip64EndOfCentral: function() {
        this.zip64EndOfCentralSize = this.reader.readInt(8);
        this.reader.skip(4);
        this.diskNumber = this.reader.readInt(4);
        this.diskWithCentralDirStart = this.reader.readInt(4);
        this.centralDirRecordsOnThisDisk = this.reader.readInt(8);
        this.centralDirRecords = this.reader.readInt(8);
        this.centralDirSize = this.reader.readInt(8);
        this.centralDirOffset = this.reader.readInt(8);
        this.zip64ExtensibleData = {};
        var extraDataSize = this.zip64EndOfCentralSize - 44, index = 0, extraFieldId, extraFieldLength, extraFieldValue;
        while (index < extraDataSize) {
          extraFieldId = this.reader.readInt(2);
          extraFieldLength = this.reader.readInt(4);
          extraFieldValue = this.reader.readData(extraFieldLength);
          this.zip64ExtensibleData[extraFieldId] = {
            id: extraFieldId,
            length: extraFieldLength,
            value: extraFieldValue
          };
        }
      },
      /**
       * Read the end of the Zip 64 central directory locator.
       */
      readBlockZip64EndOfCentralLocator: function() {
        this.diskWithZip64CentralDirStart = this.reader.readInt(4);
        this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8);
        this.disksCount = this.reader.readInt(4);
        if (this.disksCount > 1) {
          throw new Error("Multi-volumes zip are not supported");
        }
      },
      /**
       * Read the local files, based on the offset read in the central part.
       */
      readLocalFiles: function() {
        var i, file;
        for (i = 0; i < this.files.length; i++) {
          file = this.files[i];
          this.reader.setIndex(file.localHeaderOffset);
          this.checkSignature(sig.LOCAL_FILE_HEADER);
          file.readLocalPart(this.reader);
          file.handleUTF8();
          file.processAttributes();
        }
      },
      /**
       * Read the central directory.
       */
      readCentralDir: function() {
        var file;
        this.reader.setIndex(this.centralDirOffset);
        while (this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER)) {
          file = new ZipEntry({
            zip64: this.zip64
          }, this.loadOptions);
          file.readCentralPart(this.reader);
          this.files.push(file);
        }
        if (this.centralDirRecords !== this.files.length) {
          if (this.centralDirRecords !== 0 && this.files.length === 0) {
            throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length);
          } else {
          }
        }
      },
      /**
       * Read the end of central directory.
       */
      readEndOfCentral: function() {
        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
        if (offset < 0) {
          var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
          if (isGarbage) {
            throw new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html");
          } else {
            throw new Error("Corrupted zip: can't find end of central directory");
          }
        }
        this.reader.setIndex(offset);
        var endOfCentralDirOffset = offset;
        this.checkSignature(sig.CENTRAL_DIRECTORY_END);
        this.readBlockEndOfCentral();
        if (this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
          this.zip64 = true;
          offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          if (offset < 0) {
            throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
          }
          this.reader.setIndex(offset);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR);
          this.readBlockZip64EndOfCentralLocator();
          if (!this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END)) {
            this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
            if (this.relativeOffsetEndOfZip64CentralDir < 0) {
              throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
            }
          }
          this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir);
          this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END);
          this.readBlockZip64EndOfCentral();
        }
        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
        if (this.zip64) {
          expectedEndOfCentralDirOffset += 20;
          expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize;
        }
        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
        if (extraBytes > 0) {
          if (this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER)) {
          } else {
            this.reader.zero = extraBytes;
          }
        } else if (extraBytes < 0) {
          throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.");
        }
      },
      prepareReader: function(data) {
        this.reader = readerFor(data);
      },
      /**
       * Read a zip file and create ZipEntries.
       * @param {String|ArrayBuffer|Uint8Array|Buffer} data the binary string representing a zip file.
       */
      load: function(data) {
        this.prepareReader(data);
        this.readEndOfCentral();
        this.readCentralDir();
        this.readLocalFiles();
      }
    };
    module2.exports = ZipEntries;
  }
});

// ../node_modules/jszip/lib/load.js
var require_load = __commonJS({
  "../node_modules/jszip/lib/load.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    var external = require_external();
    var utf8 = require_utf8();
    var ZipEntries = require_zipEntries();
    var Crc32Probe = require_Crc32Probe();
    var nodejsUtils = require_nodejsUtils();
    function checkEntryCRC32(zipEntry) {
      return new external.Promise(function(resolve, reject2) {
        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe());
        worker.on("error", function(e) {
          reject2(e);
        }).on("end", function() {
          if (worker.streamInfo.crc32 !== zipEntry.decompressed.crc32) {
            reject2(new Error("Corrupted zip : CRC32 mismatch"));
          } else {
            resolve();
          }
        }).resume();
      });
    }
    module2.exports = function(data, options) {
      var zip = this;
      options = utils.extend(options || {}, {
        base64: false,
        checkCRC32: false,
        optimizedBinaryString: false,
        createFolders: false,
        decodeFileName: utf8.utf8decode
      });
      if (nodejsUtils.isNode && nodejsUtils.isStream(data)) {
        return external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file."));
      }
      return utils.prepareContent("the loaded zip file", data, true, options.optimizedBinaryString, options.base64).then(function(data2) {
        var zipEntries = new ZipEntries(options);
        zipEntries.load(data2);
        return zipEntries;
      }).then(function checkCRC32(zipEntries) {
        var promises = [external.Promise.resolve(zipEntries)];
        var files = zipEntries.files;
        if (options.checkCRC32) {
          for (var i = 0; i < files.length; i++) {
            promises.push(checkEntryCRC32(files[i]));
          }
        }
        return external.Promise.all(promises);
      }).then(function addFiles(results) {
        var zipEntries = results.shift();
        var files = zipEntries.files;
        for (var i = 0; i < files.length; i++) {
          var input = files[i];
          var unsafeName = input.fileNameStr;
          var safeName = utils.resolve(input.fileNameStr);
          zip.file(safeName, input.decompressed, {
            binary: true,
            optimizedBinaryString: true,
            date: input.date,
            dir: input.dir,
            comment: input.fileCommentStr.length ? input.fileCommentStr : null,
            unixPermissions: input.unixPermissions,
            dosPermissions: input.dosPermissions,
            createFolders: options.createFolders
          });
          if (!input.dir) {
            zip.file(safeName).unsafeOriginalName = unsafeName;
          }
        }
        if (zipEntries.zipComment.length) {
          zip.comment = zipEntries.zipComment;
        }
        return zip;
      });
    };
  }
});

// ../node_modules/jszip/lib/index.js
var require_lib3 = __commonJS({
  "../node_modules/jszip/lib/index.js"(exports2, module2) {
    "use strict";
    function JSZip2() {
      if (!(this instanceof JSZip2)) {
        return new JSZip2();
      }
      if (arguments.length) {
        throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
      }
      this.files = /* @__PURE__ */ Object.create(null);
      this.comment = null;
      this.root = "";
      this.clone = function() {
        var newObj = new JSZip2();
        for (var i in this) {
          if (typeof this[i] !== "function") {
            newObj[i] = this[i];
          }
        }
        return newObj;
      };
    }
    JSZip2.prototype = require_object();
    JSZip2.prototype.loadAsync = require_load();
    JSZip2.support = require_support();
    JSZip2.defaults = require_defaults();
    JSZip2.version = "3.10.1";
    JSZip2.loadAsync = function(content, options) {
      return new JSZip2().loadAsync(content, options);
    };
    JSZip2.external = require_external();
    module2.exports = JSZip2;
  }
});

// ../common/qodana.ts
var qodana_exports = {};
__export(qodana_exports, {
  BRANCH: () => BRANCH,
  COVERAGE_THRESHOLD: () => COVERAGE_THRESHOLD,
  EXECUTABLE: () => EXECUTABLE,
  FAIL_THRESHOLD_OUTPUT: () => FAIL_THRESHOLD_OUTPUT,
  NONE: () => NONE,
  PULL_REQUEST: () => PULL_REQUEST,
  QODANA_LICENSES_JSON: () => QODANA_LICENSES_JSON,
  QODANA_LICENSES_MD: () => QODANA_LICENSES_MD,
  QODANA_OPEN_IN_IDE_NAME: () => QODANA_OPEN_IN_IDE_NAME,
  QODANA_REPORT_URL_NAME: () => QODANA_REPORT_URL_NAME,
  QODANA_SARIF_NAME: () => QODANA_SARIF_NAME,
  QODANA_SHORT_SARIF_NAME: () => QODANA_SHORT_SARIF_NAME,
  QodanaExitCode: () => QodanaExitCode,
  SUPPORTED_ARCHS: () => SUPPORTED_ARCHS,
  SUPPORTED_PLATFORMS: () => SUPPORTED_PLATFORMS,
  VERSION: () => VERSION,
  compressFolder: () => compressFolder,
  extractArg: () => extractArg,
  getCoverageFromSarif: () => getCoverageFromSarif,
  getProcessArchName: () => getProcessArchName,
  getProcessPlatformName: () => getProcessPlatformName,
  getQodanaPullArgs: () => getQodanaPullArgs,
  getQodanaScanArgs: () => getQodanaScanArgs,
  getQodanaSha256: () => getQodanaSha256,
  getQodanaSha256MismatchMessage: () => getQodanaSha256MismatchMessage,
  getQodanaUrl: () => getQodanaUrl,
  isExecutionSuccessful: () => isExecutionSuccessful,
  isNativeMode: () => isNativeMode,
  sha256sum: () => sha256sum,
  validateBranchName: () => validateBranchName
});
function getQodanaSha256(arch, platform) {
  switch (`${platform}_${arch}`) {
    case "windows_x86_64":
      return checksum["windows_x86_64"];
    case "windows_arm64":
      return checksum["windows_arm64"];
    case "linux_x86_64":
      return checksum["linux_x86_64"];
    case "linux_arm64":
      return checksum["linux_arm64"];
    case "darwin_x86_64":
      return checksum["darwin_x86_64"];
    case "darwin_arm64":
      return checksum["darwin_arm64"];
    default:
      throw new Error(`Qodana CLI does not exist for ${platform}_${arch}`);
  }
}
function getProcessArchName() {
  return process.arch === "x64" ? "x86_64" : "arm64";
}
function getProcessPlatformName() {
  return process.platform === "win32" ? "windows" : process.platform;
}
function getQodanaUrl(arch, platform, nightly = false) {
  if (!SUPPORTED_PLATFORMS.includes(platform)) {
    throw new Error(`Unsupported platform: ${platform}`);
  }
  if (!SUPPORTED_ARCHS.includes(arch)) {
    throw new Error(`Unsupported architecture: ${arch}`);
  }
  const archive = platform === "windows" ? "zip" : "tar.gz";
  const cli_version = nightly ? "nightly" : `v${version}`;
  return `https://github.com/JetBrains/qodana-cli/releases/download/${cli_version}/qodana_${platform}_${arch}.${archive}`;
}
function isExecutionSuccessful(exitCode) {
  return Object.values(QodanaExitCode).includes(exitCode);
}
function extractArg(argShort, argLong, args) {
  let arg = "";
  for (let i = 0; i < args.length; i++) {
    if (args[i] === argShort || args[i] === argLong) {
      arg = args[i + 1];
      break;
    }
  }
  return arg;
}
function isNativeMode(args) {
  return args.includes("--ide");
}
function getQodanaPullArgs(args) {
  const pullArgs = ["pull"];
  const linter = extractArg("-l", "--linter", args);
  if (linter) {
    pullArgs.push("-l", linter);
  }
  const project = extractArg("-i", "--project-dir", args);
  if (project) {
    pullArgs.push("-i", project);
  }
  const config = extractArg("--config", "--config", args);
  if (config) {
    pullArgs.push("--config", config);
  }
  return pullArgs;
}
function getQodanaScanArgs(args, resultsDir, cacheDir) {
  const cliArgs = [
    "scan",
    "--cache-dir",
    cacheDir,
    "--results-dir",
    resultsDir
  ];
  if (!isNativeMode(args)) {
    cliArgs.push("--skip-pull");
  }
  if (args) {
    cliArgs.push(...args);
  }
  return cliArgs;
}
function getCoverageFromSarif(sarifPath) {
  var _a, _b, _c, _d;
  if (fs.existsSync(sarifPath)) {
    const sarifContents = JSON.parse(
      fs.readFileSync(sarifPath, { encoding: "utf8" })
    );
    if (sarifContents.runs[0].properties["coverage"]) {
      return {
        totalCoverage: sarifContents.runs[0].properties["coverage"]["totalCoverage"] || 0,
        totalLines: sarifContents.runs[0].properties["coverage"]["totalLines"] || 0,
        totalCoveredLines: sarifContents.runs[0].properties["coverage"]["totalCoveredLines"] || 0,
        freshCoverage: sarifContents.runs[0].properties["coverage"]["freshCoverage"] || 0,
        freshLines: sarifContents.runs[0].properties["coverage"]["freshLines"] || 0,
        freshCoveredLines: sarifContents.runs[0].properties["coverage"]["freshCoveredLines"] || 0,
        totalCoverageThreshold: ((_b = (_a = sarifContents.runs[0].properties["qodanaFailureConditions"]) == null ? void 0 : _a["testCoverageThresholds"]) == null ? void 0 : _b["totalCoverage"]) || COVERAGE_THRESHOLD,
        freshCoverageThreshold: ((_d = (_c = sarifContents.runs[0].properties["qodanaFailureConditions"]) == null ? void 0 : _c["testCoverageThresholds"]) == null ? void 0 : _d["freshCoverage"]) || COVERAGE_THRESHOLD
      };
    } else {
      return {
        totalCoverage: 0,
        totalLines: 0,
        totalCoveredLines: 0,
        freshCoverage: 0,
        freshLines: 0,
        freshCoveredLines: 0,
        totalCoverageThreshold: COVERAGE_THRESHOLD,
        freshCoverageThreshold: COVERAGE_THRESHOLD
      };
    }
  }
  throw new Error(`SARIF file not found: ${sarifPath}`);
}
function sha256sum(file) {
  const hash = (0, import_crypto.createHash)("sha256");
  hash.update(fs.readFileSync(file));
  return hash.digest("hex");
}
function getQodanaSha256MismatchMessage(expected, actual) {
  return `Downloaded Qodana CLI binary is corrupted. Expected SHA-256 checksum: ${expected}, actual checksum: ${actual}`;
}
function validateBranchName(branchName) {
  const validBranchNameRegex = /^[a-zA-Z0-9/\-_.]+$/;
  if (!validBranchNameRegex.test(branchName)) {
    throw new Error(
      `Invalid branch name: not allowed characters are used: ${branchName}`
    );
  }
  return branchName;
}
async function getFilePathsRecursively(dir) {
  const list = await readdir2(dir);
  const statPromises = list.map(async (file) => {
    const fullPath = import_path.default.resolve(dir, file);
    const statPromise = await stat2(fullPath);
    if (statPromise && statPromise.isDirectory()) {
      return getFilePathsRecursively(fullPath);
    }
    return [fullPath];
  });
  return (await Promise.all(statPromises)).reduce(
    (acc, val) => acc.concat(val),
    []
  );
}
async function createZipFromFolder(dir) {
  const absRoot = import_path.default.resolve(dir);
  const filePaths = await getFilePathsRecursively(dir);
  const zip = new import_jszip.default();
  for (const filePath of filePaths) {
    const relative = filePath.replace(absRoot, "");
    zip.file(relative, fs.createReadStream(filePath), {
      unixPermissions: "777"
    });
  }
  return zip;
}
async function compressFolder(srcDir, destFile) {
  await mkdir2(import_path.default.dirname(destFile), { recursive: true });
  const zip = await createZipFromFolder(srcDir);
  await new Promise((resolve, reject2) => {
    zip.generateNodeStream({ streamFiles: true, compression: "DEFLATE" }).pipe(fs.createWriteStream(destFile)).on("error", (err) => reject2(err)).on("finish", resolve);
  });
}
var import_crypto, fs, import_path, import_jszip, import_util, readdir2, stat2, mkdir2, SUPPORTED_PLATFORMS, SUPPORTED_ARCHS, FAIL_THRESHOLD_OUTPUT, QODANA_SARIF_NAME, QODANA_SHORT_SARIF_NAME, QODANA_REPORT_URL_NAME, QODANA_OPEN_IN_IDE_NAME, QODANA_LICENSES_MD, QODANA_LICENSES_JSON, EXECUTABLE, VERSION, COVERAGE_THRESHOLD, QodanaExitCode, NONE, BRANCH, PULL_REQUEST;
var init_qodana = __esm({
  "../common/qodana.ts"() {
    "use strict";
    init_cli();
    import_crypto = require("crypto");
    fs = __toESM(require("fs"));
    import_path = __toESM(require("path"));
    import_jszip = __toESM(require_lib3());
    import_util = require("util");
    readdir2 = (0, import_util.promisify)(fs.readdir);
    stat2 = (0, import_util.promisify)(fs.stat);
    mkdir2 = (0, import_util.promisify)(fs.mkdir);
    SUPPORTED_PLATFORMS = ["windows", "linux", "darwin"];
    SUPPORTED_ARCHS = ["x86_64", "arm64"];
    FAIL_THRESHOLD_OUTPUT = "The number of problems exceeds the failThreshold";
    QODANA_SARIF_NAME = "qodana.sarif.json";
    QODANA_SHORT_SARIF_NAME = "qodana-short.sarif.json";
    QODANA_REPORT_URL_NAME = "qodana.cloud";
    QODANA_OPEN_IN_IDE_NAME = "open-in-ide.json";
    QODANA_LICENSES_MD = "thirdPartySoftwareList.md";
    QODANA_LICENSES_JSON = "third-party-libraries.json";
    EXECUTABLE = "qodana";
    VERSION = version;
    COVERAGE_THRESHOLD = 50;
    QodanaExitCode = /* @__PURE__ */ ((QodanaExitCode2) => {
      QodanaExitCode2[QodanaExitCode2["Success"] = 0] = "Success";
      QodanaExitCode2[QodanaExitCode2["FailThreshold"] = 255] = "FailThreshold";
      return QodanaExitCode2;
    })(QodanaExitCode || {});
    NONE = "none";
    BRANCH = "branch";
    PULL_REQUEST = "pull-request";
  }
});

// ../node_modules/es-errors/index.js
var require_es_errors = __commonJS({
  "../node_modules/es-errors/index.js"(exports2, module2) {
    "use strict";
    module2.exports = Error;
  }
});

// ../node_modules/es-errors/eval.js
var require_eval = __commonJS({
  "../node_modules/es-errors/eval.js"(exports2, module2) {
    "use strict";
    module2.exports = EvalError;
  }
});

// ../node_modules/es-errors/range.js
var require_range = __commonJS({
  "../node_modules/es-errors/range.js"(exports2, module2) {
    "use strict";
    module2.exports = RangeError;
  }
});

// ../node_modules/es-errors/ref.js
var require_ref = __commonJS({
  "../node_modules/es-errors/ref.js"(exports2, module2) {
    "use strict";
    module2.exports = ReferenceError;
  }
});

// ../node_modules/es-errors/syntax.js
var require_syntax = __commonJS({
  "../node_modules/es-errors/syntax.js"(exports2, module2) {
    "use strict";
    module2.exports = SyntaxError;
  }
});

// ../node_modules/es-errors/type.js
var require_type = __commonJS({
  "../node_modules/es-errors/type.js"(exports2, module2) {
    "use strict";
    module2.exports = TypeError;
  }
});

// ../node_modules/es-errors/uri.js
var require_uri = __commonJS({
  "../node_modules/es-errors/uri.js"(exports2, module2) {
    "use strict";
    module2.exports = URIError;
  }
});

// ../node_modules/has-symbols/shams.js
var require_shams = __commonJS({
  "../node_modules/has-symbols/shams.js"(exports2, module2) {
    "use strict";
    module2.exports = function hasSymbols() {
      if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
        return false;
      }
      if (typeof Symbol.iterator === "symbol") {
        return true;
      }
      var obj = {};
      var sym = Symbol("test");
      var symObj = Object(sym);
      if (typeof sym === "string") {
        return false;
      }
      if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
        return false;
      }
      if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
        return false;
      }
      var symVal = 42;
      obj[sym] = symVal;
      for (sym in obj) {
        return false;
      }
      if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
        return false;
      }
      if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
        return false;
      }
      var syms = Object.getOwnPropertySymbols(obj);
      if (syms.length !== 1 || syms[0] !== sym) {
        return false;
      }
      if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
        return false;
      }
      if (typeof Object.getOwnPropertyDescriptor === "function") {
        var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
        if (descriptor.value !== symVal || descriptor.enumerable !== true) {
          return false;
        }
      }
      return true;
    };
  }
});

// ../node_modules/has-symbols/index.js
var require_has_symbols = __commonJS({
  "../node_modules/has-symbols/index.js"(exports2, module2) {
    "use strict";
    var origSymbol = typeof Symbol !== "undefined" && Symbol;
    var hasSymbolSham = require_shams();
    module2.exports = function hasNativeSymbols() {
      if (typeof origSymbol !== "function") {
        return false;
      }
      if (typeof Symbol !== "function") {
        return false;
      }
      if (typeof origSymbol("foo") !== "symbol") {
        return false;
      }
      if (typeof Symbol("bar") !== "symbol") {
        return false;
      }
      return hasSymbolSham();
    };
  }
});

// ../node_modules/has-proto/index.js
var require_has_proto = __commonJS({
  "../node_modules/has-proto/index.js"(exports2, module2) {
    "use strict";
    var test = {
      __proto__: null,
      foo: {}
    };
    var $Object = Object;
    module2.exports = function hasProto() {
      return { __proto__: test }.foo === test.foo && !(test instanceof $Object);
    };
  }
});

// ../node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "../node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max2 = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result2 = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result2) === result2) {
            return result2;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max2(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// ../node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "../node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// ../node_modules/hasown/index.js
var require_hasown = __commonJS({
  "../node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// ../node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS({
  "../node_modules/get-intrinsic/index.js"(exports2, module2) {
    "use strict";
    var undefined2;
    var $Error = require_es_errors();
    var $EvalError = require_eval();
    var $RangeError = require_range();
    var $ReferenceError = require_ref();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var $URIError = require_uri();
    var $Function = Function;
    var getEvalledConstructor = function(expressionSyntax) {
      try {
        return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
      } catch (e) {
      }
    };
    var $gOPD = Object.getOwnPropertyDescriptor;
    if ($gOPD) {
      try {
        $gOPD({}, "");
      } catch (e) {
        $gOPD = null;
      }
    }
    var throwTypeError = function() {
      throw new $TypeError();
    };
    var ThrowTypeError = $gOPD ? function() {
      try {
        arguments.callee;
        return throwTypeError;
      } catch (calleeThrows) {
        try {
          return $gOPD(arguments, "callee").get;
        } catch (gOPDthrows) {
          return throwTypeError;
        }
      }
    }() : throwTypeError;
    var hasSymbols = require_has_symbols()();
    var hasProto = require_has_proto()();
    var getProto = Object.getPrototypeOf || (hasProto ? function(x) {
      return x.__proto__;
    } : null);
    var needsEval = {};
    var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined2 : getProto(Uint8Array);
    var INTRINSICS = {
      __proto__: null,
      "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
      "%Array%": Array,
      "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
      "%ArrayIteratorPrototype%": hasSymbols && getProto ? getProto([][Symbol.iterator]()) : undefined2,
      "%AsyncFromSyncIteratorPrototype%": undefined2,
      "%AsyncFunction%": needsEval,
      "%AsyncGenerator%": needsEval,
      "%AsyncGeneratorFunction%": needsEval,
      "%AsyncIteratorPrototype%": needsEval,
      "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
      "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
      "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined2 : BigInt64Array,
      "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined2 : BigUint64Array,
      "%Boolean%": Boolean,
      "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
      "%Date%": Date,
      "%decodeURI%": decodeURI,
      "%decodeURIComponent%": decodeURIComponent,
      "%encodeURI%": encodeURI,
      "%encodeURIComponent%": encodeURIComponent,
      "%Error%": $Error,
      "%eval%": eval,
      // eslint-disable-line no-eval
      "%EvalError%": $EvalError,
      "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
      "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
      "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
      "%Function%": $Function,
      "%GeneratorFunction%": needsEval,
      "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
      "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
      "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
      "%isFinite%": isFinite,
      "%isNaN%": isNaN,
      "%IteratorPrototype%": hasSymbols && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined2,
      "%JSON%": typeof JSON === "object" ? JSON : undefined2,
      "%Map%": typeof Map === "undefined" ? undefined2 : Map,
      "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
      "%Math%": Math,
      "%Number%": Number,
      "%Object%": Object,
      "%parseFloat%": parseFloat,
      "%parseInt%": parseInt,
      "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
      "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
      "%RangeError%": $RangeError,
      "%ReferenceError%": $ReferenceError,
      "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
      "%RegExp%": RegExp,
      "%Set%": typeof Set === "undefined" ? undefined2 : Set,
      "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols || !getProto ? undefined2 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
      "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
      "%String%": String,
      "%StringIteratorPrototype%": hasSymbols && getProto ? getProto(""[Symbol.iterator]()) : undefined2,
      "%Symbol%": hasSymbols ? Symbol : undefined2,
      "%SyntaxError%": $SyntaxError,
      "%ThrowTypeError%": ThrowTypeError,
      "%TypedArray%": TypedArray,
      "%TypeError%": $TypeError,
      "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
      "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
      "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
      "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
      "%URIError%": $URIError,
      "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
      "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
      "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
    };
    if (getProto) {
      try {
        null.error;
      } catch (e) {
        errorProto = getProto(getProto(e));
        INTRINSICS["%Error.prototype%"] = errorProto;
      }
    }
    var errorProto;
    var doEval = function doEval2(name) {
      var value;
      if (name === "%AsyncFunction%") {
        value = getEvalledConstructor("async function () {}");
      } else if (name === "%GeneratorFunction%") {
        value = getEvalledConstructor("function* () {}");
      } else if (name === "%AsyncGeneratorFunction%") {
        value = getEvalledConstructor("async function* () {}");
      } else if (name === "%AsyncGenerator%") {
        var fn = doEval2("%AsyncGeneratorFunction%");
        if (fn) {
          value = fn.prototype;
        }
      } else if (name === "%AsyncIteratorPrototype%") {
        var gen = doEval2("%AsyncGenerator%");
        if (gen && getProto) {
          value = getProto(gen.prototype);
        }
      }
      INTRINSICS[name] = value;
      return value;
    };
    var LEGACY_ALIASES = {
      __proto__: null,
      "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
      "%ArrayPrototype%": ["Array", "prototype"],
      "%ArrayProto_entries%": ["Array", "prototype", "entries"],
      "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
      "%ArrayProto_keys%": ["Array", "prototype", "keys"],
      "%ArrayProto_values%": ["Array", "prototype", "values"],
      "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
      "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
      "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
      "%BooleanPrototype%": ["Boolean", "prototype"],
      "%DataViewPrototype%": ["DataView", "prototype"],
      "%DatePrototype%": ["Date", "prototype"],
      "%ErrorPrototype%": ["Error", "prototype"],
      "%EvalErrorPrototype%": ["EvalError", "prototype"],
      "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
      "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
      "%FunctionPrototype%": ["Function", "prototype"],
      "%Generator%": ["GeneratorFunction", "prototype"],
      "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
      "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
      "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
      "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
      "%JSONParse%": ["JSON", "parse"],
      "%JSONStringify%": ["JSON", "stringify"],
      "%MapPrototype%": ["Map", "prototype"],
      "%NumberPrototype%": ["Number", "prototype"],
      "%ObjectPrototype%": ["Object", "prototype"],
      "%ObjProto_toString%": ["Object", "prototype", "toString"],
      "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
      "%PromisePrototype%": ["Promise", "prototype"],
      "%PromiseProto_then%": ["Promise", "prototype", "then"],
      "%Promise_all%": ["Promise", "all"],
      "%Promise_reject%": ["Promise", "reject"],
      "%Promise_resolve%": ["Promise", "resolve"],
      "%RangeErrorPrototype%": ["RangeError", "prototype"],
      "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
      "%RegExpPrototype%": ["RegExp", "prototype"],
      "%SetPrototype%": ["Set", "prototype"],
      "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
      "%StringPrototype%": ["String", "prototype"],
      "%SymbolPrototype%": ["Symbol", "prototype"],
      "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
      "%TypedArrayPrototype%": ["TypedArray", "prototype"],
      "%TypeErrorPrototype%": ["TypeError", "prototype"],
      "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
      "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
      "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
      "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
      "%URIErrorPrototype%": ["URIError", "prototype"],
      "%WeakMapPrototype%": ["WeakMap", "prototype"],
      "%WeakSetPrototype%": ["WeakSet", "prototype"]
    };
    var bind = require_function_bind();
    var hasOwn = require_hasown();
    var $concat = bind.call(Function.call, Array.prototype.concat);
    var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
    var $replace = bind.call(Function.call, String.prototype.replace);
    var $strSlice = bind.call(Function.call, String.prototype.slice);
    var $exec = bind.call(Function.call, RegExp.prototype.exec);
    var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
    var reEscapeChar = /\\(\\)?/g;
    var stringToPath = function stringToPath2(string) {
      var first2 = $strSlice(string, 0, 1);
      var last2 = $strSlice(string, -1);
      if (first2 === "%" && last2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
      } else if (last2 === "%" && first2 !== "%") {
        throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
      }
      var result2 = [];
      $replace(string, rePropName, function(match, number, quote, subString) {
        result2[result2.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
      });
      return result2;
    };
    var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
      var intrinsicName = name;
      var alias;
      if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
        alias = LEGACY_ALIASES[intrinsicName];
        intrinsicName = "%" + alias[0] + "%";
      }
      if (hasOwn(INTRINSICS, intrinsicName)) {
        var value = INTRINSICS[intrinsicName];
        if (value === needsEval) {
          value = doEval(intrinsicName);
        }
        if (typeof value === "undefined" && !allowMissing) {
          throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
        }
        return {
          alias,
          name: intrinsicName,
          value
        };
      }
      throw new $SyntaxError("intrinsic " + name + " does not exist!");
    };
    module2.exports = function GetIntrinsic(name, allowMissing) {
      if (typeof name !== "string" || name.length === 0) {
        throw new $TypeError("intrinsic name must be a non-empty string");
      }
      if (arguments.length > 1 && typeof allowMissing !== "boolean") {
        throw new $TypeError('"allowMissing" argument must be a boolean');
      }
      if ($exec(/^%?[^%]*%?$/, name) === null) {
        throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
      }
      var parts = stringToPath(name);
      var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
      var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
      var intrinsicRealName = intrinsic.name;
      var value = intrinsic.value;
      var skipFurtherCaching = false;
      var alias = intrinsic.alias;
      if (alias) {
        intrinsicBaseName = alias[0];
        $spliceApply(parts, $concat([0, 1], alias));
      }
      for (var i = 1, isOwn = true; i < parts.length; i += 1) {
        var part = parts[i];
        var first2 = $strSlice(part, 0, 1);
        var last2 = $strSlice(part, -1);
        if ((first2 === '"' || first2 === "'" || first2 === "`" || (last2 === '"' || last2 === "'" || last2 === "`")) && first2 !== last2) {
          throw new $SyntaxError("property names with quotes must have matching quotes");
        }
        if (part === "constructor" || !isOwn) {
          skipFurtherCaching = true;
        }
        intrinsicBaseName += "." + part;
        intrinsicRealName = "%" + intrinsicBaseName + "%";
        if (hasOwn(INTRINSICS, intrinsicRealName)) {
          value = INTRINSICS[intrinsicRealName];
        } else if (value != null) {
          if (!(part in value)) {
            if (!allowMissing) {
              throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
            }
            return void 0;
          }
          if ($gOPD && i + 1 >= parts.length) {
            var desc = $gOPD(value, part);
            isOwn = !!desc;
            if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
              value = desc.get;
            } else {
              value = value[part];
            }
          } else {
            isOwn = hasOwn(value, part);
            value = value[part];
          }
          if (isOwn && !skipFurtherCaching) {
            INTRINSICS[intrinsicRealName] = value;
          }
        }
      }
      return value;
    };
  }
});

// ../node_modules/es-define-property/index.js
var require_es_define_property = __commonJS({
  "../node_modules/es-define-property/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
    if ($defineProperty) {
      try {
        $defineProperty({}, "a", { value: 1 });
      } catch (e) {
        $defineProperty = false;
      }
    }
    module2.exports = $defineProperty;
  }
});

// ../node_modules/gopd/index.js
var require_gopd = __commonJS({
  "../node_modules/gopd/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
    if ($gOPD) {
      try {
        $gOPD([], "length");
      } catch (e) {
        $gOPD = null;
      }
    }
    module2.exports = $gOPD;
  }
});

// ../node_modules/define-data-property/index.js
var require_define_data_property = __commonJS({
  "../node_modules/define-data-property/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var $SyntaxError = require_syntax();
    var $TypeError = require_type();
    var gopd = require_gopd();
    module2.exports = function defineDataProperty(obj, property2, value) {
      if (!obj || typeof obj !== "object" && typeof obj !== "function") {
        throw new $TypeError("`obj` must be an object or a function`");
      }
      if (typeof property2 !== "string" && typeof property2 !== "symbol") {
        throw new $TypeError("`property` must be a string or a symbol`");
      }
      if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
        throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
        throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
        throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
      }
      if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
        throw new $TypeError("`loose`, if provided, must be a boolean");
      }
      var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
      var nonWritable = arguments.length > 4 ? arguments[4] : null;
      var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
      var loose = arguments.length > 6 ? arguments[6] : false;
      var desc = !!gopd && gopd(obj, property2);
      if ($defineProperty) {
        $defineProperty(obj, property2, {
          configurable: nonConfigurable === null && desc ? desc.configurable : !nonConfigurable,
          enumerable: nonEnumerable === null && desc ? desc.enumerable : !nonEnumerable,
          value,
          writable: nonWritable === null && desc ? desc.writable : !nonWritable
        });
      } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
        obj[property2] = value;
      } else {
        throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
      }
    };
  }
});

// ../node_modules/has-property-descriptors/index.js
var require_has_property_descriptors = __commonJS({
  "../node_modules/has-property-descriptors/index.js"(exports2, module2) {
    "use strict";
    var $defineProperty = require_es_define_property();
    var hasPropertyDescriptors = function hasPropertyDescriptors2() {
      return !!$defineProperty;
    };
    hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
      if (!$defineProperty) {
        return null;
      }
      try {
        return $defineProperty([], "length", { value: 1 }).length !== 1;
      } catch (e) {
        return true;
      }
    };
    module2.exports = hasPropertyDescriptors;
  }
});

// ../node_modules/set-function-length/index.js
var require_set_function_length = __commonJS({
  "../node_modules/set-function-length/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var define2 = require_define_data_property();
    var hasDescriptors = require_has_property_descriptors()();
    var gOPD = require_gopd();
    var $TypeError = require_type();
    var $floor = GetIntrinsic("%Math.floor%");
    module2.exports = function setFunctionLength(fn, length) {
      if (typeof fn !== "function") {
        throw new $TypeError("`fn` is not a function");
      }
      if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
        throw new $TypeError("`length` must be a positive 32-bit integer");
      }
      var loose = arguments.length > 2 && !!arguments[2];
      var functionLengthIsConfigurable = true;
      var functionLengthIsWritable = true;
      if ("length" in fn && gOPD) {
        var desc = gOPD(fn, "length");
        if (desc && !desc.configurable) {
          functionLengthIsConfigurable = false;
        }
        if (desc && !desc.writable) {
          functionLengthIsWritable = false;
        }
      }
      if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
        if (hasDescriptors) {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length,
            true,
            true
          );
        } else {
          define2(
            /** @type {Parameters<define>[0]} */
            fn,
            "length",
            length
          );
        }
      }
      return fn;
    };
  }
});

// ../node_modules/call-bind/index.js
var require_call_bind = __commonJS({
  "../node_modules/call-bind/index.js"(exports2, module2) {
    "use strict";
    var bind = require_function_bind();
    var GetIntrinsic = require_get_intrinsic();
    var setFunctionLength = require_set_function_length();
    var $TypeError = require_type();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
    var $defineProperty = require_es_define_property();
    var $max = GetIntrinsic("%Math.max%");
    module2.exports = function callBind(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind, $call, arguments);
      return setFunctionLength(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  }
});

// ../node_modules/call-bind/callBound.js
var require_callBound = __commonJS({
  "../node_modules/call-bind/callBound.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBind = require_call_bind();
    var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
    module2.exports = function callBoundIntrinsic(name, allowMissing) {
      var intrinsic = GetIntrinsic(name, !!allowMissing);
      if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
        return callBind(intrinsic);
      }
      return intrinsic;
    };
  }
});

// ../node_modules/object-inspect/util.inspect.js
var require_util_inspect = __commonJS({
  "../node_modules/object-inspect/util.inspect.js"(exports2, module2) {
    module2.exports = require("util").inspect;
  }
});

// ../node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "../node_modules/object-inspect/index.js"(exports2, module2) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
      return O.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util_inspect();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has3(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has3(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has3(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has3(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has3(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray(obj) ? "[Array]" : "[Object]";
      }
      var indent = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect(value, from, noIndent) {
        if (from) {
          seen = $arrSlice.call(seen);
          seen.push(from);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has3(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name = nameOf(obj);
        var keys2 = arrObjKeys(obj, inspect);
        return "[Function" + (name ? ": " + name : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
      }
      if (isSymbol(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement2(obj)) {
        var s = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i = 0; i < attrs.length; i++) {
          s += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
        }
        s += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s += "...";
        }
        s += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s;
      }
      if (isArray(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect);
        if (indent && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError(obj)) {
        var parts = arrObjKeys(obj, inspect);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect(key, obj, true) + " => " + inspect(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent);
      }
      if (isSet(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber(obj)) {
        return markBoxed(inspect(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect(bigIntValueOf.call(obj)));
      }
      if (isBoolean2(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString(obj)) {
        return markBoxed(inspect(String(obj)));
      }
      if (typeof window !== "undefined" && obj === window) {
        return "{ [object Window] }";
      }
      if (obj === global) {
        return "{ [object globalThis] }";
      }
      if (!isDate(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect);
        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent) {
          return tag + "{" + indentedJoin(ys, indent) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s + quoteChar;
    }
    function quote(s) {
      return $replace.call(String(s), /"/g, "&quot;");
    }
    function isArray(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean2(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has3(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString.call(obj);
    }
    function nameOf(f) {
      if (f.name) {
        return f.name;
      }
      var m = $match.call(functionToString.call(f), /^function\s*([\w$]+)/);
      if (m) {
        return m[1];
      }
      return null;
    }
    function indexOf(xs, x) {
      if (xs.indexOf) {
        return xs.indexOf(x);
      }
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) {
          return i;
        }
      }
      return -1;
    }
    function isMap(x) {
      if (!mapSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        mapSize.call(x);
        try {
          setSize.call(x);
        } catch (s) {
          return true;
        }
        return x instanceof Map;
      } catch (e) {
      }
      return false;
    }
    function isWeakMap(x) {
      if (!weakMapHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x, weakMapHas);
        try {
          weakSetHas.call(x, weakSetHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakMap;
      } catch (e) {
      }
      return false;
    }
    function isWeakRef(x) {
      if (!weakRefDeref || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x);
        return true;
      } catch (e) {
      }
      return false;
    }
    function isSet(x) {
      if (!setSize || !x || typeof x !== "object") {
        return false;
      }
      try {
        setSize.call(x);
        try {
          mapSize.call(x);
        } catch (m) {
          return true;
        }
        return x instanceof Set;
      } catch (e) {
      }
      return false;
    }
    function isWeakSet(x) {
      if (!weakSetHas || !x || typeof x !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x, weakSetHas);
        try {
          weakMapHas.call(x, weakMapHas);
        } catch (s) {
          return true;
        }
        return x instanceof WeakSet;
      } catch (e) {
      }
      return false;
    }
    function isElement2(x) {
      if (!x || typeof x !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
        return true;
      }
      return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s, "single", opts);
    }
    function lowbyte(c) {
      var n = c.charCodeAt(0);
      var x = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n];
      if (x) {
        return "\\" + x;
      }
      return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size2, entries, indent) {
      var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
      return type + " (" + size2 + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i = 0; i < xs.length; i++) {
        if (indexOf(xs[i], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent.prev + indent.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
    }
    function arrObjKeys(obj, inspect) {
      var isArr = isArray(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i = 0; i < obj.length; i++) {
          xs[i] = has3(obj, i) ? inspect(obj[i], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k = 0; k < syms.length; k++) {
          symMap["$" + syms[k]] = syms[k];
        }
      }
      for (var key in obj) {
        if (!has3(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j = 0; j < syms.length; j++) {
          if (isEnumerable.call(obj, syms[j])) {
            xs.push("[" + inspect(syms[j]) + "]: " + inspect(obj[syms[j]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// ../node_modules/side-channel/index.js
var require_side_channel = __commonJS({
  "../node_modules/side-channel/index.js"(exports2, module2) {
    "use strict";
    var GetIntrinsic = require_get_intrinsic();
    var callBound = require_callBound();
    var inspect = require_object_inspect();
    var $TypeError = require_type();
    var $WeakMap = GetIntrinsic("%WeakMap%", true);
    var $Map = GetIntrinsic("%Map%", true);
    var $weakMapGet = callBound("WeakMap.prototype.get", true);
    var $weakMapSet = callBound("WeakMap.prototype.set", true);
    var $weakMapHas = callBound("WeakMap.prototype.has", true);
    var $mapGet = callBound("Map.prototype.get", true);
    var $mapSet = callBound("Map.prototype.set", true);
    var $mapHas = callBound("Map.prototype.has", true);
    var listGetNode = function(list, key) {
      var prev = list;
      var curr;
      for (; (curr = prev.next) !== null; prev = curr) {
        if (curr.key === key) {
          prev.next = curr.next;
          curr.next = /** @type {NonNullable<typeof list.next>} */
          list.next;
          list.next = curr;
          return curr;
        }
      }
    };
    var listGet = function(objects, key) {
      var node = listGetNode(objects, key);
      return node && node.value;
    };
    var listSet = function(objects, key, value) {
      var node = listGetNode(objects, key);
      if (node) {
        node.value = value;
      } else {
        objects.next = /** @type {import('.').ListNode<typeof value>} */
        {
          // eslint-disable-line no-param-reassign, no-extra-parens
          key,
          next: objects.next,
          value
        };
      }
    };
    var listHas = function(objects, key) {
      return !!listGetNode(objects, key);
    };
    module2.exports = function getSideChannel() {
      var $wm;
      var $m;
      var $o;
      var channel = {
        assert: function(key) {
          if (!channel.has(key)) {
            throw new $TypeError("Side channel does not contain " + inspect(key));
          }
        },
        get: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapGet($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapGet($m, key);
            }
          } else {
            if ($o) {
              return listGet($o, key);
            }
          }
        },
        has: function(key) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if ($wm) {
              return $weakMapHas($wm, key);
            }
          } else if ($Map) {
            if ($m) {
              return $mapHas($m, key);
            }
          } else {
            if ($o) {
              return listHas($o, key);
            }
          }
          return false;
        },
        set: function(key, value) {
          if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
            if (!$wm) {
              $wm = new $WeakMap();
            }
            $weakMapSet($wm, key, value);
          } else if ($Map) {
            if (!$m) {
              $m = new $Map();
            }
            $mapSet($m, key, value);
          } else {
            if (!$o) {
              $o = { key: {}, next: null };
            }
            listSet($o, key, value);
          }
        }
      };
      return channel;
    };
  }
});

// ../node_modules/qs/lib/formats.js
var require_formats = __commonJS({
  "../node_modules/qs/lib/formats.js"(exports2, module2) {
    "use strict";
    var replace = String.prototype.replace;
    var percentTwenties = /%20/g;
    var Format = {
      RFC1738: "RFC1738",
      RFC3986: "RFC3986"
    };
    module2.exports = {
      "default": Format.RFC3986,
      formatters: {
        RFC1738: function(value) {
          return replace.call(value, percentTwenties, "+");
        },
        RFC3986: function(value) {
          return String(value);
        }
      },
      RFC1738: Format.RFC1738,
      RFC3986: Format.RFC3986
    };
  }
});

// ../node_modules/qs/lib/utils.js
var require_utils2 = __commonJS({
  "../node_modules/qs/lib/utils.js"(exports2, module2) {
    "use strict";
    var formats = require_formats();
    var has3 = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var hexTable = function() {
      var array = [];
      for (var i = 0; i < 256; ++i) {
        array.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
      }
      return array;
    }();
    var compactQueue = function compactQueue2(queue) {
      while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];
        if (isArray(obj)) {
          var compacted = [];
          for (var j = 0; j < obj.length; ++j) {
            if (typeof obj[j] !== "undefined") {
              compacted.push(obj[j]);
            }
          }
          item.obj[item.prop] = compacted;
        }
      }
    };
    var arrayToObject = function arrayToObject2(source, options) {
      var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== "undefined") {
          obj[i] = source[i];
        }
      }
      return obj;
    };
    var merge = function merge2(target, source, options) {
      if (!source) {
        return target;
      }
      if (typeof source !== "object") {
        if (isArray(target)) {
          target.push(source);
        } else if (target && typeof target === "object") {
          if (options && (options.plainObjects || options.allowPrototypes) || !has3.call(Object.prototype, source)) {
            target[source] = true;
          }
        } else {
          return [target, source];
        }
        return target;
      }
      if (!target || typeof target !== "object") {
        return [target].concat(source);
      }
      var mergeTarget = target;
      if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
      }
      if (isArray(target) && isArray(source)) {
        source.forEach(function(item, i) {
          if (has3.call(target, i)) {
            var targetItem = target[i];
            if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
              target[i] = merge2(targetItem, item, options);
            } else {
              target.push(item);
            }
          } else {
            target[i] = item;
          }
        });
        return target;
      }
      return Object.keys(source).reduce(function(acc, key) {
        var value = source[key];
        if (has3.call(acc, key)) {
          acc[key] = merge2(acc[key], value, options);
        } else {
          acc[key] = value;
        }
        return acc;
      }, mergeTarget);
    };
    var assign = function assignSingleSource(target, source) {
      return Object.keys(source).reduce(function(acc, key) {
        acc[key] = source[key];
        return acc;
      }, target);
    };
    var decode = function(str, decoder, charset) {
      var strWithoutPlus = str.replace(/\+/g, " ");
      if (charset === "iso-8859-1") {
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
      }
      try {
        return decodeURIComponent(strWithoutPlus);
      } catch (e) {
        return strWithoutPlus;
      }
    };
    var limit = 1024;
    var encode = function encode2(str, defaultEncoder, charset, kind, format) {
      if (str.length === 0) {
        return str;
      }
      var string = str;
      if (typeof str === "symbol") {
        string = Symbol.prototype.toString.call(str);
      } else if (typeof str !== "string") {
        string = String(str);
      }
      if (charset === "iso-8859-1") {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function($0) {
          return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
        });
      }
      var out = "";
      for (var j = 0; j < string.length; j += limit) {
        var segment = string.length >= limit ? string.slice(j, j + limit) : string;
        var arr = [];
        for (var i = 0; i < segment.length; ++i) {
          var c = segment.charCodeAt(i);
          if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format === formats.RFC1738 && (c === 40 || c === 41)) {
            arr[arr.length] = segment.charAt(i);
            continue;
          }
          if (c < 128) {
            arr[arr.length] = hexTable[c];
            continue;
          }
          if (c < 2048) {
            arr[arr.length] = hexTable[192 | c >> 6] + hexTable[128 | c & 63];
            continue;
          }
          if (c < 55296 || c >= 57344) {
            arr[arr.length] = hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
            continue;
          }
          i += 1;
          c = 65536 + ((c & 1023) << 10 | segment.charCodeAt(i) & 1023);
          arr[arr.length] = hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
        }
        out += arr.join("");
      }
      return out;
    };
    var compact2 = function compact3(value) {
      var queue = [{ obj: { o: value }, prop: "o" }];
      var refs = [];
      for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];
        var keys2 = Object.keys(obj);
        for (var j = 0; j < keys2.length; ++j) {
          var key = keys2[j];
          var val = obj[key];
          if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
            queue.push({ obj, prop: key });
            refs.push(val);
          }
        }
      }
      compactQueue(queue);
      return value;
    };
    var isRegExp = function isRegExp2(obj) {
      return Object.prototype.toString.call(obj) === "[object RegExp]";
    };
    var isBuffer = function isBuffer2(obj) {
      if (!obj || typeof obj !== "object") {
        return false;
      }
      return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
    };
    var combine = function combine2(a, b) {
      return [].concat(a, b);
    };
    var maybeMap = function maybeMap2(val, fn) {
      if (isArray(val)) {
        var mapped = [];
        for (var i = 0; i < val.length; i += 1) {
          mapped.push(fn(val[i]));
        }
        return mapped;
      }
      return fn(val);
    };
    module2.exports = {
      arrayToObject,
      assign,
      combine,
      compact: compact2,
      decode,
      encode,
      isBuffer,
      isRegExp,
      maybeMap,
      merge
    };
  }
});

// ../node_modules/qs/lib/stringify.js
var require_stringify = __commonJS({
  "../node_modules/qs/lib/stringify.js"(exports2, module2) {
    "use strict";
    var getSideChannel = require_side_channel();
    var utils = require_utils2();
    var formats = require_formats();
    var has3 = Object.prototype.hasOwnProperty;
    var arrayPrefixGenerators = {
      brackets: function brackets(prefix) {
        return prefix + "[]";
      },
      comma: "comma",
      indices: function indices(prefix, key) {
        return prefix + "[" + key + "]";
      },
      repeat: function repeat(prefix) {
        return prefix;
      }
    };
    var isArray = Array.isArray;
    var push2 = Array.prototype.push;
    var pushToArray = function(arr, valueOrArray) {
      push2.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
    };
    var toISO = Date.prototype.toISOString;
    var defaultFormat = formats["default"];
    var defaults = {
      addQueryPrefix: false,
      allowDots: false,
      allowEmptyArrays: false,
      arrayFormat: "indices",
      charset: "utf-8",
      charsetSentinel: false,
      delimiter: "&",
      encode: true,
      encodeDotInKeys: false,
      encoder: utils.encode,
      encodeValuesOnly: false,
      format: defaultFormat,
      formatter: formats.formatters[defaultFormat],
      // deprecated
      indices: false,
      serializeDate: function serializeDate(date) {
        return toISO.call(date);
      },
      skipNulls: false,
      strictNullHandling: false
    };
    var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
      return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
    };
    var sentinel = {};
    var stringify = function stringify2(object2, prefix, generateArrayPrefix, commaRoundTrip, allowEmptyArrays, strictNullHandling, skipNulls, encodeDotInKeys, encoder, filter2, sort, allowDots, serializeDate, format, formatter, encodeValuesOnly, charset, sideChannel) {
      var obj = object2;
      var tmpSc = sideChannel;
      var step = 0;
      var findFlag = false;
      while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
        var pos = tmpSc.get(object2);
        step += 1;
        if (typeof pos !== "undefined") {
          if (pos === step) {
            throw new RangeError("Cyclic object value");
          } else {
            findFlag = true;
          }
        }
        if (typeof tmpSc.get(sentinel) === "undefined") {
          step = 0;
        }
      }
      if (typeof filter2 === "function") {
        obj = filter2(prefix, obj);
      } else if (obj instanceof Date) {
        obj = serializeDate(obj);
      } else if (generateArrayPrefix === "comma" && isArray(obj)) {
        obj = utils.maybeMap(obj, function(value2) {
          if (value2 instanceof Date) {
            return serializeDate(value2);
          }
          return value2;
        });
      }
      if (obj === null) {
        if (strictNullHandling) {
          return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, "key", format) : prefix;
        }
        obj = "";
      }
      if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {
        if (encoder) {
          var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, "key", format);
          return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults.encoder, charset, "value", format))];
        }
        return [formatter(prefix) + "=" + formatter(String(obj))];
      }
      var values2 = [];
      if (typeof obj === "undefined") {
        return values2;
      }
      var objKeys;
      if (generateArrayPrefix === "comma" && isArray(obj)) {
        if (encodeValuesOnly && encoder) {
          obj = utils.maybeMap(obj, encoder);
        }
        objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
      } else if (isArray(filter2)) {
        objKeys = filter2;
      } else {
        var keys2 = Object.keys(obj);
        objKeys = sort ? keys2.sort(sort) : keys2;
      }
      var encodedPrefix = encodeDotInKeys ? prefix.replace(/\./g, "%2E") : prefix;
      var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? encodedPrefix + "[]" : encodedPrefix;
      if (allowEmptyArrays && isArray(obj) && obj.length === 0) {
        return adjustedPrefix + "[]";
      }
      for (var j = 0; j < objKeys.length; ++j) {
        var key = objKeys[j];
        var value = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
        if (skipNulls && value === null) {
          continue;
        }
        var encodedKey = allowDots && encodeDotInKeys ? key.replace(/\./g, "%2E") : key;
        var keyPrefix = isArray(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, encodedKey) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + encodedKey : "[" + encodedKey + "]");
        sideChannel.set(object2, step);
        var valueSideChannel = getSideChannel();
        valueSideChannel.set(sentinel, sideChannel);
        pushToArray(values2, stringify2(
          value,
          keyPrefix,
          generateArrayPrefix,
          commaRoundTrip,
          allowEmptyArrays,
          strictNullHandling,
          skipNulls,
          encodeDotInKeys,
          generateArrayPrefix === "comma" && encodeValuesOnly && isArray(obj) ? null : encoder,
          filter2,
          sort,
          allowDots,
          serializeDate,
          format,
          formatter,
          encodeValuesOnly,
          charset,
          valueSideChannel
        ));
      }
      return values2;
    };
    var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.encodeDotInKeys !== "undefined" && typeof opts.encodeDotInKeys !== "boolean") {
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
        throw new TypeError("Encoder has to be a function.");
      }
      var charset = opts.charset || defaults.charset;
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var format = formats["default"];
      if (typeof opts.format !== "undefined") {
        if (!has3.call(formats.formatters, opts.format)) {
          throw new TypeError("Unknown format option provided.");
        }
        format = opts.format;
      }
      var formatter = formats.formatters[format];
      var filter2 = defaults.filter;
      if (typeof opts.filter === "function" || isArray(opts.filter)) {
        filter2 = opts.filter;
      }
      var arrayFormat;
      if (opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
      } else if ("indices" in opts) {
        arrayFormat = opts.indices ? "indices" : "repeat";
      } else {
        arrayFormat = defaults.arrayFormat;
      }
      if ("commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.encodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        arrayFormat,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        commaRoundTrip: opts.commaRoundTrip,
        delimiter: typeof opts.delimiter === "undefined" ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === "boolean" ? opts.encode : defaults.encode,
        encodeDotInKeys: typeof opts.encodeDotInKeys === "boolean" ? opts.encodeDotInKeys : defaults.encodeDotInKeys,
        encoder: typeof opts.encoder === "function" ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter2,
        format,
        formatter,
        serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === "function" ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(object2, opts) {
      var obj = object2;
      var options = normalizeStringifyOptions(opts);
      var objKeys;
      var filter2;
      if (typeof options.filter === "function") {
        filter2 = options.filter;
        obj = filter2("", obj);
      } else if (isArray(options.filter)) {
        filter2 = options.filter;
        objKeys = filter2;
      }
      var keys2 = [];
      if (typeof obj !== "object" || obj === null) {
        return "";
      }
      var generateArrayPrefix = arrayPrefixGenerators[options.arrayFormat];
      var commaRoundTrip = generateArrayPrefix === "comma" && options.commaRoundTrip;
      if (!objKeys) {
        objKeys = Object.keys(obj);
      }
      if (options.sort) {
        objKeys.sort(options.sort);
      }
      var sideChannel = getSideChannel();
      for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];
        if (options.skipNulls && obj[key] === null) {
          continue;
        }
        pushToArray(keys2, stringify(
          obj[key],
          key,
          generateArrayPrefix,
          commaRoundTrip,
          options.allowEmptyArrays,
          options.strictNullHandling,
          options.skipNulls,
          options.encodeDotInKeys,
          options.encode ? options.encoder : null,
          options.filter,
          options.sort,
          options.allowDots,
          options.serializeDate,
          options.format,
          options.formatter,
          options.encodeValuesOnly,
          options.charset,
          sideChannel
        ));
      }
      var joined = keys2.join(options.delimiter);
      var prefix = options.addQueryPrefix === true ? "?" : "";
      if (options.charsetSentinel) {
        if (options.charset === "iso-8859-1") {
          prefix += "utf8=%26%2310003%3B&";
        } else {
          prefix += "utf8=%E2%9C%93&";
        }
      }
      return joined.length > 0 ? prefix + joined : "";
    };
  }
});

// ../node_modules/qs/lib/parse.js
var require_parse = __commonJS({
  "../node_modules/qs/lib/parse.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var has3 = Object.prototype.hasOwnProperty;
    var isArray = Array.isArray;
    var defaults = {
      allowDots: false,
      allowEmptyArrays: false,
      allowPrototypes: false,
      allowSparse: false,
      arrayLimit: 20,
      charset: "utf-8",
      charsetSentinel: false,
      comma: false,
      decodeDotInKeys: false,
      decoder: utils.decode,
      delimiter: "&",
      depth: 5,
      duplicates: "combine",
      ignoreQueryPrefix: false,
      interpretNumericEntities: false,
      parameterLimit: 1e3,
      parseArrays: true,
      plainObjects: false,
      strictNullHandling: false
    };
    var interpretNumericEntities = function(str) {
      return str.replace(/&#(\d+);/g, function($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
      });
    };
    var parseArrayValue = function(val, options) {
      if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
        return val.split(",");
      }
      return val;
    };
    var isoSentinel = "utf8=%26%2310003%3B";
    var charsetSentinel = "utf8=%E2%9C%93";
    var parseValues = function parseQueryStringValues(str, options) {
      var obj = { __proto__: null };
      var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, "") : str;
      var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
      var parts = cleanStr.split(options.delimiter, limit);
      var skipIndex = -1;
      var i;
      var charset = options.charset;
      if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
          if (parts[i].indexOf("utf8=") === 0) {
            if (parts[i] === charsetSentinel) {
              charset = "utf-8";
            } else if (parts[i] === isoSentinel) {
              charset = "iso-8859-1";
            }
            skipIndex = i;
            i = parts.length;
          }
        }
      }
      for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
          continue;
        }
        var part = parts[i];
        var bracketEqualsPos = part.indexOf("]=");
        var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
        var key, val;
        if (pos === -1) {
          key = options.decoder(part, defaults.decoder, charset, "key");
          val = options.strictNullHandling ? null : "";
        } else {
          key = options.decoder(part.slice(0, pos), defaults.decoder, charset, "key");
          val = utils.maybeMap(
            parseArrayValue(part.slice(pos + 1), options),
            function(encodedVal) {
              return options.decoder(encodedVal, defaults.decoder, charset, "value");
            }
          );
        }
        if (val && options.interpretNumericEntities && charset === "iso-8859-1") {
          val = interpretNumericEntities(val);
        }
        if (part.indexOf("[]=") > -1) {
          val = isArray(val) ? [val] : val;
        }
        var existing = has3.call(obj, key);
        if (existing && options.duplicates === "combine") {
          obj[key] = utils.combine(obj[key], val);
        } else if (!existing || options.duplicates === "last") {
          obj[key] = val;
        }
      }
      return obj;
    };
    var parseObject = function(chain2, val, options, valuesParsed) {
      var leaf = valuesParsed ? val : parseArrayValue(val, options);
      for (var i = chain2.length - 1; i >= 0; --i) {
        var obj;
        var root2 = chain2[i];
        if (root2 === "[]" && options.parseArrays) {
          obj = options.allowEmptyArrays && leaf === "" ? [] : [].concat(leaf);
        } else {
          obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
          var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
          var decodedRoot = options.decodeDotInKeys ? cleanRoot.replace(/%2E/g, ".") : cleanRoot;
          var index = parseInt(decodedRoot, 10);
          if (!options.parseArrays && decodedRoot === "") {
            obj = { 0: leaf };
          } else if (!isNaN(index) && root2 !== decodedRoot && String(index) === decodedRoot && index >= 0 && (options.parseArrays && index <= options.arrayLimit)) {
            obj = [];
            obj[index] = leaf;
          } else if (decodedRoot !== "__proto__") {
            obj[decodedRoot] = leaf;
          }
        }
        leaf = obj;
      }
      return leaf;
    };
    var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
      if (!givenKey) {
        return;
      }
      var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
      var brackets = /(\[[^[\]]*])/;
      var child = /(\[[^[\]]*])/g;
      var segment = options.depth > 0 && brackets.exec(key);
      var parent = segment ? key.slice(0, segment.index) : key;
      var keys2 = [];
      if (parent) {
        if (!options.plainObjects && has3.call(Object.prototype, parent)) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys2.push(parent);
      }
      var i = 0;
      while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has3.call(Object.prototype, segment[1].slice(1, -1))) {
          if (!options.allowPrototypes) {
            return;
          }
        }
        keys2.push(segment[1]);
      }
      if (segment) {
        keys2.push("[" + key.slice(segment.index) + "]");
      }
      return parseObject(keys2, val, options, valuesParsed);
    };
    var normalizeParseOptions = function normalizeParseOptions2(opts) {
      if (!opts) {
        return defaults;
      }
      if (typeof opts.allowEmptyArrays !== "undefined" && typeof opts.allowEmptyArrays !== "boolean") {
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
      }
      if (typeof opts.decodeDotInKeys !== "undefined" && typeof opts.decodeDotInKeys !== "boolean") {
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
      }
      if (opts.decoder !== null && typeof opts.decoder !== "undefined" && typeof opts.decoder !== "function") {
        throw new TypeError("Decoder has to be a function.");
      }
      if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
      }
      var charset = typeof opts.charset === "undefined" ? defaults.charset : opts.charset;
      var duplicates = typeof opts.duplicates === "undefined" ? defaults.duplicates : opts.duplicates;
      if (duplicates !== "combine" && duplicates !== "first" && duplicates !== "last") {
        throw new TypeError("The duplicates option must be either combine, first, or last");
      }
      var allowDots = typeof opts.allowDots === "undefined" ? opts.decodeDotInKeys === true ? true : defaults.allowDots : !!opts.allowDots;
      return {
        allowDots,
        allowEmptyArrays: typeof opts.allowEmptyArrays === "boolean" ? !!opts.allowEmptyArrays : defaults.allowEmptyArrays,
        allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults.allowPrototypes,
        allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults.allowSparse,
        arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults.arrayLimit,
        charset,
        charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === "boolean" ? opts.comma : defaults.comma,
        decodeDotInKeys: typeof opts.decodeDotInKeys === "boolean" ? opts.decodeDotInKeys : defaults.decodeDotInKeys,
        decoder: typeof opts.decoder === "function" ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === "string" || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        // eslint-disable-next-line no-implicit-coercion, no-extra-parens
        depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults.depth,
        duplicates,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults.strictNullHandling
      };
    };
    module2.exports = function(str, opts) {
      var options = normalizeParseOptions(opts);
      if (str === "" || str === null || typeof str === "undefined") {
        return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      }
      var tempObj = typeof str === "string" ? parseValues(str, options) : str;
      var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
      var keys2 = Object.keys(tempObj);
      for (var i = 0; i < keys2.length; ++i) {
        var key = keys2[i];
        var newObj = parseKeys(key, tempObj[key], options, typeof str === "string");
        obj = utils.merge(obj, newObj, options);
      }
      if (options.allowSparse === true) {
        return obj;
      }
      return utils.compact(obj);
    };
  }
});

// ../node_modules/qs/lib/index.js
var require_lib4 = __commonJS({
  "../node_modules/qs/lib/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var parse = require_parse();
    var formats = require_formats();
    module2.exports = {
      formats,
      parse,
      stringify
    };
  }
});

// ../node_modules/typed-rest-client/Util.js
var require_Util = __commonJS({
  "../node_modules/typed-rest-client/Util.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : new P(function(resolve2) {
            resolve2(result2.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var qs = require_lib4();
    var url = require("url");
    var path2 = require("path");
    var zlib = require("zlib");
    function getUrl(resource, baseUrl, queryParams) {
      const pathApi = path2.posix || path2;
      let requestUrl = "";
      if (!baseUrl) {
        requestUrl = resource;
      } else if (!resource) {
        requestUrl = baseUrl;
      } else {
        const base = url.parse(baseUrl);
        const resultantUrl = url.parse(resource);
        resultantUrl.protocol = resultantUrl.protocol || base.protocol;
        resultantUrl.auth = resultantUrl.auth || base.auth;
        resultantUrl.host = resultantUrl.host || base.host;
        resultantUrl.pathname = pathApi.resolve(base.pathname, resultantUrl.pathname);
        if (!resultantUrl.pathname.endsWith("/") && resource.endsWith("/")) {
          resultantUrl.pathname += "/";
        }
        requestUrl = url.format(resultantUrl);
      }
      return queryParams ? getUrlWithParsedQueryParams(requestUrl, queryParams) : requestUrl;
    }
    exports2.getUrl = getUrl;
    function getUrlWithParsedQueryParams(requestUrl, queryParams) {
      const url2 = requestUrl.replace(/\?$/g, "");
      const parsedQueryParams = qs.stringify(queryParams.params, buildParamsStringifyOptions(queryParams));
      return `${url2}${parsedQueryParams}`;
    }
    function buildParamsStringifyOptions(queryParams) {
      let options = {
        addQueryPrefix: true,
        delimiter: (queryParams.options || {}).separator || "&",
        allowDots: (queryParams.options || {}).shouldAllowDots || false,
        arrayFormat: (queryParams.options || {}).arrayFormat || "repeat",
        encodeValuesOnly: (queryParams.options || {}).shouldOnlyEncodeValues || true
      };
      return options;
    }
    function decompressGzippedContent(buffer, charset) {
      return __awaiter2(this, void 0, void 0, function* () {
        return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
          zlib.gunzip(buffer, function(error, buffer2) {
            if (error) {
              reject2(error);
            } else {
              resolve(buffer2.toString(charset || "utf-8"));
            }
          });
        }));
      });
    }
    exports2.decompressGzippedContent = decompressGzippedContent;
    function buildProxyBypassRegexFromEnv(bypass) {
      try {
        return new RegExp(bypass, "i");
      } catch (err) {
        if (err instanceof SyntaxError && (bypass || "").startsWith("*")) {
          let wildcardEscaped = bypass.replace("*", "(.*)");
          return new RegExp(wildcardEscaped, "i");
        }
        throw err;
      }
    }
    exports2.buildProxyBypassRegexFromEnv = buildProxyBypassRegexFromEnv;
    function obtainContentCharset(response) {
      const nodeSupportedEncodings = ["ascii", "utf8", "utf16le", "ucs2", "base64", "binary", "hex"];
      const contentType = response.message.headers["content-type"] || "";
      const matches = contentType.match(/charset=([^;,\r\n]+)/i);
      return matches && matches[1] && nodeSupportedEncodings.indexOf(matches[1]) != -1 ? matches[1] : "utf-8";
    }
    exports2.obtainContentCharset = obtainContentCharset;
  }
});

// ../node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS({
  "../node_modules/tunnel/lib/tunnel.js"(exports2) {
    "use strict";
    var net = require("net");
    var tls = require("tls");
    var http = require("http");
    var https = require("https");
    var events = require("events");
    var assert = require("assert");
    var util = require("util");
    exports2.httpOverHttp = httpOverHttp;
    exports2.httpsOverHttp = httpsOverHttp;
    exports2.httpOverHttps = httpOverHttps;
    exports2.httpsOverHttps = httpsOverHttps;
    function httpOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      return agent;
    }
    function httpsOverHttp(options) {
      var agent = new TunnelingAgent(options);
      agent.request = http.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function httpOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      return agent;
    }
    function httpsOverHttps(options) {
      var agent = new TunnelingAgent(options);
      agent.request = https.request;
      agent.createSocket = createSecureSocket;
      agent.defaultPort = 443;
      return agent;
    }
    function TunnelingAgent(options) {
      var self2 = this;
      self2.options = options || {};
      self2.proxyOptions = self2.options.proxy || {};
      self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
      self2.requests = [];
      self2.sockets = [];
      self2.on("free", function onFree(socket, host, port, localAddress) {
        var options2 = toOptions(host, port, localAddress);
        for (var i = 0, len = self2.requests.length; i < len; ++i) {
          var pending = self2.requests[i];
          if (pending.host === options2.host && pending.port === options2.port) {
            self2.requests.splice(i, 1);
            pending.request.onSocket(socket);
            return;
          }
        }
        socket.destroy();
        self2.removeSocket(socket);
      });
    }
    util.inherits(TunnelingAgent, events.EventEmitter);
    TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
      var self2 = this;
      var options = mergeOptions({ request: req }, self2.options, toOptions(host, port, localAddress));
      if (self2.sockets.length >= this.maxSockets) {
        self2.requests.push(options);
        return;
      }
      self2.createSocket(options, function(socket) {
        socket.on("free", onFree);
        socket.on("close", onCloseOrRemove);
        socket.on("agentRemove", onCloseOrRemove);
        req.onSocket(socket);
        function onFree() {
          self2.emit("free", socket, options);
        }
        function onCloseOrRemove(err) {
          self2.removeSocket(socket);
          socket.removeListener("free", onFree);
          socket.removeListener("close", onCloseOrRemove);
          socket.removeListener("agentRemove", onCloseOrRemove);
        }
      });
    };
    TunnelingAgent.prototype.createSocket = function createSocket(options, cb2) {
      var self2 = this;
      var placeholder = {};
      self2.sockets.push(placeholder);
      var connectOptions = mergeOptions({}, self2.proxyOptions, {
        method: "CONNECT",
        path: options.host + ":" + options.port,
        agent: false,
        headers: {
          host: options.host + ":" + options.port
        }
      });
      if (options.localAddress) {
        connectOptions.localAddress = options.localAddress;
      }
      if (connectOptions.proxyAuth) {
        connectOptions.headers = connectOptions.headers || {};
        connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
      }
      debug("making CONNECT request");
      var connectReq = self2.request(connectOptions);
      connectReq.useChunkedEncodingByDefault = false;
      connectReq.once("response", onResponse);
      connectReq.once("upgrade", onUpgrade);
      connectReq.once("connect", onConnect);
      connectReq.once("error", onError);
      connectReq.end();
      function onResponse(res) {
        res.upgrade = true;
      }
      function onUpgrade(res, socket, head) {
        process.nextTick(function() {
          onConnect(res, socket, head);
        });
      }
      function onConnect(res, socket, head) {
        connectReq.removeAllListeners();
        socket.removeAllListeners();
        if (res.statusCode !== 200) {
          debug(
            "tunneling socket could not be established, statusCode=%d",
            res.statusCode
          );
          socket.destroy();
          var error = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self2.removeSocket(placeholder);
          return;
        }
        if (head.length > 0) {
          debug("got illegal response body from proxy");
          socket.destroy();
          var error = new Error("got illegal response body from proxy");
          error.code = "ECONNRESET";
          options.request.emit("error", error);
          self2.removeSocket(placeholder);
          return;
        }
        debug("tunneling connection has established");
        self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
        return cb2(socket);
      }
      function onError(cause) {
        connectReq.removeAllListeners();
        debug(
          "tunneling socket could not be established, cause=%s\n",
          cause.message,
          cause.stack
        );
        var error = new Error("tunneling socket could not be established, cause=" + cause.message);
        error.code = "ECONNRESET";
        options.request.emit("error", error);
        self2.removeSocket(placeholder);
      }
    };
    TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
      var pos = this.sockets.indexOf(socket);
      if (pos === -1) {
        return;
      }
      this.sockets.splice(pos, 1);
      var pending = this.requests.shift();
      if (pending) {
        this.createSocket(pending, function(socket2) {
          pending.request.onSocket(socket2);
        });
      }
    };
    function createSecureSocket(options, cb2) {
      var self2 = this;
      TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
        var hostHeader = options.request.getHeader("host");
        var tlsOptions = mergeOptions({}, self2.options, {
          socket,
          servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
        });
        var secureSocket = tls.connect(0, tlsOptions);
        self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
        cb2(secureSocket);
      });
    }
    function toOptions(host, port, localAddress) {
      if (typeof host === "string") {
        return {
          host,
          port,
          localAddress
        };
      }
      return host;
    }
    function mergeOptions(target) {
      for (var i = 1, len = arguments.length; i < len; ++i) {
        var overrides = arguments[i];
        if (typeof overrides === "object") {
          var keys2 = Object.keys(overrides);
          for (var j = 0, keyLen = keys2.length; j < keyLen; ++j) {
            var k = keys2[j];
            if (overrides[k] !== void 0) {
              target[k] = overrides[k];
            }
          }
        }
      }
      return target;
    }
    var debug;
    if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments);
        if (typeof args[0] === "string") {
          args[0] = "TUNNEL: " + args[0];
        } else {
          args.unshift("TUNNEL:");
        }
        console.error.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.debug = debug;
  }
});

// ../node_modules/tunnel/index.js
var require_tunnel2 = __commonJS({
  "../node_modules/tunnel/index.js"(exports2, module2) {
    module2.exports = require_tunnel();
  }
});

// ../node_modules/typed-rest-client/HttpClient.js
var require_HttpClient = __commonJS({
  "../node_modules/typed-rest-client/HttpClient.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : new P(function(resolve2) {
            resolve2(result2.value);
          }).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var url = require("url");
    var http = require("http");
    var https = require("https");
    var util = require_Util();
    var fs3;
    var tunnel;
    var HttpCodes;
    (function(HttpCodes2) {
      HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
      HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
      HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
      HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
      HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
      HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
      HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
      HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
      HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
      HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
      HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
      HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
      HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
      HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
      HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
      HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
      HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
      HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
      HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
      HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
      HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
      HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
      HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
      HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(HttpCodes = exports2.HttpCodes || (exports2.HttpCodes = {}));
    var HttpRedirectCodes = [HttpCodes.MovedPermanently, HttpCodes.ResourceMoved, HttpCodes.SeeOther, HttpCodes.TemporaryRedirect, HttpCodes.PermanentRedirect];
    var HttpResponseRetryCodes = [HttpCodes.BadGateway, HttpCodes.ServiceUnavailable, HttpCodes.GatewayTimeout];
    var NetworkRetryErrors = ["ECONNRESET", "ENOTFOUND", "ESOCKETTIMEDOUT", "ETIMEDOUT", "ECONNREFUSED"];
    var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
    var ExponentialBackoffCeiling = 10;
    var ExponentialBackoffTimeSlice = 5;
    var HttpClientResponse = class {
      constructor(message) {
        this.message = message;
      }
      readBody() {
        return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
          const chunks = [];
          const encodingCharset = util.obtainContentCharset(this);
          const contentEncoding = this.message.headers["content-encoding"] || "";
          const isGzippedEncoded = new RegExp("(gzip$)|(gzip, *deflate)").test(contentEncoding);
          this.message.on("data", function(data) {
            const chunk2 = typeof data === "string" ? Buffer.from(data, encodingCharset) : data;
            chunks.push(chunk2);
          }).on("end", function() {
            return __awaiter2(this, void 0, void 0, function* () {
              const buffer = Buffer.concat(chunks);
              if (isGzippedEncoded) {
                const gunzippedBody = yield util.decompressGzippedContent(buffer, encodingCharset);
                resolve(gunzippedBody);
              } else {
                resolve(buffer.toString(encodingCharset));
              }
            });
          }).on("error", function(err) {
            reject2(err);
          });
        }));
      }
    };
    exports2.HttpClientResponse = HttpClientResponse;
    function isHttps(requestUrl) {
      let parsedUrl = url.parse(requestUrl);
      return parsedUrl.protocol === "https:";
    }
    exports2.isHttps = isHttps;
    var EnvironmentVariables;
    (function(EnvironmentVariables2) {
      EnvironmentVariables2["HTTP_PROXY"] = "HTTP_PROXY";
      EnvironmentVariables2["HTTPS_PROXY"] = "HTTPS_PROXY";
      EnvironmentVariables2["NO_PROXY"] = "NO_PROXY";
    })(EnvironmentVariables || (EnvironmentVariables = {}));
    var HttpClient = class {
      constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        let no_proxy = process.env[EnvironmentVariables.NO_PROXY];
        if (no_proxy) {
          this._httpProxyBypassHosts = [];
          no_proxy.split(",").forEach((bypass) => {
            this._httpProxyBypassHosts.push(util.buildProxyBypassRegexFromEnv(bypass));
          });
        }
        this.requestOptions = requestOptions;
        if (requestOptions) {
          if (requestOptions.ignoreSslError != null) {
            this._ignoreSslError = requestOptions.ignoreSslError;
          }
          this._socketTimeout = requestOptions.socketTimeout;
          this._httpProxy = requestOptions.proxy;
          if (requestOptions.proxy && requestOptions.proxy.proxyBypassHosts) {
            this._httpProxyBypassHosts = [];
            requestOptions.proxy.proxyBypassHosts.forEach((bypass) => {
              this._httpProxyBypassHosts.push(new RegExp(bypass, "i"));
            });
          }
          this._certConfig = requestOptions.cert;
          if (this._certConfig) {
            fs3 = require("fs");
            if (this._certConfig.caFile && fs3.existsSync(this._certConfig.caFile)) {
              this._ca = fs3.readFileSync(this._certConfig.caFile, "utf8");
            }
            if (this._certConfig.certFile && fs3.existsSync(this._certConfig.certFile)) {
              this._cert = fs3.readFileSync(this._certConfig.certFile, "utf8");
            }
            if (this._certConfig.keyFile && fs3.existsSync(this._certConfig.keyFile)) {
              this._key = fs3.readFileSync(this._certConfig.keyFile, "utf8");
            }
          }
          if (requestOptions.allowRedirects != null) {
            this._allowRedirects = requestOptions.allowRedirects;
          }
          if (requestOptions.allowRedirectDowngrade != null) {
            this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
          }
          if (requestOptions.maxRedirects != null) {
            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
          }
          if (requestOptions.keepAlive != null) {
            this._keepAlive = requestOptions.keepAlive;
          }
          if (requestOptions.allowRetries != null) {
            this._allowRetries = requestOptions.allowRetries;
          }
          if (requestOptions.maxRetries != null) {
            this._maxRetries = requestOptions.maxRetries;
          }
        }
      }
      options(requestUrl, additionalHeaders) {
        return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
      }
      get(requestUrl, additionalHeaders) {
        return this.request("GET", requestUrl, null, additionalHeaders || {});
      }
      del(requestUrl, additionalHeaders) {
        return this.request("DELETE", requestUrl, null, additionalHeaders || {});
      }
      post(requestUrl, data, additionalHeaders) {
        return this.request("POST", requestUrl, data, additionalHeaders || {});
      }
      patch(requestUrl, data, additionalHeaders) {
        return this.request("PATCH", requestUrl, data, additionalHeaders || {});
      }
      put(requestUrl, data, additionalHeaders) {
        return this.request("PUT", requestUrl, data, additionalHeaders || {});
      }
      head(requestUrl, additionalHeaders) {
        return this.request("HEAD", requestUrl, null, additionalHeaders || {});
      }
      sendStream(verb, requestUrl, stream, additionalHeaders) {
        return this.request(verb, requestUrl, stream, additionalHeaders);
      }
      /**
       * Makes a raw http request.
       * All other methods such as get, post, patch, and request ultimately call this.
       * Prefer get, del, post and patch
       */
      request(verb, requestUrl, data, headers) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (this._disposed) {
            throw new Error("Client has already been disposed.");
          }
          let parsedUrl = url.parse(requestUrl);
          let info = this._prepareRequest(verb, parsedUrl, headers);
          let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1 ? this._maxRetries + 1 : 1;
          let numTries = 0;
          let response;
          while (numTries < maxTries) {
            try {
              response = yield this.requestRaw(info, data);
            } catch (err) {
              numTries++;
              if (err && err.code && NetworkRetryErrors.indexOf(err.code) > -1 && numTries < maxTries) {
                yield this._performExponentialBackoff(numTries);
                continue;
              }
              throw err;
            }
            if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
              let authenticationHandler;
              for (let i = 0; i < this.handlers.length; i++) {
                if (this.handlers[i].canHandleAuthentication(response)) {
                  authenticationHandler = this.handlers[i];
                  break;
                }
              }
              if (authenticationHandler) {
                return authenticationHandler.handleAuthentication(this, info, data);
              } else {
                return response;
              }
            }
            let redirectsRemaining = this._maxRedirects;
            while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1 && this._allowRedirects && redirectsRemaining > 0) {
              const redirectUrl = response.message.headers["location"];
              if (!redirectUrl) {
                break;
              }
              let parsedRedirectUrl = url.parse(redirectUrl);
              if (parsedUrl.protocol == "https:" && parsedUrl.protocol != parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
                throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
              }
              yield response.readBody();
              info = this._prepareRequest(verb, parsedRedirectUrl, headers);
              response = yield this.requestRaw(info, data);
              redirectsRemaining--;
            }
            if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {
              return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
              yield response.readBody();
              yield this._performExponentialBackoff(numTries);
            }
          }
          return response;
        });
      }
      /**
       * Needs to be called if keepAlive is set to true in request options.
       */
      dispose() {
        if (this._agent) {
          this._agent.destroy();
        }
        this._disposed = true;
      }
      /**
       * Raw request.
       * @param info
       * @param data
       */
      requestRaw(info, data) {
        return new Promise((resolve, reject2) => {
          let callbackForResult = function(err, res) {
            if (err) {
              reject2(err);
            }
            resolve(res);
          };
          this.requestRawWithCallback(info, data, callbackForResult);
        });
      }
      /**
       * Raw request with callback.
       * @param info
       * @param data
       * @param onResult
       */
      requestRawWithCallback(info, data, onResult) {
        let socket;
        if (typeof data === "string") {
          info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
        }
        let callbackCalled = false;
        let handleResult = (err, res) => {
          if (!callbackCalled) {
            callbackCalled = true;
            onResult(err, res);
          }
        };
        let req = info.httpModule.request(info.options, (msg) => {
          let res = new HttpClientResponse(msg);
          handleResult(null, res);
        });
        req.on("socket", (sock) => {
          socket = sock;
        });
        req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
          if (socket) {
            socket.destroy();
          }
          handleResult(new Error("Request timeout: " + info.options.path), null);
        });
        req.on("error", function(err) {
          handleResult(err, null);
        });
        if (data && typeof data === "string") {
          req.write(data, "utf8");
        }
        if (data && typeof data !== "string") {
          data.on("close", function() {
            req.end();
          });
          data.pipe(req);
        } else {
          req.end();
        }
      }
      _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === "https:";
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
        info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
        info.options.method = method;
        info.options.timeout = this.requestOptions && this.requestOptions.socketTimeout || this._socketTimeout;
        this._socketTimeout = info.options.timeout;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
          info.options.headers["user-agent"] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        if (this.handlers && !this._isPresigned(url.format(requestUrl))) {
          this.handlers.forEach((handler) => {
            handler.prepareRequest(info.options);
          });
        }
        return info;
      }
      _isPresigned(requestUrl) {
        if (this.requestOptions && this.requestOptions.presignedUrlPatterns) {
          const patterns = this.requestOptions.presignedUrlPatterns;
          for (let i = 0; i < patterns.length; i++) {
            if (requestUrl.match(patterns[i])) {
              return true;
            }
          }
        }
        return false;
      }
      _mergeHeaders(headers) {
        const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
        if (this.requestOptions && this.requestOptions.headers) {
          return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));
        }
        return lowercaseKeys(headers || {});
      }
      _getAgent(parsedUrl) {
        let agent;
        let proxy = this._getProxy(parsedUrl);
        let useProxy = proxy.proxyUrl && proxy.proxyUrl.hostname && !this._isMatchInBypassProxyList(parsedUrl);
        if (this._keepAlive && useProxy) {
          agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
          agent = this._agent;
        }
        if (!!agent) {
          return agent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        let maxSockets = 100;
        if (!!this.requestOptions) {
          maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        if (useProxy) {
          if (!tunnel) {
            tunnel = require_tunnel2();
          }
          const agentOptions = {
            maxSockets,
            keepAlive: this._keepAlive,
            proxy: {
              proxyAuth: proxy.proxyAuth,
              host: proxy.proxyUrl.hostname,
              port: proxy.proxyUrl.port
            }
          };
          let tunnelAgent;
          const overHttps = proxy.proxyUrl.protocol === "https:";
          if (usingSsl) {
            tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
          } else {
            tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
          }
          agent = tunnelAgent(agentOptions);
          this._proxyAgent = agent;
        }
        if (this._keepAlive && !agent) {
          const options = { keepAlive: this._keepAlive, maxSockets };
          agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
          this._agent = agent;
        }
        if (!agent) {
          agent = usingSsl ? https.globalAgent : http.globalAgent;
        }
        if (usingSsl && this._ignoreSslError) {
          agent.options = Object.assign(agent.options || {}, { rejectUnauthorized: false });
        }
        if (usingSsl && this._certConfig) {
          agent.options = Object.assign(agent.options || {}, { ca: this._ca, cert: this._cert, key: this._key, passphrase: this._certConfig.passphrase });
        }
        return agent;
      }
      _getProxy(parsedUrl) {
        let usingSsl = parsedUrl.protocol === "https:";
        let proxyConfig = this._httpProxy;
        let https_proxy = process.env[EnvironmentVariables.HTTPS_PROXY];
        let http_proxy = process.env[EnvironmentVariables.HTTP_PROXY];
        if (!proxyConfig) {
          if (https_proxy && usingSsl) {
            proxyConfig = {
              proxyUrl: https_proxy
            };
          } else if (http_proxy) {
            proxyConfig = {
              proxyUrl: http_proxy
            };
          }
        }
        let proxyUrl;
        let proxyAuth;
        if (proxyConfig) {
          if (proxyConfig.proxyUrl.length > 0) {
            proxyUrl = url.parse(proxyConfig.proxyUrl);
          }
          if (proxyConfig.proxyUsername || proxyConfig.proxyPassword) {
            proxyAuth = proxyConfig.proxyUsername + ":" + proxyConfig.proxyPassword;
          }
        }
        return { proxyUrl, proxyAuth };
      }
      _isMatchInBypassProxyList(parsedUrl) {
        if (!this._httpProxyBypassHosts) {
          return false;
        }
        let bypass = false;
        this._httpProxyBypassHosts.forEach((bypassHost) => {
          if (bypassHost.test(parsedUrl.href)) {
            bypass = true;
          }
        });
        return bypass;
      }
      _performExponentialBackoff(retryNumber) {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise((resolve) => setTimeout(() => resolve(), ms));
      }
    };
    exports2.HttpClient = HttpClient;
  }
});

// ../node_modules/azure-pipelines-tool-lib/node_modules/semver/semver.js
var require_semver = __commonJS({
  "../node_modules/azure-pipelines-tool-lib/node_modules/semver/semver.js"(exports2, module2) {
    exports2 = module2.exports = SemVer;
    var debug;
    if (typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift("SEMVER");
        console.log.apply(console, args);
      };
    } else {
      debug = function() {
      };
    }
    exports2.SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var re = exports2.re = [];
    var safeRe = exports2.safeRe = [];
    var src = exports2.src = [];
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    function makeSafeRe(value) {
      for (var i2 = 0; i2 < safeRegexReplacements.length; i2++) {
        var token = safeRegexReplacements[i2][0];
        var max2 = safeRegexReplacements[i2][1];
        value = value.split(token + "*").join(token + "{0," + max2 + "}").split(token + "+").join(token + "{1," + max2 + "}");
      }
      return value;
    }
    var NUMERICIDENTIFIER = R++;
    src[NUMERICIDENTIFIER] = "0|[1-9]\\d*";
    var NUMERICIDENTIFIERLOOSE = R++;
    src[NUMERICIDENTIFIERLOOSE] = "\\d+";
    var NONNUMERICIDENTIFIER = R++;
    src[NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + LETTERDASHNUMBER + "*";
    var MAINVERSION = R++;
    src[MAINVERSION] = "(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")\\.(" + src[NUMERICIDENTIFIER] + ")";
    var MAINVERSIONLOOSE = R++;
    src[MAINVERSIONLOOSE] = "(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")\\.(" + src[NUMERICIDENTIFIERLOOSE] + ")";
    var PRERELEASEIDENTIFIER = R++;
    src[PRERELEASEIDENTIFIER] = "(?:" + src[NUMERICIDENTIFIER] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASEIDENTIFIERLOOSE = R++;
    src[PRERELEASEIDENTIFIERLOOSE] = "(?:" + src[NUMERICIDENTIFIERLOOSE] + "|" + src[NONNUMERICIDENTIFIER] + ")";
    var PRERELEASE = R++;
    src[PRERELEASE] = "(?:-(" + src[PRERELEASEIDENTIFIER] + "(?:\\." + src[PRERELEASEIDENTIFIER] + ")*))";
    var PRERELEASELOOSE = R++;
    src[PRERELEASELOOSE] = "(?:-?(" + src[PRERELEASEIDENTIFIERLOOSE] + "(?:\\." + src[PRERELEASEIDENTIFIERLOOSE] + ")*))";
    var BUILDIDENTIFIER = R++;
    src[BUILDIDENTIFIER] = LETTERDASHNUMBER + "+";
    var BUILD = R++;
    src[BUILD] = "(?:\\+(" + src[BUILDIDENTIFIER] + "(?:\\." + src[BUILDIDENTIFIER] + ")*))";
    var FULL = R++;
    var FULLPLAIN = "v?" + src[MAINVERSION] + src[PRERELEASE] + "?" + src[BUILD] + "?";
    src[FULL] = "^" + FULLPLAIN + "$";
    var LOOSEPLAIN = "[v=\\s]*" + src[MAINVERSIONLOOSE] + src[PRERELEASELOOSE] + "?" + src[BUILD] + "?";
    var LOOSE = R++;
    src[LOOSE] = "^" + LOOSEPLAIN + "$";
    var GTLT = R++;
    src[GTLT] = "((?:<|>)?=?)";
    var XRANGEIDENTIFIERLOOSE = R++;
    src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
    var XRANGEIDENTIFIER = R++;
    src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + "|x|X|\\*";
    var XRANGEPLAIN = R++;
    src[XRANGEPLAIN] = "[v=\\s]*(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:\\.(" + src[XRANGEIDENTIFIER] + ")(?:" + src[PRERELEASE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGEPLAINLOOSE = R++;
    src[XRANGEPLAINLOOSE] = "[v=\\s]*(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:\\.(" + src[XRANGEIDENTIFIERLOOSE] + ")(?:" + src[PRERELEASELOOSE] + ")?" + src[BUILD] + "?)?)?";
    var XRANGE = R++;
    src[XRANGE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAIN] + "$";
    var XRANGELOOSE = R++;
    src[XRANGELOOSE] = "^" + src[GTLT] + "\\s*" + src[XRANGEPLAINLOOSE] + "$";
    var COERCE = R++;
    src[COERCE] = "(?:^|[^\\d])(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "})(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:\\.(\\d{1," + MAX_SAFE_COMPONENT_LENGTH + "}))?(?:$|[^\\d])";
    var LONETILDE = R++;
    src[LONETILDE] = "(?:~>?)";
    var TILDETRIM = R++;
    src[TILDETRIM] = "(\\s*)" + src[LONETILDE] + "\\s+";
    re[TILDETRIM] = new RegExp(src[TILDETRIM], "g");
    safeRe[TILDETRIM] = new RegExp(makeSafeRe(src[TILDETRIM]), "g");
    var tildeTrimReplace = "$1~";
    var TILDE = R++;
    src[TILDE] = "^" + src[LONETILDE] + src[XRANGEPLAIN] + "$";
    var TILDELOOSE = R++;
    src[TILDELOOSE] = "^" + src[LONETILDE] + src[XRANGEPLAINLOOSE] + "$";
    var LONECARET = R++;
    src[LONECARET] = "(?:\\^)";
    var CARETTRIM = R++;
    src[CARETTRIM] = "(\\s*)" + src[LONECARET] + "\\s+";
    re[CARETTRIM] = new RegExp(src[CARETTRIM], "g");
    safeRe[CARETTRIM] = new RegExp(makeSafeRe(src[CARETTRIM]), "g");
    var caretTrimReplace = "$1^";
    var CARET = R++;
    src[CARET] = "^" + src[LONECARET] + src[XRANGEPLAIN] + "$";
    var CARETLOOSE = R++;
    src[CARETLOOSE] = "^" + src[LONECARET] + src[XRANGEPLAINLOOSE] + "$";
    var COMPARATORLOOSE = R++;
    src[COMPARATORLOOSE] = "^" + src[GTLT] + "\\s*(" + LOOSEPLAIN + ")$|^$";
    var COMPARATOR = R++;
    src[COMPARATOR] = "^" + src[GTLT] + "\\s*(" + FULLPLAIN + ")$|^$";
    var COMPARATORTRIM = R++;
    src[COMPARATORTRIM] = "(\\s*)" + src[GTLT] + "\\s*(" + LOOSEPLAIN + "|" + src[XRANGEPLAIN] + ")";
    re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], "g");
    safeRe[COMPARATORTRIM] = new RegExp(makeSafeRe(src[COMPARATORTRIM]), "g");
    var comparatorTrimReplace = "$1$2$3";
    var HYPHENRANGE = R++;
    src[HYPHENRANGE] = "^\\s*(" + src[XRANGEPLAIN] + ")\\s+-\\s+(" + src[XRANGEPLAIN] + ")\\s*$";
    var HYPHENRANGELOOSE = R++;
    src[HYPHENRANGELOOSE] = "^\\s*(" + src[XRANGEPLAINLOOSE] + ")\\s+-\\s+(" + src[XRANGEPLAINLOOSE] + ")\\s*$";
    var STAR = R++;
    src[STAR] = "(<|>)?=?\\s*\\*";
    for (i = 0; i < R; i++) {
      debug(i, src[i]);
      if (!re[i]) {
        re[i] = new RegExp(src[i]);
        safeRe[i] = new RegExp(makeSafeRe(src[i]));
      }
    }
    var i;
    exports2.parse = parse;
    function parse(version2, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 !== "string") {
        return null;
      }
      if (version2.length > MAX_LENGTH) {
        return null;
      }
      var r = options.loose ? safeRe[LOOSE] : safeRe[FULL];
      if (!r.test(version2)) {
        return null;
      }
      try {
        return new SemVer(version2, options);
      } catch (er) {
        return null;
      }
    }
    exports2.valid = valid;
    function valid(version2, options) {
      var v = parse(version2, options);
      return v ? v.version : null;
    }
    exports2.clean = clean;
    function clean(version2, options) {
      var s = parse(version2.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }
    exports2.SemVer = SemVer;
    function SemVer(version2, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (version2 instanceof SemVer) {
        if (version2.loose === options.loose) {
          return version2;
        } else {
          version2 = version2.version;
        }
      } else if (typeof version2 !== "string") {
        throw new TypeError("Invalid Version: " + version2);
      }
      if (version2.length > MAX_LENGTH) {
        throw new TypeError("version is longer than " + MAX_LENGTH + " characters");
      }
      if (!(this instanceof SemVer)) {
        return new SemVer(version2, options);
      }
      debug("SemVer", version2, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version2.trim().match(options.loose ? safeRe[LOOSE] : safeRe[FULL]);
      if (!m) {
        throw new TypeError("Invalid Version: " + version2);
      }
      this.raw = version2;
      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];
      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError("Invalid major version");
      }
      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError("Invalid minor version");
      }
      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError("Invalid patch version");
      }
      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split(".").map(function(id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;
            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }
          return id;
        });
      }
      this.build = m[5] ? m[5].split(".") : [];
      this.format();
    }
    SemVer.prototype.format = function() {
      this.version = this.major + "." + this.minor + "." + this.patch;
      if (this.prerelease.length) {
        this.version += "-" + this.prerelease.join(".");
      }
      return this.version;
    };
    SemVer.prototype.toString = function() {
      return this.version;
    };
    SemVer.prototype.compare = function(other) {
      debug("SemVer.compare", this.version, this.options, other);
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return this.compareMain(other) || this.comparePre(other);
    };
    SemVer.prototype.compareMain = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };
    SemVer.prototype.comparePre = function(other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }
      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }
      var i2 = 0;
      do {
        var a = this.prerelease[i2];
        var b = other.prerelease[i2];
        debug("prerelease compare", i2, a, b);
        if (a === void 0 && b === void 0) {
          return 0;
        } else if (b === void 0) {
          return 1;
        } else if (a === void 0) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i2);
    };
    SemVer.prototype.inc = function(release, identifier) {
      switch (release) {
        case "premajor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc("pre", identifier);
          break;
        case "preminor":
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc("pre", identifier);
          break;
        case "prepatch":
          this.prerelease.length = 0;
          this.inc("patch", identifier);
          this.inc("pre", identifier);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.
        case "prerelease":
          if (this.prerelease.length === 0) {
            this.inc("patch", identifier);
          }
          this.inc("pre", identifier);
          break;
        case "major":
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }
          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;
        case "minor":
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }
          this.patch = 0;
          this.prerelease = [];
          break;
        case "patch":
          if (this.prerelease.length === 0) {
            this.patch++;
          }
          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
        case "pre":
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i2 = this.prerelease.length;
            while (--i2 >= 0) {
              if (typeof this.prerelease[i2] === "number") {
                this.prerelease[i2]++;
                i2 = -2;
              }
            }
            if (i2 === -1) {
              this.prerelease.push(0);
            }
          }
          if (identifier) {
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }
          break;
        default:
          throw new Error("invalid increment argument: " + release);
      }
      this.format();
      this.raw = this.version;
      return this;
    };
    exports2.inc = inc;
    function inc(version2, release, loose, identifier) {
      if (typeof loose === "string") {
        identifier = loose;
        loose = void 0;
      }
      try {
        return new SemVer(version2, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }
    exports2.diff = diff;
    function diff(version1, version2) {
      if (eq2(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = "";
        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = "pre";
          var defaultResult = "prerelease";
        }
        for (var key in v1) {
          if (key === "major" || key === "minor" || key === "patch") {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }
        return defaultResult;
      }
    }
    exports2.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;
    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);
      if (anum && bnum) {
        a = +a;
        b = +b;
      }
      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }
    exports2.rcompareIdentifiers = rcompareIdentifiers;
    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }
    exports2.major = major;
    function major(a, loose) {
      return new SemVer(a, loose).major;
    }
    exports2.minor = minor;
    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }
    exports2.patch = patch;
    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }
    exports2.compare = compare;
    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }
    exports2.compareLoose = compareLoose;
    function compareLoose(a, b) {
      return compare(a, b, true);
    }
    exports2.rcompare = rcompare;
    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }
    exports2.sort = sort;
    function sort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.compare(a, b, loose);
      });
    }
    exports2.rsort = rsort;
    function rsort(list, loose) {
      return list.sort(function(a, b) {
        return exports2.rcompare(a, b, loose);
      });
    }
    exports2.gt = gt;
    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }
    exports2.lt = lt;
    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }
    exports2.eq = eq2;
    function eq2(a, b, loose) {
      return compare(a, b, loose) === 0;
    }
    exports2.neq = neq;
    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }
    exports2.gte = gte;
    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }
    exports2.lte = lte;
    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }
    exports2.cmp = cmp;
    function cmp(a, op, b, loose) {
      switch (op) {
        case "===":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a === b;
        case "!==":
          if (typeof a === "object")
            a = a.version;
          if (typeof b === "object")
            b = b.version;
          return a !== b;
        case "":
        case "=":
        case "==":
          return eq2(a, b, loose);
        case "!=":
          return neq(a, b, loose);
        case ">":
          return gt(a, b, loose);
        case ">=":
          return gte(a, b, loose);
        case "<":
          return lt(a, b, loose);
        case "<=":
          return lte(a, b, loose);
        default:
          throw new TypeError("Invalid operator: " + op);
      }
    }
    exports2.Comparator = Comparator;
    function Comparator(comp, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }
      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }
      comp = comp.trim().split(/\s+/).join(" ");
      debug("comparator", comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);
      if (this.semver === ANY) {
        this.value = "";
      } else {
        this.value = this.operator + this.semver.version;
      }
      debug("comp", this);
    }
    var ANY = {};
    Comparator.prototype.parse = function(comp) {
      var r = this.options.loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];
      var m = comp.match(r);
      if (!m) {
        throw new TypeError("Invalid comparator: " + comp);
      }
      this.operator = m[1];
      if (this.operator === "=") {
        this.operator = "";
      }
      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };
    Comparator.prototype.toString = function() {
      return this.value;
    };
    Comparator.prototype.test = function(version2) {
      debug("Comparator.test", version2, this.options.loose);
      if (this.semver === ANY) {
        return true;
      }
      if (typeof version2 === "string") {
        version2 = new SemVer(version2, this.options);
      }
      return cmp(version2, this.operator, this.semver, this.options);
    };
    Comparator.prototype.intersects = function(comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError("a Comparator is required");
      }
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      var rangeTmp;
      if (this.operator === "") {
        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === "") {
        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }
      var sameDirectionIncreasing = (this.operator === ">=" || this.operator === ">") && (comp.operator === ">=" || comp.operator === ">");
      var sameDirectionDecreasing = (this.operator === "<=" || this.operator === "<") && (comp.operator === "<=" || comp.operator === "<");
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === ">=" || this.operator === "<=") && (comp.operator === ">=" || comp.operator === "<=");
      var oppositeDirectionsLessThan = cmp(this.semver, "<", comp.semver, options) && ((this.operator === ">=" || this.operator === ">") && (comp.operator === "<=" || comp.operator === "<"));
      var oppositeDirectionsGreaterThan = cmp(this.semver, ">", comp.semver, options) && ((this.operator === "<=" || this.operator === "<") && (comp.operator === ">=" || comp.operator === ">"));
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };
    exports2.Range = Range;
    function Range(range2, options) {
      if (!options || typeof options !== "object") {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }
      if (range2 instanceof Range) {
        if (range2.loose === !!options.loose && range2.includePrerelease === !!options.includePrerelease) {
          return range2;
        } else {
          return new Range(range2.raw, options);
        }
      }
      if (range2 instanceof Comparator) {
        return new Range(range2.value, options);
      }
      if (!(this instanceof Range)) {
        return new Range(range2, options);
      }
      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease;
      this.raw = range2.trim().split(/\s+/).join(" ");
      this.set = this.raw.split("||").map(function(range3) {
        return this.parseRange(range3.trim());
      }, this).filter(function(c) {
        return c.length;
      });
      if (!this.set.length) {
        throw new TypeError("Invalid SemVer Range: " + this.raw);
      }
      this.format();
    }
    Range.prototype.format = function() {
      this.range = this.set.map(function(comps) {
        return comps.join(" ").trim();
      }).join("||").trim();
      return this.range;
    };
    Range.prototype.toString = function() {
      return this.range;
    };
    Range.prototype.parseRange = function(range2) {
      var loose = this.options.loose;
      var hr = loose ? safeRe[HYPHENRANGELOOSE] : safeRe[HYPHENRANGE];
      range2 = range2.replace(hr, hyphenReplace);
      debug("hyphen replace", range2);
      range2 = range2.replace(safeRe[COMPARATORTRIM], comparatorTrimReplace);
      debug("comparator trim", range2, safeRe[COMPARATORTRIM]);
      range2 = range2.replace(safeRe[TILDETRIM], tildeTrimReplace);
      range2 = range2.replace(safeRe[CARETTRIM], caretTrimReplace);
      var compRe = loose ? safeRe[COMPARATORLOOSE] : safeRe[COMPARATOR];
      var set = range2.split(" ").map(function(comp) {
        return parseComparator(comp, this.options);
      }, this).join(" ").split(/\s+/);
      if (this.options.loose) {
        set = set.filter(function(comp) {
          return !!comp.match(compRe);
        });
      }
      set = set.map(function(comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };
    Range.prototype.intersects = function(range2, options) {
      if (!(range2 instanceof Range)) {
        throw new TypeError("a Range is required");
      }
      return this.set.some(function(thisComparators) {
        return thisComparators.every(function(thisComparator) {
          return range2.set.some(function(rangeComparators) {
            return rangeComparators.every(function(rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    };
    exports2.toComparators = toComparators;
    function toComparators(range2, options) {
      return new Range(range2, options).set.map(function(comp) {
        return comp.map(function(c) {
          return c.value;
        }).join(" ").trim().split(" ");
      });
    }
    function parseComparator(comp, options) {
      debug("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug("caret", comp);
      comp = replaceTildes(comp, options);
      debug("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug("xrange", comp);
      comp = replaceStars(comp, options);
      debug("stars", comp);
      return comp;
    }
    function isX(id) {
      return !id || id.toLowerCase() === "x" || id === "*";
    }
    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceTilde(comp2, options);
      }).join(" ");
    }
    function replaceTilde(comp, options) {
      var r = options.loose ? safeRe[TILDELOOSE] : safeRe[TILDE];
      return comp.replace(r, function(_3, M, m, p, pr) {
        debug("tilde", comp, _3, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        } else if (pr) {
          debug("replaceTilde pr", pr);
          ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
        } else {
          ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
        }
        debug("tilde return", ret);
        return ret;
      });
    }
    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function(comp2) {
        return replaceCaret(comp2, options);
      }).join(" ");
    }
    function replaceCaret(comp, options) {
      debug("caret", comp, options);
      var r = options.loose ? safeRe[CARETLOOSE] : safeRe[CARET];
      return comp.replace(r, function(_3, M, m, p, pr) {
        debug("caret", comp, _3, M, m, p, pr);
        var ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m)) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (isX(p)) {
          if (M === "0") {
            ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
          } else {
            ret = ">=" + M + "." + m + ".0 <" + (+M + 1) + ".0.0";
          }
        } else if (pr) {
          debug("replaceCaret pr", pr);
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + "-" + pr + " <" + (+M + 1) + ".0.0";
          }
        } else {
          debug("no pr");
          if (M === "0") {
            if (m === "0") {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + m + "." + (+p + 1);
            } else {
              ret = ">=" + M + "." + m + "." + p + " <" + M + "." + (+m + 1) + ".0";
            }
          } else {
            ret = ">=" + M + "." + m + "." + p + " <" + (+M + 1) + ".0.0";
          }
        }
        debug("caret return", ret);
        return ret;
      });
    }
    function replaceXRanges(comp, options) {
      debug("replaceXRanges", comp, options);
      return comp.split(/\s+/).map(function(comp2) {
        return replaceXRange(comp2, options);
      }).join(" ");
    }
    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? safeRe[XRANGELOOSE] : safeRe[XRANGE];
      return comp.replace(r, function(ret, gtlt, M, m, p, pr) {
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m = 0;
          }
          p = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }
          ret = gtlt + M + "." + m + "." + p;
        } else if (xm) {
          ret = ">=" + M + ".0.0 <" + (+M + 1) + ".0.0";
        } else if (xp) {
          ret = ">=" + M + "." + m + ".0 <" + M + "." + (+m + 1) + ".0";
        }
        debug("xRange return", ret);
        return ret;
      });
    }
    function replaceStars(comp, options) {
      debug("replaceStars", comp, options);
      return comp.trim().replace(safeRe[STAR], "");
    }
    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = ">=" + fM + ".0.0";
      } else if (isX(fp)) {
        from = ">=" + fM + "." + fm + ".0";
      } else {
        from = ">=" + from;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = "<" + (+tM + 1) + ".0.0";
      } else if (isX(tp)) {
        to = "<" + tM + "." + (+tm + 1) + ".0";
      } else if (tpr) {
        to = "<=" + tM + "." + tm + "." + tp + "-" + tpr;
      } else {
        to = "<=" + to;
      }
      return (from + " " + to).trim();
    }
    Range.prototype.test = function(version2) {
      if (!version2) {
        return false;
      }
      if (typeof version2 === "string") {
        version2 = new SemVer(version2, this.options);
      }
      for (var i2 = 0; i2 < this.set.length; i2++) {
        if (testSet(this.set[i2], version2, this.options)) {
          return true;
        }
      }
      return false;
    };
    function testSet(set, version2, options) {
      for (var i2 = 0; i2 < set.length; i2++) {
        if (!set[i2].test(version2)) {
          return false;
        }
      }
      if (version2.prerelease.length && !options.includePrerelease) {
        for (i2 = 0; i2 < set.length; i2++) {
          debug(set[i2].semver);
          if (set[i2].semver === ANY) {
            continue;
          }
          if (set[i2].semver.prerelease.length > 0) {
            var allowed = set[i2].semver;
            if (allowed.major === version2.major && allowed.minor === version2.minor && allowed.patch === version2.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }
    exports2.satisfies = satisfies;
    function satisfies(version2, range2, options) {
      try {
        range2 = new Range(range2, options);
      } catch (er) {
        return false;
      }
      return range2.test(version2);
    }
    exports2.maxSatisfying = maxSatisfying;
    function maxSatisfying(versions, range2, options) {
      var max2 = null;
      var maxSV = null;
      try {
        var rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!max2 || maxSV.compare(v) === -1) {
            max2 = v;
            maxSV = new SemVer(max2, options);
          }
        }
      });
      return max2;
    }
    exports2.minSatisfying = minSatisfying;
    function minSatisfying(versions, range2, options) {
      var min2 = null;
      var minSV = null;
      try {
        var rangeObj = new Range(range2, options);
      } catch (er) {
        return null;
      }
      versions.forEach(function(v) {
        if (rangeObj.test(v)) {
          if (!min2 || minSV.compare(v) === 1) {
            min2 = v;
            minSV = new SemVer(min2, options);
          }
        }
      });
      return min2;
    }
    exports2.minVersion = minVersion;
    function minVersion(range2, loose) {
      range2 = new Range(range2, loose);
      var minver = new SemVer("0.0.0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range2.test(minver)) {
        return minver;
      }
      minver = null;
      for (var i2 = 0; i2 < range2.set.length; ++i2) {
        var comparators = range2.set[i2];
        comparators.forEach(function(comparator) {
          var compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error("Unexpected operation: " + comparator.operator);
          }
        });
      }
      if (minver && range2.test(minver)) {
        return minver;
      }
      return null;
    }
    exports2.validRange = validRange;
    function validRange(range2, options) {
      try {
        return new Range(range2, options).range || "*";
      } catch (er) {
        return null;
      }
    }
    exports2.ltr = ltr;
    function ltr(version2, range2, options) {
      return outside(version2, range2, "<", options);
    }
    exports2.gtr = gtr;
    function gtr(version2, range2, options) {
      return outside(version2, range2, ">", options);
    }
    exports2.outside = outside;
    function outside(version2, range2, hilo, options) {
      version2 = new SemVer(version2, options);
      range2 = new Range(range2, options);
      var gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version2, range2, options)) {
        return false;
      }
      for (var i2 = 0; i2 < range2.set.length; ++i2) {
        var comparators = range2.set[i2];
        var high = null;
        var low = null;
        comparators.forEach(function(comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version2, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version2, low.semver)) {
          return false;
        }
      }
      return true;
    }
    exports2.prerelease = prerelease;
    function prerelease(version2, options) {
      var parsed = parse(version2, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }
    exports2.intersects = intersects;
    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }
    exports2.coerce = coerce;
    function coerce(version2) {
      if (version2 instanceof SemVer) {
        return version2;
      }
      if (typeof version2 !== "string") {
        return null;
      }
      var match = version2.match(safeRe[COERCE]);
      if (match == null) {
        return null;
      }
      return parse(match[1] + "." + (match[2] || "0") + "." + (match[3] || "0"));
    }
  }
});

// ../node_modules/semver-compare/index.js
var require_semver_compare = __commonJS({
  "../node_modules/semver-compare/index.js"(exports2, module2) {
    module2.exports = function cmp(a, b) {
      var pa = a.split(".");
      var pb = b.split(".");
      for (var i = 0; i < 3; i++) {
        var na = Number(pa[i]);
        var nb = Number(pb[i]);
        if (na > nb) return 1;
        if (nb > na) return -1;
        if (!isNaN(na) && isNaN(nb)) return 1;
        if (isNaN(na) && !isNaN(nb)) return -1;
      }
      return 0;
    };
  }
});

// ../node_modules/uuid/lib/rng.js
var require_rng = __commonJS({
  "../node_modules/uuid/lib/rng.js"(exports2, module2) {
    var crypto = require("crypto");
    module2.exports = function nodeRNG() {
      return crypto.randomBytes(16);
    };
  }
});

// ../node_modules/uuid/lib/bytesToUuid.js
var require_bytesToUuid = __commonJS({
  "../node_modules/uuid/lib/bytesToUuid.js"(exports2, module2) {
    var byteToHex = [];
    for (i = 0; i < 256; ++i) {
      byteToHex[i] = (i + 256).toString(16).substr(1);
    }
    var i;
    function bytesToUuid(buf, offset) {
      var i2 = offset || 0;
      var bth = byteToHex;
      return [
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        "-",
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]],
        bth[buf[i2++]]
      ].join("");
    }
    module2.exports = bytesToUuid;
  }
});

// ../node_modules/uuid/v4.js
var require_v4 = __commonJS({
  "../node_modules/uuid/v4.js"(exports2, module2) {
    var rng = require_rng();
    var bytesToUuid = require_bytesToUuid();
    function v4(options, buf, offset) {
      var i = buf && offset || 0;
      if (typeof options == "string") {
        buf = options === "binary" ? new Array(16) : null;
        options = null;
      }
      options = options || {};
      var rnds = options.random || (options.rng || rng)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        for (var ii = 0; ii < 16; ++ii) {
          buf[i + ii] = rnds[ii];
        }
      }
      return buf || bytesToUuid(rnds);
    }
    module2.exports = v4;
  }
});

// ../node_modules/azure-pipelines-tool-lib/tool.js
var require_tool = __commonJS({
  "../node_modules/azure-pipelines-tool-lib/tool.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.scrape = exports2.extractZip = exports2.extractTar = exports2.extract7z = exports2.cacheFile = exports2.cacheDir = exports2.downloadToolWithRetries = exports2.downloadTool = exports2.findLocalToolVersions = exports2.findLocalTool = exports2.evaluateVersions = exports2.cleanVersion = exports2.isExplicitVersion = exports2.prependPath = exports2.debug = void 0;
    var httpm = require_HttpClient();
    var path2 = require("path");
    var os = require("os");
    var process2 = require("process");
    var fs3 = require("fs");
    var semver = require_semver();
    var tl2 = require("azure-pipelines-task-lib/task");
    var cmp = require_semver_compare();
    var uuidV4 = require_v4();
    var pkg = require(path2.join(__dirname, "package.json"));
    var userAgent = "vsts-task-installer/" + pkg.version;
    var requestOptions = {
      // ignoreSslError: true,
      proxy: tl2.getHttpProxyConfiguration(),
      cert: tl2.getHttpCertConfiguration(),
      allowRedirects: true,
      allowRetries: true,
      maxRetries: 2
    };
    tl2.setResourcePath(path2.join(__dirname, "lib.json"));
    function debug(message) {
      tl2.debug(message);
    }
    exports2.debug = debug;
    function prependPath(toolPath) {
      tl2.assertAgent("2.115.0");
      if (!toolPath) {
        throw new Error("Parameter toolPath must not be null or empty");
      } else if (!tl2.exist(toolPath) || !tl2.stats(toolPath).isDirectory()) {
        throw new Error("Directory does not exist: " + toolPath);
      }
      console.log(tl2.loc("TOOL_LIB_PrependPath", toolPath));
      let newPath = toolPath + path2.delimiter + process2.env["PATH"];
      tl2.debug("new Path: " + newPath);
      process2.env["PATH"] = newPath;
      console.log("##vso[task.prependpath]" + toolPath);
    }
    exports2.prependPath = prependPath;
    function delay(ms) {
      return new Promise((resolve) => setTimeout(resolve, ms));
    }
    function isExplicitVersion(versionSpec) {
      let c = semver.clean(versionSpec);
      tl2.debug("isExplicit: " + c);
      let valid = semver.valid(c) != null;
      tl2.debug("explicit? " + valid);
      return valid;
    }
    exports2.isExplicitVersion = isExplicitVersion;
    function cleanVersion(version2) {
      tl2.debug("cleaning: " + version2);
      return semver.clean(version2);
    }
    exports2.cleanVersion = cleanVersion;
    function evaluateVersions(versions, versionSpec) {
      let version2;
      tl2.debug("evaluating " + versions.length + " versions");
      versions = versions.sort(cmp);
      for (let i = versions.length - 1; i >= 0; i--) {
        let potential = versions[i];
        let satisfied = semver.satisfies(potential, versionSpec);
        if (satisfied) {
          version2 = potential;
          break;
        }
      }
      if (version2) {
        tl2.debug("matched: " + version2);
      } else {
        tl2.debug("match not found");
      }
      return version2;
    }
    exports2.evaluateVersions = evaluateVersions;
    function findLocalTool(toolName, versionSpec, arch) {
      if (!toolName) {
        throw new Error("toolName parameter is required");
      }
      if (!versionSpec) {
        throw new Error("versionSpec parameter is required");
      }
      arch = arch || os.arch();
      if (!isExplicitVersion(versionSpec)) {
        let localVersions = findLocalToolVersions(toolName, arch);
        let match = evaluateVersions(localVersions, versionSpec);
        versionSpec = match;
      }
      let toolPath;
      if (versionSpec) {
        versionSpec = semver.clean(versionSpec);
        let cacheRoot = _getCacheRoot();
        let cachePath = path2.join(cacheRoot, toolName, versionSpec, arch);
        tl2.debug("checking cache: " + cachePath);
        if (tl2.exist(cachePath) && tl2.exist(`${cachePath}.complete`)) {
          console.log(tl2.loc("TOOL_LIB_FoundInCache", toolName, versionSpec, arch));
          toolPath = cachePath;
        } else {
          tl2.debug("not found");
        }
      }
      return toolPath;
    }
    exports2.findLocalTool = findLocalTool;
    function findLocalToolVersions(toolName, arch) {
      let versions = [];
      arch = arch || os.arch();
      let toolPath = path2.join(_getCacheRoot(), toolName);
      if (tl2.exist(toolPath)) {
        let children = tl2.ls("", [toolPath]);
        children.forEach((child) => {
          if (isExplicitVersion(child)) {
            let fullPath = path2.join(toolPath, child, arch);
            if (tl2.exist(fullPath) && tl2.exist(`${fullPath}.complete`)) {
              versions.push(child);
            }
          }
        });
      }
      return versions;
    }
    exports2.findLocalToolVersions = findLocalToolVersions;
    function downloadTool(url, fileName, handlers, additionalHeaders) {
      return __awaiter2(this, void 0, void 0, function* () {
        return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
          try {
            handlers = handlers || null;
            let http = new httpm.HttpClient(userAgent, handlers, requestOptions);
            tl2.debug(fileName);
            fileName = fileName || uuidV4();
            var destPath;
            if (path2.isAbsolute(fileName)) {
              destPath = fileName;
            } else {
              destPath = path2.join(_getAgentTemp(), fileName);
            }
            tl2.mkdirP(path2.dirname(destPath));
            console.log(tl2.loc("TOOL_LIB_Downloading", url.replace(/sig=[^&]*/, "sig=-REDACTED-")));
            tl2.debug("destination " + destPath);
            if (fs3.existsSync(destPath)) {
              throw new Error("Destination file path already exists");
            }
            tl2.debug("downloading");
            let response = yield http.get(url, additionalHeaders);
            if (response.message.statusCode != 200) {
              let err = new Error("Unexpected HTTP response: " + response.message.statusCode);
              err["httpStatusCode"] = response.message.statusCode;
              tl2.debug(`Failed to download "${fileName}" from "${url}". Code(${response.message.statusCode}) Message(${response.message.statusMessage})`);
              throw err;
            }
            let downloadedContentLength = _getContentLengthOfDownloadedFile(response);
            if (!isNaN(downloadedContentLength)) {
              tl2.debug(`Content-Length of downloaded file: ${downloadedContentLength}`);
            } else {
              tl2.debug(`Content-Length header missing`);
            }
            tl2.debug("creating stream");
            const file = fs3.createWriteStream(destPath);
            file.on("open", (fd) => __awaiter2(this, void 0, void 0, function* () {
              tl2.debug("file write stream opened. fd: " + fd);
              const messageStream = response.message;
              if (messageStream.aborted || messageStream.destroyed) {
                file.end();
                reject2(new Error("Incoming message read stream was Aborted or Destroyed before download was complete"));
                return;
              }
              tl2.debug("subscribing to message read stream events...");
              try {
                messageStream.on("error", (err) => {
                  file.end();
                  reject2(err);
                }).on("aborted", () => {
                  file.end();
                  reject2(new Error("Aborted"));
                }).pipe(file);
              } catch (err) {
                reject2(err);
              }
              tl2.debug("successfully subscribed to message read stream events");
            })).on("close", () => {
              tl2.debug("download complete");
              let fileSizeInBytes;
              try {
                fileSizeInBytes = _getFileSizeOnDisk(destPath);
              } catch (err) {
                fileSizeInBytes = NaN;
                tl2.warning(`Unable to check file size of ${destPath} due to error: ${err.Message}`);
              }
              if (!isNaN(fileSizeInBytes)) {
                tl2.debug(`Downloaded file size: ${fileSizeInBytes} bytes`);
              } else {
                tl2.debug(`File size on disk was not found`);
              }
              if (!isNaN(downloadedContentLength) && !isNaN(fileSizeInBytes) && fileSizeInBytes !== downloadedContentLength) {
                tl2.warning(`Content-Length (${downloadedContentLength} bytes) did not match downloaded file size (${fileSizeInBytes} bytes).`);
              }
              resolve(destPath);
            }).on("error", (err) => {
              file.end();
              reject2(err);
            });
          } catch (error) {
            reject2(error);
          }
        }));
      });
    }
    exports2.downloadTool = downloadTool;
    function downloadToolWithRetries(url, fileName, handlers, additionalHeaders, maxAttempts = 3, retryInterval = 500) {
      return __awaiter2(this, void 0, void 0, function* () {
        let attempt = 1;
        let destinationPath = "";
        while (attempt <= maxAttempts && destinationPath == "") {
          try {
            destinationPath = yield downloadTool(url, fileName, handlers, additionalHeaders);
          } catch (err) {
            if (attempt === maxAttempts)
              throw err;
            const attemptInterval = attempt * retryInterval;
            tl2.debug(`Attempt ${attempt} failed. Retrying after ${attemptInterval} ms`);
            yield delay(attemptInterval);
            attempt++;
          }
        }
        return destinationPath;
      });
    }
    exports2.downloadToolWithRetries = downloadToolWithRetries;
    function _getContentLengthOfDownloadedFile(response) {
      let contentLengthHeader = response.message.headers["content-length"];
      let parsedContentLength = parseInt(contentLengthHeader);
      return parsedContentLength;
    }
    function _getFileSizeOnDisk(filePath) {
      let fileStats = fs3.statSync(filePath);
      let fileSizeInBytes = fileStats.size;
      return fileSizeInBytes;
    }
    function _createToolPath(tool, version2, arch) {
      let folderPath = path2.join(_getCacheRoot(), tool, semver.clean(version2), arch);
      tl2.debug("destination " + folderPath);
      let markerPath = `${folderPath}.complete`;
      tl2.rmRF(folderPath);
      tl2.rmRF(markerPath);
      tl2.mkdirP(folderPath);
      return folderPath;
    }
    function _completeToolPath(tool, version2, arch) {
      let folderPath = path2.join(_getCacheRoot(), tool, semver.clean(version2), arch);
      let markerPath = `${folderPath}.complete`;
      tl2.writeFile(markerPath, "");
      tl2.debug("finished caching tool");
    }
    function cacheDir(sourceDir, tool, version2, arch) {
      return __awaiter2(this, void 0, void 0, function* () {
        version2 = semver.clean(version2);
        arch = arch || os.arch();
        console.log(tl2.loc("TOOL_LIB_CachingTool", tool, version2, arch));
        tl2.debug("source dir: " + sourceDir);
        if (!tl2.stats(sourceDir).isDirectory()) {
          throw new Error("sourceDir is not a directory");
        }
        let destPath = _createToolPath(tool, version2, arch);
        for (let itemName of fs3.readdirSync(sourceDir)) {
          let s = path2.join(sourceDir, itemName);
          tl2.cp(s, destPath + "/", "-r");
        }
        _completeToolPath(tool, version2, arch);
        return destPath;
      });
    }
    exports2.cacheDir = cacheDir;
    function cacheFile(sourceFile, targetFile, tool, version2, arch) {
      return __awaiter2(this, void 0, void 0, function* () {
        version2 = semver.clean(version2);
        arch = arch || os.arch();
        console.log(tl2.loc("TOOL_LIB_CachingTool", tool, version2, arch));
        tl2.debug("source file:" + sourceFile);
        if (!tl2.stats(sourceFile).isFile()) {
          throw new Error("sourceFile is not a file");
        }
        let destFolder = _createToolPath(tool, version2, arch);
        let destPath = path2.join(destFolder, targetFile);
        tl2.debug("destination file" + destPath);
        tl2.cp(sourceFile, destPath);
        _completeToolPath(tool, version2, arch);
        return destFolder;
      });
    }
    exports2.cacheFile = cacheFile;
    function extract7z(file, dest, _7zPath, overwriteDest) {
      return __awaiter2(this, void 0, void 0, function* () {
        if (process2.platform != "win32") {
          throw new Error("extract7z() not supported on current OS");
        }
        if (!file) {
          throw new Error("parameter 'file' is required");
        }
        console.log(tl2.loc("TOOL_LIB_ExtractingArchive"));
        dest = _createExtractFolder(dest);
        let originalCwd = process2.cwd();
        try {
          process2.chdir(dest);
          if (_7zPath) {
            const _7z = tl2.tool(_7zPath);
            if (overwriteDest) {
              _7z.arg("-aoa");
            }
            _7z.arg("x").arg("-bb1").arg("-bd").arg("-sccUTF-8").arg(file);
            yield _7z.exec();
          } else {
            let escapedScript = path2.join(__dirname, "Invoke-7zdec.ps1").replace(/'/g, "''").replace(/"|\n|\r/g, "");
            let escapedFile = file.replace(/'/g, "''").replace(/"|\n|\r/g, "");
            let escapedTarget = dest.replace(/'/g, "''").replace(/"|\n|\r/g, "");
            const overrideDestDirectory = overwriteDest ? 1 : 0;
            const command = `& '${escapedScript}' -Source '${escapedFile}' -Target '${escapedTarget}' -OverrideDestDirectory ${overrideDestDirectory}`;
            let powershellPath = tl2.which("powershell", true);
            let powershell = tl2.tool(powershellPath).line("-NoLogo -Sta -NoProfile -NonInteractive -ExecutionPolicy Unrestricted -Command").arg(command);
            powershell.on("stdout", (buffer) => {
              process2.stdout.write(buffer);
            });
            powershell.on("stderr", (buffer) => {
              process2.stderr.write(buffer);
            });
            yield powershell.exec({ silent: true });
          }
        } finally {
          process2.chdir(originalCwd);
        }
        return dest;
      });
    }
    exports2.extract7z = extract7z;
    function extractTar(file, destination) {
      return __awaiter2(this, void 0, void 0, function* () {
        console.log(tl2.loc("TOOL_LIB_ExtractingArchive"));
        let dest = _createExtractFolder(destination);
        let tr = tl2.tool("tar");
        tr.arg(["xC", dest, "-f", file]);
        yield tr.exec();
        return dest;
      });
    }
    exports2.extractTar = extractTar;
    function extractZip(file, destination) {
      return __awaiter2(this, void 0, void 0, function* () {
        if (!file) {
          throw new Error("parameter 'file' is required");
        }
        console.log(tl2.loc("TOOL_LIB_ExtractingArchive"));
        let dest = _createExtractFolder(destination);
        if (process2.platform == "win32") {
          let escapedFile = file.replace(/'/g, "''").replace(/"|\n|\r/g, "");
          let escapedDest = dest.replace(/'/g, "''").replace(/"|\n|\r/g, "");
          let command = `$ErrorActionPreference = 'Stop' ; try { Add-Type -AssemblyName System.IO.Compression.FileSystem } catch { } ; [System.IO.Compression.ZipFile]::ExtractToDirectory('${escapedFile}', '${escapedDest}')`;
          let chcpPath = path2.join(process2.env.windir, "system32", "chcp.com");
          yield tl2.exec(chcpPath, "65001");
          let powershell = tl2.tool("powershell").line("-NoLogo -Sta -NoProfile -NonInteractive -ExecutionPolicy Unrestricted -Command").arg(command);
          yield powershell.exec();
        } else {
          let unzip2 = tl2.tool("unzip").arg(file);
          yield unzip2.exec({ cwd: dest });
        }
        return dest;
      });
    }
    exports2.extractZip = extractZip;
    function _createExtractFolder(dest) {
      if (!dest) {
        dest = path2.join(_getAgentTemp(), uuidV4());
      }
      tl2.mkdirP(dest);
      return dest;
    }
    function scrape(url, regex, handlers) {
      return __awaiter2(this, void 0, void 0, function* () {
        handlers = handlers || null;
        let http = new httpm.HttpClient(userAgent, handlers, requestOptions);
        let output = yield (yield http.get(url)).readBody();
        let matches = output.match(regex);
        let seen = {};
        let versions = [];
        for (let i = 0; i < matches.length; i++) {
          let ver = semver.clean(matches[i]);
          if (!seen.hasOwnProperty(ver)) {
            seen[ver] = true;
            versions.push(ver);
          }
        }
        return versions;
      });
    }
    exports2.scrape = scrape;
    function _getCacheRoot() {
      tl2.assertAgent("2.115.0");
      let cacheRoot = tl2.getVariable("Agent.ToolsDirectory");
      if (!cacheRoot) {
        throw new Error("Agent.ToolsDirectory is not set");
      }
      return cacheRoot;
    }
    function _getAgentTemp() {
      tl2.assertAgent("2.115.0");
      let tempDirectory = tl2.getVariable("Agent.TempDirectory");
      if (!tempDirectory) {
        throw new Error("Agent.TempDirectory is not set");
      }
      return tempDirectory;
    }
  }
});

// ../node_modules/azure-devops-node-api/interfaces/PolicyInterfaces.js
var require_PolicyInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/PolicyInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.PolicyEvaluationStatus = void 0;
    var PolicyEvaluationStatus;
    (function(PolicyEvaluationStatus2) {
      PolicyEvaluationStatus2[PolicyEvaluationStatus2["Queued"] = 0] = "Queued";
      PolicyEvaluationStatus2[PolicyEvaluationStatus2["Running"] = 1] = "Running";
      PolicyEvaluationStatus2[PolicyEvaluationStatus2["Approved"] = 2] = "Approved";
      PolicyEvaluationStatus2[PolicyEvaluationStatus2["Rejected"] = 3] = "Rejected";
      PolicyEvaluationStatus2[PolicyEvaluationStatus2["NotApplicable"] = 4] = "NotApplicable";
      PolicyEvaluationStatus2[PolicyEvaluationStatus2["Broken"] = 5] = "Broken";
    })(PolicyEvaluationStatus = exports2.PolicyEvaluationStatus || (exports2.PolicyEvaluationStatus = {}));
    exports2.TypeInfo = {
      PolicyConfiguration: {},
      PolicyEvaluationRecord: {},
      PolicyEvaluationStatus: {
        enumValues: {
          "queued": 0,
          "running": 1,
          "approved": 2,
          "rejected": 3,
          "notApplicable": 4,
          "broken": 5
        }
      }
    };
    exports2.TypeInfo.PolicyConfiguration.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.PolicyEvaluationRecord.fields = {
      completedDate: {
        isDate: true
      },
      configuration: {
        typeInfo: exports2.TypeInfo.PolicyConfiguration
      },
      startedDate: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.PolicyEvaluationStatus
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/interfaces/CoreInterfaces.js
var require_CoreInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/CoreInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.SourceControlTypes = exports2.ProjectVisibility = exports2.ProjectChangeType = exports2.ProcessType = exports2.ProcessCustomizationType = exports2.ConnectedServiceKind = void 0;
    var ConnectedServiceKind;
    (function(ConnectedServiceKind2) {
      ConnectedServiceKind2[ConnectedServiceKind2["Custom"] = 0] = "Custom";
      ConnectedServiceKind2[ConnectedServiceKind2["AzureSubscription"] = 1] = "AzureSubscription";
      ConnectedServiceKind2[ConnectedServiceKind2["Chef"] = 2] = "Chef";
      ConnectedServiceKind2[ConnectedServiceKind2["Generic"] = 3] = "Generic";
    })(ConnectedServiceKind = exports2.ConnectedServiceKind || (exports2.ConnectedServiceKind = {}));
    var ProcessCustomizationType;
    (function(ProcessCustomizationType2) {
      ProcessCustomizationType2[ProcessCustomizationType2["Unknown"] = -1] = "Unknown";
      ProcessCustomizationType2[ProcessCustomizationType2["Xml"] = 0] = "Xml";
      ProcessCustomizationType2[ProcessCustomizationType2["Inherited"] = 1] = "Inherited";
    })(ProcessCustomizationType = exports2.ProcessCustomizationType || (exports2.ProcessCustomizationType = {}));
    var ProcessType;
    (function(ProcessType2) {
      ProcessType2[ProcessType2["System"] = 0] = "System";
      ProcessType2[ProcessType2["Custom"] = 1] = "Custom";
      ProcessType2[ProcessType2["Inherited"] = 2] = "Inherited";
    })(ProcessType = exports2.ProcessType || (exports2.ProcessType = {}));
    var ProjectChangeType;
    (function(ProjectChangeType2) {
      ProjectChangeType2[ProjectChangeType2["Modified"] = 0] = "Modified";
      ProjectChangeType2[ProjectChangeType2["Deleted"] = 1] = "Deleted";
      ProjectChangeType2[ProjectChangeType2["Added"] = 2] = "Added";
    })(ProjectChangeType = exports2.ProjectChangeType || (exports2.ProjectChangeType = {}));
    var ProjectVisibility;
    (function(ProjectVisibility2) {
      ProjectVisibility2[ProjectVisibility2["Unchanged"] = -1] = "Unchanged";
      ProjectVisibility2[ProjectVisibility2["Private"] = 0] = "Private";
      ProjectVisibility2[ProjectVisibility2["Organization"] = 1] = "Organization";
      ProjectVisibility2[ProjectVisibility2["Public"] = 2] = "Public";
      ProjectVisibility2[ProjectVisibility2["SystemPrivate"] = 3] = "SystemPrivate";
    })(ProjectVisibility = exports2.ProjectVisibility || (exports2.ProjectVisibility = {}));
    var SourceControlTypes;
    (function(SourceControlTypes2) {
      SourceControlTypes2[SourceControlTypes2["Tfvc"] = 1] = "Tfvc";
      SourceControlTypes2[SourceControlTypes2["Git"] = 2] = "Git";
    })(SourceControlTypes = exports2.SourceControlTypes || (exports2.SourceControlTypes = {}));
    exports2.TypeInfo = {
      ConnectedServiceKind: {
        enumValues: {
          "custom": 0,
          "azureSubscription": 1,
          "chef": 2,
          "generic": 3
        }
      },
      Process: {},
      ProcessCustomizationType: {
        enumValues: {
          "unknown": -1,
          "xml": 0,
          "inherited": 1
        }
      },
      ProcessType: {
        enumValues: {
          "system": 0,
          "custom": 1,
          "inherited": 2
        }
      },
      ProjectChangeType: {
        enumValues: {
          "modified": 0,
          "deleted": 1,
          "added": 2
        }
      },
      ProjectInfo: {},
      ProjectMessage: {},
      ProjectVisibility: {
        enumValues: {
          "private": 0,
          "organization": 1,
          "public": 2
        }
      },
      SourceControlTypes: {
        enumValues: {
          "tfvc": 1,
          "git": 2
        }
      },
      TeamProject: {},
      TeamProjectCollection: {},
      TeamProjectReference: {},
      TemporaryDataCreatedDTO: {},
      WebApiConnectedService: {},
      WebApiConnectedServiceDetails: {},
      WebApiProject: {}
    };
    exports2.TypeInfo.Process.fields = {
      type: {
        enumType: exports2.TypeInfo.ProcessType
      }
    };
    exports2.TypeInfo.ProjectInfo.fields = {
      lastUpdateTime: {
        isDate: true
      },
      visibility: {
        enumType: exports2.TypeInfo.ProjectVisibility
      }
    };
    exports2.TypeInfo.ProjectMessage.fields = {
      project: {
        typeInfo: exports2.TypeInfo.ProjectInfo
      },
      projectChangeType: {
        enumType: exports2.TypeInfo.ProjectChangeType
      }
    };
    exports2.TypeInfo.TeamProject.fields = {
      lastUpdateTime: {
        isDate: true
      },
      visibility: {
        enumType: exports2.TypeInfo.ProjectVisibility
      }
    };
    exports2.TypeInfo.TeamProjectCollection.fields = {
      processCustomizationType: {
        enumType: exports2.TypeInfo.ProcessCustomizationType
      }
    };
    exports2.TypeInfo.TeamProjectReference.fields = {
      lastUpdateTime: {
        isDate: true
      },
      visibility: {
        enumType: exports2.TypeInfo.ProjectVisibility
      }
    };
    exports2.TypeInfo.TemporaryDataCreatedDTO.fields = {
      expirationDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.WebApiConnectedService.fields = {
      project: {
        typeInfo: exports2.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.WebApiConnectedServiceDetails.fields = {
      connectedServiceMetaData: {
        typeInfo: exports2.TypeInfo.WebApiConnectedService
      }
    };
    exports2.TypeInfo.WebApiProject.fields = {
      lastUpdateTime: {
        isDate: true
      },
      visibility: {
        enumType: exports2.TypeInfo.ProjectVisibility
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/interfaces/GitInterfaces.js
var require_GitInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/GitInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.VersionControlRecursionType = exports2.VersionControlChangeType = exports2.TfvcVersionType = exports2.TfvcVersionOption = exports2.SupportedIdeType = exports2.RefFavoriteType = exports2.PullRequestTimeRangeType = exports2.PullRequestStatus = exports2.PullRequestMergeFailureType = exports2.PullRequestAsyncStatus = exports2.LineDiffBlockChangeType = exports2.IterationReason = exports2.ItemContentType = exports2.GitVersionType = exports2.GitVersionOptions = exports2.GitStatusState = exports2.GitResolutionWhichAction = exports2.GitResolutionStatus = exports2.GitResolutionRename1to2Action = exports2.GitResolutionPathConflictAction = exports2.GitResolutionMergeType = exports2.GitResolutionError = exports2.GitRefUpdateStatus = exports2.GitRefUpdateMode = exports2.GitRefSearchType = exports2.GitPullRequestReviewFileType = exports2.GitPullRequestQueryType = exports2.GitPullRequestMergeStrategy = exports2.GitPathActions = exports2.GitObjectType = exports2.GitHistoryMode = exports2.GitConflictUpdateStatus = exports2.GitConflictType = exports2.GitAsyncRefOperationFailureStatus = exports2.GitAsyncOperationStatus = exports2.CommentType = exports2.CommentThreadStatus = void 0;
    var PolicyInterfaces = require_PolicyInterfaces();
    var TfsCoreInterfaces = require_CoreInterfaces();
    var CommentThreadStatus;
    (function(CommentThreadStatus2) {
      CommentThreadStatus2[CommentThreadStatus2["Unknown"] = 0] = "Unknown";
      CommentThreadStatus2[CommentThreadStatus2["Active"] = 1] = "Active";
      CommentThreadStatus2[CommentThreadStatus2["Fixed"] = 2] = "Fixed";
      CommentThreadStatus2[CommentThreadStatus2["WontFix"] = 3] = "WontFix";
      CommentThreadStatus2[CommentThreadStatus2["Closed"] = 4] = "Closed";
      CommentThreadStatus2[CommentThreadStatus2["ByDesign"] = 5] = "ByDesign";
      CommentThreadStatus2[CommentThreadStatus2["Pending"] = 6] = "Pending";
    })(CommentThreadStatus = exports2.CommentThreadStatus || (exports2.CommentThreadStatus = {}));
    var CommentType;
    (function(CommentType2) {
      CommentType2[CommentType2["Unknown"] = 0] = "Unknown";
      CommentType2[CommentType2["Text"] = 1] = "Text";
      CommentType2[CommentType2["CodeChange"] = 2] = "CodeChange";
      CommentType2[CommentType2["System"] = 3] = "System";
    })(CommentType = exports2.CommentType || (exports2.CommentType = {}));
    var GitAsyncOperationStatus;
    (function(GitAsyncOperationStatus2) {
      GitAsyncOperationStatus2[GitAsyncOperationStatus2["Queued"] = 1] = "Queued";
      GitAsyncOperationStatus2[GitAsyncOperationStatus2["InProgress"] = 2] = "InProgress";
      GitAsyncOperationStatus2[GitAsyncOperationStatus2["Completed"] = 3] = "Completed";
      GitAsyncOperationStatus2[GitAsyncOperationStatus2["Failed"] = 4] = "Failed";
      GitAsyncOperationStatus2[GitAsyncOperationStatus2["Abandoned"] = 5] = "Abandoned";
    })(GitAsyncOperationStatus = exports2.GitAsyncOperationStatus || (exports2.GitAsyncOperationStatus = {}));
    var GitAsyncRefOperationFailureStatus;
    (function(GitAsyncRefOperationFailureStatus2) {
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["None"] = 0] = "None";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["InvalidRefName"] = 1] = "InvalidRefName";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["RefNameConflict"] = 2] = "RefNameConflict";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["CreateBranchPermissionRequired"] = 3] = "CreateBranchPermissionRequired";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["WritePermissionRequired"] = 4] = "WritePermissionRequired";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["TargetBranchDeleted"] = 5] = "TargetBranchDeleted";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["GitObjectTooLarge"] = 6] = "GitObjectTooLarge";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["OperationIndentityNotFound"] = 7] = "OperationIndentityNotFound";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["AsyncOperationNotFound"] = 8] = "AsyncOperationNotFound";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["Other"] = 9] = "Other";
      GitAsyncRefOperationFailureStatus2[GitAsyncRefOperationFailureStatus2["EmptyCommitterSignature"] = 10] = "EmptyCommitterSignature";
    })(GitAsyncRefOperationFailureStatus = exports2.GitAsyncRefOperationFailureStatus || (exports2.GitAsyncRefOperationFailureStatus = {}));
    var GitConflictType;
    (function(GitConflictType2) {
      GitConflictType2[GitConflictType2["None"] = 0] = "None";
      GitConflictType2[GitConflictType2["AddAdd"] = 1] = "AddAdd";
      GitConflictType2[GitConflictType2["AddRename"] = 2] = "AddRename";
      GitConflictType2[GitConflictType2["DeleteEdit"] = 3] = "DeleteEdit";
      GitConflictType2[GitConflictType2["DeleteRename"] = 4] = "DeleteRename";
      GitConflictType2[GitConflictType2["DirectoryFile"] = 5] = "DirectoryFile";
      GitConflictType2[GitConflictType2["DirectoryChild"] = 6] = "DirectoryChild";
      GitConflictType2[GitConflictType2["EditDelete"] = 7] = "EditDelete";
      GitConflictType2[GitConflictType2["EditEdit"] = 8] = "EditEdit";
      GitConflictType2[GitConflictType2["FileDirectory"] = 9] = "FileDirectory";
      GitConflictType2[GitConflictType2["Rename1to2"] = 10] = "Rename1to2";
      GitConflictType2[GitConflictType2["Rename2to1"] = 11] = "Rename2to1";
      GitConflictType2[GitConflictType2["RenameAdd"] = 12] = "RenameAdd";
      GitConflictType2[GitConflictType2["RenameDelete"] = 13] = "RenameDelete";
      GitConflictType2[GitConflictType2["RenameRename"] = 14] = "RenameRename";
    })(GitConflictType = exports2.GitConflictType || (exports2.GitConflictType = {}));
    var GitConflictUpdateStatus;
    (function(GitConflictUpdateStatus2) {
      GitConflictUpdateStatus2[GitConflictUpdateStatus2["Succeeded"] = 0] = "Succeeded";
      GitConflictUpdateStatus2[GitConflictUpdateStatus2["BadRequest"] = 1] = "BadRequest";
      GitConflictUpdateStatus2[GitConflictUpdateStatus2["InvalidResolution"] = 2] = "InvalidResolution";
      GitConflictUpdateStatus2[GitConflictUpdateStatus2["UnsupportedConflictType"] = 3] = "UnsupportedConflictType";
      GitConflictUpdateStatus2[GitConflictUpdateStatus2["NotFound"] = 4] = "NotFound";
    })(GitConflictUpdateStatus = exports2.GitConflictUpdateStatus || (exports2.GitConflictUpdateStatus = {}));
    var GitHistoryMode;
    (function(GitHistoryMode2) {
      GitHistoryMode2[GitHistoryMode2["SimplifiedHistory"] = 0] = "SimplifiedHistory";
      GitHistoryMode2[GitHistoryMode2["FirstParent"] = 1] = "FirstParent";
      GitHistoryMode2[GitHistoryMode2["FullHistory"] = 2] = "FullHistory";
      GitHistoryMode2[GitHistoryMode2["FullHistorySimplifyMerges"] = 3] = "FullHistorySimplifyMerges";
    })(GitHistoryMode = exports2.GitHistoryMode || (exports2.GitHistoryMode = {}));
    var GitObjectType;
    (function(GitObjectType2) {
      GitObjectType2[GitObjectType2["Bad"] = 0] = "Bad";
      GitObjectType2[GitObjectType2["Commit"] = 1] = "Commit";
      GitObjectType2[GitObjectType2["Tree"] = 2] = "Tree";
      GitObjectType2[GitObjectType2["Blob"] = 3] = "Blob";
      GitObjectType2[GitObjectType2["Tag"] = 4] = "Tag";
      GitObjectType2[GitObjectType2["Ext2"] = 5] = "Ext2";
      GitObjectType2[GitObjectType2["OfsDelta"] = 6] = "OfsDelta";
      GitObjectType2[GitObjectType2["RefDelta"] = 7] = "RefDelta";
    })(GitObjectType = exports2.GitObjectType || (exports2.GitObjectType = {}));
    var GitPathActions;
    (function(GitPathActions2) {
      GitPathActions2[GitPathActions2["None"] = 0] = "None";
      GitPathActions2[GitPathActions2["Edit"] = 1] = "Edit";
      GitPathActions2[GitPathActions2["Delete"] = 2] = "Delete";
      GitPathActions2[GitPathActions2["Add"] = 3] = "Add";
      GitPathActions2[GitPathActions2["Rename"] = 4] = "Rename";
    })(GitPathActions = exports2.GitPathActions || (exports2.GitPathActions = {}));
    var GitPullRequestMergeStrategy;
    (function(GitPullRequestMergeStrategy2) {
      GitPullRequestMergeStrategy2[GitPullRequestMergeStrategy2["NoFastForward"] = 1] = "NoFastForward";
      GitPullRequestMergeStrategy2[GitPullRequestMergeStrategy2["Squash"] = 2] = "Squash";
      GitPullRequestMergeStrategy2[GitPullRequestMergeStrategy2["Rebase"] = 3] = "Rebase";
      GitPullRequestMergeStrategy2[GitPullRequestMergeStrategy2["RebaseMerge"] = 4] = "RebaseMerge";
    })(GitPullRequestMergeStrategy = exports2.GitPullRequestMergeStrategy || (exports2.GitPullRequestMergeStrategy = {}));
    var GitPullRequestQueryType;
    (function(GitPullRequestQueryType2) {
      GitPullRequestQueryType2[GitPullRequestQueryType2["NotSet"] = 0] = "NotSet";
      GitPullRequestQueryType2[GitPullRequestQueryType2["LastMergeCommit"] = 1] = "LastMergeCommit";
      GitPullRequestQueryType2[GitPullRequestQueryType2["Commit"] = 2] = "Commit";
    })(GitPullRequestQueryType = exports2.GitPullRequestQueryType || (exports2.GitPullRequestQueryType = {}));
    var GitPullRequestReviewFileType;
    (function(GitPullRequestReviewFileType2) {
      GitPullRequestReviewFileType2[GitPullRequestReviewFileType2["ChangeEntry"] = 0] = "ChangeEntry";
      GitPullRequestReviewFileType2[GitPullRequestReviewFileType2["Attachment"] = 1] = "Attachment";
    })(GitPullRequestReviewFileType = exports2.GitPullRequestReviewFileType || (exports2.GitPullRequestReviewFileType = {}));
    var GitRefSearchType;
    (function(GitRefSearchType2) {
      GitRefSearchType2[GitRefSearchType2["Exact"] = 0] = "Exact";
      GitRefSearchType2[GitRefSearchType2["StartsWith"] = 1] = "StartsWith";
      GitRefSearchType2[GitRefSearchType2["Contains"] = 2] = "Contains";
    })(GitRefSearchType = exports2.GitRefSearchType || (exports2.GitRefSearchType = {}));
    var GitRefUpdateMode;
    (function(GitRefUpdateMode2) {
      GitRefUpdateMode2[GitRefUpdateMode2["BestEffort"] = 0] = "BestEffort";
      GitRefUpdateMode2[GitRefUpdateMode2["AllOrNone"] = 1] = "AllOrNone";
    })(GitRefUpdateMode = exports2.GitRefUpdateMode || (exports2.GitRefUpdateMode = {}));
    var GitRefUpdateStatus;
    (function(GitRefUpdateStatus2) {
      GitRefUpdateStatus2[GitRefUpdateStatus2["Succeeded"] = 0] = "Succeeded";
      GitRefUpdateStatus2[GitRefUpdateStatus2["ForcePushRequired"] = 1] = "ForcePushRequired";
      GitRefUpdateStatus2[GitRefUpdateStatus2["StaleOldObjectId"] = 2] = "StaleOldObjectId";
      GitRefUpdateStatus2[GitRefUpdateStatus2["InvalidRefName"] = 3] = "InvalidRefName";
      GitRefUpdateStatus2[GitRefUpdateStatus2["Unprocessed"] = 4] = "Unprocessed";
      GitRefUpdateStatus2[GitRefUpdateStatus2["UnresolvableToCommit"] = 5] = "UnresolvableToCommit";
      GitRefUpdateStatus2[GitRefUpdateStatus2["WritePermissionRequired"] = 6] = "WritePermissionRequired";
      GitRefUpdateStatus2[GitRefUpdateStatus2["ManageNotePermissionRequired"] = 7] = "ManageNotePermissionRequired";
      GitRefUpdateStatus2[GitRefUpdateStatus2["CreateBranchPermissionRequired"] = 8] = "CreateBranchPermissionRequired";
      GitRefUpdateStatus2[GitRefUpdateStatus2["CreateTagPermissionRequired"] = 9] = "CreateTagPermissionRequired";
      GitRefUpdateStatus2[GitRefUpdateStatus2["RejectedByPlugin"] = 10] = "RejectedByPlugin";
      GitRefUpdateStatus2[GitRefUpdateStatus2["Locked"] = 11] = "Locked";
      GitRefUpdateStatus2[GitRefUpdateStatus2["RefNameConflict"] = 12] = "RefNameConflict";
      GitRefUpdateStatus2[GitRefUpdateStatus2["RejectedByPolicy"] = 13] = "RejectedByPolicy";
      GitRefUpdateStatus2[GitRefUpdateStatus2["SucceededNonExistentRef"] = 14] = "SucceededNonExistentRef";
      GitRefUpdateStatus2[GitRefUpdateStatus2["SucceededCorruptRef"] = 15] = "SucceededCorruptRef";
    })(GitRefUpdateStatus = exports2.GitRefUpdateStatus || (exports2.GitRefUpdateStatus = {}));
    var GitResolutionError;
    (function(GitResolutionError2) {
      GitResolutionError2[GitResolutionError2["None"] = 0] = "None";
      GitResolutionError2[GitResolutionError2["MergeContentNotFound"] = 1] = "MergeContentNotFound";
      GitResolutionError2[GitResolutionError2["PathInUse"] = 2] = "PathInUse";
      GitResolutionError2[GitResolutionError2["InvalidPath"] = 3] = "InvalidPath";
      GitResolutionError2[GitResolutionError2["UnknownAction"] = 4] = "UnknownAction";
      GitResolutionError2[GitResolutionError2["UnknownMergeType"] = 5] = "UnknownMergeType";
      GitResolutionError2[GitResolutionError2["OtherError"] = 255] = "OtherError";
    })(GitResolutionError = exports2.GitResolutionError || (exports2.GitResolutionError = {}));
    var GitResolutionMergeType;
    (function(GitResolutionMergeType2) {
      GitResolutionMergeType2[GitResolutionMergeType2["Undecided"] = 0] = "Undecided";
      GitResolutionMergeType2[GitResolutionMergeType2["TakeSourceContent"] = 1] = "TakeSourceContent";
      GitResolutionMergeType2[GitResolutionMergeType2["TakeTargetContent"] = 2] = "TakeTargetContent";
      GitResolutionMergeType2[GitResolutionMergeType2["AutoMerged"] = 3] = "AutoMerged";
      GitResolutionMergeType2[GitResolutionMergeType2["UserMerged"] = 4] = "UserMerged";
    })(GitResolutionMergeType = exports2.GitResolutionMergeType || (exports2.GitResolutionMergeType = {}));
    var GitResolutionPathConflictAction;
    (function(GitResolutionPathConflictAction2) {
      GitResolutionPathConflictAction2[GitResolutionPathConflictAction2["Undecided"] = 0] = "Undecided";
      GitResolutionPathConflictAction2[GitResolutionPathConflictAction2["KeepSourceRenameTarget"] = 1] = "KeepSourceRenameTarget";
      GitResolutionPathConflictAction2[GitResolutionPathConflictAction2["KeepSourceDeleteTarget"] = 2] = "KeepSourceDeleteTarget";
      GitResolutionPathConflictAction2[GitResolutionPathConflictAction2["KeepTargetRenameSource"] = 3] = "KeepTargetRenameSource";
      GitResolutionPathConflictAction2[GitResolutionPathConflictAction2["KeepTargetDeleteSource"] = 4] = "KeepTargetDeleteSource";
    })(GitResolutionPathConflictAction = exports2.GitResolutionPathConflictAction || (exports2.GitResolutionPathConflictAction = {}));
    var GitResolutionRename1to2Action;
    (function(GitResolutionRename1to2Action2) {
      GitResolutionRename1to2Action2[GitResolutionRename1to2Action2["Undecided"] = 0] = "Undecided";
      GitResolutionRename1to2Action2[GitResolutionRename1to2Action2["KeepSourcePath"] = 1] = "KeepSourcePath";
      GitResolutionRename1to2Action2[GitResolutionRename1to2Action2["KeepTargetPath"] = 2] = "KeepTargetPath";
      GitResolutionRename1to2Action2[GitResolutionRename1to2Action2["KeepBothFiles"] = 3] = "KeepBothFiles";
    })(GitResolutionRename1to2Action = exports2.GitResolutionRename1to2Action || (exports2.GitResolutionRename1to2Action = {}));
    var GitResolutionStatus;
    (function(GitResolutionStatus2) {
      GitResolutionStatus2[GitResolutionStatus2["Unresolved"] = 0] = "Unresolved";
      GitResolutionStatus2[GitResolutionStatus2["PartiallyResolved"] = 1] = "PartiallyResolved";
      GitResolutionStatus2[GitResolutionStatus2["Resolved"] = 2] = "Resolved";
    })(GitResolutionStatus = exports2.GitResolutionStatus || (exports2.GitResolutionStatus = {}));
    var GitResolutionWhichAction;
    (function(GitResolutionWhichAction2) {
      GitResolutionWhichAction2[GitResolutionWhichAction2["Undecided"] = 0] = "Undecided";
      GitResolutionWhichAction2[GitResolutionWhichAction2["PickSourceAction"] = 1] = "PickSourceAction";
      GitResolutionWhichAction2[GitResolutionWhichAction2["PickTargetAction"] = 2] = "PickTargetAction";
    })(GitResolutionWhichAction = exports2.GitResolutionWhichAction || (exports2.GitResolutionWhichAction = {}));
    var GitStatusState;
    (function(GitStatusState2) {
      GitStatusState2[GitStatusState2["NotSet"] = 0] = "NotSet";
      GitStatusState2[GitStatusState2["Pending"] = 1] = "Pending";
      GitStatusState2[GitStatusState2["Succeeded"] = 2] = "Succeeded";
      GitStatusState2[GitStatusState2["Failed"] = 3] = "Failed";
      GitStatusState2[GitStatusState2["Error"] = 4] = "Error";
      GitStatusState2[GitStatusState2["NotApplicable"] = 5] = "NotApplicable";
      GitStatusState2[GitStatusState2["PartiallySucceeded"] = 6] = "PartiallySucceeded";
    })(GitStatusState = exports2.GitStatusState || (exports2.GitStatusState = {}));
    var GitVersionOptions;
    (function(GitVersionOptions2) {
      GitVersionOptions2[GitVersionOptions2["None"] = 0] = "None";
      GitVersionOptions2[GitVersionOptions2["PreviousChange"] = 1] = "PreviousChange";
      GitVersionOptions2[GitVersionOptions2["FirstParent"] = 2] = "FirstParent";
    })(GitVersionOptions = exports2.GitVersionOptions || (exports2.GitVersionOptions = {}));
    var GitVersionType;
    (function(GitVersionType2) {
      GitVersionType2[GitVersionType2["Branch"] = 0] = "Branch";
      GitVersionType2[GitVersionType2["Tag"] = 1] = "Tag";
      GitVersionType2[GitVersionType2["Commit"] = 2] = "Commit";
    })(GitVersionType = exports2.GitVersionType || (exports2.GitVersionType = {}));
    var ItemContentType;
    (function(ItemContentType2) {
      ItemContentType2[ItemContentType2["RawText"] = 0] = "RawText";
      ItemContentType2[ItemContentType2["Base64Encoded"] = 1] = "Base64Encoded";
    })(ItemContentType = exports2.ItemContentType || (exports2.ItemContentType = {}));
    var IterationReason;
    (function(IterationReason2) {
      IterationReason2[IterationReason2["Push"] = 0] = "Push";
      IterationReason2[IterationReason2["ForcePush"] = 1] = "ForcePush";
      IterationReason2[IterationReason2["Create"] = 2] = "Create";
      IterationReason2[IterationReason2["Rebase"] = 4] = "Rebase";
      IterationReason2[IterationReason2["Unknown"] = 8] = "Unknown";
      IterationReason2[IterationReason2["Retarget"] = 16] = "Retarget";
      IterationReason2[IterationReason2["ResolveConflicts"] = 32] = "ResolveConflicts";
    })(IterationReason = exports2.IterationReason || (exports2.IterationReason = {}));
    var LineDiffBlockChangeType;
    (function(LineDiffBlockChangeType2) {
      LineDiffBlockChangeType2[LineDiffBlockChangeType2["None"] = 0] = "None";
      LineDiffBlockChangeType2[LineDiffBlockChangeType2["Add"] = 1] = "Add";
      LineDiffBlockChangeType2[LineDiffBlockChangeType2["Delete"] = 2] = "Delete";
      LineDiffBlockChangeType2[LineDiffBlockChangeType2["Edit"] = 3] = "Edit";
    })(LineDiffBlockChangeType = exports2.LineDiffBlockChangeType || (exports2.LineDiffBlockChangeType = {}));
    var PullRequestAsyncStatus;
    (function(PullRequestAsyncStatus2) {
      PullRequestAsyncStatus2[PullRequestAsyncStatus2["NotSet"] = 0] = "NotSet";
      PullRequestAsyncStatus2[PullRequestAsyncStatus2["Queued"] = 1] = "Queued";
      PullRequestAsyncStatus2[PullRequestAsyncStatus2["Conflicts"] = 2] = "Conflicts";
      PullRequestAsyncStatus2[PullRequestAsyncStatus2["Succeeded"] = 3] = "Succeeded";
      PullRequestAsyncStatus2[PullRequestAsyncStatus2["RejectedByPolicy"] = 4] = "RejectedByPolicy";
      PullRequestAsyncStatus2[PullRequestAsyncStatus2["Failure"] = 5] = "Failure";
    })(PullRequestAsyncStatus = exports2.PullRequestAsyncStatus || (exports2.PullRequestAsyncStatus = {}));
    var PullRequestMergeFailureType;
    (function(PullRequestMergeFailureType2) {
      PullRequestMergeFailureType2[PullRequestMergeFailureType2["None"] = 0] = "None";
      PullRequestMergeFailureType2[PullRequestMergeFailureType2["Unknown"] = 1] = "Unknown";
      PullRequestMergeFailureType2[PullRequestMergeFailureType2["CaseSensitive"] = 2] = "CaseSensitive";
      PullRequestMergeFailureType2[PullRequestMergeFailureType2["ObjectTooLarge"] = 3] = "ObjectTooLarge";
    })(PullRequestMergeFailureType = exports2.PullRequestMergeFailureType || (exports2.PullRequestMergeFailureType = {}));
    var PullRequestStatus;
    (function(PullRequestStatus2) {
      PullRequestStatus2[PullRequestStatus2["NotSet"] = 0] = "NotSet";
      PullRequestStatus2[PullRequestStatus2["Active"] = 1] = "Active";
      PullRequestStatus2[PullRequestStatus2["Abandoned"] = 2] = "Abandoned";
      PullRequestStatus2[PullRequestStatus2["Completed"] = 3] = "Completed";
      PullRequestStatus2[PullRequestStatus2["All"] = 4] = "All";
    })(PullRequestStatus = exports2.PullRequestStatus || (exports2.PullRequestStatus = {}));
    var PullRequestTimeRangeType;
    (function(PullRequestTimeRangeType2) {
      PullRequestTimeRangeType2[PullRequestTimeRangeType2["Created"] = 1] = "Created";
      PullRequestTimeRangeType2[PullRequestTimeRangeType2["Closed"] = 2] = "Closed";
    })(PullRequestTimeRangeType = exports2.PullRequestTimeRangeType || (exports2.PullRequestTimeRangeType = {}));
    var RefFavoriteType;
    (function(RefFavoriteType2) {
      RefFavoriteType2[RefFavoriteType2["Invalid"] = 0] = "Invalid";
      RefFavoriteType2[RefFavoriteType2["Folder"] = 1] = "Folder";
      RefFavoriteType2[RefFavoriteType2["Ref"] = 2] = "Ref";
    })(RefFavoriteType = exports2.RefFavoriteType || (exports2.RefFavoriteType = {}));
    var SupportedIdeType;
    (function(SupportedIdeType2) {
      SupportedIdeType2[SupportedIdeType2["Unknown"] = 0] = "Unknown";
      SupportedIdeType2[SupportedIdeType2["AndroidStudio"] = 1] = "AndroidStudio";
      SupportedIdeType2[SupportedIdeType2["AppCode"] = 2] = "AppCode";
      SupportedIdeType2[SupportedIdeType2["CLion"] = 3] = "CLion";
      SupportedIdeType2[SupportedIdeType2["DataGrip"] = 4] = "DataGrip";
      SupportedIdeType2[SupportedIdeType2["Eclipse"] = 13] = "Eclipse";
      SupportedIdeType2[SupportedIdeType2["IntelliJ"] = 5] = "IntelliJ";
      SupportedIdeType2[SupportedIdeType2["MPS"] = 6] = "MPS";
      SupportedIdeType2[SupportedIdeType2["PhpStorm"] = 7] = "PhpStorm";
      SupportedIdeType2[SupportedIdeType2["PyCharm"] = 8] = "PyCharm";
      SupportedIdeType2[SupportedIdeType2["RubyMine"] = 9] = "RubyMine";
      SupportedIdeType2[SupportedIdeType2["Tower"] = 10] = "Tower";
      SupportedIdeType2[SupportedIdeType2["VisualStudio"] = 11] = "VisualStudio";
      SupportedIdeType2[SupportedIdeType2["VSCode"] = 14] = "VSCode";
      SupportedIdeType2[SupportedIdeType2["WebStorm"] = 12] = "WebStorm";
    })(SupportedIdeType = exports2.SupportedIdeType || (exports2.SupportedIdeType = {}));
    var TfvcVersionOption;
    (function(TfvcVersionOption2) {
      TfvcVersionOption2[TfvcVersionOption2["None"] = 0] = "None";
      TfvcVersionOption2[TfvcVersionOption2["Previous"] = 1] = "Previous";
      TfvcVersionOption2[TfvcVersionOption2["UseRename"] = 2] = "UseRename";
    })(TfvcVersionOption = exports2.TfvcVersionOption || (exports2.TfvcVersionOption = {}));
    var TfvcVersionType;
    (function(TfvcVersionType2) {
      TfvcVersionType2[TfvcVersionType2["None"] = 0] = "None";
      TfvcVersionType2[TfvcVersionType2["Changeset"] = 1] = "Changeset";
      TfvcVersionType2[TfvcVersionType2["Shelveset"] = 2] = "Shelveset";
      TfvcVersionType2[TfvcVersionType2["Change"] = 3] = "Change";
      TfvcVersionType2[TfvcVersionType2["Date"] = 4] = "Date";
      TfvcVersionType2[TfvcVersionType2["Latest"] = 5] = "Latest";
      TfvcVersionType2[TfvcVersionType2["Tip"] = 6] = "Tip";
      TfvcVersionType2[TfvcVersionType2["MergeSource"] = 7] = "MergeSource";
    })(TfvcVersionType = exports2.TfvcVersionType || (exports2.TfvcVersionType = {}));
    var VersionControlChangeType;
    (function(VersionControlChangeType2) {
      VersionControlChangeType2[VersionControlChangeType2["None"] = 0] = "None";
      VersionControlChangeType2[VersionControlChangeType2["Add"] = 1] = "Add";
      VersionControlChangeType2[VersionControlChangeType2["Edit"] = 2] = "Edit";
      VersionControlChangeType2[VersionControlChangeType2["Encoding"] = 4] = "Encoding";
      VersionControlChangeType2[VersionControlChangeType2["Rename"] = 8] = "Rename";
      VersionControlChangeType2[VersionControlChangeType2["Delete"] = 16] = "Delete";
      VersionControlChangeType2[VersionControlChangeType2["Undelete"] = 32] = "Undelete";
      VersionControlChangeType2[VersionControlChangeType2["Branch"] = 64] = "Branch";
      VersionControlChangeType2[VersionControlChangeType2["Merge"] = 128] = "Merge";
      VersionControlChangeType2[VersionControlChangeType2["Lock"] = 256] = "Lock";
      VersionControlChangeType2[VersionControlChangeType2["Rollback"] = 512] = "Rollback";
      VersionControlChangeType2[VersionControlChangeType2["SourceRename"] = 1024] = "SourceRename";
      VersionControlChangeType2[VersionControlChangeType2["TargetRename"] = 2048] = "TargetRename";
      VersionControlChangeType2[VersionControlChangeType2["Property"] = 4096] = "Property";
      VersionControlChangeType2[VersionControlChangeType2["All"] = 8191] = "All";
    })(VersionControlChangeType = exports2.VersionControlChangeType || (exports2.VersionControlChangeType = {}));
    var VersionControlRecursionType;
    (function(VersionControlRecursionType2) {
      VersionControlRecursionType2[VersionControlRecursionType2["None"] = 0] = "None";
      VersionControlRecursionType2[VersionControlRecursionType2["OneLevel"] = 1] = "OneLevel";
      VersionControlRecursionType2[VersionControlRecursionType2["OneLevelPlusNestedEmptyFolders"] = 4] = "OneLevelPlusNestedEmptyFolders";
      VersionControlRecursionType2[VersionControlRecursionType2["Full"] = 120] = "Full";
    })(VersionControlRecursionType = exports2.VersionControlRecursionType || (exports2.VersionControlRecursionType = {}));
    exports2.TypeInfo = {
      AdvSecEnablementStatus: {},
      Attachment: {},
      BillableCommitterDetail: {},
      Change: {},
      ChangeList: {},
      Comment: {},
      CommentThread: {},
      CommentThreadStatus: {
        enumValues: {
          "unknown": 0,
          "active": 1,
          "fixed": 2,
          "wontFix": 3,
          "closed": 4,
          "byDesign": 5,
          "pending": 6
        }
      },
      CommentType: {
        enumValues: {
          "unknown": 0,
          "text": 1,
          "codeChange": 2,
          "system": 3
        }
      },
      FileDiff: {},
      GitAnnotatedTag: {},
      GitAsyncOperationStatus: {
        enumValues: {
          "queued": 1,
          "inProgress": 2,
          "completed": 3,
          "failed": 4,
          "abandoned": 5
        }
      },
      GitAsyncRefOperation: {},
      GitAsyncRefOperationDetail: {},
      GitAsyncRefOperationFailureStatus: {
        enumValues: {
          "none": 0,
          "invalidRefName": 1,
          "refNameConflict": 2,
          "createBranchPermissionRequired": 3,
          "writePermissionRequired": 4,
          "targetBranchDeleted": 5,
          "gitObjectTooLarge": 6,
          "operationIndentityNotFound": 7,
          "asyncOperationNotFound": 8,
          "other": 9,
          "emptyCommitterSignature": 10
        }
      },
      GitAsyncRefOperationParameters: {},
      GitAsyncRefOperationSource: {},
      GitBaseVersionDescriptor: {},
      GitBranchStats: {},
      GitChange: {},
      GitCherryPick: {},
      GitCommit: {},
      GitCommitChanges: {},
      GitCommitDiffs: {},
      GitCommitRef: {},
      GitCommitToCreate: {},
      GitConflict: {},
      GitConflictAddAdd: {},
      GitConflictAddRename: {},
      GitConflictDeleteEdit: {},
      GitConflictDeleteRename: {},
      GitConflictDirectoryFile: {},
      GitConflictEditDelete: {},
      GitConflictEditEdit: {},
      GitConflictFileDirectory: {},
      GitConflictRename1to2: {},
      GitConflictRename2to1: {},
      GitConflictRenameAdd: {},
      GitConflictRenameDelete: {},
      GitConflictRenameRename: {},
      GitConflictType: {
        enumValues: {
          "none": 0,
          "addAdd": 1,
          "addRename": 2,
          "deleteEdit": 3,
          "deleteRename": 4,
          "directoryFile": 5,
          "directoryChild": 6,
          "editDelete": 7,
          "editEdit": 8,
          "fileDirectory": 9,
          "rename1to2": 10,
          "rename2to1": 11,
          "renameAdd": 12,
          "renameDelete": 13,
          "renameRename": 14
        }
      },
      GitConflictUpdateResult: {},
      GitConflictUpdateStatus: {
        enumValues: {
          "succeeded": 0,
          "badRequest": 1,
          "invalidResolution": 2,
          "unsupportedConflictType": 3,
          "notFound": 4
        }
      },
      GitDeletedRepository: {},
      GitForkRef: {},
      GitForkSyncRequest: {},
      GitForkTeamProjectReference: {},
      GitHistoryMode: {
        enumValues: {
          "simplifiedHistory": 0,
          "firstParent": 1,
          "fullHistory": 2,
          "fullHistorySimplifyMerges": 3
        }
      },
      GitImportFailedEvent: {},
      GitImportRequest: {},
      GitImportSucceededEvent: {},
      GitItem: {},
      GitItemDescriptor: {},
      GitItemRequestData: {},
      GitLastChangeTreeItems: {},
      GitMerge: {},
      GitObject: {},
      GitObjectType: {
        enumValues: {
          "bad": 0,
          "commit": 1,
          "tree": 2,
          "blob": 3,
          "tag": 4,
          "ext2": 5,
          "ofsDelta": 6,
          "refDelta": 7
        }
      },
      GitPathAction: {},
      GitPathActions: {
        enumValues: {
          "none": 0,
          "edit": 1,
          "delete": 2,
          "add": 3,
          "rename": 4
        }
      },
      GitPathToItemsCollection: {},
      GitPolicyConfigurationResponse: {},
      GitPullRequest: {},
      GitPullRequestChange: {},
      GitPullRequestCommentThread: {},
      GitPullRequestCompletionOptions: {},
      GitPullRequestIteration: {},
      GitPullRequestIterationChanges: {},
      GitPullRequestMergeStrategy: {
        enumValues: {
          "noFastForward": 1,
          "squash": 2,
          "rebase": 3,
          "rebaseMerge": 4
        }
      },
      GitPullRequestQuery: {},
      GitPullRequestQueryInput: {},
      GitPullRequestQueryType: {
        enumValues: {
          "notSet": 0,
          "lastMergeCommit": 1,
          "commit": 2
        }
      },
      GitPullRequestReviewFileType: {
        enumValues: {
          "changeEntry": 0,
          "attachment": 1
        }
      },
      GitPullRequestSearchCriteria: {},
      GitPullRequestStatus: {},
      GitPush: {},
      GitPushEventData: {},
      GitPushRef: {},
      GitPushSearchCriteria: {},
      GitQueryBranchStatsCriteria: {},
      GitQueryCommitsCriteria: {},
      GitQueryRefsCriteria: {},
      GitRef: {},
      GitRefFavorite: {},
      GitRefSearchType: {
        enumValues: {
          "exact": 0,
          "startsWith": 1,
          "contains": 2
        }
      },
      GitRefUpdateMode: {
        enumValues: {
          "bestEffort": 0,
          "allOrNone": 1
        }
      },
      GitRefUpdateResult: {},
      GitRefUpdateStatus: {
        enumValues: {
          "succeeded": 0,
          "forcePushRequired": 1,
          "staleOldObjectId": 2,
          "invalidRefName": 3,
          "unprocessed": 4,
          "unresolvableToCommit": 5,
          "writePermissionRequired": 6,
          "manageNotePermissionRequired": 7,
          "createBranchPermissionRequired": 8,
          "createTagPermissionRequired": 9,
          "rejectedByPlugin": 10,
          "locked": 11,
          "refNameConflict": 12,
          "rejectedByPolicy": 13,
          "succeededNonExistentRef": 14,
          "succeededCorruptRef": 15
        }
      },
      GitRepository: {},
      GitRepositoryCreateOptions: {},
      GitRepositoryRef: {},
      GitResolutionError: {
        enumValues: {
          "none": 0,
          "mergeContentNotFound": 1,
          "pathInUse": 2,
          "invalidPath": 3,
          "unknownAction": 4,
          "unknownMergeType": 5,
          "otherError": 255
        }
      },
      GitResolutionMergeContent: {},
      GitResolutionMergeType: {
        enumValues: {
          "undecided": 0,
          "takeSourceContent": 1,
          "takeTargetContent": 2,
          "autoMerged": 3,
          "userMerged": 4
        }
      },
      GitResolutionPathConflict: {},
      GitResolutionPathConflictAction: {
        enumValues: {
          "undecided": 0,
          "keepSourceRenameTarget": 1,
          "keepSourceDeleteTarget": 2,
          "keepTargetRenameSource": 3,
          "keepTargetDeleteSource": 4
        }
      },
      GitResolutionPickOneAction: {},
      GitResolutionRename1to2: {},
      GitResolutionRename1to2Action: {
        enumValues: {
          "undecided": 0,
          "keepSourcePath": 1,
          "keepTargetPath": 2,
          "keepBothFiles": 3
        }
      },
      GitResolutionStatus: {
        enumValues: {
          "unresolved": 0,
          "partiallyResolved": 1,
          "resolved": 2
        }
      },
      GitResolutionWhichAction: {
        enumValues: {
          "undecided": 0,
          "pickSourceAction": 1,
          "pickTargetAction": 2
        }
      },
      GitRevert: {},
      GitStatus: {},
      GitStatusState: {
        enumValues: {
          "notSet": 0,
          "pending": 1,
          "succeeded": 2,
          "failed": 3,
          "error": 4,
          "notApplicable": 5,
          "partiallySucceeded": 6
        }
      },
      GitTargetVersionDescriptor: {},
      GitTreeDiff: {},
      GitTreeDiffEntry: {},
      GitTreeDiffResponse: {},
      GitTreeEntryRef: {},
      GitTreeRef: {},
      GitUserDate: {},
      GitVersionDescriptor: {},
      GitVersionOptions: {
        enumValues: {
          "none": 0,
          "previousChange": 1,
          "firstParent": 2
        }
      },
      GitVersionType: {
        enumValues: {
          "branch": 0,
          "tag": 1,
          "commit": 2
        }
      },
      HistoryEntry: {},
      IncludedGitCommit: {},
      ItemContent: {},
      ItemContentType: {
        enumValues: {
          "rawText": 0,
          "base64Encoded": 1
        }
      },
      ItemDetailsOptions: {},
      IterationReason: {
        enumValues: {
          "push": 0,
          "forcePush": 1,
          "create": 2,
          "rebase": 4,
          "unknown": 8,
          "retarget": 16,
          "resolveConflicts": 32
        }
      },
      LineDiffBlock: {},
      LineDiffBlockChangeType: {
        enumValues: {
          "none": 0,
          "add": 1,
          "delete": 2,
          "edit": 3
        }
      },
      PullRequestAsyncStatus: {
        enumValues: {
          "notSet": 0,
          "queued": 1,
          "conflicts": 2,
          "succeeded": 3,
          "rejectedByPolicy": 4,
          "failure": 5
        }
      },
      PullRequestMergeFailureType: {
        enumValues: {
          "none": 0,
          "unknown": 1,
          "caseSensitive": 2,
          "objectTooLarge": 3
        }
      },
      PullRequestStatus: {
        enumValues: {
          "notSet": 0,
          "active": 1,
          "abandoned": 2,
          "completed": 3,
          "all": 4
        }
      },
      PullRequestTimeRangeType: {
        enumValues: {
          "created": 1,
          "closed": 2
        }
      },
      RefFavoriteType: {
        enumValues: {
          "invalid": 0,
          "folder": 1,
          "ref": 2
        }
      },
      SupportedIde: {},
      SupportedIdeType: {
        enumValues: {
          "unknown": 0,
          "androidStudio": 1,
          "appCode": 2,
          "cLion": 3,
          "dataGrip": 4,
          "eclipse": 13,
          "intelliJ": 5,
          "mps": 6,
          "phpStorm": 7,
          "pyCharm": 8,
          "rubyMine": 9,
          "tower": 10,
          "visualStudio": 11,
          "vsCode": 14,
          "webStorm": 12
        }
      },
      TfvcBranch: {},
      TfvcBranchRef: {},
      TfvcChange: {},
      TfvcChangeset: {},
      TfvcChangesetRef: {},
      TfvcCheckinEventData: {},
      TfvcHistoryEntry: {},
      TfvcItem: {},
      TfvcItemDescriptor: {},
      TfvcItemPreviousHash: {},
      TfvcItemRequestData: {},
      TfvcLabel: {},
      TfvcLabelRef: {},
      TfvcShelveset: {},
      TfvcShelvesetRef: {},
      TfvcVersionDescriptor: {},
      TfvcVersionOption: {
        enumValues: {
          "none": 0,
          "previous": 1,
          "useRename": 2
        }
      },
      TfvcVersionType: {
        enumValues: {
          "none": 0,
          "changeset": 1,
          "shelveset": 2,
          "change": 3,
          "date": 4,
          "latest": 5,
          "tip": 6,
          "mergeSource": 7
        }
      },
      UpdateRefsRequest: {},
      VersionControlChangeType: {
        enumValues: {
          "none": 0,
          "add": 1,
          "edit": 2,
          "encoding": 4,
          "rename": 8,
          "delete": 16,
          "undelete": 32,
          "branch": 64,
          "merge": 128,
          "lock": 256,
          "rollback": 512,
          "sourceRename": 1024,
          "targetRename": 2048,
          "property": 4096,
          "all": 8191
        }
      },
      VersionControlProjectInfo: {},
      VersionControlRecursionType: {
        enumValues: {
          "none": 0,
          "oneLevel": 1,
          "oneLevelPlusNestedEmptyFolders": 4,
          "full": 120
        }
      }
    };
    exports2.TypeInfo.AdvSecEnablementStatus.fields = {
      changedOnDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.Attachment.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.BillableCommitterDetail.fields = {
      commitTime: {
        isDate: true
      },
      pushedTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.Change.fields = {
      changeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      },
      newContent: {
        typeInfo: exports2.TypeInfo.ItemContent
      }
    };
    exports2.TypeInfo.ChangeList.fields = {
      changeCounts: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.VersionControlChangeType
      },
      creationDate: {
        isDate: true
      },
      sortDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.Comment.fields = {
      commentType: {
        enumType: exports2.TypeInfo.CommentType
      },
      lastContentUpdatedDate: {
        isDate: true
      },
      lastUpdatedDate: {
        isDate: true
      },
      publishedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.CommentThread.fields = {
      comments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Comment
      },
      lastUpdatedDate: {
        isDate: true
      },
      publishedDate: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.CommentThreadStatus
      }
    };
    exports2.TypeInfo.FileDiff.fields = {
      lineDiffBlocks: {
        isArray: true,
        typeInfo: exports2.TypeInfo.LineDiffBlock
      }
    };
    exports2.TypeInfo.GitAnnotatedTag.fields = {
      taggedBy: {
        typeInfo: exports2.TypeInfo.GitUserDate
      },
      taggedObject: {
        typeInfo: exports2.TypeInfo.GitObject
      }
    };
    exports2.TypeInfo.GitAsyncRefOperation.fields = {
      detailedStatus: {
        typeInfo: exports2.TypeInfo.GitAsyncRefOperationDetail
      },
      parameters: {
        typeInfo: exports2.TypeInfo.GitAsyncRefOperationParameters
      },
      status: {
        enumType: exports2.TypeInfo.GitAsyncOperationStatus
      }
    };
    exports2.TypeInfo.GitAsyncRefOperationDetail.fields = {
      status: {
        enumType: exports2.TypeInfo.GitAsyncRefOperationFailureStatus
      }
    };
    exports2.TypeInfo.GitAsyncRefOperationParameters.fields = {
      repository: {
        typeInfo: exports2.TypeInfo.GitRepository
      },
      source: {
        typeInfo: exports2.TypeInfo.GitAsyncRefOperationSource
      }
    };
    exports2.TypeInfo.GitAsyncRefOperationSource.fields = {
      commitList: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitCommitRef
      }
    };
    exports2.TypeInfo.GitBaseVersionDescriptor.fields = {
      baseVersionOptions: {
        enumType: exports2.TypeInfo.GitVersionOptions
      },
      baseVersionType: {
        enumType: exports2.TypeInfo.GitVersionType
      },
      versionOptions: {
        enumType: exports2.TypeInfo.GitVersionOptions
      },
      versionType: {
        enumType: exports2.TypeInfo.GitVersionType
      }
    };
    exports2.TypeInfo.GitBranchStats.fields = {
      commit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      }
    };
    exports2.TypeInfo.GitChange.fields = {
      changeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      },
      newContent: {
        typeInfo: exports2.TypeInfo.ItemContent
      }
    };
    exports2.TypeInfo.GitCherryPick.fields = {
      detailedStatus: {
        typeInfo: exports2.TypeInfo.GitAsyncRefOperationDetail
      },
      parameters: {
        typeInfo: exports2.TypeInfo.GitAsyncRefOperationParameters
      },
      status: {
        enumType: exports2.TypeInfo.GitAsyncOperationStatus
      }
    };
    exports2.TypeInfo.GitCommit.fields = {
      author: {
        typeInfo: exports2.TypeInfo.GitUserDate
      },
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitChange
      },
      committer: {
        typeInfo: exports2.TypeInfo.GitUserDate
      },
      push: {
        typeInfo: exports2.TypeInfo.GitPushRef
      },
      statuses: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitStatus
      }
    };
    exports2.TypeInfo.GitCommitChanges.fields = {
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitChange
      }
    };
    exports2.TypeInfo.GitCommitDiffs.fields = {
      changeCounts: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.VersionControlChangeType
      },
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitChange
      }
    };
    exports2.TypeInfo.GitCommitRef.fields = {
      author: {
        typeInfo: exports2.TypeInfo.GitUserDate
      },
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitChange
      },
      committer: {
        typeInfo: exports2.TypeInfo.GitUserDate
      },
      push: {
        typeInfo: exports2.TypeInfo.GitPushRef
      },
      statuses: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitStatus
      }
    };
    exports2.TypeInfo.GitCommitToCreate.fields = {
      baseRef: {
        typeInfo: exports2.TypeInfo.GitRef
      },
      pathActions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitPathAction
      }
    };
    exports2.TypeInfo.GitConflict.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictAddAdd.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionMergeContent
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictAddRename.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPathConflict
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictDeleteEdit.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPickOneAction
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictDeleteRename.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPickOneAction
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictDirectoryFile.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPathConflict
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      },
      sourceTree: {
        typeInfo: exports2.TypeInfo.GitTreeRef
      }
    };
    exports2.TypeInfo.GitConflictEditDelete.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPickOneAction
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictEditEdit.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionMergeContent
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictFileDirectory.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPathConflict
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      },
      targetTree: {
        typeInfo: exports2.TypeInfo.GitTreeRef
      }
    };
    exports2.TypeInfo.GitConflictRename1to2.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionRename1to2
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictRename2to1.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPathConflict
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictRenameAdd.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPathConflict
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictRenameDelete.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionPickOneAction
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictRenameRename.fields = {
      conflictType: {
        enumType: exports2.TypeInfo.GitConflictType
      },
      mergeBaseCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      resolution: {
        typeInfo: exports2.TypeInfo.GitResolutionMergeContent
      },
      resolutionError: {
        enumType: exports2.TypeInfo.GitResolutionError
      },
      resolutionStatus: {
        enumType: exports2.TypeInfo.GitResolutionStatus
      },
      resolvedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitConflictUpdateResult.fields = {
      updatedConflict: {
        typeInfo: exports2.TypeInfo.GitConflict
      },
      updateStatus: {
        enumType: exports2.TypeInfo.GitConflictUpdateStatus
      }
    };
    exports2.TypeInfo.GitDeletedRepository.fields = {
      createdDate: {
        isDate: true
      },
      deletedDate: {
        isDate: true
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.GitForkRef.fields = {
      repository: {
        typeInfo: exports2.TypeInfo.GitRepository
      },
      statuses: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitStatus
      }
    };
    exports2.TypeInfo.GitForkSyncRequest.fields = {
      status: {
        enumType: exports2.TypeInfo.GitAsyncOperationStatus
      }
    };
    exports2.TypeInfo.GitForkTeamProjectReference.fields = {
      lastUpdateTime: {
        isDate: true
      },
      visibility: {
        enumType: TfsCoreInterfaces.TypeInfo.ProjectVisibility
      }
    };
    exports2.TypeInfo.GitImportFailedEvent.fields = {
      targetRepository: {
        typeInfo: exports2.TypeInfo.GitRepository
      }
    };
    exports2.TypeInfo.GitImportRequest.fields = {
      repository: {
        typeInfo: exports2.TypeInfo.GitRepository
      },
      status: {
        enumType: exports2.TypeInfo.GitAsyncOperationStatus
      }
    };
    exports2.TypeInfo.GitImportSucceededEvent.fields = {
      targetRepository: {
        typeInfo: exports2.TypeInfo.GitRepository
      }
    };
    exports2.TypeInfo.GitItem.fields = {
      gitObjectType: {
        enumType: exports2.TypeInfo.GitObjectType
      },
      latestProcessedChange: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      }
    };
    exports2.TypeInfo.GitItemDescriptor.fields = {
      recursionLevel: {
        enumType: exports2.TypeInfo.VersionControlRecursionType
      },
      versionOptions: {
        enumType: exports2.TypeInfo.GitVersionOptions
      },
      versionType: {
        enumType: exports2.TypeInfo.GitVersionType
      }
    };
    exports2.TypeInfo.GitItemRequestData.fields = {
      itemDescriptors: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitItemDescriptor
      }
    };
    exports2.TypeInfo.GitLastChangeTreeItems.fields = {
      commits: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      lastExploredTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitMerge.fields = {
      status: {
        enumType: exports2.TypeInfo.GitAsyncOperationStatus
      }
    };
    exports2.TypeInfo.GitObject.fields = {
      objectType: {
        enumType: exports2.TypeInfo.GitObjectType
      }
    };
    exports2.TypeInfo.GitPathAction.fields = {
      action: {
        enumType: exports2.TypeInfo.GitPathActions
      }
    };
    exports2.TypeInfo.GitPathToItemsCollection.fields = {
      items: {
        isDictionary: true,
        dictionaryValueFieldInfo: {
          isArray: true,
          typeInfo: exports2.TypeInfo.GitItem
        }
      }
    };
    exports2.TypeInfo.GitPolicyConfigurationResponse.fields = {
      policyConfigurations: {
        isArray: true,
        typeInfo: PolicyInterfaces.TypeInfo.PolicyConfiguration
      }
    };
    exports2.TypeInfo.GitPullRequest.fields = {
      closedDate: {
        isDate: true
      },
      commits: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      completionOptions: {
        typeInfo: exports2.TypeInfo.GitPullRequestCompletionOptions
      },
      completionQueueTime: {
        isDate: true
      },
      creationDate: {
        isDate: true
      },
      forkSource: {
        typeInfo: exports2.TypeInfo.GitForkRef
      },
      lastMergeCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      lastMergeSourceCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      lastMergeTargetCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      mergeFailureType: {
        enumType: exports2.TypeInfo.PullRequestMergeFailureType
      },
      mergeStatus: {
        enumType: exports2.TypeInfo.PullRequestAsyncStatus
      },
      repository: {
        typeInfo: exports2.TypeInfo.GitRepository
      },
      status: {
        enumType: exports2.TypeInfo.PullRequestStatus
      }
    };
    exports2.TypeInfo.GitPullRequestChange.fields = {
      changeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      },
      newContent: {
        typeInfo: exports2.TypeInfo.ItemContent
      }
    };
    exports2.TypeInfo.GitPullRequestCommentThread.fields = {
      comments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Comment
      },
      lastUpdatedDate: {
        isDate: true
      },
      publishedDate: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.CommentThreadStatus
      }
    };
    exports2.TypeInfo.GitPullRequestCompletionOptions.fields = {
      mergeStrategy: {
        enumType: exports2.TypeInfo.GitPullRequestMergeStrategy
      }
    };
    exports2.TypeInfo.GitPullRequestIteration.fields = {
      changeList: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitPullRequestChange
      },
      commits: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      commonRefCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      createdDate: {
        isDate: true
      },
      push: {
        typeInfo: exports2.TypeInfo.GitPushRef
      },
      reason: {
        enumType: exports2.TypeInfo.IterationReason
      },
      sourceRefCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      targetRefCommit: {
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitPullRequestIterationChanges.fields = {
      changeEntries: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitPullRequestChange
      }
    };
    exports2.TypeInfo.GitPullRequestQuery.fields = {
      queries: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitPullRequestQueryInput
      }
    };
    exports2.TypeInfo.GitPullRequestQueryInput.fields = {
      type: {
        enumType: exports2.TypeInfo.GitPullRequestQueryType
      }
    };
    exports2.TypeInfo.GitPullRequestSearchCriteria.fields = {
      maxTime: {
        isDate: true
      },
      minTime: {
        isDate: true
      },
      queryTimeRangeType: {
        enumType: exports2.TypeInfo.PullRequestTimeRangeType
      },
      status: {
        enumType: exports2.TypeInfo.PullRequestStatus
      }
    };
    exports2.TypeInfo.GitPullRequestStatus.fields = {
      creationDate: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.GitStatusState
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitPush.fields = {
      commits: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitCommitRef
      },
      date: {
        isDate: true
      },
      repository: {
        typeInfo: exports2.TypeInfo.GitRepository
      }
    };
    exports2.TypeInfo.GitPushEventData.fields = {
      commits: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitCommit
      },
      repository: {
        typeInfo: exports2.TypeInfo.GitRepository
      }
    };
    exports2.TypeInfo.GitPushRef.fields = {
      date: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitPushSearchCriteria.fields = {
      fromDate: {
        isDate: true
      },
      toDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitQueryBranchStatsCriteria.fields = {
      baseCommit: {
        typeInfo: exports2.TypeInfo.GitVersionDescriptor
      },
      targetCommits: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitVersionDescriptor
      }
    };
    exports2.TypeInfo.GitQueryCommitsCriteria.fields = {
      compareVersion: {
        typeInfo: exports2.TypeInfo.GitVersionDescriptor
      },
      historyMode: {
        enumType: exports2.TypeInfo.GitHistoryMode
      },
      itemVersion: {
        typeInfo: exports2.TypeInfo.GitVersionDescriptor
      }
    };
    exports2.TypeInfo.GitQueryRefsCriteria.fields = {
      searchType: {
        enumType: exports2.TypeInfo.GitRefSearchType
      }
    };
    exports2.TypeInfo.GitRef.fields = {
      statuses: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitStatus
      }
    };
    exports2.TypeInfo.GitRefFavorite.fields = {
      type: {
        enumType: exports2.TypeInfo.RefFavoriteType
      }
    };
    exports2.TypeInfo.GitRefUpdateResult.fields = {
      updateStatus: {
        enumType: exports2.TypeInfo.GitRefUpdateStatus
      }
    };
    exports2.TypeInfo.GitRepository.fields = {
      parentRepository: {
        typeInfo: exports2.TypeInfo.GitRepositoryRef
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.GitRepositoryCreateOptions.fields = {
      parentRepository: {
        typeInfo: exports2.TypeInfo.GitRepositoryRef
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.GitRepositoryRef.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.GitResolutionMergeContent.fields = {
      mergeType: {
        enumType: exports2.TypeInfo.GitResolutionMergeType
      }
    };
    exports2.TypeInfo.GitResolutionPathConflict.fields = {
      action: {
        enumType: exports2.TypeInfo.GitResolutionPathConflictAction
      }
    };
    exports2.TypeInfo.GitResolutionPickOneAction.fields = {
      action: {
        enumType: exports2.TypeInfo.GitResolutionWhichAction
      }
    };
    exports2.TypeInfo.GitResolutionRename1to2.fields = {
      action: {
        enumType: exports2.TypeInfo.GitResolutionRename1to2Action
      },
      mergeType: {
        enumType: exports2.TypeInfo.GitResolutionMergeType
      }
    };
    exports2.TypeInfo.GitRevert.fields = {
      detailedStatus: {
        typeInfo: exports2.TypeInfo.GitAsyncRefOperationDetail
      },
      parameters: {
        typeInfo: exports2.TypeInfo.GitAsyncRefOperationParameters
      },
      status: {
        enumType: exports2.TypeInfo.GitAsyncOperationStatus
      }
    };
    exports2.TypeInfo.GitStatus.fields = {
      creationDate: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.GitStatusState
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitTargetVersionDescriptor.fields = {
      targetVersionOptions: {
        enumType: exports2.TypeInfo.GitVersionOptions
      },
      targetVersionType: {
        enumType: exports2.TypeInfo.GitVersionType
      },
      versionOptions: {
        enumType: exports2.TypeInfo.GitVersionOptions
      },
      versionType: {
        enumType: exports2.TypeInfo.GitVersionType
      }
    };
    exports2.TypeInfo.GitTreeDiff.fields = {
      diffEntries: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitTreeDiffEntry
      }
    };
    exports2.TypeInfo.GitTreeDiffEntry.fields = {
      changeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      },
      objectType: {
        enumType: exports2.TypeInfo.GitObjectType
      }
    };
    exports2.TypeInfo.GitTreeDiffResponse.fields = {
      treeDiff: {
        typeInfo: exports2.TypeInfo.GitTreeDiff
      }
    };
    exports2.TypeInfo.GitTreeEntryRef.fields = {
      gitObjectType: {
        enumType: exports2.TypeInfo.GitObjectType
      }
    };
    exports2.TypeInfo.GitTreeRef.fields = {
      treeEntries: {
        isArray: true,
        typeInfo: exports2.TypeInfo.GitTreeEntryRef
      }
    };
    exports2.TypeInfo.GitUserDate.fields = {
      date: {
        isDate: true
      }
    };
    exports2.TypeInfo.GitVersionDescriptor.fields = {
      versionOptions: {
        enumType: exports2.TypeInfo.GitVersionOptions
      },
      versionType: {
        enumType: exports2.TypeInfo.GitVersionType
      }
    };
    exports2.TypeInfo.HistoryEntry.fields = {
      itemChangeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      }
    };
    exports2.TypeInfo.IncludedGitCommit.fields = {
      commitTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.ItemContent.fields = {
      contentType: {
        enumType: exports2.TypeInfo.ItemContentType
      }
    };
    exports2.TypeInfo.ItemDetailsOptions.fields = {
      recursionLevel: {
        enumType: exports2.TypeInfo.VersionControlRecursionType
      }
    };
    exports2.TypeInfo.LineDiffBlock.fields = {
      changeType: {
        enumType: exports2.TypeInfo.LineDiffBlockChangeType
      }
    };
    exports2.TypeInfo.SupportedIde.fields = {
      ideType: {
        enumType: exports2.TypeInfo.SupportedIdeType
      }
    };
    exports2.TypeInfo.TfvcBranch.fields = {
      children: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcBranch
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcBranchRef.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcChange.fields = {
      changeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      },
      newContent: {
        typeInfo: exports2.TypeInfo.ItemContent
      }
    };
    exports2.TypeInfo.TfvcChangeset.fields = {
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcChange
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcChangesetRef.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcCheckinEventData.fields = {
      changeset: {
        typeInfo: exports2.TypeInfo.TfvcChangeset
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.TfvcHistoryEntry.fields = {
      itemChangeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      }
    };
    exports2.TypeInfo.TfvcItem.fields = {
      changeDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcItemDescriptor.fields = {
      recursionLevel: {
        enumType: exports2.TypeInfo.VersionControlRecursionType
      },
      versionOption: {
        enumType: exports2.TypeInfo.TfvcVersionOption
      },
      versionType: {
        enumType: exports2.TypeInfo.TfvcVersionType
      }
    };
    exports2.TypeInfo.TfvcItemPreviousHash.fields = {
      changeDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcItemRequestData.fields = {
      itemDescriptors: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcItemDescriptor
      }
    };
    exports2.TypeInfo.TfvcLabel.fields = {
      items: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcItem
      },
      modifiedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcLabelRef.fields = {
      modifiedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcShelveset.fields = {
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcChange
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcShelvesetRef.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcVersionDescriptor.fields = {
      versionOption: {
        enumType: exports2.TypeInfo.TfvcVersionOption
      },
      versionType: {
        enumType: exports2.TypeInfo.TfvcVersionType
      }
    };
    exports2.TypeInfo.UpdateRefsRequest.fields = {
      updateMode: {
        enumType: exports2.TypeInfo.GitRefUpdateMode
      }
    };
    exports2.TypeInfo.VersionControlProjectInfo.fields = {
      defaultSourceControlType: {
        enumType: TfsCoreInterfaces.TypeInfo.SourceControlTypes
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
  }
});

// ../common/output.ts
var output_exports = {};
__export(output_exports, {
  COMMIT_EMAIL: () => COMMIT_EMAIL,
  COMMIT_USER: () => COMMIT_USER,
  FAILURE_LEVEL: () => FAILURE_LEVEL,
  NOTICE_LEVEL: () => NOTICE_LEVEL,
  QODANA_CHECK_NAME: () => QODANA_CHECK_NAME,
  WARNING_LEVEL: () => WARNING_LEVEL,
  getCoverageStats: () => getCoverageStats,
  getDepencencyPlural: () => getDepencencyPlural,
  getLicenseInfo: () => getLicenseInfo,
  getProblemPlural: () => getProblemPlural,
  getReportURL: () => getReportURL,
  getSummary: () => getSummary,
  parseResult: () => parseResult
});
function parseResult(result2, rules) {
  var _a;
  if (!result2.locations || result2.locations.length === 0 || !result2.locations[0].physicalLocation) {
    return null;
  }
  return {
    title: (_a = rules.get(result2.ruleId)) == null ? void 0 : _a.shortDescription,
    level: (() => {
      switch (result2.level) {
        case "error":
          return FAILURE_LEVEL;
        case "warning":
          return WARNING_LEVEL;
        default:
          return NOTICE_LEVEL;
      }
    })()
  };
}
function wrapToDiffBlock(message) {
  return `\`\`\`diff
${message}
\`\`\``;
}
function makeConclusion(conclusion, failedByThreshold) {
  if (failedByThreshold) {
    return `- ${conclusion}`;
  } else {
    return `+ ${conclusion}`;
  }
}
function getCoverageStats(c) {
  if (c.totalLines === 0 && c.totalCoveredLines === 0) {
    return "";
  }
  let stats = "";
  if (c.totalLines !== 0) {
    const conclusion = `${c.totalCoverage}% total lines covered`;
    stats += `${makeConclusion(conclusion, c.totalCoverage < c.totalCoverageThreshold)}
${c.totalLines} lines analyzed, ${c.totalCoveredLines} lines covered`;
  }
  if (c.freshLines !== 0) {
    const conclusion = `${c.freshCoverage}% fresh lines covered`;
    stats += `
${makeConclusion(conclusion, c.freshCoverage < c.freshCoverageThreshold)}
${c.freshLines} lines analyzed, ${c.freshCoveredLines} lines covered`;
  }
  return wrapToDiffBlock(
    [
      `@@ Code coverage @@`,
      `${stats}`,
      `# Calculated according to the filters of your coverage tool`
    ].join("\n")
  );
}
function getLicenseInfo(resultsDir) {
  let licensesInfo = "";
  let packages = 0;
  const licensesJson = `${resultsDir}/projectStructure/${QODANA_LICENSES_JSON}`;
  if (fs2.existsSync(licensesJson)) {
    const licenses = JSON.parse(
      fs2.readFileSync(licensesJson, { encoding: "utf8" })
    );
    if (licenses.length > 0) {
      packages = licenses.length;
      licensesInfo = fs2.readFileSync(
        `${resultsDir}/projectStructure/${QODANA_LICENSES_MD}`,
        { encoding: "utf8" }
      );
    }
  }
  return { licenses: licensesInfo, packages };
}
function getReportURL(resultsDir) {
  var _a;
  let reportUrlFile = `${resultsDir}/${QODANA_OPEN_IN_IDE_NAME}`;
  if (fs2.existsSync(reportUrlFile)) {
    const rawData = fs2.readFileSync(reportUrlFile, { encoding: "utf8" });
    const data = JSON.parse(rawData);
    if ((_a = data == null ? void 0 : data.cloud) == null ? void 0 : _a.url) {
      return data.cloud.url;
    }
  } else {
    reportUrlFile = `${resultsDir}/${QODANA_REPORT_URL_NAME}`;
    if (fs2.existsSync(reportUrlFile)) {
      return fs2.readFileSync(reportUrlFile, { encoding: "utf8" });
    }
  }
  return "";
}
function wrapToToggleBlock(header, body) {
  return `<details>
<summary>${header}</summary>

${body}
</details>`;
}
function getViewReportText(reportUrl, viewReportOptions) {
  if (reportUrl !== "") {
    return `\u2601\uFE0F [View the detailed Qodana report](${reportUrl})`;
  }
  return wrapToToggleBlock(
    "View the detailed Qodana report",
    viewReportOptions
  );
}
function getRowsByLevel(annotations, level) {
  const problems = annotations.reduce(
    (map2, e) => map2.set(
      e.title ?? UNKNOWN_RULE_ID,
      map2.get(e.title ?? UNKNOWN_RULE_ID) !== void 0 ? map2.get(e.title ?? UNKNOWN_RULE_ID) + 1 : 1
    ),
    /* @__PURE__ */ new Map()
  );
  return Array.from(problems.entries()).sort((a, b) => b[1] - a[1]).map(([title, count]) => `| \`${title}\` | ${level} | ${count} |`).join("\n");
}
function getSummary(toolName, projectDir, sourceDir, problemsDescriptors, coverageInfo, packages, licensesInfo, reportUrl, prMode, dependencyCharsLimit, reportViewOptionsHelp) {
  const contactBlock = wrapToToggleBlock("Contact Qodana team", SUMMARY_MISC);
  let licensesBlock = "";
  if (licensesInfo !== "" && licensesInfo.length < dependencyCharsLimit) {
    licensesBlock = wrapToToggleBlock(
      `Detected ${packages} ${getDepencencyPlural(packages)}`,
      licensesInfo
    );
  }
  let prModeBlock = "";
  if (prMode) {
    prModeBlock = SUMMARY_PR_MODE;
  }
  if (reportUrl !== "") {
    const firstToolName = toolName.split(" ")[0];
    toolName = toolName.replace(
      firstToolName,
      `[${firstToolName}](${reportUrl})`
    );
  }
  const analysisScope = (projectDir === "" ? "" : ["Analyzed project: `", projectDir, "/`\n"].join("")).concat(
    sourceDir === "" ? "" : ["Analyzed directory: `", sourceDir, "/`\n"].join("")
  );
  if (problemsDescriptors.length === 0) {
    return [
      `# ${toolName}`,
      analysisScope,
      "**It seems all right \u{1F44C}**",
      "",
      "No new problems were found according to the checks applied",
      coverageInfo,
      prModeBlock,
      getViewReportText(reportUrl, reportViewOptionsHelp),
      licensesBlock,
      contactBlock
    ].join("\n");
  }
  return [
    `# ${toolName}`,
    analysisScope,
    `**${problemsDescriptors.length} ${getProblemPlural(
      problemsDescriptors.length
    )}** were found`,
    "",
    SUMMARY_TABLE_HEADER,
    SUMMARY_TABLE_SEP,
    [
      getRowsByLevel(
        problemsDescriptors.filter((a) => a.level === FAILURE_LEVEL),
        "\u{1F534} Failure"
      ),
      getRowsByLevel(
        problemsDescriptors.filter((a) => a.level === WARNING_LEVEL),
        "\u{1F536} Warning"
      ),
      getRowsByLevel(
        problemsDescriptors.filter((a) => a.level === NOTICE_LEVEL),
        "\u25FD\uFE0F Notice"
      )
    ].filter((e) => e !== "").join("\n"),
    "",
    coverageInfo,
    prModeBlock,
    getViewReportText(reportUrl, reportViewOptionsHelp),
    licensesBlock,
    contactBlock
  ].join("\n");
}
function getProblemPlural(count) {
  return `new problem${count !== 1 ? "s" : ""}`;
}
function getDepencencyPlural(count) {
  return `dependenc${count !== 1 ? "ies" : "y"}`;
}
var fs2, COMMIT_USER, COMMIT_EMAIL, QODANA_CHECK_NAME, UNKNOWN_RULE_ID, SUMMARY_TABLE_HEADER, SUMMARY_TABLE_SEP, SUMMARY_MISC, SUMMARY_PR_MODE, FAILURE_LEVEL, WARNING_LEVEL, NOTICE_LEVEL;
var init_output = __esm({
  "../common/output.ts"() {
    "use strict";
    init_qodana();
    fs2 = __toESM(require("fs"));
    COMMIT_USER = "qodana-bot";
    COMMIT_EMAIL = "qodana-support@jetbrains.com";
    QODANA_CHECK_NAME = "Qodana";
    UNKNOWN_RULE_ID = "Unknown";
    SUMMARY_TABLE_HEADER = "| Inspection name | Severity | Problems |";
    SUMMARY_TABLE_SEP = "| --- | --- | --- |";
    SUMMARY_MISC = `Contact us at [qodana-support@jetbrains.com](mailto:qodana-support@jetbrains.com)
  - Or via our issue tracker: https://jb.gg/qodana-issue
  - Or share your feedback: https://jb.gg/qodana-discussions`;
    SUMMARY_PR_MODE = `\u{1F4A1} Qodana analysis was run in the pull request mode: only the changed files were checked`;
    FAILURE_LEVEL = "failure";
    WARNING_LEVEL = "warning";
    NOTICE_LEVEL = "notice";
  }
});

// ../common/utils.ts
var utils_exports = {};
__export(utils_exports, {
  parseRules: () => parseRules
});
function parseRules(tool) {
  var _a, _b;
  const rules = /* @__PURE__ */ new Map();
  (_a = tool.driver.rules) == null ? void 0 : _a.forEach((rule) => {
    rules.set(rule.id, {
      shortDescription: rule.shortDescription.text,
      fullDescription: rule.fullDescription.markdown || rule.fullDescription.text
    });
  });
  (_b = tool == null ? void 0 : tool.extensions) == null ? void 0 : _b.forEach((ext) => {
    var _a2;
    (_a2 = ext == null ? void 0 : ext.rules) == null ? void 0 : _a2.forEach((rule) => {
      rules.set(rule.id, {
        shortDescription: rule.shortDescription.text,
        fullDescription: rule.fullDescription.markdown || rule.fullDescription.text
      });
    });
  });
  return rules;
}
var init_utils = __esm({
  "../common/utils.ts"() {
    "use strict";
  }
});

// ../node_modules/azure-devops-node-api/VsoClient.js
var require_VsoClient = __commonJS({
  "../node_modules/azure-devops-node-api/VsoClient.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VsoClient = exports2.InvalidApiResourceVersionError = void 0;
    var url = require("url");
    var path2 = require("path");
    var InvalidApiResourceVersionError = class {
      constructor(message) {
        this.name = "Invalid resource version";
        this.message = message;
      }
    };
    exports2.InvalidApiResourceVersionError = InvalidApiResourceVersionError;
    var VsoClient = class _VsoClient {
      constructor(baseUrl, restClient) {
        this.baseUrl = baseUrl;
        this.basePath = url.parse(baseUrl).pathname;
        this.restClient = restClient;
        this._locationsByAreaPromises = {};
        this._initializationPromise = Promise.resolve(true);
      }
      autoNegotiateApiVersion(location, requestedVersion) {
        let negotiatedVersion;
        let apiVersion;
        let apiVersionString;
        if (requestedVersion) {
          let apiVersionRegEx = new RegExp("(\\d+(\\.\\d+)?)(-preview(\\.(\\d+))?)?");
          let isPreview = false;
          let resourceVersion;
          let regExExecArray = apiVersionRegEx.exec(requestedVersion);
          if (regExExecArray) {
            if (regExExecArray[1]) {
              apiVersion = +regExExecArray[1];
              apiVersionString = regExExecArray[1];
              if (regExExecArray[3]) {
                isPreview = true;
                if (regExExecArray[5]) {
                  resourceVersion = +regExExecArray[5];
                }
              }
              if (apiVersion <= +location.releasedVersion || !resourceVersion && apiVersion <= +location.maxVersion && isPreview || resourceVersion && apiVersion <= +location.maxVersion && resourceVersion <= +location.resourceVersion) {
                negotiatedVersion = requestedVersion;
              }
            }
          }
        }
        if (!negotiatedVersion) {
          if (apiVersion < +location.maxVersion) {
            negotiatedVersion = apiVersionString + "-preview";
          } else if (location.maxVersion === location.releasedVersion) {
            negotiatedVersion = location.maxVersion;
          } else {
            negotiatedVersion = location.maxVersion + "-preview." + location.resourceVersion;
          }
        }
        return negotiatedVersion;
      }
      /**
       * Gets the route template for a resource based on its location ID and negotiates the api version
       */
      getVersioningData(apiVersion, area, locationId, routeValues, queryParams) {
        let requestUrl;
        return this.beginGetLocation(area, locationId).then((location) => {
          if (!location) {
            throw new Error("Failed to find api location for area: " + area + " id: " + locationId);
          }
          apiVersion = this.autoNegotiateApiVersion(location, apiVersion);
          requestUrl = this.getRequestUrl(location.routeTemplate, location.area, location.resourceName, routeValues, queryParams);
          return {
            apiVersion,
            requestUrl
          };
        });
      }
      /**
       * Sets a promise that is waited on before any requests are issued. Can be used to asynchronously
       * set the request url and auth token manager.
       */
      _setInitializationPromise(promise) {
        if (promise) {
          this._initializationPromise = promise;
        }
      }
      /**
       * Gets information about an API resource location (route template, supported versions, etc.)
       *
       * @param area resource area name
       * @param locationId Guid of the location to get
       */
      beginGetLocation(area, locationId) {
        return this._initializationPromise.then(() => {
          return this.beginGetAreaLocations(area);
        }).then((areaLocations) => {
          return areaLocations[(locationId || "").toLowerCase()];
        });
      }
      beginGetAreaLocations(area) {
        let areaLocationsPromise = this._locationsByAreaPromises[area];
        if (!areaLocationsPromise) {
          let requestUrl = this.resolveUrl(_VsoClient.APIS_RELATIVE_PATH + "/" + area);
          areaLocationsPromise = this.restClient.options(requestUrl).then((res) => {
            if (!res.result) {
              return {};
            }
            let locationsLookup = {};
            let resourceLocations = res.result.value;
            let i;
            for (i = 0; i < resourceLocations.length; i++) {
              let resourceLocation = resourceLocations[i];
              locationsLookup[resourceLocation.id.toLowerCase()] = resourceLocation;
            }
            this._locationsByAreaPromises[area] = areaLocationsPromise;
            return locationsLookup;
          });
        }
        return areaLocationsPromise;
      }
      resolveUrl(relativeUrl) {
        return url.resolve(this.baseUrl, path2.join(this.basePath, relativeUrl));
      }
      queryParamsToStringHelper(queryParams, prefix) {
        if (queryParams == null || queryParams.length === 0) {
          return "";
        }
        let queryString = "";
        if (typeof queryParams !== "string") {
          for (let property2 in queryParams) {
            if (queryParams.hasOwnProperty(property2)) {
              const prop = queryParams[property2];
              const newPrefix = prefix + encodeURIComponent(property2.toString()) + ".";
              queryString += this.queryParamsToStringHelper(prop, newPrefix);
            }
          }
        }
        if (queryString === "" && prefix.length > 0) {
          const queryValue = typeof queryParams === "object" && "toUTCString" in queryParams ? queryParams.toUTCString() : queryParams.toString();
          queryString = prefix.slice(0, -1) + "=" + encodeURIComponent(queryValue) + "&";
        }
        return queryString;
      }
      queryParamsToString(queryParams) {
        const queryString = "?" + this.queryParamsToStringHelper(queryParams, "");
        return queryString.slice(0, -1);
      }
      getRequestUrl(routeTemplate, area, resource, routeValues, queryParams) {
        routeValues = routeValues || {};
        if (!routeValues.area) {
          routeValues.area = area;
        }
        if (!routeValues.resource) {
          routeValues.resource = resource;
        }
        let relativeUrl = this.replaceRouteValues(routeTemplate, routeValues);
        if (queryParams) {
          relativeUrl += this.queryParamsToString(queryParams);
        }
        return url.resolve(this.baseUrl, path2.join(this.basePath, relativeUrl));
      }
      // helper method copied directly from VSS\WebAPI\restclient.ts
      replaceRouteValues(routeTemplate, routeValues) {
        let result2 = "", currentPathPart = "", paramName = "", insideParam = false, charIndex, routeTemplateLength = routeTemplate.length, c;
        for (charIndex = 0; charIndex < routeTemplateLength; charIndex++) {
          c = routeTemplate[charIndex];
          if (insideParam) {
            if (c == "}") {
              insideParam = false;
              if (routeValues[paramName]) {
                currentPathPart += encodeURIComponent(routeValues[paramName]);
              } else {
                let strippedParamName = paramName.replace(/[^a-z0-9]/ig, "");
                if (routeValues[strippedParamName]) {
                  currentPathPart += encodeURIComponent(routeValues[strippedParamName]);
                }
              }
              paramName = "";
            } else {
              paramName += c;
            }
          } else {
            if (c == "/") {
              if (currentPathPart) {
                if (result2) {
                  result2 += "/";
                }
                result2 += currentPathPart;
                currentPathPart = "";
              }
            } else if (c == "{") {
              if (charIndex + 1 < routeTemplateLength && routeTemplate[charIndex + 1] == "{") {
                currentPathPart += c;
                charIndex++;
              } else {
                insideParam = true;
              }
            } else if (c == "}") {
              currentPathPart += c;
              if (charIndex + 1 < routeTemplateLength && routeTemplate[charIndex + 1] == "}") {
                charIndex++;
              }
            } else {
              currentPathPart += c;
            }
          }
        }
        if (currentPathPart) {
          if (result2) {
            result2 += "/";
          }
          result2 += currentPathPart;
        }
        return result2;
      }
    };
    exports2.VsoClient = VsoClient;
    VsoClient.APIS_RELATIVE_PATH = "_apis";
    VsoClient.PREVIEW_INDICATOR = "-preview.";
  }
});

// ../node_modules/azure-devops-node-api/Serialization.js
var require_Serialization = __commonJS({
  "../node_modules/azure-devops-node-api/Serialization.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ContractSerializer = void 0;
    var ContractSerializer;
    (function(ContractSerializer2) {
      var _legacyDateRegExp;
      function serialize(data, contractMetadata, preserveOriginal) {
        if (data && contractMetadata) {
          if (Array.isArray(data)) {
            return _getTranslatedArray(data, contractMetadata, true, preserveOriginal);
          } else {
            return _getTranslatedObject(data, contractMetadata, true, preserveOriginal);
          }
        } else {
          return data;
        }
      }
      ContractSerializer2.serialize = serialize;
      function deserialize(data, contractMetadata, preserveOriginal, unwrapWrappedCollections) {
        if (data) {
          if (unwrapWrappedCollections && Array.isArray(data.value)) {
            data = data.value;
          }
          if (contractMetadata) {
            if (Array.isArray(data)) {
              data = _getTranslatedArray(data, contractMetadata, false, preserveOriginal);
            } else {
              data = _getTranslatedObject(data, contractMetadata, false, preserveOriginal);
            }
          }
        }
        return data;
      }
      ContractSerializer2.deserialize = deserialize;
      function _getTranslatedArray(array, typeMetadata, serialize2, preserveOriginal) {
        var resultArray = array;
        var arrayCopy = [];
        var i;
        for (i = 0; i < array.length; i++) {
          var item = array[i];
          var processedItem;
          if (Array.isArray(item)) {
            processedItem = _getTranslatedArray(item, typeMetadata, serialize2, preserveOriginal);
          } else {
            processedItem = _getTranslatedObject(item, typeMetadata, serialize2, preserveOriginal);
          }
          if (preserveOriginal) {
            arrayCopy.push(processedItem);
            if (processedItem !== item) {
              resultArray = arrayCopy;
            }
          } else {
            array[i] = processedItem;
          }
        }
        return resultArray;
      }
      function _getTranslatedObject(typeObject, typeMetadata, serialize2, preserveOriginal) {
        var processedItem = typeObject, copiedItem = false;
        if (typeObject && typeMetadata.fields) {
          for (var fieldName in typeMetadata.fields) {
            var fieldMetadata = typeMetadata.fields[fieldName];
            var fieldValue = typeObject[fieldName];
            var translatedValue = _getTranslatedField(fieldValue, fieldMetadata, serialize2, preserveOriginal);
            if (fieldValue !== translatedValue) {
              if (preserveOriginal && !copiedItem) {
                processedItem = this._extend({}, typeObject);
                copiedItem = true;
              }
              processedItem[fieldName] = translatedValue;
            }
          }
        }
        return processedItem;
      }
      function _getTranslatedField(fieldValue, fieldMetadata, serialize2, preserveOriginal) {
        if (!fieldValue) {
          return fieldValue;
        }
        if (fieldMetadata.isArray) {
          if (Array.isArray(fieldValue)) {
            var newArray = [], processedArray = fieldValue;
            for (var index = 0; index < fieldValue.length; index++) {
              var arrayValue = fieldValue[index];
              var processedValue = arrayValue;
              if (fieldMetadata.isDate) {
                processedValue = _getTranslatedDateValue(arrayValue, serialize2);
              } else if (fieldMetadata.enumType) {
                processedValue = _getTranslatedEnumValue(fieldMetadata.enumType, arrayValue, serialize2);
              } else if (fieldMetadata.typeInfo) {
                if (Array.isArray(arrayValue)) {
                  processedValue = _getTranslatedArray(arrayValue, fieldMetadata.typeInfo, serialize2, preserveOriginal);
                } else {
                  processedValue = _getTranslatedObject(arrayValue, fieldMetadata.typeInfo, serialize2, preserveOriginal);
                }
              }
              if (preserveOriginal) {
                newArray.push(processedValue);
                if (processedValue !== arrayValue) {
                  processedArray = newArray;
                }
              } else {
                fieldValue[index] = processedValue;
              }
            }
            return processedArray;
          } else {
            return fieldValue;
          }
        } else if (fieldMetadata.isDictionary) {
          var dictionaryModified = false;
          var newDictionary = {};
          for (var key in fieldValue) {
            var dictionaryValue = fieldValue[key];
            var newKey = key, newValue = dictionaryValue;
            if (fieldMetadata.dictionaryKeyIsDate) {
              newKey = _getTranslatedDateValue(key, serialize2);
            } else if (fieldMetadata.dictionaryKeyEnumType) {
              newKey = _getTranslatedEnumValue(fieldMetadata.dictionaryKeyEnumType, key, serialize2);
            }
            if (fieldMetadata.dictionaryValueIsDate) {
              newValue = _getTranslatedDateValue(dictionaryValue, serialize2);
            } else if (fieldMetadata.dictionaryValueEnumType) {
              newValue = _getTranslatedEnumValue(fieldMetadata.dictionaryValueEnumType, dictionaryValue, serialize2);
            } else if (fieldMetadata.dictionaryValueTypeInfo) {
              newValue = _getTranslatedObject(newValue, fieldMetadata.dictionaryValueTypeInfo, serialize2, preserveOriginal);
            } else if (fieldMetadata.dictionaryValueFieldInfo) {
              newValue = _getTranslatedField(dictionaryValue, fieldMetadata.dictionaryValueFieldInfo, serialize2, preserveOriginal);
            }
            newDictionary[newKey] = newValue;
            if (key !== newKey || dictionaryValue !== newValue) {
              dictionaryModified = true;
            }
          }
          return dictionaryModified ? newDictionary : fieldValue;
        } else {
          if (fieldMetadata.isDate) {
            return _getTranslatedDateValue(fieldValue, serialize2);
          } else if (fieldMetadata.enumType) {
            return _getTranslatedEnumValue(fieldMetadata.enumType, fieldValue, serialize2);
          } else if (fieldMetadata.typeInfo) {
            return _getTranslatedObject(fieldValue, fieldMetadata.typeInfo, serialize2, preserveOriginal);
          } else {
            return fieldValue;
          }
        }
      }
      function _getTranslatedEnumValue(enumType, valueToConvert, serialize2) {
        if (serialize2 && typeof valueToConvert === "number") {
        } else if (!serialize2 && typeof valueToConvert === "string") {
          var result2 = 0;
          if (valueToConvert) {
            var splitValue = valueToConvert.split(",");
            for (var i = 0; i < splitValue.length; i++) {
              var valuePart = splitValue[i];
              var enumName = valuePart.replace(/^\s+|\s+$/g, "") || "";
              if (enumName) {
                var resultPart = enumType.enumValues[enumName];
                if (!resultPart) {
                  var lowerCaseEnumName = enumName.toLowerCase();
                  if (lowerCaseEnumName !== enumName) {
                    for (var name in enumType.enumValues) {
                      var value = enumType.enumValues[name];
                      if (name.toLowerCase() === lowerCaseEnumName) {
                        resultPart = value;
                        break;
                      }
                    }
                  }
                }
                if (resultPart) {
                  result2 |= resultPart;
                }
              }
            }
          }
          return result2;
        }
        return valueToConvert;
      }
      function _getTranslatedDateValue(valueToConvert, serialize2) {
        if (!serialize2 && typeof valueToConvert === "string") {
          var dateValue = new Date(valueToConvert);
          if (isNaN(dateValue) && navigator.userAgent && /msie/i.test(navigator.userAgent)) {
            dateValue = _convertLegacyIEDate(valueToConvert);
          }
          return dateValue;
        }
        return valueToConvert;
      }
      function _convertLegacyIEDate(dateStringValue) {
        var match;
        if (!_legacyDateRegExp) {
          _legacyDateRegExp = new RegExp("(\\d+)-(\\d+)-(\\d+)T(\\d+):(\\d+):(\\d+).(\\d+)Z");
        }
        match = _legacyDateRegExp.exec(dateStringValue);
        if (match) {
          return new Date(Date.UTC(parseInt(match[1]), parseInt(match[2]) - 1, parseInt(match[3]), parseInt(match[4]), parseInt(match[5]), parseInt(match[6]), parseInt(match[7])));
        } else {
          return null;
        }
      }
      var _extend = function(out) {
        out = out || {};
        for (var i = 1; i < arguments.length; i++) {
          if (!arguments[i])
            continue;
          for (var key in arguments[i]) {
            if (arguments[i].hasOwnProperty(key))
              out[key] = arguments[i][key];
          }
        }
        return out;
      };
    })(ContractSerializer = exports2.ContractSerializer || (exports2.ContractSerializer = {}));
  }
});

// ../node_modules/azure-devops-node-api/node_modules/typed-rest-client/Util.js
var require_Util2 = __commonJS({
  "../node_modules/azure-devops-node-api/node_modules/typed-rest-client/Util.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getUrl = getUrl;
    exports2.decompressGzippedContent = decompressGzippedContent;
    exports2.buildProxyBypassRegexFromEnv = buildProxyBypassRegexFromEnv;
    exports2.obtainContentCharset = obtainContentCharset;
    var qs = require_lib4();
    var url = require("url");
    var path2 = require("path");
    var zlib = require("zlib");
    function getUrl(resource, baseUrl, queryParams) {
      const pathApi = path2.posix || path2;
      let requestUrl = "";
      if (!baseUrl) {
        requestUrl = resource;
      } else if (!resource) {
        requestUrl = baseUrl;
      } else {
        const base = url.parse(baseUrl);
        const resultantUrl = url.parse(resource);
        resultantUrl.protocol = resultantUrl.protocol || base.protocol;
        resultantUrl.auth = resultantUrl.auth || base.auth;
        resultantUrl.host = resultantUrl.host || base.host;
        resultantUrl.pathname = pathApi.resolve(base.pathname, resultantUrl.pathname);
        if (!resultantUrl.pathname.endsWith("/") && resource.endsWith("/")) {
          resultantUrl.pathname += "/";
        }
        requestUrl = url.format(resultantUrl);
      }
      return queryParams ? getUrlWithParsedQueryParams(requestUrl, queryParams) : requestUrl;
    }
    function getUrlWithParsedQueryParams(requestUrl, queryParams) {
      const url2 = requestUrl.replace(/\?$/g, "");
      const parsedQueryParams = qs.stringify(queryParams.params, buildParamsStringifyOptions(queryParams));
      return `${url2}${parsedQueryParams}`;
    }
    function buildParamsStringifyOptions(queryParams) {
      let options = {
        addQueryPrefix: true,
        delimiter: (queryParams.options || {}).separator || "&",
        allowDots: (queryParams.options || {}).shouldAllowDots || false,
        arrayFormat: (queryParams.options || {}).arrayFormat || "repeat",
        encodeValuesOnly: (queryParams.options || {}).shouldOnlyEncodeValues || true
      };
      return options;
    }
    function decompressGzippedContent(buffer, charset) {
      return __awaiter2(this, void 0, void 0, function* () {
        return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
          zlib.gunzip(buffer, function(error, buffer2) {
            if (error) {
              reject2(error);
            } else {
              resolve(buffer2.toString(charset || "utf-8"));
            }
          });
        }));
      });
    }
    function buildProxyBypassRegexFromEnv(bypass) {
      try {
        return new RegExp(bypass, "i");
      } catch (err) {
        if (err instanceof SyntaxError && (bypass || "").startsWith("*")) {
          let wildcardEscaped = bypass.replace("*", "(.*)");
          return new RegExp(wildcardEscaped, "i");
        }
        throw err;
      }
    }
    function obtainContentCharset(response) {
      const nodeSupportedEncodings = ["ascii", "utf8", "utf16le", "ucs2", "base64", "binary", "hex"];
      const contentType = response.message.headers["content-type"] || "";
      const matches = contentType.match(/charset=([^;,\r\n]+)/i);
      if (matches && matches[1] && nodeSupportedEncodings.indexOf(matches[1]) != -1) {
        return matches[1];
      }
      return "utf-8";
    }
  }
});

// ../node_modules/azure-devops-node-api/node_modules/typed-rest-client/HttpClient.js
var require_HttpClient2 = __commonJS({
  "../node_modules/azure-devops-node-api/node_modules/typed-rest-client/HttpClient.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.HttpClient = exports2.HttpClientResponse = exports2.HttpCodes = void 0;
    exports2.isHttps = isHttps;
    var url = require("url");
    var http = require("http");
    var https = require("https");
    var util = require_Util2();
    var fs3;
    var tunnel;
    var HttpCodes;
    (function(HttpCodes2) {
      HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
      HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
      HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
      HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
      HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
      HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
      HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
      HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
      HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
      HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
      HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
      HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
      HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
      HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
      HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
      HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
      HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
      HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
      HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
      HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
      HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
      HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
      HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
      HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
      HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
      HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
      HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
    })(HttpCodes || (exports2.HttpCodes = HttpCodes = {}));
    var HttpRedirectCodes = [HttpCodes.MovedPermanently, HttpCodes.ResourceMoved, HttpCodes.SeeOther, HttpCodes.TemporaryRedirect, HttpCodes.PermanentRedirect];
    var HttpResponseRetryCodes = [HttpCodes.BadGateway, HttpCodes.ServiceUnavailable, HttpCodes.GatewayTimeout];
    var NetworkRetryErrors = ["ECONNRESET", "ENOTFOUND", "ESOCKETTIMEDOUT", "ETIMEDOUT", "ECONNREFUSED", "EHOSTUNREACH"];
    var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
    var ExponentialBackoffCeiling = 10;
    var ExponentialBackoffTimeSlice = 5;
    var HttpClientResponse = class {
      constructor(message) {
        this.message = message;
      }
      readBody() {
        return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
          const chunks = [];
          const encodingCharset = util.obtainContentCharset(this);
          const contentEncoding = this.message.headers["content-encoding"] || "";
          const isGzippedEncoded = new RegExp("(gzip$)|(gzip, *deflate)").test(contentEncoding);
          this.message.on("data", function(data) {
            const chunk2 = typeof data === "string" ? Buffer.from(data, encodingCharset) : data;
            chunks.push(chunk2);
          }).on("end", function() {
            return __awaiter2(this, void 0, void 0, function* () {
              const buffer = Buffer.concat(chunks);
              if (isGzippedEncoded) {
                const gunzippedBody = yield util.decompressGzippedContent(buffer, encodingCharset);
                resolve(gunzippedBody);
              } else {
                resolve(buffer.toString(encodingCharset));
              }
            });
          }).on("error", function(err) {
            reject2(err);
          });
        }));
      }
    };
    exports2.HttpClientResponse = HttpClientResponse;
    function isHttps(requestUrl) {
      let parsedUrl = url.parse(requestUrl);
      return parsedUrl.protocol === "https:";
    }
    var EnvironmentVariables;
    (function(EnvironmentVariables2) {
      EnvironmentVariables2["HTTP_PROXY"] = "HTTP_PROXY";
      EnvironmentVariables2["HTTPS_PROXY"] = "HTTPS_PROXY";
      EnvironmentVariables2["NO_PROXY"] = "NO_PROXY";
    })(EnvironmentVariables || (EnvironmentVariables = {}));
    var HttpClient = class {
      constructor(userAgent, handlers, requestOptions) {
        this._ignoreSslError = false;
        this._allowRedirects = true;
        this._allowRedirectDowngrade = false;
        this._maxRedirects = 50;
        this._allowRetries = false;
        this._maxRetries = 1;
        this._keepAlive = false;
        this._disposed = false;
        this._httpGlobalAgentOptions = {
          keepAlive: false,
          timeout: 3e4
        };
        this.userAgent = userAgent;
        this.handlers = handlers || [];
        let no_proxy = process.env[EnvironmentVariables.NO_PROXY];
        if (no_proxy) {
          this._httpProxyBypassHosts = [];
          no_proxy.split(",").forEach((bypass) => {
            this._httpProxyBypassHosts.push(util.buildProxyBypassRegexFromEnv(bypass));
          });
        }
        this.requestOptions = requestOptions;
        if (requestOptions) {
          if (requestOptions.ignoreSslError != null) {
            this._ignoreSslError = requestOptions.ignoreSslError;
          }
          this._socketTimeout = requestOptions.socketTimeout;
          this._httpProxy = requestOptions.proxy;
          if (requestOptions.proxy && requestOptions.proxy.proxyBypassHosts) {
            this._httpProxyBypassHosts = [];
            requestOptions.proxy.proxyBypassHosts.forEach((bypass) => {
              this._httpProxyBypassHosts.push(new RegExp(bypass, "i"));
            });
          }
          if (requestOptions.globalAgentOptions) {
            this._httpGlobalAgentOptions = requestOptions.globalAgentOptions;
          }
          this._certConfig = requestOptions.cert;
          if (this._certConfig) {
            fs3 = require("fs");
            if (this._certConfig.caFile && fs3.existsSync(this._certConfig.caFile)) {
              this._ca = fs3.readFileSync(this._certConfig.caFile, "utf8");
            }
            if (this._certConfig.certFile && fs3.existsSync(this._certConfig.certFile)) {
              this._cert = fs3.readFileSync(this._certConfig.certFile, "utf8");
            }
            if (this._certConfig.keyFile && fs3.existsSync(this._certConfig.keyFile)) {
              this._key = fs3.readFileSync(this._certConfig.keyFile, "utf8");
            }
          }
          if (requestOptions.allowRedirects != null) {
            this._allowRedirects = requestOptions.allowRedirects;
          }
          if (requestOptions.allowRedirectDowngrade != null) {
            this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
          }
          if (requestOptions.maxRedirects != null) {
            this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
          }
          if (requestOptions.keepAlive != null) {
            this._keepAlive = requestOptions.keepAlive;
          }
          if (requestOptions.allowRetries != null) {
            this._allowRetries = requestOptions.allowRetries;
          }
          if (requestOptions.maxRetries != null) {
            this._maxRetries = requestOptions.maxRetries;
          }
        }
      }
      options(requestUrl, additionalHeaders) {
        return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
      }
      get(requestUrl, additionalHeaders) {
        return this.request("GET", requestUrl, null, additionalHeaders || {});
      }
      del(requestUrl, additionalHeaders) {
        return this.request("DELETE", requestUrl, null, additionalHeaders || {});
      }
      post(requestUrl, data, additionalHeaders) {
        return this.request("POST", requestUrl, data, additionalHeaders || {});
      }
      patch(requestUrl, data, additionalHeaders) {
        return this.request("PATCH", requestUrl, data, additionalHeaders || {});
      }
      put(requestUrl, data, additionalHeaders) {
        return this.request("PUT", requestUrl, data, additionalHeaders || {});
      }
      head(requestUrl, additionalHeaders) {
        return this.request("HEAD", requestUrl, null, additionalHeaders || {});
      }
      sendStream(verb, requestUrl, stream, additionalHeaders) {
        return this.request(verb, requestUrl, stream, additionalHeaders);
      }
      /**
       * Makes a raw http request.
       * All other methods such as get, post, patch, and request ultimately call this.
       * Prefer get, del, post and patch
       */
      request(verb, requestUrl, data, headers) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (this._disposed) {
            throw new Error("Client has already been disposed.");
          }
          let parsedUrl = url.parse(requestUrl);
          let info = this._prepareRequest(verb, parsedUrl, headers);
          let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1 ? this._maxRetries + 1 : 1;
          let numTries = 0;
          let response;
          while (numTries < maxTries) {
            try {
              response = yield this.requestRaw(info, data);
            } catch (err) {
              numTries++;
              if (err && err.code && NetworkRetryErrors.indexOf(err.code) > -1 && numTries < maxTries) {
                yield this._performExponentialBackoff(numTries);
                continue;
              }
              throw err;
            }
            if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
              let authenticationHandler;
              for (let i = 0; i < this.handlers.length; i++) {
                if (this.handlers[i].canHandleAuthentication(response)) {
                  authenticationHandler = this.handlers[i];
                  break;
                }
              }
              if (authenticationHandler) {
                return authenticationHandler.handleAuthentication(this, info, data);
              } else {
                return response;
              }
            }
            let redirectsRemaining = this._maxRedirects;
            while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1 && this._allowRedirects && redirectsRemaining > 0) {
              const redirectUrl = response.message.headers["location"];
              if (!redirectUrl) {
                break;
              }
              let parsedRedirectUrl = url.parse(redirectUrl);
              if (parsedUrl.protocol == "https:" && parsedUrl.protocol != parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
                throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
              }
              yield response.readBody();
              info = this._prepareRequest(verb, parsedRedirectUrl, headers);
              response = yield this.requestRaw(info, data);
              redirectsRemaining--;
            }
            if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {
              return response;
            }
            numTries += 1;
            if (numTries < maxTries) {
              yield response.readBody();
              yield this._performExponentialBackoff(numTries);
            }
          }
          return response;
        });
      }
      /**
       * Needs to be called if keepAlive is set to true in request options.
       */
      dispose() {
        if (this._agent) {
          this._agent.destroy();
        }
        this._disposed = true;
      }
      /**
       * Raw request.
       * @param info
       * @param data
       */
      requestRaw(info, data) {
        return new Promise((resolve, reject2) => {
          let callbackForResult = function(err, res) {
            if (err) {
              reject2(err);
            }
            resolve(res);
          };
          this.requestRawWithCallback(info, data, callbackForResult);
        });
      }
      /**
       * Raw request with callback.
       * @param info
       * @param data
       * @param onResult
       */
      requestRawWithCallback(info, data, onResult) {
        let socket;
        if (typeof data === "string") {
          info.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
        }
        let callbackCalled = false;
        let handleResult = (err, res) => {
          if (!callbackCalled) {
            callbackCalled = true;
            onResult(err, res);
          }
        };
        let req = info.httpModule.request(info.options, (msg) => {
          let res = new HttpClientResponse(msg);
          handleResult(null, res);
        });
        req.on("socket", (sock) => {
          socket = sock;
        });
        req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
          if (socket) {
            socket.destroy();
          }
          handleResult(new Error("Request timeout: " + info.options.path), null);
        });
        req.on("error", function(err) {
          handleResult(err, null);
        });
        if (data && typeof data === "string") {
          req.write(data, "utf8");
        }
        if (data && typeof data !== "string") {
          data.on("close", function() {
            req.end();
          });
          data.pipe(req);
        } else {
          req.end();
        }
      }
      _prepareRequest(method, requestUrl, headers) {
        const info = {};
        info.parsedUrl = requestUrl;
        const usingSsl = info.parsedUrl.protocol === "https:";
        info.httpModule = usingSsl ? https : http;
        const defaultPort = usingSsl ? 443 : 80;
        info.options = {};
        info.options.host = info.parsedUrl.hostname;
        info.options.port = info.parsedUrl.port ? parseInt(info.parsedUrl.port) : defaultPort;
        info.options.path = (info.parsedUrl.pathname || "") + (info.parsedUrl.search || "");
        info.options.method = method;
        info.options.timeout = this.requestOptions && this.requestOptions.socketTimeout || this._socketTimeout;
        this._socketTimeout = info.options.timeout;
        info.options.headers = this._mergeHeaders(headers);
        if (this.userAgent != null) {
          info.options.headers["user-agent"] = this.userAgent;
        }
        info.options.agent = this._getAgent(info.parsedUrl);
        if (this.handlers && !this._isPresigned(url.format(requestUrl))) {
          this.handlers.forEach((handler) => {
            handler.prepareRequest(info.options);
          });
        }
        return info;
      }
      _isPresigned(requestUrl) {
        if (this.requestOptions && this.requestOptions.presignedUrlPatterns) {
          const patterns = this.requestOptions.presignedUrlPatterns;
          for (let i = 0; i < patterns.length; i++) {
            if (requestUrl.match(patterns[i])) {
              return true;
            }
          }
        }
        return false;
      }
      _mergeHeaders(headers) {
        const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
        if (this.requestOptions && this.requestOptions.headers) {
          return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));
        }
        return lowercaseKeys(headers || {});
      }
      _getAgent(parsedUrl) {
        let agent;
        let proxy = this._getProxy(parsedUrl);
        let useProxy = proxy.proxyUrl && proxy.proxyUrl.hostname && !this._isMatchInBypassProxyList(parsedUrl);
        if (this._keepAlive && useProxy) {
          agent = this._proxyAgent;
        }
        if (this._keepAlive && !useProxy) {
          agent = this._agent;
        }
        if (!!agent) {
          return agent;
        }
        const usingSsl = parsedUrl.protocol === "https:";
        let maxSockets = 100;
        if (!!this.requestOptions) {
          maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
        }
        if (useProxy) {
          if (!tunnel) {
            tunnel = require_tunnel2();
          }
          const agentOptions = {
            maxSockets,
            keepAlive: this._keepAlive,
            proxy: {
              proxyAuth: proxy.proxyAuth,
              host: proxy.proxyUrl.hostname,
              port: proxy.proxyUrl.port
            }
          };
          let tunnelAgent;
          const overHttps = proxy.proxyUrl.protocol === "https:";
          if (usingSsl) {
            tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
          } else {
            tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
          }
          agent = tunnelAgent(agentOptions);
          this._proxyAgent = agent;
        }
        if (this._keepAlive && !agent) {
          const options = { keepAlive: this._keepAlive, maxSockets };
          agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
          this._agent = agent;
        }
        if (!agent) {
          const globalAgentOptions = {
            keepAlive: this._httpGlobalAgentOptions.keepAlive,
            timeout: this._httpGlobalAgentOptions.timeout
          };
          agent = usingSsl ? new https.Agent(globalAgentOptions) : new http.Agent(globalAgentOptions);
        }
        if (usingSsl && this._ignoreSslError) {
          agent.options = Object.assign(agent.options || {}, { rejectUnauthorized: false });
        }
        if (usingSsl && this._certConfig) {
          agent.options = Object.assign(agent.options || {}, { ca: this._ca, cert: this._cert, key: this._key, passphrase: this._certConfig.passphrase });
        }
        return agent;
      }
      _getProxy(parsedUrl) {
        let usingSsl = parsedUrl.protocol === "https:";
        let proxyConfig = this._httpProxy;
        let https_proxy = process.env[EnvironmentVariables.HTTPS_PROXY];
        let http_proxy = process.env[EnvironmentVariables.HTTP_PROXY];
        if (!proxyConfig) {
          if (https_proxy && usingSsl) {
            proxyConfig = {
              proxyUrl: https_proxy
            };
          } else if (http_proxy) {
            proxyConfig = {
              proxyUrl: http_proxy
            };
          }
        }
        let proxyUrl;
        let proxyAuth;
        if (proxyConfig) {
          if (proxyConfig.proxyUrl.length > 0) {
            proxyUrl = url.parse(proxyConfig.proxyUrl);
          }
          if (proxyConfig.proxyUsername || proxyConfig.proxyPassword) {
            proxyAuth = proxyConfig.proxyUsername + ":" + proxyConfig.proxyPassword;
          }
        }
        return { proxyUrl, proxyAuth };
      }
      _isMatchInBypassProxyList(parsedUrl) {
        if (!this._httpProxyBypassHosts) {
          return false;
        }
        let bypass = false;
        this._httpProxyBypassHosts.forEach((bypassHost) => {
          if (bypassHost.test(parsedUrl.href)) {
            bypass = true;
          }
        });
        return bypass;
      }
      _performExponentialBackoff(retryNumber) {
        retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
        const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
        return new Promise((resolve) => setTimeout(() => resolve(), ms));
      }
    };
    exports2.HttpClient = HttpClient;
  }
});

// ../node_modules/azure-devops-node-api/node_modules/typed-rest-client/RestClient.js
var require_RestClient = __commonJS({
  "../node_modules/azure-devops-node-api/node_modules/typed-rest-client/RestClient.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.RestClient = void 0;
    var httpm = require_HttpClient2();
    var util = require_Util2();
    var RestClient = class _RestClient {
      /**
       * Creates an instance of the RestClient
       * @constructor
       * @param {string} userAgent - userAgent for requests
       * @param {string} baseUrl - (Optional) If not specified, use full urls per request.  If supplied and a function passes a relative url, it will be appended to this
       * @param {ifm.IRequestHandler[]} handlers - handlers are typically auth handlers (basic, bearer, ntlm supplied)
       * @param {ifm.IRequestOptions} requestOptions - options for each http requests (http proxy setting, socket timeout)
       */
      constructor(userAgent, baseUrl, handlers, requestOptions) {
        this.client = new httpm.HttpClient(userAgent, handlers, requestOptions);
        if (baseUrl) {
          this._baseUrl = baseUrl;
        }
      }
      /**
       * Gets a resource from an endpoint
       * Be aware that not found returns a null.  Other error conditions reject the promise
       * @param {string} requestUrl - fully qualified or relative url
       * @param {IRequestOptions} requestOptions - (optional) requestOptions object
       */
      options(requestUrl, options) {
        return __awaiter2(this, void 0, void 0, function* () {
          let url = util.getUrl(requestUrl, this._baseUrl);
          let res = yield this.client.options(url, this._headersFromOptions(options));
          return this.processResponse(res, options);
        });
      }
      /**
       * Gets a resource from an endpoint
       * Be aware that not found returns a null.  Other error conditions reject the promise
       * @param {string} resource - fully qualified url or relative path
       * @param {IRequestOptions} requestOptions - (optional) requestOptions object
       */
      get(resource, options) {
        return __awaiter2(this, void 0, void 0, function* () {
          let url = util.getUrl(resource, this._baseUrl, (options || {}).queryParameters);
          let res = yield this.client.get(url, this._headersFromOptions(options));
          return this.processResponse(res, options);
        });
      }
      /**
       * Deletes a resource from an endpoint
       * Be aware that not found returns a null.  Other error conditions reject the promise
       * @param {string} resource - fully qualified or relative url
       * @param {IRequestOptions} requestOptions - (optional) requestOptions object
       */
      del(resource, options) {
        return __awaiter2(this, void 0, void 0, function* () {
          let url = util.getUrl(resource, this._baseUrl, (options || {}).queryParameters);
          let res = yield this.client.del(url, this._headersFromOptions(options));
          return this.processResponse(res, options);
        });
      }
      /**
       * Creates resource(s) from an endpoint
       * T type of object returned.
       * Be aware that not found returns a null.  Other error conditions reject the promise
       * @param {string} resource - fully qualified or relative url
       * @param {IRequestOptions} requestOptions - (optional) requestOptions object
       */
      create(resource, resources, options) {
        return __awaiter2(this, void 0, void 0, function* () {
          let url = util.getUrl(resource, this._baseUrl);
          let headers = this._headersFromOptions(options, true);
          let data = JSON.stringify(resources, null, 2);
          let res = yield this.client.post(url, data, headers);
          return this.processResponse(res, options);
        });
      }
      /**
       * Updates resource(s) from an endpoint
       * T type of object returned.
       * Be aware that not found returns a null.  Other error conditions reject the promise
       * @param {string} resource - fully qualified or relative url
       * @param {IRequestOptions} requestOptions - (optional) requestOptions object
       */
      update(resource, resources, options) {
        return __awaiter2(this, void 0, void 0, function* () {
          let url = util.getUrl(resource, this._baseUrl);
          let headers = this._headersFromOptions(options, true);
          let data = JSON.stringify(resources, null, 2);
          let res = yield this.client.patch(url, data, headers);
          return this.processResponse(res, options);
        });
      }
      /**
       * Replaces resource(s) from an endpoint
       * T type of object returned.
       * Be aware that not found returns a null.  Other error conditions reject the promise
       * @param {string} resource - fully qualified or relative url
       * @param {IRequestOptions} requestOptions - (optional) requestOptions object
       */
      replace(resource, resources, options) {
        return __awaiter2(this, void 0, void 0, function* () {
          let url = util.getUrl(resource, this._baseUrl);
          let headers = this._headersFromOptions(options, true);
          let data = JSON.stringify(resources, null, 2);
          let res = yield this.client.put(url, data, headers);
          return this.processResponse(res, options);
        });
      }
      uploadStream(verb, requestUrl, stream, options) {
        return __awaiter2(this, void 0, void 0, function* () {
          let url = util.getUrl(requestUrl, this._baseUrl);
          let headers = this._headersFromOptions(options, true);
          let res = yield this.client.sendStream(verb, url, stream, headers);
          return this.processResponse(res, options);
        });
      }
      _headersFromOptions(options, contentType) {
        options = options || {};
        let headers = options.additionalHeaders || {};
        headers["Accept"] = options.acceptHeader || "application/json";
        if (contentType) {
          let found = false;
          for (let header in headers) {
            if (header.toLowerCase() == "content-type") {
              found = true;
            }
          }
          if (!found) {
            headers["Content-Type"] = "application/json; charset=utf-8";
          }
        }
        return headers;
      }
      static dateTimeDeserializer(key, value) {
        if (typeof value === "string") {
          let a = new Date(value);
          if (!isNaN(a.valueOf())) {
            return a;
          }
        }
        return value;
      }
      processResponse(res, options) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            const statusCode = res.message.statusCode;
            const response = {
              statusCode,
              result: null,
              headers: {}
            };
            if (statusCode == httpm.HttpCodes.NotFound) {
              resolve(response);
            }
            let obj;
            let contents;
            try {
              contents = yield res.readBody();
              if (contents && contents.length > 0) {
                if (options && options.deserializeDates) {
                  obj = JSON.parse(contents, _RestClient.dateTimeDeserializer);
                } else {
                  obj = JSON.parse(contents);
                }
                if (options && options.responseProcessor) {
                  response.result = options.responseProcessor(obj);
                } else {
                  response.result = obj;
                }
              }
              response.headers = res.message.headers;
            } catch (err) {
            }
            if (statusCode > 299) {
              let msg;
              if (obj && obj.message) {
                msg = obj.message;
              } else if (contents && contents.length > 0) {
                msg = contents;
              } else {
                msg = "Failed request: (" + statusCode + ")";
              }
              let err = new Error(msg);
              err["statusCode"] = statusCode;
              if (response.result) {
                err["result"] = response.result;
              }
              if (response.headers) {
                err["responseHeaders"] = response.headers;
              }
              reject2(err);
            } else {
              resolve(response);
            }
          }));
        });
      }
    };
    exports2.RestClient = RestClient;
  }
});

// ../node_modules/azure-devops-node-api/ClientApiBases.js
var require_ClientApiBases = __commonJS({
  "../node_modules/azure-devops-node-api/ClientApiBases.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ClientApiBase = void 0;
    var vsom = require_VsoClient();
    var serm = require_Serialization();
    var rm = require_RestClient();
    var hm = require_HttpClient2();
    var ClientApiBase = class {
      constructor(baseUrl, handlers, userAgent, options) {
        this.baseUrl = baseUrl;
        this.http = new hm.HttpClient(userAgent, handlers, options);
        this.rest = new rm.RestClient(userAgent, null, handlers, options);
        this.vsoClient = new vsom.VsoClient(baseUrl, this.rest);
        this.userAgent = userAgent;
      }
      createAcceptHeader(type, apiVersion) {
        return type + (apiVersion ? ";api-version=" + apiVersion : "");
      }
      createRequestOptions(type, apiVersion) {
        let options = {};
        options.acceptHeader = this.createAcceptHeader(type, apiVersion);
        return options;
      }
      formatResponse(data, responseTypeMetadata, isCollection) {
        let serializationData = {
          responseTypeMetadata,
          responseIsCollection: isCollection
        };
        let deserializedResult = serm.ContractSerializer.deserialize(data, serializationData.responseTypeMetadata, false, serializationData.responseIsCollection);
        return deserializedResult;
      }
    };
    exports2.ClientApiBase = ClientApiBase;
  }
});

// ../node_modules/azure-devops-node-api/interfaces/AlertInterfaces.js
var require_AlertInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/AlertInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.State = exports2.Severity = exports2.SarifJobStatus = exports2.ResultType = exports2.MetadataOperation = exports2.MetadataChangeType = exports2.ExpandOption = exports2.DismissalType = exports2.Confidence = exports2.ComponentType = exports2.AnalysisConfigurationType = exports2.AlertType = void 0;
    var AlertType;
    (function(AlertType2) {
      AlertType2[AlertType2["Unknown"] = 0] = "Unknown";
      AlertType2[AlertType2["Dependency"] = 1] = "Dependency";
      AlertType2[AlertType2["Secret"] = 2] = "Secret";
      AlertType2[AlertType2["Code"] = 3] = "Code";
    })(AlertType = exports2.AlertType || (exports2.AlertType = {}));
    var AnalysisConfigurationType;
    (function(AnalysisConfigurationType2) {
      AnalysisConfigurationType2[AnalysisConfigurationType2["Default"] = 0] = "Default";
      AnalysisConfigurationType2[AnalysisConfigurationType2["AdoPipeline"] = 1] = "AdoPipeline";
    })(AnalysisConfigurationType = exports2.AnalysisConfigurationType || (exports2.AnalysisConfigurationType = {}));
    var ComponentType;
    (function(ComponentType2) {
      ComponentType2[ComponentType2["Unknown"] = 0] = "Unknown";
      ComponentType2[ComponentType2["NuGet"] = 1] = "NuGet";
      ComponentType2[ComponentType2["Npm"] = 2] = "Npm";
      ComponentType2[ComponentType2["Maven"] = 3] = "Maven";
      ComponentType2[ComponentType2["Git"] = 4] = "Git";
      ComponentType2[ComponentType2["Other"] = 5] = "Other";
      ComponentType2[ComponentType2["RubyGems"] = 6] = "RubyGems";
      ComponentType2[ComponentType2["Cargo"] = 7] = "Cargo";
      ComponentType2[ComponentType2["Pip"] = 8] = "Pip";
      ComponentType2[ComponentType2["File"] = 9] = "File";
      ComponentType2[ComponentType2["Go"] = 10] = "Go";
      ComponentType2[ComponentType2["DockerImage"] = 11] = "DockerImage";
      ComponentType2[ComponentType2["Pod"] = 12] = "Pod";
      ComponentType2[ComponentType2["Linux"] = 13] = "Linux";
      ComponentType2[ComponentType2["Conda"] = 14] = "Conda";
      ComponentType2[ComponentType2["DockerReference"] = 15] = "DockerReference";
      ComponentType2[ComponentType2["Vcpkg"] = 16] = "Vcpkg";
    })(ComponentType = exports2.ComponentType || (exports2.ComponentType = {}));
    var Confidence;
    (function(Confidence2) {
      Confidence2[Confidence2["High"] = 0] = "High";
      Confidence2[Confidence2["Other"] = 1] = "Other";
    })(Confidence = exports2.Confidence || (exports2.Confidence = {}));
    var DismissalType;
    (function(DismissalType2) {
      DismissalType2[DismissalType2["Unknown"] = 0] = "Unknown";
      DismissalType2[DismissalType2["Fixed"] = 1] = "Fixed";
      DismissalType2[DismissalType2["AcceptedRisk"] = 2] = "AcceptedRisk";
      DismissalType2[DismissalType2["FalsePositive"] = 3] = "FalsePositive";
    })(DismissalType = exports2.DismissalType || (exports2.DismissalType = {}));
    var ExpandOption;
    (function(ExpandOption2) {
      ExpandOption2[ExpandOption2["None"] = 0] = "None";
      ExpandOption2[ExpandOption2["ValidationFingerprint"] = 1] = "ValidationFingerprint";
    })(ExpandOption = exports2.ExpandOption || (exports2.ExpandOption = {}));
    var MetadataChangeType;
    (function(MetadataChangeType2) {
      MetadataChangeType2[MetadataChangeType2["None"] = 0] = "None";
      MetadataChangeType2[MetadataChangeType2["Created"] = 1] = "Created";
      MetadataChangeType2[MetadataChangeType2["Updated"] = 2] = "Updated";
      MetadataChangeType2[MetadataChangeType2["Deleted"] = 3] = "Deleted";
    })(MetadataChangeType = exports2.MetadataChangeType || (exports2.MetadataChangeType = {}));
    var MetadataOperation;
    (function(MetadataOperation2) {
      MetadataOperation2[MetadataOperation2["Add"] = 0] = "Add";
      MetadataOperation2[MetadataOperation2["Remove"] = 1] = "Remove";
    })(MetadataOperation = exports2.MetadataOperation || (exports2.MetadataOperation = {}));
    var ResultType;
    (function(ResultType2) {
      ResultType2[ResultType2["Unknown"] = 0] = "Unknown";
      ResultType2[ResultType2["Dependency"] = 1] = "Dependency";
      ResultType2[ResultType2["VersionControl"] = 2] = "VersionControl";
    })(ResultType = exports2.ResultType || (exports2.ResultType = {}));
    var SarifJobStatus;
    (function(SarifJobStatus2) {
      SarifJobStatus2[SarifJobStatus2["New"] = 0] = "New";
      SarifJobStatus2[SarifJobStatus2["Queued"] = 1] = "Queued";
      SarifJobStatus2[SarifJobStatus2["Completed"] = 2] = "Completed";
      SarifJobStatus2[SarifJobStatus2["Failed"] = 3] = "Failed";
    })(SarifJobStatus = exports2.SarifJobStatus || (exports2.SarifJobStatus = {}));
    var Severity;
    (function(Severity2) {
      Severity2[Severity2["Low"] = 0] = "Low";
      Severity2[Severity2["Medium"] = 1] = "Medium";
      Severity2[Severity2["High"] = 2] = "High";
      Severity2[Severity2["Critical"] = 3] = "Critical";
      Severity2[Severity2["Note"] = 4] = "Note";
      Severity2[Severity2["Warning"] = 5] = "Warning";
      Severity2[Severity2["Error"] = 6] = "Error";
    })(Severity = exports2.Severity || (exports2.Severity = {}));
    var State;
    (function(State2) {
      State2[State2["Unknown"] = 0] = "Unknown";
      State2[State2["Active"] = 1] = "Active";
      State2[State2["Dismissed"] = 2] = "Dismissed";
      State2[State2["Fixed"] = 4] = "Fixed";
      State2[State2["AutoDismissed"] = 8] = "AutoDismissed";
    })(State = exports2.State || (exports2.State = {}));
    exports2.TypeInfo = {
      Alert: {},
      AlertAnalysisInstance: {},
      AlertMetadata: {},
      AlertMetadataChange: {},
      AlertStateUpdate: {},
      AlertType: {
        enumValues: {
          "unknown": 0,
          "dependency": 1,
          "secret": 2,
          "code": 3
        }
      },
      AnalysisConfiguration: {},
      AnalysisConfigurationType: {
        enumValues: {
          "default": 0,
          "adoPipeline": 1
        }
      },
      AnalysisInstance: {},
      AnalysisResult: {},
      Branch: {},
      ComponentType: {
        enumValues: {
          "unknown": 0,
          "nuGet": 1,
          "npm": 2,
          "maven": 3,
          "git": 4,
          "other": 5,
          "rubyGems": 6,
          "cargo": 7,
          "pip": 8,
          "file": 9,
          "go": 10,
          "dockerImage": 11,
          "pod": 12,
          "linux": 13,
          "conda": 14,
          "dockerReference": 15,
          "vcpkg": 16
        }
      },
      Confidence: {
        enumValues: {
          "high": 0,
          "other": 1
        }
      },
      Dependency: {},
      DependencyResult: {},
      Dismissal: {},
      DismissalType: {
        enumValues: {
          "unknown": 0,
          "fixed": 1,
          "acceptedRisk": 2,
          "falsePositive": 3
        }
      },
      ExpandOption: {
        enumValues: {
          "none": 0,
          "validationFingerprint": 1
        }
      },
      Metadata: {},
      MetadataChange: {},
      MetadataChangeType: {
        enumValues: {
          "none": 0,
          "created": 1,
          "updated": 2,
          "deleted": 3
        }
      },
      MetadataOperation: {
        enumValues: {
          "add": 0,
          "remove": 1
        }
      },
      Result: {},
      ResultType: {
        enumValues: {
          "unknown": 0,
          "dependency": 1,
          "versionControl": 2
        }
      },
      SarifJobStatus: {
        enumValues: {
          "new": 0,
          "queued": 1,
          "completed": 2,
          "failed": 3
        }
      },
      SarifUploadStatus: {},
      SearchCriteria: {},
      Severity: {
        enumValues: {
          "low": 0,
          "medium": 1,
          "high": 2,
          "critical": 3,
          "note": 4,
          "warning": 5,
          "error": 6
        }
      },
      State: {
        enumValues: {
          "unknown": 0,
          "active": 1,
          "dismissed": 2,
          "fixed": 4,
          "autoDismissed": 8
        }
      },
      UxFilters: {}
    };
    exports2.TypeInfo.Alert.fields = {
      alertType: {
        enumType: exports2.TypeInfo.AlertType
      },
      confidence: {
        enumType: exports2.TypeInfo.Confidence
      },
      dismissal: {
        typeInfo: exports2.TypeInfo.Dismissal
      },
      firstSeenDate: {
        isDate: true
      },
      fixedDate: {
        isDate: true
      },
      introducedDate: {
        isDate: true
      },
      lastSeenDate: {
        isDate: true
      },
      severity: {
        enumType: exports2.TypeInfo.Severity
      },
      state: {
        enumType: exports2.TypeInfo.State
      }
    };
    exports2.TypeInfo.AlertAnalysisInstance.fields = {
      analysisConfiguration: {
        typeInfo: exports2.TypeInfo.AnalysisConfiguration
      },
      firstSeen: {
        typeInfo: exports2.TypeInfo.AnalysisInstance
      },
      fixedIn: {
        typeInfo: exports2.TypeInfo.AnalysisInstance
      },
      lastSeen: {
        typeInfo: exports2.TypeInfo.AnalysisInstance
      },
      recentAnalysisInstance: {
        typeInfo: exports2.TypeInfo.AnalysisInstance
      },
      state: {
        enumType: exports2.TypeInfo.State
      }
    };
    exports2.TypeInfo.AlertMetadata.fields = {
      metadata: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Metadata
      }
    };
    exports2.TypeInfo.AlertMetadataChange.fields = {
      metadataChange: {
        typeInfo: exports2.TypeInfo.MetadataChange
      }
    };
    exports2.TypeInfo.AlertStateUpdate.fields = {
      dismissedReason: {
        enumType: exports2.TypeInfo.DismissalType
      },
      state: {
        enumType: exports2.TypeInfo.State
      }
    };
    exports2.TypeInfo.AnalysisConfiguration.fields = {
      analysisConfigurationType: {
        enumType: exports2.TypeInfo.AnalysisConfigurationType
      }
    };
    exports2.TypeInfo.AnalysisInstance.fields = {
      configuration: {
        typeInfo: exports2.TypeInfo.AnalysisConfiguration
      },
      createdDate: {
        isDate: true
      },
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.AnalysisResult
      }
    };
    exports2.TypeInfo.AnalysisResult.fields = {
      result: {
        typeInfo: exports2.TypeInfo.Result
      },
      state: {
        enumType: exports2.TypeInfo.State
      }
    };
    exports2.TypeInfo.Branch.fields = {
      deletedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.Dependency.fields = {
      componentType: {
        enumType: exports2.TypeInfo.ComponentType
      }
    };
    exports2.TypeInfo.DependencyResult.fields = {
      dependency: {
        typeInfo: exports2.TypeInfo.Dependency
      }
    };
    exports2.TypeInfo.Dismissal.fields = {
      dismissalType: {
        enumType: exports2.TypeInfo.DismissalType
      },
      requestedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.Metadata.fields = {
      op: {
        enumType: exports2.TypeInfo.MetadataOperation
      }
    };
    exports2.TypeInfo.MetadataChange.fields = {
      changeType: {
        enumType: exports2.TypeInfo.MetadataChangeType
      }
    };
    exports2.TypeInfo.Result.fields = {
      dependencyResult: {
        typeInfo: exports2.TypeInfo.DependencyResult
      },
      resultType: {
        enumType: exports2.TypeInfo.ResultType
      },
      severity: {
        enumType: exports2.TypeInfo.Severity
      }
    };
    exports2.TypeInfo.SarifUploadStatus.fields = {
      processingStatus: {
        enumType: exports2.TypeInfo.SarifJobStatus
      }
    };
    exports2.TypeInfo.SearchCriteria.fields = {
      alertType: {
        enumType: exports2.TypeInfo.AlertType
      },
      confidenceLevels: {
        isArray: true,
        enumType: exports2.TypeInfo.Confidence
      },
      fromDate: {
        isDate: true
      },
      modifiedSince: {
        isDate: true
      },
      severities: {
        isArray: true,
        enumType: exports2.TypeInfo.Severity
      },
      states: {
        isArray: true,
        enumType: exports2.TypeInfo.State
      },
      toDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.UxFilters.fields = {
      branches: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Branch
      },
      confidenceLevels: {
        isArray: true,
        enumType: exports2.TypeInfo.Confidence
      },
      packages: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Dependency
      },
      severities: {
        isArray: true,
        enumType: exports2.TypeInfo.Severity
      },
      states: {
        isArray: true,
        enumType: exports2.TypeInfo.State
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/AlertApi.js
var require_AlertApi = __commonJS({
  "../node_modules/azure-devops-node-api/AlertApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AlertApi = void 0;
    var basem = require_ClientApiBases();
    var AlertInterfaces = require_AlertInterfaces();
    var AlertApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Alert-api", options);
      }
      /**
       * Get an alert.
       *
       * @param {string} project - Project ID or project name
       * @param {number} alertId - ID of alert to retrieve
       * @param {string} repository - Name or id  of a repository that alert is part of
       * @param {string} ref
       * @param {AlertInterfaces.ExpandOption} expand - Expand alert attributes. Possible options are {ValidationFingerprint, None}
       */
      getAlert(project, alertId, repository, ref, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              alertId,
              repository
            };
            let queryValues = {
              ref,
              expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "e21b4630-b7d2-4031-99e3-3ad328cc4a7f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, AlertInterfaces.TypeInfo.Alert, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get alerts for a repository
       *
       * @param {string} project - Project ID or project name
       * @param {string} repository - The name or ID of the repository
       * @param {number} top - The maximum number of alerts to return
       * @param {string} orderBy - Must be "id" "firstSeen" "lastSeen" "fixedOn" or "severity"  Defaults to "id"
       * @param {AlertInterfaces.SearchCriteria} criteria - Options to limit the alerts returned
       * @param {string} continuationToken - If there are more alerts than can be returned, a continuation token is placed in the "x-ms-continuationtoken" header.  Use that token here to get the next page of alerts
       */
      getAlerts(project, repository, top, orderBy, criteria, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repository
            };
            let queryValues = {
              top,
              orderBy,
              criteria,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "e21b4630-b7d2-4031-99e3-3ad328cc4a7f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, AlertInterfaces.TypeInfo.Alert, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get an alert.
       *
       * @param {string} project - Project ID or project name
       * @param {number} alertId - ID of alert to retrieve
       * @param {string} repository - Name or id  of a repository that alert is part of
       * @param {string} ref
       * @param {AlertInterfaces.ExpandOption} expand - Expand alert attributes. Possible options are {ValidationFingerprint, None}
       */
      getAlertSarif(project, alertId, repository, ref, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              alertId,
              repository
            };
            let queryValues = {
              ref,
              expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "e21b4630-b7d2-4031-99e3-3ad328cc4a7f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the status of an alert
       *
       * @param {AlertInterfaces.AlertStateUpdate} stateUpdate - The new status of the alert
       * @param {string} project - Project ID or project name
       * @param {number} alertId - The ID of the alert
       * @param {string} repository - The name or ID of the repository
       */
      updateAlert(stateUpdate, project, alertId, repository) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              alertId,
              repository
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "e21b4630-b7d2-4031-99e3-3ad328cc4a7f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, stateUpdate, options);
              let ret = this.formatResponse(res.result, AlertInterfaces.TypeInfo.Alert, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get instances of an alert.
       *
       * @param {string} project - Project ID or project name
       * @param {number} alertId - ID of alert to retrieve
       * @param {string} repository - Name or id of a repository that alert is part of
       * @param {string} ref
       */
      getAlertInstances(project, alertId, repository, ref) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              alertId,
              repository
            };
            let queryValues = {
              ref
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "f451ba96-0e95-458a-8dd5-3df894770a49", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, AlertInterfaces.TypeInfo.AlertAnalysisInstance, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update alert metadata associations.
       *
       * @param {AlertInterfaces.AlertMetadata[]} alertsMetadata - A list of metadata to associate with alerts.
       * @param {string} project - Project ID or project name
       * @param {string} repository - The name or ID of the repository.
       */
      updateAlertsMetadata(alertsMetadata, project, repository) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repository
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "65de4b84-7519-4ae8-8623-175f79b49b80", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, alertsMetadata, options);
              let ret = this.formatResponse(res.result, AlertInterfaces.TypeInfo.AlertMetadataChange, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Upload a Sarif containing security alerts
       *
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} project - Project ID or project name
       * @param {string} repository - The name or ID of a repository
       */
      uploadSarif(customHeaders, contentStream, project, repository) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repository
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "2a141cae-a50d-4c22-b41b-13f77748d035", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} repository
       * @param {AlertInterfaces.AlertType} alertType
       */
      getUxFilters(project, repository, alertType) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (alertType == null) {
            throw new TypeError("alertType can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repository
            };
            let queryValues = {
              alertType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Alert", "8f90675b-f794-434d-8f2c-cfae0a11c02a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, AlertInterfaces.TypeInfo.UxFilters, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the status of the Sarif processing job
       *
       * @param {number} sarifId - Sarif ID returned when the Sarif was uploaded
       */
      getSarif(sarifId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              sarifId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Alert", "a04689e7-0f81-48a2-8d18-40654c47494c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, AlertInterfaces.TypeInfo.SarifUploadStatus, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.AlertApi = AlertApi;
  }
});

// ../node_modules/azure-devops-node-api/interfaces/common/SystemDataInterfaces.js
var require_SystemDataInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/common/SystemDataInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.SqlDbType = void 0;
    var SqlDbType;
    (function(SqlDbType2) {
      SqlDbType2[SqlDbType2["BigInt"] = 0] = "BigInt";
      SqlDbType2[SqlDbType2["Binary"] = 1] = "Binary";
      SqlDbType2[SqlDbType2["Bit"] = 2] = "Bit";
      SqlDbType2[SqlDbType2["Char"] = 3] = "Char";
      SqlDbType2[SqlDbType2["DateTime"] = 4] = "DateTime";
      SqlDbType2[SqlDbType2["Decimal"] = 5] = "Decimal";
      SqlDbType2[SqlDbType2["Float"] = 6] = "Float";
      SqlDbType2[SqlDbType2["Image"] = 7] = "Image";
      SqlDbType2[SqlDbType2["Int"] = 8] = "Int";
      SqlDbType2[SqlDbType2["Money"] = 9] = "Money";
      SqlDbType2[SqlDbType2["NChar"] = 10] = "NChar";
      SqlDbType2[SqlDbType2["NText"] = 11] = "NText";
      SqlDbType2[SqlDbType2["NVarChar"] = 12] = "NVarChar";
      SqlDbType2[SqlDbType2["Real"] = 13] = "Real";
      SqlDbType2[SqlDbType2["UniqueIdentifier"] = 14] = "UniqueIdentifier";
      SqlDbType2[SqlDbType2["SmallDateTime"] = 15] = "SmallDateTime";
      SqlDbType2[SqlDbType2["SmallInt"] = 16] = "SmallInt";
      SqlDbType2[SqlDbType2["SmallMoney"] = 17] = "SmallMoney";
      SqlDbType2[SqlDbType2["Text"] = 18] = "Text";
      SqlDbType2[SqlDbType2["Timestamp"] = 19] = "Timestamp";
      SqlDbType2[SqlDbType2["TinyInt"] = 20] = "TinyInt";
      SqlDbType2[SqlDbType2["VarBinary"] = 21] = "VarBinary";
      SqlDbType2[SqlDbType2["VarChar"] = 22] = "VarChar";
      SqlDbType2[SqlDbType2["Variant"] = 23] = "Variant";
      SqlDbType2[SqlDbType2["Xml"] = 25] = "Xml";
      SqlDbType2[SqlDbType2["Udt"] = 29] = "Udt";
      SqlDbType2[SqlDbType2["Structured"] = 30] = "Structured";
      SqlDbType2[SqlDbType2["Date"] = 31] = "Date";
      SqlDbType2[SqlDbType2["Time"] = 32] = "Time";
      SqlDbType2[SqlDbType2["DateTime2"] = 33] = "DateTime2";
      SqlDbType2[SqlDbType2["DateTimeOffset"] = 34] = "DateTimeOffset";
    })(SqlDbType = exports2.SqlDbType || (exports2.SqlDbType = {}));
    exports2.TypeInfo = {
      SqlDbType: {
        enumValues: {
          "BigInt": 0,
          "Binary": 1,
          "Bit": 2,
          "Char": 3,
          "DateTime": 4,
          "Decimal": 5,
          "Float": 6,
          "Image": 7,
          "Int": 8,
          "Money": 9,
          "NChar": 10,
          "NText": 11,
          "NVarChar": 12,
          "Real": 13,
          "UniqueIdentifier": 14,
          "SmallDateTime": 15,
          "SmallInt": 16,
          "SmallMoney": 17,
          "Text": 18,
          "Timestamp": 19,
          "TinyInt": 20,
          "VarBinary": 21,
          "VarChar": 22,
          "Variant": 23,
          "Xml": 25,
          "Udt": 29,
          "Structured": 30,
          "Date": 31,
          "Time": 32,
          "DateTime2": 33,
          "DateTimeOffset": 34
        }
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/interfaces/TestInterfaces.js
var require_TestInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/TestInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.TestSessionState = exports2.TestSessionSource = exports2.TestRunSubstate = exports2.TestRunState = exports2.TestRunPublishContext = exports2.TestRunOutcome = exports2.TestResultsSettingsType = exports2.TestResultsSessionState = exports2.TestResultsContextType = exports2.TestResultGroupBy = exports2.TestPointState = exports2.TestOutcome = exports2.TestLogType = exports2.TestLogStoreOperationType = exports2.TestLogStoreEndpointType = exports2.TestLogStatusCode = exports2.TestLogScope = exports2.TestConfigurationState = exports2.TCMServiceDataMigrationStatus = exports2.SuiteExpand = exports2.SessionTimelineType = exports2.SessionResult = exports2.Service = exports2.RunType = exports2.ResultObjectType = exports2.ResultMetaDataDetails = exports2.ResultMetadata = exports2.ResultGroupType = exports2.ResultDetails = exports2.OperationType = exports2.Metrics = exports2.FlakyDetectionType = exports2.CustomTestFieldType = exports2.CustomTestFieldScope = exports2.CoverageSummaryStatus = exports2.CoverageStatus = exports2.CoverageQueryFlags = exports2.CoverageDetailedSummaryStatus = exports2.CloneOperationState = exports2.AttachmentType = void 0;
    var SystemData = require_SystemDataInterfaces();
    var TfsCoreInterfaces = require_CoreInterfaces();
    var AttachmentType;
    (function(AttachmentType2) {
      AttachmentType2[AttachmentType2["GeneralAttachment"] = 0] = "GeneralAttachment";
      AttachmentType2[AttachmentType2["AfnStrip"] = 1] = "AfnStrip";
      AttachmentType2[AttachmentType2["BugFilingData"] = 2] = "BugFilingData";
      AttachmentType2[AttachmentType2["CodeCoverage"] = 3] = "CodeCoverage";
      AttachmentType2[AttachmentType2["IntermediateCollectorData"] = 4] = "IntermediateCollectorData";
      AttachmentType2[AttachmentType2["RunConfig"] = 5] = "RunConfig";
      AttachmentType2[AttachmentType2["TestImpactDetails"] = 6] = "TestImpactDetails";
      AttachmentType2[AttachmentType2["TmiTestRunDeploymentFiles"] = 7] = "TmiTestRunDeploymentFiles";
      AttachmentType2[AttachmentType2["TmiTestRunReverseDeploymentFiles"] = 8] = "TmiTestRunReverseDeploymentFiles";
      AttachmentType2[AttachmentType2["TmiTestResultDetail"] = 9] = "TmiTestResultDetail";
      AttachmentType2[AttachmentType2["TmiTestRunSummary"] = 10] = "TmiTestRunSummary";
      AttachmentType2[AttachmentType2["ConsoleLog"] = 11] = "ConsoleLog";
    })(AttachmentType = exports2.AttachmentType || (exports2.AttachmentType = {}));
    var CloneOperationState;
    (function(CloneOperationState2) {
      CloneOperationState2[CloneOperationState2["Failed"] = 2] = "Failed";
      CloneOperationState2[CloneOperationState2["InProgress"] = 1] = "InProgress";
      CloneOperationState2[CloneOperationState2["Queued"] = 0] = "Queued";
      CloneOperationState2[CloneOperationState2["Succeeded"] = 3] = "Succeeded";
    })(CloneOperationState = exports2.CloneOperationState || (exports2.CloneOperationState = {}));
    var CoverageDetailedSummaryStatus;
    (function(CoverageDetailedSummaryStatus2) {
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["None"] = 0] = "None";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["InProgress"] = 1] = "InProgress";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["Finalized"] = 2] = "Finalized";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["Pending"] = 3] = "Pending";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["UpdateRequestQueued"] = 4] = "UpdateRequestQueued";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["NoModulesFound"] = 5] = "NoModulesFound";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["NumberOfFilesExceeded"] = 6] = "NumberOfFilesExceeded";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["NoInputFiles"] = 7] = "NoInputFiles";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["BuildCancelled"] = 8] = "BuildCancelled";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["FailedJobs"] = 9] = "FailedJobs";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["ModuleMergeJobTimeout"] = 10] = "ModuleMergeJobTimeout";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["CodeCoverageSuccess"] = 11] = "CodeCoverageSuccess";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["InvalidBuildConfiguration"] = 12] = "InvalidBuildConfiguration";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["CoverageAnalyzerBuildNotFound"] = 13] = "CoverageAnalyzerBuildNotFound";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["FailedToRequeue"] = 14] = "FailedToRequeue";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["BuildBailedOut"] = 15] = "BuildBailedOut";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["NoCodeCoverageTask"] = 16] = "NoCodeCoverageTask";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["MergeJobFailed"] = 17] = "MergeJobFailed";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["MergeInvokerJobFailed"] = 18] = "MergeInvokerJobFailed";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["MonitorJobFailed"] = 19] = "MonitorJobFailed";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["ModuleMergeInvokerJobTimeout"] = 20] = "ModuleMergeInvokerJobTimeout";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["MonitorJobTimeout"] = 21] = "MonitorJobTimeout";
      CoverageDetailedSummaryStatus2[CoverageDetailedSummaryStatus2["InvalidCoverageInput"] = 22] = "InvalidCoverageInput";
    })(CoverageDetailedSummaryStatus = exports2.CoverageDetailedSummaryStatus || (exports2.CoverageDetailedSummaryStatus = {}));
    var CoverageQueryFlags;
    (function(CoverageQueryFlags2) {
      CoverageQueryFlags2[CoverageQueryFlags2["Modules"] = 1] = "Modules";
      CoverageQueryFlags2[CoverageQueryFlags2["Functions"] = 2] = "Functions";
      CoverageQueryFlags2[CoverageQueryFlags2["BlockData"] = 4] = "BlockData";
    })(CoverageQueryFlags = exports2.CoverageQueryFlags || (exports2.CoverageQueryFlags = {}));
    var CoverageStatus;
    (function(CoverageStatus2) {
      CoverageStatus2[CoverageStatus2["Covered"] = 0] = "Covered";
      CoverageStatus2[CoverageStatus2["NotCovered"] = 1] = "NotCovered";
      CoverageStatus2[CoverageStatus2["PartiallyCovered"] = 2] = "PartiallyCovered";
    })(CoverageStatus = exports2.CoverageStatus || (exports2.CoverageStatus = {}));
    var CoverageSummaryStatus;
    (function(CoverageSummaryStatus2) {
      CoverageSummaryStatus2[CoverageSummaryStatus2["None"] = 0] = "None";
      CoverageSummaryStatus2[CoverageSummaryStatus2["InProgress"] = 1] = "InProgress";
      CoverageSummaryStatus2[CoverageSummaryStatus2["Completed"] = 2] = "Completed";
      CoverageSummaryStatus2[CoverageSummaryStatus2["Finalized"] = 3] = "Finalized";
      CoverageSummaryStatus2[CoverageSummaryStatus2["Pending"] = 4] = "Pending";
      CoverageSummaryStatus2[CoverageSummaryStatus2["UpdateRequestQueued"] = 5] = "UpdateRequestQueued";
    })(CoverageSummaryStatus = exports2.CoverageSummaryStatus || (exports2.CoverageSummaryStatus = {}));
    var CustomTestFieldScope;
    (function(CustomTestFieldScope2) {
      CustomTestFieldScope2[CustomTestFieldScope2["None"] = 0] = "None";
      CustomTestFieldScope2[CustomTestFieldScope2["TestRun"] = 1] = "TestRun";
      CustomTestFieldScope2[CustomTestFieldScope2["TestResult"] = 2] = "TestResult";
      CustomTestFieldScope2[CustomTestFieldScope2["System"] = 4] = "System";
      CustomTestFieldScope2[CustomTestFieldScope2["All"] = 7] = "All";
    })(CustomTestFieldScope = exports2.CustomTestFieldScope || (exports2.CustomTestFieldScope = {}));
    var CustomTestFieldType;
    (function(CustomTestFieldType2) {
      CustomTestFieldType2[CustomTestFieldType2["Bit"] = 2] = "Bit";
      CustomTestFieldType2[CustomTestFieldType2["DateTime"] = 4] = "DateTime";
      CustomTestFieldType2[CustomTestFieldType2["Int"] = 8] = "Int";
      CustomTestFieldType2[CustomTestFieldType2["Float"] = 6] = "Float";
      CustomTestFieldType2[CustomTestFieldType2["String"] = 12] = "String";
      CustomTestFieldType2[CustomTestFieldType2["Guid"] = 14] = "Guid";
    })(CustomTestFieldType = exports2.CustomTestFieldType || (exports2.CustomTestFieldType = {}));
    var FlakyDetectionType;
    (function(FlakyDetectionType2) {
      FlakyDetectionType2[FlakyDetectionType2["Custom"] = 1] = "Custom";
      FlakyDetectionType2[FlakyDetectionType2["System"] = 2] = "System";
    })(FlakyDetectionType = exports2.FlakyDetectionType || (exports2.FlakyDetectionType = {}));
    var Metrics;
    (function(Metrics2) {
      Metrics2[Metrics2["All"] = 1] = "All";
      Metrics2[Metrics2["ResultSummary"] = 2] = "ResultSummary";
      Metrics2[Metrics2["ResultsAnalysis"] = 3] = "ResultsAnalysis";
      Metrics2[Metrics2["RunSummary"] = 4] = "RunSummary";
    })(Metrics = exports2.Metrics || (exports2.Metrics = {}));
    var OperationType;
    (function(OperationType2) {
      OperationType2[OperationType2["Add"] = 1] = "Add";
      OperationType2[OperationType2["Delete"] = 2] = "Delete";
    })(OperationType = exports2.OperationType || (exports2.OperationType = {}));
    var ResultDetails;
    (function(ResultDetails2) {
      ResultDetails2[ResultDetails2["None"] = 0] = "None";
      ResultDetails2[ResultDetails2["Iterations"] = 1] = "Iterations";
      ResultDetails2[ResultDetails2["WorkItems"] = 2] = "WorkItems";
      ResultDetails2[ResultDetails2["SubResults"] = 4] = "SubResults";
      ResultDetails2[ResultDetails2["Point"] = 8] = "Point";
    })(ResultDetails = exports2.ResultDetails || (exports2.ResultDetails = {}));
    var ResultGroupType;
    (function(ResultGroupType2) {
      ResultGroupType2[ResultGroupType2["None"] = 0] = "None";
      ResultGroupType2[ResultGroupType2["Rerun"] = 1] = "Rerun";
      ResultGroupType2[ResultGroupType2["DataDriven"] = 2] = "DataDriven";
      ResultGroupType2[ResultGroupType2["OrderedTest"] = 3] = "OrderedTest";
      ResultGroupType2[ResultGroupType2["Generic"] = 4] = "Generic";
    })(ResultGroupType = exports2.ResultGroupType || (exports2.ResultGroupType = {}));
    var ResultMetadata;
    (function(ResultMetadata2) {
      ResultMetadata2[ResultMetadata2["Rerun"] = 1] = "Rerun";
      ResultMetadata2[ResultMetadata2["Flaky"] = 2] = "Flaky";
    })(ResultMetadata = exports2.ResultMetadata || (exports2.ResultMetadata = {}));
    var ResultMetaDataDetails;
    (function(ResultMetaDataDetails2) {
      ResultMetaDataDetails2[ResultMetaDataDetails2["None"] = 0] = "None";
      ResultMetaDataDetails2[ResultMetaDataDetails2["FlakyIdentifiers"] = 1] = "FlakyIdentifiers";
    })(ResultMetaDataDetails = exports2.ResultMetaDataDetails || (exports2.ResultMetaDataDetails = {}));
    var ResultObjectType;
    (function(ResultObjectType2) {
      ResultObjectType2[ResultObjectType2["TestSuite"] = 0] = "TestSuite";
      ResultObjectType2[ResultObjectType2["TestPlan"] = 1] = "TestPlan";
    })(ResultObjectType = exports2.ResultObjectType || (exports2.ResultObjectType = {}));
    var RunType;
    (function(RunType2) {
      RunType2[RunType2["Unspecified"] = 0] = "Unspecified";
      RunType2[RunType2["Normal"] = 1] = "Normal";
      RunType2[RunType2["Blocking"] = 2] = "Blocking";
      RunType2[RunType2["Web"] = 4] = "Web";
      RunType2[RunType2["MtrRunInitiatedFromWeb"] = 8] = "MtrRunInitiatedFromWeb";
      RunType2[RunType2["RunWithDtlEnv"] = 16] = "RunWithDtlEnv";
      RunType2[RunType2["NoConfigRun"] = 32] = "NoConfigRun";
    })(RunType = exports2.RunType || (exports2.RunType = {}));
    var Service;
    (function(Service2) {
      Service2[Service2["Any"] = 0] = "Any";
      Service2[Service2["Tcm"] = 1] = "Tcm";
      Service2[Service2["Tfs"] = 2] = "Tfs";
    })(Service = exports2.Service || (exports2.Service = {}));
    var SessionResult;
    (function(SessionResult2) {
      SessionResult2[SessionResult2["None"] = 0] = "None";
      SessionResult2[SessionResult2["Passed"] = 1] = "Passed";
      SessionResult2[SessionResult2["Failed"] = 2] = "Failed";
    })(SessionResult = exports2.SessionResult || (exports2.SessionResult = {}));
    var SessionTimelineType;
    (function(SessionTimelineType2) {
      SessionTimelineType2[SessionTimelineType2["None"] = 0] = "None";
      SessionTimelineType2[SessionTimelineType2["Queued"] = 1] = "Queued";
      SessionTimelineType2[SessionTimelineType2["Completed"] = 2] = "Completed";
      SessionTimelineType2[SessionTimelineType2["Started"] = 3] = "Started";
    })(SessionTimelineType = exports2.SessionTimelineType || (exports2.SessionTimelineType = {}));
    var SuiteExpand;
    (function(SuiteExpand2) {
      SuiteExpand2[SuiteExpand2["Children"] = 1] = "Children";
      SuiteExpand2[SuiteExpand2["DefaultTesters"] = 2] = "DefaultTesters";
    })(SuiteExpand = exports2.SuiteExpand || (exports2.SuiteExpand = {}));
    var TCMServiceDataMigrationStatus;
    (function(TCMServiceDataMigrationStatus2) {
      TCMServiceDataMigrationStatus2[TCMServiceDataMigrationStatus2["NotStarted"] = 0] = "NotStarted";
      TCMServiceDataMigrationStatus2[TCMServiceDataMigrationStatus2["InProgress"] = 1] = "InProgress";
      TCMServiceDataMigrationStatus2[TCMServiceDataMigrationStatus2["Completed"] = 2] = "Completed";
      TCMServiceDataMigrationStatus2[TCMServiceDataMigrationStatus2["Failed"] = 3] = "Failed";
    })(TCMServiceDataMigrationStatus = exports2.TCMServiceDataMigrationStatus || (exports2.TCMServiceDataMigrationStatus = {}));
    var TestConfigurationState;
    (function(TestConfigurationState2) {
      TestConfigurationState2[TestConfigurationState2["Active"] = 1] = "Active";
      TestConfigurationState2[TestConfigurationState2["Inactive"] = 2] = "Inactive";
    })(TestConfigurationState = exports2.TestConfigurationState || (exports2.TestConfigurationState = {}));
    var TestLogScope;
    (function(TestLogScope2) {
      TestLogScope2[TestLogScope2["Run"] = 0] = "Run";
      TestLogScope2[TestLogScope2["Build"] = 1] = "Build";
      TestLogScope2[TestLogScope2["Release"] = 2] = "Release";
    })(TestLogScope = exports2.TestLogScope || (exports2.TestLogScope = {}));
    var TestLogStatusCode;
    (function(TestLogStatusCode2) {
      TestLogStatusCode2[TestLogStatusCode2["Success"] = 0] = "Success";
      TestLogStatusCode2[TestLogStatusCode2["Failed"] = 1] = "Failed";
      TestLogStatusCode2[TestLogStatusCode2["FileAlreadyExists"] = 2] = "FileAlreadyExists";
      TestLogStatusCode2[TestLogStatusCode2["InvalidInput"] = 3] = "InvalidInput";
      TestLogStatusCode2[TestLogStatusCode2["InvalidFileName"] = 4] = "InvalidFileName";
      TestLogStatusCode2[TestLogStatusCode2["InvalidContainer"] = 5] = "InvalidContainer";
      TestLogStatusCode2[TestLogStatusCode2["TransferFailed"] = 6] = "TransferFailed";
      TestLogStatusCode2[TestLogStatusCode2["FeatureDisabled"] = 7] = "FeatureDisabled";
      TestLogStatusCode2[TestLogStatusCode2["BuildDoesNotExist"] = 8] = "BuildDoesNotExist";
      TestLogStatusCode2[TestLogStatusCode2["RunDoesNotExist"] = 9] = "RunDoesNotExist";
      TestLogStatusCode2[TestLogStatusCode2["ContainerNotCreated"] = 10] = "ContainerNotCreated";
      TestLogStatusCode2[TestLogStatusCode2["APINotSupported"] = 11] = "APINotSupported";
      TestLogStatusCode2[TestLogStatusCode2["FileSizeExceeds"] = 12] = "FileSizeExceeds";
      TestLogStatusCode2[TestLogStatusCode2["ContainerNotFound"] = 13] = "ContainerNotFound";
      TestLogStatusCode2[TestLogStatusCode2["FileNotFound"] = 14] = "FileNotFound";
      TestLogStatusCode2[TestLogStatusCode2["DirectoryNotFound"] = 15] = "DirectoryNotFound";
      TestLogStatusCode2[TestLogStatusCode2["StorageCapacityExceeded"] = 16] = "StorageCapacityExceeded";
    })(TestLogStatusCode = exports2.TestLogStatusCode || (exports2.TestLogStatusCode = {}));
    var TestLogStoreEndpointType;
    (function(TestLogStoreEndpointType2) {
      TestLogStoreEndpointType2[TestLogStoreEndpointType2["Root"] = 1] = "Root";
      TestLogStoreEndpointType2[TestLogStoreEndpointType2["File"] = 2] = "File";
    })(TestLogStoreEndpointType = exports2.TestLogStoreEndpointType || (exports2.TestLogStoreEndpointType = {}));
    var TestLogStoreOperationType;
    (function(TestLogStoreOperationType2) {
      TestLogStoreOperationType2[TestLogStoreOperationType2["Read"] = 1] = "Read";
      TestLogStoreOperationType2[TestLogStoreOperationType2["Create"] = 2] = "Create";
      TestLogStoreOperationType2[TestLogStoreOperationType2["ReadAndCreate"] = 3] = "ReadAndCreate";
    })(TestLogStoreOperationType = exports2.TestLogStoreOperationType || (exports2.TestLogStoreOperationType = {}));
    var TestLogType;
    (function(TestLogType2) {
      TestLogType2[TestLogType2["GeneralAttachment"] = 1] = "GeneralAttachment";
      TestLogType2[TestLogType2["CodeCoverage"] = 2] = "CodeCoverage";
      TestLogType2[TestLogType2["TestImpact"] = 3] = "TestImpact";
      TestLogType2[TestLogType2["Intermediate"] = 4] = "Intermediate";
      TestLogType2[TestLogType2["System"] = 5] = "System";
      TestLogType2[TestLogType2["MergedCoverageFile"] = 6] = "MergedCoverageFile";
    })(TestLogType = exports2.TestLogType || (exports2.TestLogType = {}));
    var TestOutcome;
    (function(TestOutcome2) {
      TestOutcome2[TestOutcome2["Unspecified"] = 0] = "Unspecified";
      TestOutcome2[TestOutcome2["None"] = 1] = "None";
      TestOutcome2[TestOutcome2["Passed"] = 2] = "Passed";
      TestOutcome2[TestOutcome2["Failed"] = 3] = "Failed";
      TestOutcome2[TestOutcome2["Inconclusive"] = 4] = "Inconclusive";
      TestOutcome2[TestOutcome2["Timeout"] = 5] = "Timeout";
      TestOutcome2[TestOutcome2["Aborted"] = 6] = "Aborted";
      TestOutcome2[TestOutcome2["Blocked"] = 7] = "Blocked";
      TestOutcome2[TestOutcome2["NotExecuted"] = 8] = "NotExecuted";
      TestOutcome2[TestOutcome2["Warning"] = 9] = "Warning";
      TestOutcome2[TestOutcome2["Error"] = 10] = "Error";
      TestOutcome2[TestOutcome2["NotApplicable"] = 11] = "NotApplicable";
      TestOutcome2[TestOutcome2["Paused"] = 12] = "Paused";
      TestOutcome2[TestOutcome2["InProgress"] = 13] = "InProgress";
      TestOutcome2[TestOutcome2["NotImpacted"] = 14] = "NotImpacted";
      TestOutcome2[TestOutcome2["MaxValue"] = 14] = "MaxValue";
    })(TestOutcome = exports2.TestOutcome || (exports2.TestOutcome = {}));
    var TestPointState;
    (function(TestPointState2) {
      TestPointState2[TestPointState2["None"] = 0] = "None";
      TestPointState2[TestPointState2["Ready"] = 1] = "Ready";
      TestPointState2[TestPointState2["Completed"] = 2] = "Completed";
      TestPointState2[TestPointState2["NotReady"] = 3] = "NotReady";
      TestPointState2[TestPointState2["InProgress"] = 4] = "InProgress";
      TestPointState2[TestPointState2["MaxValue"] = 4] = "MaxValue";
    })(TestPointState = exports2.TestPointState || (exports2.TestPointState = {}));
    var TestResultGroupBy;
    (function(TestResultGroupBy2) {
      TestResultGroupBy2[TestResultGroupBy2["Branch"] = 1] = "Branch";
      TestResultGroupBy2[TestResultGroupBy2["Environment"] = 2] = "Environment";
    })(TestResultGroupBy = exports2.TestResultGroupBy || (exports2.TestResultGroupBy = {}));
    var TestResultsContextType;
    (function(TestResultsContextType2) {
      TestResultsContextType2[TestResultsContextType2["Build"] = 1] = "Build";
      TestResultsContextType2[TestResultsContextType2["Release"] = 2] = "Release";
      TestResultsContextType2[TestResultsContextType2["Pipeline"] = 3] = "Pipeline";
    })(TestResultsContextType = exports2.TestResultsContextType || (exports2.TestResultsContextType = {}));
    var TestResultsSessionState;
    (function(TestResultsSessionState2) {
      TestResultsSessionState2[TestResultsSessionState2["None"] = 0] = "None";
      TestResultsSessionState2[TestResultsSessionState2["Running"] = 1] = "Running";
      TestResultsSessionState2[TestResultsSessionState2["Completed"] = 2] = "Completed";
      TestResultsSessionState2[TestResultsSessionState2["Waiting"] = 3] = "Waiting";
      TestResultsSessionState2[TestResultsSessionState2["Cancelled"] = 4] = "Cancelled";
    })(TestResultsSessionState = exports2.TestResultsSessionState || (exports2.TestResultsSessionState = {}));
    var TestResultsSettingsType;
    (function(TestResultsSettingsType2) {
      TestResultsSettingsType2[TestResultsSettingsType2["All"] = 1] = "All";
      TestResultsSettingsType2[TestResultsSettingsType2["Flaky"] = 2] = "Flaky";
      TestResultsSettingsType2[TestResultsSettingsType2["NewTestLogging"] = 3] = "NewTestLogging";
    })(TestResultsSettingsType = exports2.TestResultsSettingsType || (exports2.TestResultsSettingsType = {}));
    var TestRunOutcome;
    (function(TestRunOutcome2) {
      TestRunOutcome2[TestRunOutcome2["Passed"] = 0] = "Passed";
      TestRunOutcome2[TestRunOutcome2["Failed"] = 1] = "Failed";
      TestRunOutcome2[TestRunOutcome2["NotImpacted"] = 2] = "NotImpacted";
      TestRunOutcome2[TestRunOutcome2["Others"] = 3] = "Others";
    })(TestRunOutcome = exports2.TestRunOutcome || (exports2.TestRunOutcome = {}));
    var TestRunPublishContext;
    (function(TestRunPublishContext2) {
      TestRunPublishContext2[TestRunPublishContext2["Build"] = 1] = "Build";
      TestRunPublishContext2[TestRunPublishContext2["Release"] = 2] = "Release";
      TestRunPublishContext2[TestRunPublishContext2["All"] = 3] = "All";
    })(TestRunPublishContext = exports2.TestRunPublishContext || (exports2.TestRunPublishContext = {}));
    var TestRunState;
    (function(TestRunState2) {
      TestRunState2[TestRunState2["Unspecified"] = 0] = "Unspecified";
      TestRunState2[TestRunState2["NotStarted"] = 1] = "NotStarted";
      TestRunState2[TestRunState2["InProgress"] = 2] = "InProgress";
      TestRunState2[TestRunState2["Completed"] = 3] = "Completed";
      TestRunState2[TestRunState2["Aborted"] = 4] = "Aborted";
      TestRunState2[TestRunState2["Waiting"] = 5] = "Waiting";
      TestRunState2[TestRunState2["NeedsInvestigation"] = 6] = "NeedsInvestigation";
    })(TestRunState = exports2.TestRunState || (exports2.TestRunState = {}));
    var TestRunSubstate;
    (function(TestRunSubstate2) {
      TestRunSubstate2[TestRunSubstate2["None"] = 0] = "None";
      TestRunSubstate2[TestRunSubstate2["CreatingEnvironment"] = 1] = "CreatingEnvironment";
      TestRunSubstate2[TestRunSubstate2["RunningTests"] = 2] = "RunningTests";
      TestRunSubstate2[TestRunSubstate2["CanceledByUser"] = 3] = "CanceledByUser";
      TestRunSubstate2[TestRunSubstate2["AbortedBySystem"] = 4] = "AbortedBySystem";
      TestRunSubstate2[TestRunSubstate2["TimedOut"] = 5] = "TimedOut";
      TestRunSubstate2[TestRunSubstate2["PendingAnalysis"] = 6] = "PendingAnalysis";
      TestRunSubstate2[TestRunSubstate2["Analyzed"] = 7] = "Analyzed";
      TestRunSubstate2[TestRunSubstate2["CancellationInProgress"] = 8] = "CancellationInProgress";
    })(TestRunSubstate = exports2.TestRunSubstate || (exports2.TestRunSubstate = {}));
    var TestSessionSource;
    (function(TestSessionSource2) {
      TestSessionSource2[TestSessionSource2["Unknown"] = 0] = "Unknown";
      TestSessionSource2[TestSessionSource2["XTDesktop"] = 1] = "XTDesktop";
      TestSessionSource2[TestSessionSource2["FeedbackDesktop"] = 2] = "FeedbackDesktop";
      TestSessionSource2[TestSessionSource2["XTWeb"] = 3] = "XTWeb";
      TestSessionSource2[TestSessionSource2["FeedbackWeb"] = 4] = "FeedbackWeb";
      TestSessionSource2[TestSessionSource2["XTDesktop2"] = 5] = "XTDesktop2";
      TestSessionSource2[TestSessionSource2["SessionInsightsForAll"] = 6] = "SessionInsightsForAll";
    })(TestSessionSource = exports2.TestSessionSource || (exports2.TestSessionSource = {}));
    var TestSessionState;
    (function(TestSessionState2) {
      TestSessionState2[TestSessionState2["Unspecified"] = 0] = "Unspecified";
      TestSessionState2[TestSessionState2["NotStarted"] = 1] = "NotStarted";
      TestSessionState2[TestSessionState2["InProgress"] = 2] = "InProgress";
      TestSessionState2[TestSessionState2["Paused"] = 3] = "Paused";
      TestSessionState2[TestSessionState2["Completed"] = 4] = "Completed";
      TestSessionState2[TestSessionState2["Declined"] = 5] = "Declined";
    })(TestSessionState = exports2.TestSessionState || (exports2.TestSessionState = {}));
    exports2.TypeInfo = {
      AfnStrip: {},
      AggregatedDataForResultTrend: {},
      AggregatedResultDetailsByOutcome: {},
      AggregatedResultsAnalysis: {},
      AggregatedResultsByOutcome: {},
      AggregatedRunsByOutcome: {},
      AggregatedRunsByState: {},
      AttachmentType: {
        enumValues: {
          "generalAttachment": 0,
          "afnStrip": 1,
          "bugFilingData": 2,
          "codeCoverage": 3,
          "intermediateCollectorData": 4,
          "runConfig": 5,
          "testImpactDetails": 6,
          "tmiTestRunDeploymentFiles": 7,
          "tmiTestRunReverseDeploymentFiles": 8,
          "tmiTestResultDetail": 9,
          "tmiTestRunSummary": 10,
          "consoleLog": 11
        }
      },
      BatchResponse: {},
      BuildConfiguration: {},
      BuildCoverage: {},
      BuildReference2: {},
      BulkResultUpdateRequest: {},
      CloneOperationInformation: {},
      CloneOperationState: {
        enumValues: {
          "failed": 2,
          "inProgress": 1,
          "queued": 0,
          "succeeded": 3
        }
      },
      CodeCoverageSummary: {},
      Coverage2: {},
      CoverageDetailedSummaryStatus: {
        enumValues: {
          "none": 0,
          "inProgress": 1,
          "finalized": 2,
          "pending": 3,
          "updateRequestQueued": 4,
          "noModulesFound": 5,
          "numberOfFilesExceeded": 6,
          "noInputFiles": 7,
          "buildCancelled": 8,
          "failedJobs": 9,
          "moduleMergeJobTimeout": 10,
          "codeCoverageSuccess": 11,
          "invalidBuildConfiguration": 12,
          "coverageAnalyzerBuildNotFound": 13,
          "failedToRequeue": 14,
          "buildBailedOut": 15,
          "noCodeCoverageTask": 16,
          "mergeJobFailed": 17,
          "mergeInvokerJobFailed": 18,
          "monitorJobFailed": 19,
          "moduleMergeInvokerJobTimeout": 20,
          "monitorJobTimeout": 21,
          "invalidCoverageInput": 22
        }
      },
      CoverageQueryFlags: {
        enumValues: {
          "modules": 1,
          "functions": 2,
          "blockData": 4
        }
      },
      CoverageStatus: {
        enumValues: {
          "covered": 0,
          "notCovered": 1,
          "partiallyCovered": 2
        }
      },
      CoverageSummaryStatus: {
        enumValues: {
          "none": 0,
          "inProgress": 1,
          "completed": 2,
          "finalized": 3,
          "pending": 4,
          "updateRequestQueued": 5
        }
      },
      CreateTestMessageLogEntryRequest: {},
      CreateTestResultsRequest: {},
      CreateTestRunRequest: {},
      CustomTestFieldDefinition: {},
      CustomTestFieldScope: {
        enumValues: {
          "none": 0,
          "testRun": 1,
          "testResult": 2,
          "system": 4,
          "all": 7
        }
      },
      CustomTestFieldType: {
        enumValues: {
          "bit": 2,
          "dateTime": 4,
          "int": 8,
          "float": 6,
          "string": 12,
          "guid": 14
        }
      },
      DatedTestFieldData: {},
      FailingSince: {},
      FetchTestResultsResponse: {},
      FlakyDetection: {},
      FlakyDetectionType: {
        enumValues: {
          "custom": 1,
          "system": 2
        }
      },
      FlakySettings: {},
      LastResultDetails: {},
      LegacyBuildConfiguration: {},
      LegacyReleaseReference: {},
      LegacyTestCaseResult: {},
      LegacyTestRun: {},
      LegacyTestSettings: {},
      Metrics: {
        enumValues: {
          "all": 1,
          "resultSummary": 2,
          "resultsAnalysis": 3,
          "runSummary": 4
        }
      },
      OperationType: {
        enumValues: {
          "add": 1,
          "delete": 2
        }
      },
      PipelineTestMetrics: {},
      PointLastResult: {},
      PointsResults2: {},
      QueryTestActionResultResponse: {},
      ReleaseReference: {},
      ReleaseReference2: {},
      RequirementsToTestsMapping2: {},
      Response: {},
      ResultDetails: {
        enumValues: {
          "none": 0,
          "iterations": 1,
          "workItems": 2,
          "subResults": 4,
          "point": 8
        }
      },
      ResultGroupType: {
        enumValues: {
          "none": 0,
          "rerun": 1,
          "dataDriven": 2,
          "orderedTest": 3,
          "generic": 4
        }
      },
      ResultMetadata: {
        enumValues: {
          "rerun": 1,
          "flaky": 2
        }
      },
      ResultMetaDataDetails: {
        enumValues: {
          "none": 0,
          "flakyIdentifiers": 1
        }
      },
      ResultObjectType: {
        enumValues: {
          "testSuite": 0,
          "testPlan": 1
        }
      },
      ResultRetentionSettings: {},
      ResultsByQueryResponse: {},
      ResultsFilter: {},
      ResultsSummaryByOutcome: {},
      ResultSummary: {},
      ResultUpdateRequest: {},
      ResultUpdateRequestModel: {},
      ResultUpdateResponse: {},
      RunCreateModel: {},
      RunStatistic: {},
      RunSummary: {},
      RunSummaryModel: {},
      RunType: {
        enumValues: {
          "unspecified": 0,
          "normal": 1,
          "blocking": 2,
          "web": 4,
          "mtrRunInitiatedFromWeb": 8,
          "runWithDtlEnv": 16,
          "noConfigRun": 32
        }
      },
      RunUpdateModel: {},
      Service: {
        enumValues: {
          "any": 0,
          "tcm": 1,
          "tfs": 2
        }
      },
      SessionResult: {
        enumValues: {
          "none": 0,
          "passed": 1,
          "failed": 2
        }
      },
      SessionTimelineType: {
        enumValues: {
          "none": 0,
          "queued": 1,
          "completed": 2,
          "started": 3
        }
      },
      SourceViewBuildCoverage: {},
      SuiteExpand: {
        enumValues: {
          "children": 1,
          "defaultTesters": 2
        }
      },
      TCMServiceDataMigrationStatus: {
        enumValues: {
          "notStarted": 0,
          "inProgress": 1,
          "completed": 2,
          "failed": 3
        }
      },
      TestActionResult: {},
      TestActionResult2: {},
      TestActionResultModel: {},
      TestAttachment: {},
      TestAuthoringDetails: {},
      TestCaseReference2: {},
      TestCaseResult: {},
      TestConfiguration: {},
      TestConfigurationState: {
        enumValues: {
          "active": 1,
          "inactive": 2
        }
      },
      TestExecutionReportData: {},
      TestExtensionField: {},
      TestExtensionFieldDetails: {},
      TestFailuresAnalysis: {},
      TestHistoryQuery: {},
      TestIterationDetailsModel: {},
      TestLog: {},
      TestLogReference: {},
      TestLogScope: {
        enumValues: {
          "run": 0,
          "build": 1,
          "release": 2
        }
      },
      TestLogStatus: {},
      TestLogStatusCode: {
        enumValues: {
          "success": 0,
          "failed": 1,
          "fileAlreadyExists": 2,
          "invalidInput": 3,
          "invalidFileName": 4,
          "invalidContainer": 5,
          "transferFailed": 6,
          "featureDisabled": 7,
          "buildDoesNotExist": 8,
          "runDoesNotExist": 9,
          "containerNotCreated": 10,
          "apiNotSupported": 11,
          "fileSizeExceeds": 12,
          "containerNotFound": 13,
          "fileNotFound": 14,
          "directoryNotFound": 15,
          "storageCapacityExceeded": 16
        }
      },
      TestLogStoreAttachment: {},
      TestLogStoreEndpointDetails: {},
      TestLogStoreEndpointType: {
        enumValues: {
          "root": 1,
          "file": 2
        }
      },
      TestLogStoreOperationType: {
        enumValues: {
          "read": 1,
          "create": 2,
          "readAndCreate": 3
        }
      },
      TestLogType: {
        enumValues: {
          "generalAttachment": 1,
          "codeCoverage": 2,
          "testImpact": 3,
          "intermediate": 4,
          "system": 5,
          "mergedCoverageFile": 6
        }
      },
      TestMessageLogDetails: {},
      TestMessageLogEntry: {},
      TestMessageLogEntry2: {},
      TestOutcome: {
        enumValues: {
          "unspecified": 0,
          "none": 1,
          "passed": 2,
          "failed": 3,
          "inconclusive": 4,
          "timeout": 5,
          "aborted": 6,
          "blocked": 7,
          "notExecuted": 8,
          "warning": 9,
          "error": 10,
          "notApplicable": 11,
          "paused": 12,
          "inProgress": 13,
          "notImpacted": 14,
          "maxValue": 14
        }
      },
      TestParameter2: {},
      TestPlan: {},
      TestPlanCloneRequest: {},
      TestPlanHubData: {},
      TestPlansWithSelection: {},
      TestPoint: {},
      TestPointReference: {},
      TestPointsEvent: {},
      TestPointsQuery: {},
      TestPointState: {
        enumValues: {
          "none": 0,
          "ready": 1,
          "completed": 2,
          "notReady": 3,
          "inProgress": 4,
          "maxValue": 4
        }
      },
      TestPointsUpdatedEvent: {},
      TestResult2: {},
      TestResultAcrossProjectResponse: {},
      TestResultAttachment: {},
      TestResultGroupBy: {
        enumValues: {
          "branch": 1,
          "environment": 2
        }
      },
      TestResultHistory: {},
      TestResultHistoryDetailsForGroup: {},
      TestResultHistoryForGroup: {},
      TestResultModelBase: {},
      TestResultReset2: {},
      TestResultsContext: {},
      TestResultsContextType: {
        enumValues: {
          "build": 1,
          "release": 2,
          "pipeline": 3
        }
      },
      TestResultsDetails: {},
      TestResultsDetailsForGroup: {},
      TestResultsEx2: {},
      TestResultsQuery: {},
      TestResultsSession: {},
      TestResultsSessionState: {
        enumValues: {
          "none": 0,
          "running": 1,
          "completed": 2,
          "waiting": 3,
          "cancelled": 4
        }
      },
      TestResultsSettings: {},
      TestResultsSettingsType: {
        enumValues: {
          "all": 1,
          "flaky": 2,
          "newTestLogging": 3
        }
      },
      TestResultSummary: {},
      TestResultsUpdateSettings: {},
      TestResultsWithWatermark: {},
      TestResultTrendFilter: {},
      TestRun: {},
      TestRun2: {},
      TestRunCanceledEvent: {},
      TestRunCreatedEvent: {},
      TestRunEvent: {},
      TestRunEx2: {},
      TestRunOutcome: {
        enumValues: {
          "passed": 0,
          "failed": 1,
          "notImpacted": 2,
          "others": 3
        }
      },
      TestRunPublishContext: {
        enumValues: {
          "build": 1,
          "release": 2,
          "all": 3
        }
      },
      TestRunStartedEvent: {},
      TestRunState: {
        enumValues: {
          "unspecified": 0,
          "notStarted": 1,
          "inProgress": 2,
          "completed": 3,
          "aborted": 4,
          "waiting": 5,
          "needsInvestigation": 6
        }
      },
      TestRunStatistic: {},
      TestRunSubstate: {
        enumValues: {
          "none": 0,
          "creatingEnvironment": 1,
          "runningTests": 2,
          "canceledByUser": 3,
          "abortedBySystem": 4,
          "timedOut": 5,
          "pendingAnalysis": 6,
          "analyzed": 7,
          "cancellationInProgress": 8
        }
      },
      TestRunSummary2: {},
      TestRunWithDtlEnvEvent: {},
      TestSession: {},
      TestSessionExploredWorkItemReference: {},
      TestSessionSource: {
        enumValues: {
          "unknown": 0,
          "xtDesktop": 1,
          "feedbackDesktop": 2,
          "xtWeb": 3,
          "feedbackWeb": 4,
          "xtDesktop2": 5,
          "sessionInsightsForAll": 6
        }
      },
      TestSessionState: {
        enumValues: {
          "unspecified": 0,
          "notStarted": 1,
          "inProgress": 2,
          "paused": 3,
          "completed": 4,
          "declined": 5
        }
      },
      TestSettings2: {},
      TestSubResult: {},
      TestSuite: {},
      TestSummaryForWorkItem: {},
      Timeline: {},
      UpdatedProperties: {},
      UpdateTestRunRequest: {},
      UpdateTestRunResponse: {},
      WorkItemToTestLinks: {}
    };
    exports2.TypeInfo.AfnStrip.fields = {
      creationDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.AggregatedDataForResultTrend.fields = {
      resultsByOutcome: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestOutcome,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedResultsByOutcome
      },
      runSummaryByState: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestRunState,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedRunsByState
      },
      testResultsContext: {
        typeInfo: exports2.TypeInfo.TestResultsContext
      }
    };
    exports2.TypeInfo.AggregatedResultDetailsByOutcome.fields = {
      outcome: {
        enumType: exports2.TypeInfo.TestOutcome
      }
    };
    exports2.TypeInfo.AggregatedResultsAnalysis.fields = {
      notReportedResultsByOutcome: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestOutcome,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedResultsByOutcome
      },
      previousContext: {
        typeInfo: exports2.TypeInfo.TestResultsContext
      },
      resultsByOutcome: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestOutcome,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedResultsByOutcome
      },
      runSummaryByOutcome: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestRunOutcome,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedRunsByOutcome
      },
      runSummaryByState: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestRunState,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedRunsByState
      }
    };
    exports2.TypeInfo.AggregatedResultsByOutcome.fields = {
      outcome: {
        enumType: exports2.TypeInfo.TestOutcome
      }
    };
    exports2.TypeInfo.AggregatedRunsByOutcome.fields = {
      outcome: {
        enumType: exports2.TypeInfo.TestRunOutcome
      }
    };
    exports2.TypeInfo.AggregatedRunsByState.fields = {
      resultsByOutcome: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestOutcome,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedResultsByOutcome
      },
      state: {
        enumType: exports2.TypeInfo.TestRunState
      }
    };
    exports2.TypeInfo.BatchResponse.fields = {
      responses: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Response
      }
    };
    exports2.TypeInfo.BuildConfiguration.fields = {
      creationDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.BuildCoverage.fields = {
      configuration: {
        typeInfo: exports2.TypeInfo.BuildConfiguration
      }
    };
    exports2.TypeInfo.BuildReference2.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.BulkResultUpdateRequest.fields = {
      requests: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ResultUpdateRequest
      }
    };
    exports2.TypeInfo.CloneOperationInformation.fields = {
      completionDate: {
        isDate: true
      },
      creationDate: {
        isDate: true
      },
      resultObjectType: {
        enumType: exports2.TypeInfo.ResultObjectType
      },
      state: {
        enumType: exports2.TypeInfo.CloneOperationState
      }
    };
    exports2.TypeInfo.CodeCoverageSummary.fields = {
      coverageDetailedSummaryStatus: {
        enumType: exports2.TypeInfo.CoverageDetailedSummaryStatus
      },
      status: {
        enumType: exports2.TypeInfo.CoverageSummaryStatus
      }
    };
    exports2.TypeInfo.Coverage2.fields = {
      dateCreated: {
        isDate: true
      },
      dateModified: {
        isDate: true
      }
    };
    exports2.TypeInfo.CreateTestMessageLogEntryRequest.fields = {
      testMessageLogEntry: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestMessageLogEntry
      }
    };
    exports2.TypeInfo.CreateTestResultsRequest.fields = {
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.LegacyTestCaseResult
      }
    };
    exports2.TypeInfo.CreateTestRunRequest.fields = {
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.LegacyTestCaseResult
      },
      testRun: {
        typeInfo: exports2.TypeInfo.LegacyTestRun
      },
      testSettings: {
        typeInfo: exports2.TypeInfo.LegacyTestSettings
      }
    };
    exports2.TypeInfo.CustomTestFieldDefinition.fields = {
      fieldType: {
        enumType: exports2.TypeInfo.CustomTestFieldType
      },
      scope: {
        enumType: exports2.TypeInfo.CustomTestFieldScope
      }
    };
    exports2.TypeInfo.DatedTestFieldData.fields = {
      date: {
        isDate: true
      }
    };
    exports2.TypeInfo.FailingSince.fields = {
      date: {
        isDate: true
      },
      release: {
        typeInfo: exports2.TypeInfo.ReleaseReference
      }
    };
    exports2.TypeInfo.FetchTestResultsResponse.fields = {
      actionResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestActionResult
      },
      attachments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestResultAttachment
      },
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.LegacyTestCaseResult
      }
    };
    exports2.TypeInfo.FlakyDetection.fields = {
      flakyDetectionType: {
        enumType: exports2.TypeInfo.FlakyDetectionType
      }
    };
    exports2.TypeInfo.FlakySettings.fields = {
      flakyDetection: {
        typeInfo: exports2.TypeInfo.FlakyDetection
      }
    };
    exports2.TypeInfo.LastResultDetails.fields = {
      dateCompleted: {
        isDate: true
      }
    };
    exports2.TypeInfo.LegacyBuildConfiguration.fields = {
      completedDate: {
        isDate: true
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.LegacyReleaseReference.fields = {
      environmentCreationDate: {
        isDate: true
      },
      releaseCreationDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.LegacyTestCaseResult.fields = {
      buildReference: {
        typeInfo: exports2.TypeInfo.LegacyBuildConfiguration
      },
      creationDate: {
        isDate: true
      },
      customFields: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestExtensionField
      },
      dateCompleted: {
        isDate: true
      },
      dateStarted: {
        isDate: true
      },
      failingSince: {
        typeInfo: exports2.TypeInfo.FailingSince
      },
      lastUpdated: {
        isDate: true
      },
      releaseReference: {
        typeInfo: exports2.TypeInfo.LegacyReleaseReference
      },
      resultGroupType: {
        enumType: exports2.TypeInfo.ResultGroupType
      },
      stackTrace: {
        typeInfo: exports2.TypeInfo.TestExtensionField
      }
    };
    exports2.TypeInfo.LegacyTestRun.fields = {
      buildReference: {
        typeInfo: exports2.TypeInfo.LegacyBuildConfiguration
      },
      completeDate: {
        isDate: true
      },
      creationDate: {
        isDate: true
      },
      customFields: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestExtensionField
      },
      dueDate: {
        isDate: true
      },
      lastUpdated: {
        isDate: true
      },
      releaseReference: {
        typeInfo: exports2.TypeInfo.LegacyReleaseReference
      },
      startDate: {
        isDate: true
      },
      testMessageLogEntries: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestMessageLogDetails
      }
    };
    exports2.TypeInfo.LegacyTestSettings.fields = {
      createdDate: {
        isDate: true
      },
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.PipelineTestMetrics.fields = {
      resultSummary: {
        typeInfo: exports2.TypeInfo.ResultSummary
      },
      runSummary: {
        typeInfo: exports2.TypeInfo.RunSummary
      },
      summaryAtChild: {
        isArray: true,
        typeInfo: exports2.TypeInfo.PipelineTestMetrics
      }
    };
    exports2.TypeInfo.PointLastResult.fields = {
      lastUpdatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.PointsResults2.fields = {
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.QueryTestActionResultResponse.fields = {
      testActionResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestActionResult
      },
      testAttachments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestResultAttachment
      }
    };
    exports2.TypeInfo.ReleaseReference.fields = {
      creationDate: {
        isDate: true
      },
      environmentCreationDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReleaseReference2.fields = {
      environmentCreationDate: {
        isDate: true
      },
      releaseCreationDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.RequirementsToTestsMapping2.fields = {
      creationDate: {
        isDate: true
      },
      deletionDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.Response.fields = {};
    exports2.TypeInfo.ResultRetentionSettings.fields = {
      lastUpdatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ResultsByQueryResponse.fields = {
      testResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.LegacyTestCaseResult
      }
    };
    exports2.TypeInfo.ResultsFilter.fields = {
      executedIn: {
        enumType: exports2.TypeInfo.Service
      },
      maxCompleteDate: {
        isDate: true
      },
      testResultsContext: {
        typeInfo: exports2.TypeInfo.TestResultsContext
      }
    };
    exports2.TypeInfo.ResultsSummaryByOutcome.fields = {
      aggregatedResultDetailsByOutcome: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestOutcome,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedResultDetailsByOutcome
      }
    };
    exports2.TypeInfo.ResultSummary.fields = {
      resultSummaryByRunState: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestRunState,
        dictionaryValueTypeInfo: exports2.TypeInfo.ResultsSummaryByOutcome
      }
    };
    exports2.TypeInfo.ResultUpdateRequest.fields = {
      actionResultDeletes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestActionResult
      },
      actionResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestActionResult
      },
      attachments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestResultAttachment
      },
      testCaseResult: {
        typeInfo: exports2.TypeInfo.LegacyTestCaseResult
      }
    };
    exports2.TypeInfo.ResultUpdateRequestModel.fields = {
      actionResultDeletes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestActionResultModel
      },
      actionResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestActionResultModel
      }
    };
    exports2.TypeInfo.ResultUpdateResponse.fields = {
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.RunCreateModel.fields = {
      buildReference: {
        typeInfo: exports2.TypeInfo.BuildConfiguration
      },
      releaseReference: {
        typeInfo: exports2.TypeInfo.ReleaseReference
      },
      runSummary: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RunSummaryModel
      }
    };
    exports2.TypeInfo.RunStatistic.fields = {
      resultMetadata: {
        enumType: exports2.TypeInfo.ResultMetadata
      }
    };
    exports2.TypeInfo.RunSummary.fields = {
      runSummaryByOutcome: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestRunOutcome
      },
      runSummaryByState: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestRunState
      }
    };
    exports2.TypeInfo.RunSummaryModel.fields = {
      testOutcome: {
        enumType: exports2.TypeInfo.TestOutcome
      }
    };
    exports2.TypeInfo.RunUpdateModel.fields = {
      logEntries: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestMessageLogDetails
      },
      runSummary: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RunSummaryModel
      },
      substate: {
        enumType: exports2.TypeInfo.TestRunSubstate
      }
    };
    exports2.TypeInfo.SourceViewBuildCoverage.fields = {
      configuration: {
        typeInfo: exports2.TypeInfo.BuildConfiguration
      }
    };
    exports2.TypeInfo.TestActionResult.fields = {
      creationDate: {
        isDate: true
      },
      dateCompleted: {
        isDate: true
      },
      dateStarted: {
        isDate: true
      },
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestActionResult2.fields = {
      creationDate: {
        isDate: true
      },
      dateCompleted: {
        isDate: true
      },
      dateStarted: {
        isDate: true
      },
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestActionResultModel.fields = {
      completedDate: {
        isDate: true
      },
      startedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestAttachment.fields = {
      attachmentType: {
        enumType: exports2.TypeInfo.AttachmentType
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestAuthoringDetails.fields = {
      lastUpdated: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.TestPointState
      }
    };
    exports2.TypeInfo.TestCaseReference2.fields = {
      creationDate: {
        isDate: true
      },
      lastRefTestRunDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestCaseResult.fields = {
      completedDate: {
        isDate: true
      },
      createdDate: {
        isDate: true
      },
      failingSince: {
        typeInfo: exports2.TypeInfo.FailingSince
      },
      iterationDetails: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestIterationDetailsModel
      },
      lastUpdatedDate: {
        isDate: true
      },
      releaseReference: {
        typeInfo: exports2.TypeInfo.ReleaseReference
      },
      resultGroupType: {
        enumType: exports2.TypeInfo.ResultGroupType
      },
      startedDate: {
        isDate: true
      },
      subResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestSubResult
      }
    };
    exports2.TypeInfo.TestConfiguration.fields = {
      lastUpdatedDate: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.TestConfigurationState
      }
    };
    exports2.TypeInfo.TestExecutionReportData.fields = {
      reportData: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DatedTestFieldData
      }
    };
    exports2.TypeInfo.TestExtensionField.fields = {
      field: {
        typeInfo: exports2.TypeInfo.TestExtensionFieldDetails
      }
    };
    exports2.TypeInfo.TestExtensionFieldDetails.fields = {
      type: {
        enumType: SystemData.TypeInfo.SqlDbType
      }
    };
    exports2.TypeInfo.TestFailuresAnalysis.fields = {
      previousContext: {
        typeInfo: exports2.TypeInfo.TestResultsContext
      }
    };
    exports2.TypeInfo.TestHistoryQuery.fields = {
      groupBy: {
        enumType: exports2.TypeInfo.TestResultGroupBy
      },
      maxCompleteDate: {
        isDate: true
      },
      resultsForGroup: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestResultHistoryForGroup
      }
    };
    exports2.TypeInfo.TestIterationDetailsModel.fields = {
      actionResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestActionResultModel
      },
      completedDate: {
        isDate: true
      },
      startedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestLog.fields = {
      logReference: {
        typeInfo: exports2.TypeInfo.TestLogReference
      },
      modifiedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestLogReference.fields = {
      scope: {
        enumType: exports2.TypeInfo.TestLogScope
      },
      type: {
        enumType: exports2.TypeInfo.TestLogType
      }
    };
    exports2.TypeInfo.TestLogStatus.fields = {
      status: {
        enumType: exports2.TypeInfo.TestLogStatusCode
      }
    };
    exports2.TypeInfo.TestLogStoreAttachment.fields = {
      attachmentType: {
        enumType: exports2.TypeInfo.AttachmentType
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestLogStoreEndpointDetails.fields = {
      endpointType: {
        enumType: exports2.TypeInfo.TestLogStoreEndpointType
      },
      status: {
        enumType: exports2.TypeInfo.TestLogStatusCode
      }
    };
    exports2.TypeInfo.TestMessageLogDetails.fields = {
      dateCreated: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestMessageLogEntry.fields = {
      dateCreated: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestMessageLogEntry2.fields = {
      dateCreated: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestParameter2.fields = {
      creationDate: {
        isDate: true
      },
      dateModified: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestPlan.fields = {
      endDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestPlanCloneRequest.fields = {
      destinationTestPlan: {
        typeInfo: exports2.TypeInfo.TestPlan
      }
    };
    exports2.TypeInfo.TestPlanHubData.fields = {
      testPlan: {
        typeInfo: exports2.TypeInfo.TestPlan
      },
      testPoints: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestPoint
      },
      testSuites: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestSuite
      }
    };
    exports2.TypeInfo.TestPlansWithSelection.fields = {
      plans: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestPlan
      }
    };
    exports2.TypeInfo.TestPoint.fields = {
      lastResetToActive: {
        isDate: true
      },
      lastResultDetails: {
        typeInfo: exports2.TypeInfo.LastResultDetails
      },
      lastUpdatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestPointReference.fields = {
      state: {
        enumType: exports2.TypeInfo.TestPointState
      }
    };
    exports2.TypeInfo.TestPointsEvent.fields = {
      testPoints: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestPointReference
      }
    };
    exports2.TypeInfo.TestPointsQuery.fields = {
      points: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestPoint
      }
    };
    exports2.TypeInfo.TestPointsUpdatedEvent.fields = {
      testPoints: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestPointReference
      }
    };
    exports2.TypeInfo.TestResult2.fields = {
      creationDate: {
        isDate: true
      },
      dateCompleted: {
        isDate: true
      },
      dateStarted: {
        isDate: true
      },
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestResultAcrossProjectResponse.fields = {
      testResult: {
        typeInfo: exports2.TypeInfo.LegacyTestCaseResult
      }
    };
    exports2.TypeInfo.TestResultAttachment.fields = {
      attachmentType: {
        enumType: exports2.TypeInfo.AttachmentType
      },
      creationDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestResultHistory.fields = {
      resultsForGroup: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestResultHistoryDetailsForGroup
      }
    };
    exports2.TypeInfo.TestResultHistoryDetailsForGroup.fields = {
      latestResult: {
        typeInfo: exports2.TypeInfo.TestCaseResult
      }
    };
    exports2.TypeInfo.TestResultHistoryForGroup.fields = {
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestCaseResult
      }
    };
    exports2.TypeInfo.TestResultModelBase.fields = {
      completedDate: {
        isDate: true
      },
      startedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestResultReset2.fields = {
      dateModified: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestResultsContext.fields = {
      contextType: {
        enumType: exports2.TypeInfo.TestResultsContextType
      },
      release: {
        typeInfo: exports2.TypeInfo.ReleaseReference
      }
    };
    exports2.TypeInfo.TestResultsDetails.fields = {
      resultsForGroup: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestResultsDetailsForGroup
      }
    };
    exports2.TypeInfo.TestResultsDetailsForGroup.fields = {
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestCaseResult
      },
      resultsCountByOutcome: {
        isDictionary: true,
        dictionaryKeyEnumType: exports2.TypeInfo.TestOutcome,
        dictionaryValueTypeInfo: exports2.TypeInfo.AggregatedResultsByOutcome
      }
    };
    exports2.TypeInfo.TestResultsEx2.fields = {
      creationDate: {
        isDate: true
      },
      dateTimeValue: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestResultsQuery.fields = {
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestCaseResult
      },
      resultsFilter: {
        typeInfo: exports2.TypeInfo.ResultsFilter
      }
    };
    exports2.TypeInfo.TestResultsSession.fields = {
      endTimeUTC: {
        isDate: true
      },
      result: {
        enumType: exports2.TypeInfo.SessionResult
      },
      startTimeUTC: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.TestResultsSessionState
      }
    };
    exports2.TypeInfo.TestResultsSettings.fields = {
      flakySettings: {
        typeInfo: exports2.TypeInfo.FlakySettings
      }
    };
    exports2.TypeInfo.TestResultSummary.fields = {
      aggregatedResultsAnalysis: {
        typeInfo: exports2.TypeInfo.AggregatedResultsAnalysis
      },
      teamProject: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      testFailures: {
        typeInfo: exports2.TypeInfo.TestFailuresAnalysis
      },
      testResultsContext: {
        typeInfo: exports2.TypeInfo.TestResultsContext
      }
    };
    exports2.TypeInfo.TestResultsUpdateSettings.fields = {
      flakySettings: {
        typeInfo: exports2.TypeInfo.FlakySettings
      }
    };
    exports2.TypeInfo.TestResultsWithWatermark.fields = {
      changedDate: {
        isDate: true
      },
      pointsResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.PointsResults2
      }
    };
    exports2.TypeInfo.TestResultTrendFilter.fields = {
      maxCompleteDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestRun.fields = {
      buildConfiguration: {
        typeInfo: exports2.TypeInfo.BuildConfiguration
      },
      completedDate: {
        isDate: true
      },
      createdDate: {
        isDate: true
      },
      dueDate: {
        isDate: true
      },
      lastUpdatedDate: {
        isDate: true
      },
      release: {
        typeInfo: exports2.TypeInfo.ReleaseReference
      },
      runStatistics: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RunStatistic
      },
      startedDate: {
        isDate: true
      },
      substate: {
        enumType: exports2.TypeInfo.TestRunSubstate
      }
    };
    exports2.TypeInfo.TestRun2.fields = {
      completeDate: {
        isDate: true
      },
      creationDate: {
        isDate: true
      },
      deletedOn: {
        isDate: true
      },
      dueDate: {
        isDate: true
      },
      lastUpdated: {
        isDate: true
      },
      startDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestRunCanceledEvent.fields = {
      testRun: {
        typeInfo: exports2.TypeInfo.TestRun
      }
    };
    exports2.TypeInfo.TestRunCreatedEvent.fields = {
      testRun: {
        typeInfo: exports2.TypeInfo.TestRun
      }
    };
    exports2.TypeInfo.TestRunEvent.fields = {
      testRun: {
        typeInfo: exports2.TypeInfo.TestRun
      }
    };
    exports2.TypeInfo.TestRunEx2.fields = {
      createdDate: {
        isDate: true
      },
      dateTimeValue: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestRunStartedEvent.fields = {
      testRun: {
        typeInfo: exports2.TypeInfo.TestRun
      }
    };
    exports2.TypeInfo.TestRunStatistic.fields = {
      runStatistics: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RunStatistic
      }
    };
    exports2.TypeInfo.TestRunSummary2.fields = {
      testRunCompletedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestRunWithDtlEnvEvent.fields = {
      testRun: {
        typeInfo: exports2.TypeInfo.TestRun
      }
    };
    exports2.TypeInfo.TestSession.fields = {
      endDate: {
        isDate: true
      },
      lastUpdatedDate: {
        isDate: true
      },
      source: {
        enumType: exports2.TypeInfo.TestSessionSource
      },
      startDate: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.TestSessionState
      }
    };
    exports2.TypeInfo.TestSessionExploredWorkItemReference.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestSettings2.fields = {
      createdDate: {
        isDate: true
      },
      lastUpdatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestSubResult.fields = {
      completedDate: {
        isDate: true
      },
      lastUpdatedDate: {
        isDate: true
      },
      resultGroupType: {
        enumType: exports2.TypeInfo.ResultGroupType
      },
      startedDate: {
        isDate: true
      },
      subResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestSubResult
      }
    };
    exports2.TypeInfo.TestSuite.fields = {
      children: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestSuite
      },
      lastPopulatedDate: {
        isDate: true
      },
      lastUpdatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestSummaryForWorkItem.fields = {
      summary: {
        typeInfo: exports2.TypeInfo.AggregatedDataForResultTrend
      }
    };
    exports2.TypeInfo.Timeline.fields = {
      timestampUTC: {
        isDate: true
      }
    };
    exports2.TypeInfo.UpdatedProperties.fields = {
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.UpdateTestRunRequest.fields = {
      attachmentsToAdd: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestResultAttachment
      },
      testRun: {
        typeInfo: exports2.TypeInfo.LegacyTestRun
      }
    };
    exports2.TypeInfo.UpdateTestRunResponse.fields = {
      updatedProperties: {
        typeInfo: exports2.TypeInfo.UpdatedProperties
      }
    };
    exports2.TypeInfo.WorkItemToTestLinks.fields = {
      executedIn: {
        enumType: exports2.TypeInfo.Service
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/interfaces/BuildInterfaces.js
var require_BuildInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/BuildInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.WorkspaceMappingType = exports2.ValidationResult = exports2.TimelineRecordState = exports2.TaskResult = exports2.SupportLevel = exports2.StageUpdateType = exports2.SourceProviderAvailability = exports2.ServiceHostStatus = exports2.ScheduleDays = exports2.ResultSet = exports2.RepositoryCleanOptions = exports2.QueuePriority = exports2.QueueOptions = exports2.QueryDeletedOption = exports2.ProcessTemplateType = exports2.IssueType = exports2.GetOption = exports2.FolderQueryOrder = exports2.DeleteOptions = exports2.DefinitionType = exports2.DefinitionTriggerType = exports2.DefinitionQueueStatus = exports2.DefinitionQueryOrder = exports2.DefinitionQuality = exports2.ControllerStatus = exports2.BuildStatus = exports2.BuildResult = exports2.BuildReason = exports2.BuildQueryOrder = exports2.BuildPhaseStatus = exports2.BuildOptionInputType = exports2.BuildAuthorizationScope = exports2.AuditAction = exports2.AgentStatus = void 0;
    var TFS_TestManagement_Contracts = require_TestInterfaces();
    var TfsCoreInterfaces = require_CoreInterfaces();
    var AgentStatus;
    (function(AgentStatus2) {
      AgentStatus2[AgentStatus2["Unavailable"] = 0] = "Unavailable";
      AgentStatus2[AgentStatus2["Available"] = 1] = "Available";
      AgentStatus2[AgentStatus2["Offline"] = 2] = "Offline";
    })(AgentStatus = exports2.AgentStatus || (exports2.AgentStatus = {}));
    var AuditAction;
    (function(AuditAction2) {
      AuditAction2[AuditAction2["Add"] = 1] = "Add";
      AuditAction2[AuditAction2["Update"] = 2] = "Update";
      AuditAction2[AuditAction2["Delete"] = 3] = "Delete";
    })(AuditAction = exports2.AuditAction || (exports2.AuditAction = {}));
    var BuildAuthorizationScope;
    (function(BuildAuthorizationScope2) {
      BuildAuthorizationScope2[BuildAuthorizationScope2["ProjectCollection"] = 1] = "ProjectCollection";
      BuildAuthorizationScope2[BuildAuthorizationScope2["Project"] = 2] = "Project";
    })(BuildAuthorizationScope = exports2.BuildAuthorizationScope || (exports2.BuildAuthorizationScope = {}));
    var BuildOptionInputType;
    (function(BuildOptionInputType2) {
      BuildOptionInputType2[BuildOptionInputType2["String"] = 0] = "String";
      BuildOptionInputType2[BuildOptionInputType2["Boolean"] = 1] = "Boolean";
      BuildOptionInputType2[BuildOptionInputType2["StringList"] = 2] = "StringList";
      BuildOptionInputType2[BuildOptionInputType2["Radio"] = 3] = "Radio";
      BuildOptionInputType2[BuildOptionInputType2["PickList"] = 4] = "PickList";
      BuildOptionInputType2[BuildOptionInputType2["MultiLine"] = 5] = "MultiLine";
      BuildOptionInputType2[BuildOptionInputType2["BranchFilter"] = 6] = "BranchFilter";
    })(BuildOptionInputType = exports2.BuildOptionInputType || (exports2.BuildOptionInputType = {}));
    var BuildPhaseStatus;
    (function(BuildPhaseStatus2) {
      BuildPhaseStatus2[BuildPhaseStatus2["Unknown"] = 0] = "Unknown";
      BuildPhaseStatus2[BuildPhaseStatus2["Failed"] = 1] = "Failed";
      BuildPhaseStatus2[BuildPhaseStatus2["Succeeded"] = 2] = "Succeeded";
    })(BuildPhaseStatus = exports2.BuildPhaseStatus || (exports2.BuildPhaseStatus = {}));
    var BuildQueryOrder;
    (function(BuildQueryOrder2) {
      BuildQueryOrder2[BuildQueryOrder2["FinishTimeAscending"] = 2] = "FinishTimeAscending";
      BuildQueryOrder2[BuildQueryOrder2["FinishTimeDescending"] = 3] = "FinishTimeDescending";
      BuildQueryOrder2[BuildQueryOrder2["QueueTimeDescending"] = 4] = "QueueTimeDescending";
      BuildQueryOrder2[BuildQueryOrder2["QueueTimeAscending"] = 5] = "QueueTimeAscending";
      BuildQueryOrder2[BuildQueryOrder2["StartTimeDescending"] = 6] = "StartTimeDescending";
      BuildQueryOrder2[BuildQueryOrder2["StartTimeAscending"] = 7] = "StartTimeAscending";
    })(BuildQueryOrder = exports2.BuildQueryOrder || (exports2.BuildQueryOrder = {}));
    var BuildReason;
    (function(BuildReason2) {
      BuildReason2[BuildReason2["None"] = 0] = "None";
      BuildReason2[BuildReason2["Manual"] = 1] = "Manual";
      BuildReason2[BuildReason2["IndividualCI"] = 2] = "IndividualCI";
      BuildReason2[BuildReason2["BatchedCI"] = 4] = "BatchedCI";
      BuildReason2[BuildReason2["Schedule"] = 8] = "Schedule";
      BuildReason2[BuildReason2["ScheduleForced"] = 16] = "ScheduleForced";
      BuildReason2[BuildReason2["UserCreated"] = 32] = "UserCreated";
      BuildReason2[BuildReason2["ValidateShelveset"] = 64] = "ValidateShelveset";
      BuildReason2[BuildReason2["CheckInShelveset"] = 128] = "CheckInShelveset";
      BuildReason2[BuildReason2["PullRequest"] = 256] = "PullRequest";
      BuildReason2[BuildReason2["BuildCompletion"] = 512] = "BuildCompletion";
      BuildReason2[BuildReason2["ResourceTrigger"] = 1024] = "ResourceTrigger";
      BuildReason2[BuildReason2["Triggered"] = 1967] = "Triggered";
      BuildReason2[BuildReason2["All"] = 2031] = "All";
    })(BuildReason = exports2.BuildReason || (exports2.BuildReason = {}));
    var BuildResult;
    (function(BuildResult2) {
      BuildResult2[BuildResult2["None"] = 0] = "None";
      BuildResult2[BuildResult2["Succeeded"] = 2] = "Succeeded";
      BuildResult2[BuildResult2["PartiallySucceeded"] = 4] = "PartiallySucceeded";
      BuildResult2[BuildResult2["Failed"] = 8] = "Failed";
      BuildResult2[BuildResult2["Canceled"] = 32] = "Canceled";
    })(BuildResult = exports2.BuildResult || (exports2.BuildResult = {}));
    var BuildStatus;
    (function(BuildStatus2) {
      BuildStatus2[BuildStatus2["None"] = 0] = "None";
      BuildStatus2[BuildStatus2["InProgress"] = 1] = "InProgress";
      BuildStatus2[BuildStatus2["Completed"] = 2] = "Completed";
      BuildStatus2[BuildStatus2["Cancelling"] = 4] = "Cancelling";
      BuildStatus2[BuildStatus2["Postponed"] = 8] = "Postponed";
      BuildStatus2[BuildStatus2["NotStarted"] = 32] = "NotStarted";
      BuildStatus2[BuildStatus2["All"] = 47] = "All";
    })(BuildStatus = exports2.BuildStatus || (exports2.BuildStatus = {}));
    var ControllerStatus;
    (function(ControllerStatus2) {
      ControllerStatus2[ControllerStatus2["Unavailable"] = 0] = "Unavailable";
      ControllerStatus2[ControllerStatus2["Available"] = 1] = "Available";
      ControllerStatus2[ControllerStatus2["Offline"] = 2] = "Offline";
    })(ControllerStatus = exports2.ControllerStatus || (exports2.ControllerStatus = {}));
    var DefinitionQuality;
    (function(DefinitionQuality2) {
      DefinitionQuality2[DefinitionQuality2["Definition"] = 1] = "Definition";
      DefinitionQuality2[DefinitionQuality2["Draft"] = 2] = "Draft";
    })(DefinitionQuality = exports2.DefinitionQuality || (exports2.DefinitionQuality = {}));
    var DefinitionQueryOrder;
    (function(DefinitionQueryOrder2) {
      DefinitionQueryOrder2[DefinitionQueryOrder2["None"] = 0] = "None";
      DefinitionQueryOrder2[DefinitionQueryOrder2["LastModifiedAscending"] = 1] = "LastModifiedAscending";
      DefinitionQueryOrder2[DefinitionQueryOrder2["LastModifiedDescending"] = 2] = "LastModifiedDescending";
      DefinitionQueryOrder2[DefinitionQueryOrder2["DefinitionNameAscending"] = 3] = "DefinitionNameAscending";
      DefinitionQueryOrder2[DefinitionQueryOrder2["DefinitionNameDescending"] = 4] = "DefinitionNameDescending";
    })(DefinitionQueryOrder = exports2.DefinitionQueryOrder || (exports2.DefinitionQueryOrder = {}));
    var DefinitionQueueStatus;
    (function(DefinitionQueueStatus2) {
      DefinitionQueueStatus2[DefinitionQueueStatus2["Enabled"] = 0] = "Enabled";
      DefinitionQueueStatus2[DefinitionQueueStatus2["Paused"] = 1] = "Paused";
      DefinitionQueueStatus2[DefinitionQueueStatus2["Disabled"] = 2] = "Disabled";
    })(DefinitionQueueStatus = exports2.DefinitionQueueStatus || (exports2.DefinitionQueueStatus = {}));
    var DefinitionTriggerType;
    (function(DefinitionTriggerType2) {
      DefinitionTriggerType2[DefinitionTriggerType2["None"] = 1] = "None";
      DefinitionTriggerType2[DefinitionTriggerType2["ContinuousIntegration"] = 2] = "ContinuousIntegration";
      DefinitionTriggerType2[DefinitionTriggerType2["BatchedContinuousIntegration"] = 4] = "BatchedContinuousIntegration";
      DefinitionTriggerType2[DefinitionTriggerType2["Schedule"] = 8] = "Schedule";
      DefinitionTriggerType2[DefinitionTriggerType2["GatedCheckIn"] = 16] = "GatedCheckIn";
      DefinitionTriggerType2[DefinitionTriggerType2["BatchedGatedCheckIn"] = 32] = "BatchedGatedCheckIn";
      DefinitionTriggerType2[DefinitionTriggerType2["PullRequest"] = 64] = "PullRequest";
      DefinitionTriggerType2[DefinitionTriggerType2["BuildCompletion"] = 128] = "BuildCompletion";
      DefinitionTriggerType2[DefinitionTriggerType2["All"] = 255] = "All";
    })(DefinitionTriggerType = exports2.DefinitionTriggerType || (exports2.DefinitionTriggerType = {}));
    var DefinitionType;
    (function(DefinitionType2) {
      DefinitionType2[DefinitionType2["Xaml"] = 1] = "Xaml";
      DefinitionType2[DefinitionType2["Build"] = 2] = "Build";
    })(DefinitionType = exports2.DefinitionType || (exports2.DefinitionType = {}));
    var DeleteOptions;
    (function(DeleteOptions2) {
      DeleteOptions2[DeleteOptions2["None"] = 0] = "None";
      DeleteOptions2[DeleteOptions2["DropLocation"] = 1] = "DropLocation";
      DeleteOptions2[DeleteOptions2["TestResults"] = 2] = "TestResults";
      DeleteOptions2[DeleteOptions2["Label"] = 4] = "Label";
      DeleteOptions2[DeleteOptions2["Details"] = 8] = "Details";
      DeleteOptions2[DeleteOptions2["Symbols"] = 16] = "Symbols";
      DeleteOptions2[DeleteOptions2["All"] = 31] = "All";
    })(DeleteOptions = exports2.DeleteOptions || (exports2.DeleteOptions = {}));
    var FolderQueryOrder;
    (function(FolderQueryOrder2) {
      FolderQueryOrder2[FolderQueryOrder2["None"] = 0] = "None";
      FolderQueryOrder2[FolderQueryOrder2["FolderAscending"] = 1] = "FolderAscending";
      FolderQueryOrder2[FolderQueryOrder2["FolderDescending"] = 2] = "FolderDescending";
    })(FolderQueryOrder = exports2.FolderQueryOrder || (exports2.FolderQueryOrder = {}));
    var GetOption;
    (function(GetOption2) {
      GetOption2[GetOption2["LatestOnQueue"] = 0] = "LatestOnQueue";
      GetOption2[GetOption2["LatestOnBuild"] = 1] = "LatestOnBuild";
      GetOption2[GetOption2["Custom"] = 2] = "Custom";
    })(GetOption = exports2.GetOption || (exports2.GetOption = {}));
    var IssueType;
    (function(IssueType2) {
      IssueType2[IssueType2["Error"] = 1] = "Error";
      IssueType2[IssueType2["Warning"] = 2] = "Warning";
    })(IssueType = exports2.IssueType || (exports2.IssueType = {}));
    var ProcessTemplateType;
    (function(ProcessTemplateType2) {
      ProcessTemplateType2[ProcessTemplateType2["Custom"] = 0] = "Custom";
      ProcessTemplateType2[ProcessTemplateType2["Default"] = 1] = "Default";
      ProcessTemplateType2[ProcessTemplateType2["Upgrade"] = 2] = "Upgrade";
    })(ProcessTemplateType = exports2.ProcessTemplateType || (exports2.ProcessTemplateType = {}));
    var QueryDeletedOption;
    (function(QueryDeletedOption2) {
      QueryDeletedOption2[QueryDeletedOption2["ExcludeDeleted"] = 0] = "ExcludeDeleted";
      QueryDeletedOption2[QueryDeletedOption2["IncludeDeleted"] = 1] = "IncludeDeleted";
      QueryDeletedOption2[QueryDeletedOption2["OnlyDeleted"] = 2] = "OnlyDeleted";
    })(QueryDeletedOption = exports2.QueryDeletedOption || (exports2.QueryDeletedOption = {}));
    var QueueOptions;
    (function(QueueOptions2) {
      QueueOptions2[QueueOptions2["None"] = 0] = "None";
      QueueOptions2[QueueOptions2["DoNotRun"] = 1] = "DoNotRun";
    })(QueueOptions = exports2.QueueOptions || (exports2.QueueOptions = {}));
    var QueuePriority;
    (function(QueuePriority2) {
      QueuePriority2[QueuePriority2["Low"] = 5] = "Low";
      QueuePriority2[QueuePriority2["BelowNormal"] = 4] = "BelowNormal";
      QueuePriority2[QueuePriority2["Normal"] = 3] = "Normal";
      QueuePriority2[QueuePriority2["AboveNormal"] = 2] = "AboveNormal";
      QueuePriority2[QueuePriority2["High"] = 1] = "High";
    })(QueuePriority = exports2.QueuePriority || (exports2.QueuePriority = {}));
    var RepositoryCleanOptions;
    (function(RepositoryCleanOptions2) {
      RepositoryCleanOptions2[RepositoryCleanOptions2["Source"] = 0] = "Source";
      RepositoryCleanOptions2[RepositoryCleanOptions2["SourceAndOutputDir"] = 1] = "SourceAndOutputDir";
      RepositoryCleanOptions2[RepositoryCleanOptions2["SourceDir"] = 2] = "SourceDir";
      RepositoryCleanOptions2[RepositoryCleanOptions2["AllBuildDir"] = 3] = "AllBuildDir";
    })(RepositoryCleanOptions = exports2.RepositoryCleanOptions || (exports2.RepositoryCleanOptions = {}));
    var ResultSet;
    (function(ResultSet2) {
      ResultSet2[ResultSet2["All"] = 0] = "All";
      ResultSet2[ResultSet2["Top"] = 1] = "Top";
    })(ResultSet = exports2.ResultSet || (exports2.ResultSet = {}));
    var ScheduleDays;
    (function(ScheduleDays2) {
      ScheduleDays2[ScheduleDays2["None"] = 0] = "None";
      ScheduleDays2[ScheduleDays2["Monday"] = 1] = "Monday";
      ScheduleDays2[ScheduleDays2["Tuesday"] = 2] = "Tuesday";
      ScheduleDays2[ScheduleDays2["Wednesday"] = 4] = "Wednesday";
      ScheduleDays2[ScheduleDays2["Thursday"] = 8] = "Thursday";
      ScheduleDays2[ScheduleDays2["Friday"] = 16] = "Friday";
      ScheduleDays2[ScheduleDays2["Saturday"] = 32] = "Saturday";
      ScheduleDays2[ScheduleDays2["Sunday"] = 64] = "Sunday";
      ScheduleDays2[ScheduleDays2["All"] = 127] = "All";
    })(ScheduleDays = exports2.ScheduleDays || (exports2.ScheduleDays = {}));
    var ServiceHostStatus;
    (function(ServiceHostStatus2) {
      ServiceHostStatus2[ServiceHostStatus2["Online"] = 1] = "Online";
      ServiceHostStatus2[ServiceHostStatus2["Offline"] = 2] = "Offline";
    })(ServiceHostStatus = exports2.ServiceHostStatus || (exports2.ServiceHostStatus = {}));
    var SourceProviderAvailability;
    (function(SourceProviderAvailability2) {
      SourceProviderAvailability2[SourceProviderAvailability2["Hosted"] = 1] = "Hosted";
      SourceProviderAvailability2[SourceProviderAvailability2["OnPremises"] = 2] = "OnPremises";
      SourceProviderAvailability2[SourceProviderAvailability2["All"] = 3] = "All";
    })(SourceProviderAvailability = exports2.SourceProviderAvailability || (exports2.SourceProviderAvailability = {}));
    var StageUpdateType;
    (function(StageUpdateType2) {
      StageUpdateType2[StageUpdateType2["Cancel"] = 0] = "Cancel";
      StageUpdateType2[StageUpdateType2["Retry"] = 1] = "Retry";
    })(StageUpdateType = exports2.StageUpdateType || (exports2.StageUpdateType = {}));
    var SupportLevel;
    (function(SupportLevel2) {
      SupportLevel2[SupportLevel2["Unsupported"] = 0] = "Unsupported";
      SupportLevel2[SupportLevel2["Supported"] = 1] = "Supported";
      SupportLevel2[SupportLevel2["Required"] = 2] = "Required";
    })(SupportLevel = exports2.SupportLevel || (exports2.SupportLevel = {}));
    var TaskResult;
    (function(TaskResult2) {
      TaskResult2[TaskResult2["Succeeded"] = 0] = "Succeeded";
      TaskResult2[TaskResult2["SucceededWithIssues"] = 1] = "SucceededWithIssues";
      TaskResult2[TaskResult2["Failed"] = 2] = "Failed";
      TaskResult2[TaskResult2["Canceled"] = 3] = "Canceled";
      TaskResult2[TaskResult2["Skipped"] = 4] = "Skipped";
      TaskResult2[TaskResult2["Abandoned"] = 5] = "Abandoned";
    })(TaskResult = exports2.TaskResult || (exports2.TaskResult = {}));
    var TimelineRecordState;
    (function(TimelineRecordState2) {
      TimelineRecordState2[TimelineRecordState2["Pending"] = 0] = "Pending";
      TimelineRecordState2[TimelineRecordState2["InProgress"] = 1] = "InProgress";
      TimelineRecordState2[TimelineRecordState2["Completed"] = 2] = "Completed";
    })(TimelineRecordState = exports2.TimelineRecordState || (exports2.TimelineRecordState = {}));
    var ValidationResult;
    (function(ValidationResult2) {
      ValidationResult2[ValidationResult2["OK"] = 0] = "OK";
      ValidationResult2[ValidationResult2["Warning"] = 1] = "Warning";
      ValidationResult2[ValidationResult2["Error"] = 2] = "Error";
    })(ValidationResult = exports2.ValidationResult || (exports2.ValidationResult = {}));
    var WorkspaceMappingType;
    (function(WorkspaceMappingType2) {
      WorkspaceMappingType2[WorkspaceMappingType2["Map"] = 0] = "Map";
      WorkspaceMappingType2[WorkspaceMappingType2["Cloak"] = 1] = "Cloak";
    })(WorkspaceMappingType = exports2.WorkspaceMappingType || (exports2.WorkspaceMappingType = {}));
    exports2.TypeInfo = {
      AgentStatus: {
        enumValues: {
          "unavailable": 0,
          "available": 1,
          "offline": 2
        }
      },
      AuditAction: {
        enumValues: {
          "add": 1,
          "update": 2,
          "delete": 3
        }
      },
      Build: {},
      BuildAgent: {},
      BuildAuthorizationScope: {
        enumValues: {
          "projectCollection": 1,
          "project": 2
        }
      },
      BuildCompletedEvent: {},
      BuildCompletionTrigger: {},
      BuildController: {},
      BuildDefinition: {},
      BuildDefinition3_2: {},
      BuildDefinitionReference: {},
      BuildDefinitionReference3_2: {},
      BuildDefinitionRevision: {},
      BuildDefinitionSourceProvider: {},
      BuildDefinitionTemplate: {},
      BuildDefinitionTemplate3_2: {},
      BuildDeletedEvent: {},
      BuildDeployment: {},
      BuildLog: {},
      BuildMetric: {},
      BuildOptionDefinition: {},
      BuildOptionInputDefinition: {},
      BuildOptionInputType: {
        enumValues: {
          "string": 0,
          "boolean": 1,
          "stringList": 2,
          "radio": 3,
          "pickList": 4,
          "multiLine": 5,
          "branchFilter": 6
        }
      },
      BuildPhaseStatus: {
        enumValues: {
          "unknown": 0,
          "failed": 1,
          "succeeded": 2
        }
      },
      BuildProcessTemplate: {},
      BuildQueryOrder: {
        enumValues: {
          "finishTimeAscending": 2,
          "finishTimeDescending": 3,
          "queueTimeDescending": 4,
          "queueTimeAscending": 5,
          "startTimeDescending": 6,
          "startTimeAscending": 7
        }
      },
      BuildQueuedEvent: {},
      BuildReason: {
        enumValues: {
          "none": 0,
          "manual": 1,
          "individualCI": 2,
          "batchedCI": 4,
          "schedule": 8,
          "scheduleForced": 16,
          "userCreated": 32,
          "validateShelveset": 64,
          "checkInShelveset": 128,
          "pullRequest": 256,
          "buildCompletion": 512,
          "resourceTrigger": 1024,
          "triggered": 1967,
          "all": 2031
        }
      },
      BuildReference: {},
      BuildRequestValidationResult: {},
      BuildResult: {
        enumValues: {
          "none": 0,
          "succeeded": 2,
          "partiallySucceeded": 4,
          "failed": 8,
          "canceled": 32
        }
      },
      BuildRetentionHistory: {},
      BuildRetentionSample: {},
      BuildServer: {},
      BuildStatus: {
        enumValues: {
          "none": 0,
          "inProgress": 1,
          "completed": 2,
          "cancelling": 4,
          "postponed": 8,
          "notStarted": 32,
          "all": 47
        }
      },
      BuildSummary: {},
      BuildTagsAddedEvent: {},
      BuildTrigger: {},
      BuildUpdatedEvent: {},
      Change: {},
      ContinuousDeploymentDefinition: {},
      ContinuousIntegrationTrigger: {},
      ControllerStatus: {
        enumValues: {
          "unavailable": 0,
          "available": 1,
          "offline": 2
        }
      },
      DefinitionQuality: {
        enumValues: {
          "definition": 1,
          "draft": 2
        }
      },
      DefinitionQueryOrder: {
        enumValues: {
          "none": 0,
          "lastModifiedAscending": 1,
          "lastModifiedDescending": 2,
          "definitionNameAscending": 3,
          "definitionNameDescending": 4
        }
      },
      DefinitionQueueStatus: {
        enumValues: {
          "enabled": 0,
          "paused": 1,
          "disabled": 2
        }
      },
      DefinitionReference: {},
      DefinitionTriggerType: {
        enumValues: {
          "none": 1,
          "continuousIntegration": 2,
          "batchedContinuousIntegration": 4,
          "schedule": 8,
          "gatedCheckIn": 16,
          "batchedGatedCheckIn": 32,
          "pullRequest": 64,
          "buildCompletion": 128,
          "all": 255
        }
      },
      DefinitionType: {
        enumValues: {
          "xaml": 1,
          "build": 2
        }
      },
      DeleteOptions: {
        enumValues: {
          "none": 0,
          "dropLocation": 1,
          "testResults": 2,
          "label": 4,
          "details": 8,
          "symbols": 16,
          "all": 31
        }
      },
      DesignerProcess: {},
      Folder: {},
      FolderQueryOrder: {
        enumValues: {
          "none": 0,
          "folderAscending": 1,
          "folderDescending": 2
        }
      },
      GatedCheckInTrigger: {},
      GetOption: {
        enumValues: {
          "latestOnQueue": 0,
          "latestOnBuild": 1,
          "custom": 2
        }
      },
      InformationNode: {},
      Issue: {},
      IssueType: {
        enumValues: {
          "error": 1,
          "warning": 2
        }
      },
      Phase: {},
      ProcessTemplateType: {
        enumValues: {
          "custom": 0,
          "default": 1,
          "upgrade": 2
        }
      },
      PullRequestTrigger: {},
      QueryDeletedOption: {
        enumValues: {
          "excludeDeleted": 0,
          "includeDeleted": 1,
          "onlyDeleted": 2
        }
      },
      QueueOptions: {
        enumValues: {
          "none": 0,
          "doNotRun": 1
        }
      },
      QueuePriority: {
        enumValues: {
          "low": 5,
          "belowNormal": 4,
          "normal": 3,
          "aboveNormal": 2,
          "high": 1
        }
      },
      RepositoryCleanOptions: {
        enumValues: {
          "source": 0,
          "sourceAndOutputDir": 1,
          "sourceDir": 2,
          "allBuildDir": 3
        }
      },
      RepositoryWebhook: {},
      ResultSet: {
        enumValues: {
          "all": 0,
          "top": 1
        }
      },
      RetentionLease: {},
      Schedule: {},
      ScheduleDays: {
        enumValues: {
          "none": 0,
          "monday": 1,
          "tuesday": 2,
          "wednesday": 4,
          "thursday": 8,
          "friday": 16,
          "saturday": 32,
          "sunday": 64,
          "all": 127
        }
      },
      ScheduleTrigger: {},
      ServiceHostStatus: {
        enumValues: {
          "online": 1,
          "offline": 2
        }
      },
      SourceProviderAttributes: {},
      SourceProviderAvailability: {
        enumValues: {
          "hosted": 1,
          "onPremises": 2,
          "all": 3
        }
      },
      StageUpdateType: {
        enumValues: {
          "cancel": 0,
          "retry": 1
        }
      },
      SupportedTrigger: {},
      SupportLevel: {
        enumValues: {
          "unsupported": 0,
          "supported": 1,
          "required": 2
        }
      },
      TaskResult: {
        enumValues: {
          "succeeded": 0,
          "succeededWithIssues": 1,
          "failed": 2,
          "canceled": 3,
          "skipped": 4,
          "abandoned": 5
        }
      },
      Timeline: {},
      TimelineRecord: {},
      TimelineRecordState: {
        enumValues: {
          "pending": 0,
          "inProgress": 1,
          "completed": 2
        }
      },
      TimelineRecordsUpdatedEvent: {},
      UpdateStageParameters: {},
      ValidationResult: {
        enumValues: {
          "ok": 0,
          "warning": 1,
          "error": 2
        }
      },
      WorkspaceMapping: {},
      WorkspaceMappingType: {
        enumValues: {
          "map": 0,
          "cloak": 1
        }
      },
      WorkspaceTemplate: {},
      XamlBuildDefinition: {}
    };
    exports2.TypeInfo.Build.fields = {
      controller: {
        typeInfo: exports2.TypeInfo.BuildController
      },
      definition: {
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      deletedDate: {
        isDate: true
      },
      finishTime: {
        isDate: true
      },
      lastChangedDate: {
        isDate: true
      },
      priority: {
        enumType: exports2.TypeInfo.QueuePriority
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      queueOptions: {
        enumType: exports2.TypeInfo.QueueOptions
      },
      queueTime: {
        isDate: true
      },
      reason: {
        enumType: exports2.TypeInfo.BuildReason
      },
      result: {
        enumType: exports2.TypeInfo.BuildResult
      },
      startTime: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.BuildStatus
      },
      triggeredByBuild: {
        typeInfo: exports2.TypeInfo.Build
      },
      validationResults: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildRequestValidationResult
      }
    };
    exports2.TypeInfo.BuildAgent.fields = {
      createdDate: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.AgentStatus
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.BuildCompletedEvent.fields = {
      build: {
        typeInfo: exports2.TypeInfo.Build
      },
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Change
      },
      testResults: {
        typeInfo: TFS_TestManagement_Contracts.TypeInfo.AggregatedResultsAnalysis
      },
      timelineRecords: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TimelineRecord
      }
    };
    exports2.TypeInfo.BuildCompletionTrigger.fields = {
      definition: {
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      triggerType: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.BuildController.fields = {
      createdDate: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.ControllerStatus
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.BuildDefinition.fields = {
      createdDate: {
        isDate: true
      },
      draftOf: {
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      drafts: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      jobAuthorizationScope: {
        enumType: exports2.TypeInfo.BuildAuthorizationScope
      },
      latestBuild: {
        typeInfo: exports2.TypeInfo.Build
      },
      latestCompletedBuild: {
        typeInfo: exports2.TypeInfo.Build
      },
      metrics: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildMetric
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      quality: {
        enumType: exports2.TypeInfo.DefinitionQuality
      },
      queueStatus: {
        enumType: exports2.TypeInfo.DefinitionQueueStatus
      },
      triggers: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildTrigger
      },
      type: {
        enumType: exports2.TypeInfo.DefinitionType
      }
    };
    exports2.TypeInfo.BuildDefinition3_2.fields = {
      createdDate: {
        isDate: true
      },
      draftOf: {
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      drafts: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      jobAuthorizationScope: {
        enumType: exports2.TypeInfo.BuildAuthorizationScope
      },
      latestBuild: {
        typeInfo: exports2.TypeInfo.Build
      },
      latestCompletedBuild: {
        typeInfo: exports2.TypeInfo.Build
      },
      metrics: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildMetric
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      quality: {
        enumType: exports2.TypeInfo.DefinitionQuality
      },
      queueStatus: {
        enumType: exports2.TypeInfo.DefinitionQueueStatus
      },
      triggers: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildTrigger
      },
      type: {
        enumType: exports2.TypeInfo.DefinitionType
      }
    };
    exports2.TypeInfo.BuildDefinitionReference.fields = {
      createdDate: {
        isDate: true
      },
      draftOf: {
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      drafts: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      latestBuild: {
        typeInfo: exports2.TypeInfo.Build
      },
      latestCompletedBuild: {
        typeInfo: exports2.TypeInfo.Build
      },
      metrics: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildMetric
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      quality: {
        enumType: exports2.TypeInfo.DefinitionQuality
      },
      queueStatus: {
        enumType: exports2.TypeInfo.DefinitionQueueStatus
      },
      type: {
        enumType: exports2.TypeInfo.DefinitionType
      }
    };
    exports2.TypeInfo.BuildDefinitionReference3_2.fields = {
      createdDate: {
        isDate: true
      },
      draftOf: {
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      drafts: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DefinitionReference
      },
      metrics: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildMetric
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      quality: {
        enumType: exports2.TypeInfo.DefinitionQuality
      },
      queueStatus: {
        enumType: exports2.TypeInfo.DefinitionQueueStatus
      },
      type: {
        enumType: exports2.TypeInfo.DefinitionType
      }
    };
    exports2.TypeInfo.BuildDefinitionRevision.fields = {
      changedDate: {
        isDate: true
      },
      changeType: {
        enumType: exports2.TypeInfo.AuditAction
      }
    };
    exports2.TypeInfo.BuildDefinitionSourceProvider.fields = {
      lastModified: {
        isDate: true
      },
      supportedTriggerTypes: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.BuildDefinitionTemplate.fields = {
      template: {
        typeInfo: exports2.TypeInfo.BuildDefinition
      }
    };
    exports2.TypeInfo.BuildDefinitionTemplate3_2.fields = {
      template: {
        typeInfo: exports2.TypeInfo.BuildDefinition3_2
      }
    };
    exports2.TypeInfo.BuildDeletedEvent.fields = {
      build: {
        typeInfo: exports2.TypeInfo.Build
      }
    };
    exports2.TypeInfo.BuildDeployment.fields = {
      deployment: {
        typeInfo: exports2.TypeInfo.BuildSummary
      }
    };
    exports2.TypeInfo.BuildLog.fields = {
      createdOn: {
        isDate: true
      },
      lastChangedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.BuildMetric.fields = {
      date: {
        isDate: true
      }
    };
    exports2.TypeInfo.BuildOptionDefinition.fields = {
      inputs: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildOptionInputDefinition
      }
    };
    exports2.TypeInfo.BuildOptionInputDefinition.fields = {
      type: {
        enumType: exports2.TypeInfo.BuildOptionInputType
      }
    };
    exports2.TypeInfo.BuildProcessTemplate.fields = {
      supportedReasons: {
        enumType: exports2.TypeInfo.BuildReason
      },
      templateType: {
        enumType: exports2.TypeInfo.ProcessTemplateType
      }
    };
    exports2.TypeInfo.BuildQueuedEvent.fields = {
      build: {
        typeInfo: exports2.TypeInfo.Build
      }
    };
    exports2.TypeInfo.BuildReference.fields = {
      finishTime: {
        isDate: true
      },
      queueTime: {
        isDate: true
      },
      result: {
        enumType: exports2.TypeInfo.BuildResult
      },
      startTime: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.BuildStatus
      }
    };
    exports2.TypeInfo.BuildRequestValidationResult.fields = {
      result: {
        enumType: exports2.TypeInfo.ValidationResult
      }
    };
    exports2.TypeInfo.BuildRetentionHistory.fields = {
      buildRetentionSamples: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildRetentionSample
      }
    };
    exports2.TypeInfo.BuildRetentionSample.fields = {
      sampleTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.BuildServer.fields = {
      status: {
        enumType: exports2.TypeInfo.ServiceHostStatus
      },
      statusChangedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.BuildSummary.fields = {
      finishTime: {
        isDate: true
      },
      reason: {
        enumType: exports2.TypeInfo.BuildReason
      },
      startTime: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.BuildStatus
      }
    };
    exports2.TypeInfo.BuildTagsAddedEvent.fields = {
      build: {
        typeInfo: exports2.TypeInfo.Build
      }
    };
    exports2.TypeInfo.BuildTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.BuildUpdatedEvent.fields = {
      build: {
        typeInfo: exports2.TypeInfo.Build
      }
    };
    exports2.TypeInfo.Change.fields = {
      timestamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.ContinuousDeploymentDefinition.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.ContinuousIntegrationTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.DefinitionReference.fields = {
      createdDate: {
        isDate: true
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      queueStatus: {
        enumType: exports2.TypeInfo.DefinitionQueueStatus
      },
      type: {
        enumType: exports2.TypeInfo.DefinitionType
      }
    };
    exports2.TypeInfo.DesignerProcess.fields = {
      phases: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Phase
      }
    };
    exports2.TypeInfo.Folder.fields = {
      createdOn: {
        isDate: true
      },
      lastChangedDate: {
        isDate: true
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.GatedCheckInTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.InformationNode.fields = {
      lastModifiedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.Issue.fields = {
      type: {
        enumType: exports2.TypeInfo.IssueType
      }
    };
    exports2.TypeInfo.Phase.fields = {
      jobAuthorizationScope: {
        enumType: exports2.TypeInfo.BuildAuthorizationScope
      }
    };
    exports2.TypeInfo.PullRequestTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.RepositoryWebhook.fields = {
      types: {
        isArray: true,
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.RetentionLease.fields = {
      createdOn: {
        isDate: true
      },
      validUntil: {
        isDate: true
      }
    };
    exports2.TypeInfo.Schedule.fields = {
      daysToBuild: {
        enumType: exports2.TypeInfo.ScheduleDays
      }
    };
    exports2.TypeInfo.ScheduleTrigger.fields = {
      schedules: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Schedule
      },
      triggerType: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.SourceProviderAttributes.fields = {
      supportedTriggers: {
        isArray: true,
        typeInfo: exports2.TypeInfo.SupportedTrigger
      }
    };
    exports2.TypeInfo.SupportedTrigger.fields = {
      supportedCapabilities: {
        isDictionary: true,
        dictionaryValueEnumType: exports2.TypeInfo.SupportLevel
      },
      type: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      }
    };
    exports2.TypeInfo.Timeline.fields = {
      lastChangedOn: {
        isDate: true
      },
      records: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TimelineRecord
      }
    };
    exports2.TypeInfo.TimelineRecord.fields = {
      finishTime: {
        isDate: true
      },
      issues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Issue
      },
      lastModified: {
        isDate: true
      },
      result: {
        enumType: exports2.TypeInfo.TaskResult
      },
      startTime: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.TimelineRecordState
      }
    };
    exports2.TypeInfo.TimelineRecordsUpdatedEvent.fields = {
      timelineRecords: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TimelineRecord
      }
    };
    exports2.TypeInfo.UpdateStageParameters.fields = {
      state: {
        enumType: exports2.TypeInfo.StageUpdateType
      }
    };
    exports2.TypeInfo.WorkspaceMapping.fields = {
      mappingType: {
        enumType: exports2.TypeInfo.WorkspaceMappingType
      }
    };
    exports2.TypeInfo.WorkspaceTemplate.fields = {
      lastModifiedDate: {
        isDate: true
      },
      mappings: {
        isArray: true,
        typeInfo: exports2.TypeInfo.WorkspaceMapping
      }
    };
    exports2.TypeInfo.XamlBuildDefinition.fields = {
      controller: {
        typeInfo: exports2.TypeInfo.BuildController
      },
      createdDate: {
        isDate: true
      },
      createdOn: {
        isDate: true
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      queueStatus: {
        enumType: exports2.TypeInfo.DefinitionQueueStatus
      },
      supportedReasons: {
        enumType: exports2.TypeInfo.BuildReason
      },
      triggerType: {
        enumType: exports2.TypeInfo.DefinitionTriggerType
      },
      type: {
        enumType: exports2.TypeInfo.DefinitionType
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/BuildApi.js
var require_BuildApi = __commonJS({
  "../node_modules/azure-devops-node-api/BuildApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BuildApi = void 0;
    var basem = require_ClientApiBases();
    var BuildInterfaces = require_BuildInterfaces();
    var BuildApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Build-api", options);
      }
      /**
       * Associates an artifact with a build.
       *
       * @param {BuildInterfaces.BuildArtifact} artifact - The artifact.
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      createArtifact(artifact, project, buildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.5", "build", "1db06c96-014e-44e1-ac91-90b2d4b3e984", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, artifact, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a specific artifact for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} artifactName - The name of the artifact.
       */
      getArtifact(project, buildId, artifactName) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (artifactName == null) {
            throw new TypeError("artifactName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              artifactName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.5", "build", "1db06c96-014e-44e1-ac91-90b2d4b3e984", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a specific artifact for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} artifactName - The name of the artifact.
       */
      getArtifactContentZip(project, buildId, artifactName) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (artifactName == null) {
            throw new TypeError("artifactName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              artifactName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.5", "build", "1db06c96-014e-44e1-ac91-90b2d4b3e984", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets all artifacts for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      getArtifacts(project, buildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.5", "build", "1db06c96-014e-44e1-ac91-90b2d4b3e984", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a file from the build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} artifactName - The name of the artifact.
       * @param {string} fileId - The primary key for the file.
       * @param {string} fileName - The name that the file will be set to.
       */
      getFile(project, buildId, artifactName, fileId, fileName) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (artifactName == null) {
            throw new TypeError("artifactName can not be null or undefined");
          }
          if (fileId == null) {
            throw new TypeError("fileId can not be null or undefined");
          }
          if (fileName == null) {
            throw new TypeError("fileName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              artifactName,
              fileId,
              fileName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.5", "build", "1db06c96-014e-44e1-ac91-90b2d4b3e984", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the list of attachments of a specific type that are associated with a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} type - The type of attachment.
       */
      getAttachments(project, buildId, type) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "f2192269-89fa-4f94-baf6-8fb128c55159", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a specific attachment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} timelineId - The ID of the timeline.
       * @param {string} recordId - The ID of the timeline record.
       * @param {string} type - The type of the attachment.
       * @param {string} name - The name of the attachment.
       */
      getAttachment(project, buildId, timelineId, recordId, type, name) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              timelineId,
              recordId,
              type,
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "af5122d3-3438-485e-a25a-2dbbfde84ee6", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {BuildInterfaces.DefinitionResourceReference[]} resources
       * @param {string} project - Project ID or project name
       */
      authorizeProjectResources(resources, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "398c85bc-81aa-4822-947c-a194a05f0fef", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, resources, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} type
       * @param {string} id
       */
      getProjectResources(project, type, id) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              type,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "398c85bc-81aa-4822-947c-a194a05f0fef", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a badge that indicates the status of the most recent build for a definition. Note that this API is deprecated. Prefer StatusBadgeController.GetStatusBadge.
       *
       * @param {string} project - The project ID or name.
       * @param {number} definitionId - The ID of the definition.
       * @param {string} branchName - The name of the branch.
       */
      getBadge(project, definitionId, branchName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              branchName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "de6a4df8-22cd-44ee-af2d-39f6aa7a4261", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of branches for the given source code repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} providerName - The name of the source provider.
       * @param {string} serviceEndpointId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
       * @param {string} repository - The vendor-specific identifier or the name of the repository to get branches. Can only be omitted for providers that do not support multiple repositories.
       * @param {string} branchName - If supplied, the name of the branch to check for specifically.
       */
      listBranches(project, providerName, serviceEndpointId, repository, branchName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              providerName
            };
            let queryValues = {
              serviceEndpointId,
              repository,
              branchName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "e05d4403-9b81-4244-8763-20fde28d1976", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a badge that indicates the status of the most recent build for the specified branch.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repoType - The repository type.
       * @param {string} repoId - The repository ID.
       * @param {string} branchName - The branch name.
       */
      getBuildBadge(project, repoType, repoId, branchName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repoType
            };
            let queryValues = {
              repoId,
              branchName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "21b3b9ce-fad5-4567-9ad0-80679794e003", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a badge that indicates the status of the most recent build for the specified branch.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repoType - The repository type.
       * @param {string} repoId - The repository ID.
       * @param {string} branchName - The branch name.
       */
      getBuildBadgeData(project, repoType, repoId, branchName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repoType
            };
            let queryValues = {
              repoId,
              branchName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "21b3b9ce-fad5-4567-9ad0-80679794e003", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets all retention leases that apply to a specific build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      getRetentionLeasesForBuild(project, buildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "3da19a6a-f088-45c4-83ce-2ad3a87be6c4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.RetentionLease, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      deleteBuild(project, buildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "0cd358e1-9217-4d94-8269-1c1ee6f93dcf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a build
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} propertyFilters
       */
      getBuild(project, buildId, propertyFilters) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              propertyFilters
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "0cd358e1-9217-4d94-8269-1c1ee6f93dcf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Build, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of builds.
       *
       * @param {string} project - Project ID or project name
       * @param {number[]} definitions - A comma-delimited list of definition IDs. If specified, filters to builds for these definitions.
       * @param {number[]} queues - A comma-delimited list of queue IDs. If specified, filters to builds that ran against these queues.
       * @param {string} buildNumber - If specified, filters to builds that match this build number. Append * to do a prefix search.
       * @param {Date} minTime - If specified, filters to builds that finished/started/queued after this date based on the queryOrder specified.
       * @param {Date} maxTime - If specified, filters to builds that finished/started/queued before this date based on the queryOrder specified.
       * @param {string} requestedFor - If specified, filters to builds requested for the specified user.
       * @param {BuildInterfaces.BuildReason} reasonFilter - If specified, filters to builds that match this reason.
       * @param {BuildInterfaces.BuildStatus} statusFilter - If specified, filters to builds that match this status.
       * @param {BuildInterfaces.BuildResult} resultFilter - If specified, filters to builds that match this result.
       * @param {string[]} tagFilters - A comma-delimited list of tags. If specified, filters to builds that have the specified tags.
       * @param {string[]} properties - A comma-delimited list of properties to retrieve.
       * @param {number} top - The maximum number of builds to return.
       * @param {string} continuationToken - A continuation token, returned by a previous call to this method, that can be used to return the next set of builds.
       * @param {number} maxBuildsPerDefinition - The maximum number of builds to return per definition.
       * @param {BuildInterfaces.QueryDeletedOption} deletedFilter - Indicates whether to exclude, include, or only return deleted builds.
       * @param {BuildInterfaces.BuildQueryOrder} queryOrder - The order in which builds should be returned.
       * @param {string} branchName - If specified, filters to builds that built branches that built this branch.
       * @param {number[]} buildIds - A comma-delimited list that specifies the IDs of builds to retrieve.
       * @param {string} repositoryId - If specified, filters to builds that built from this repository.
       * @param {string} repositoryType - If specified, filters to builds that built from repositories of this type.
       */
      getBuilds(project, definitions, queues, buildNumber, minTime, maxTime, requestedFor, reasonFilter, statusFilter, resultFilter, tagFilters, properties, top, continuationToken, maxBuildsPerDefinition, deletedFilter, queryOrder, branchName, buildIds, repositoryId, repositoryType) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              definitions: definitions && definitions.join(","),
              queues: queues && queues.join(","),
              buildNumber,
              minTime,
              maxTime,
              requestedFor,
              reasonFilter,
              statusFilter,
              resultFilter,
              tagFilters: tagFilters && tagFilters.join(","),
              properties: properties && properties.join(","),
              "$top": top,
              continuationToken,
              maxBuildsPerDefinition,
              deletedFilter,
              queryOrder,
              branchName,
              buildIds: buildIds && buildIds.join(","),
              repositoryId,
              repositoryType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "0cd358e1-9217-4d94-8269-1c1ee6f93dcf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Build, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Queues a build
       *
       * @param {BuildInterfaces.Build} build
       * @param {string} project - Project ID or project name
       * @param {boolean} ignoreWarnings
       * @param {string} checkInTicket
       * @param {number} sourceBuildId
       * @param {number} definitionId - Optional definition id to queue a build without a body. Ignored if there's a valid body
       */
      queueBuild(build, project, ignoreWarnings, checkInTicket, sourceBuildId, definitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              ignoreWarnings,
              checkInTicket,
              sourceBuildId,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "0cd358e1-9217-4d94-8269-1c1ee6f93dcf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, build, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Build, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a build.
       *
       * @param {BuildInterfaces.Build} build - The build.
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {boolean} retry
       */
      updateBuild(build, project, buildId, retry) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              retry
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "0cd358e1-9217-4d94-8269-1c1ee6f93dcf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, build, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Build, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates multiple builds.
       *
       * @param {BuildInterfaces.Build[]} builds - The builds to update.
       * @param {string} project - Project ID or project name
       */
      updateBuilds(builds, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "0cd358e1-9217-4d94-8269-1c1ee6f93dcf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, builds, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Build, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the changes associated with a build
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} continuationToken
       * @param {number} top - The maximum number of changes to return
       * @param {boolean} includeSourceChange
       */
      getBuildChanges(project, buildId, continuationToken, top, includeSourceChange) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              continuationToken,
              "$top": top,
              includeSourceChange
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "54572c7b-bbd3-45d4-80dc-28be08941620", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Change, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the changes made to the repository between two given builds.
       *
       * @param {string} project - Project ID or project name
       * @param {number} fromBuildId - The ID of the first build.
       * @param {number} toBuildId - The ID of the last build.
       * @param {number} top - The maximum number of changes to return.
       */
      getChangesBetweenBuilds(project, fromBuildId, toBuildId, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              fromBuildId,
              toBuildId,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "f10f0ea5-18a1-43ec-a8fb-2042c7be9b43", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Change, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a controller
       *
       * @param {number} controllerId
       */
      getBuildController(controllerId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              controllerId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "fcac1932-2ee1-437f-9b6f-7f696be858f6", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildController, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets controller, optionally filtered by name
       *
       * @param {string} name
       */
      getBuildControllers(name) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "fcac1932-2ee1-437f-9b6f-7f696be858f6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildController, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new definition.
       *
       * @param {BuildInterfaces.BuildDefinition} definition - The definition.
       * @param {string} project - Project ID or project name
       * @param {number} definitionToCloneId
       * @param {number} definitionToCloneRevision
       */
      createDefinition(definition, project, definitionToCloneId, definitionToCloneRevision) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              definitionToCloneId,
              definitionToCloneRevision
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "dbeaf647-6167-421a-bda9-c9327b25e2e6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, definition, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a definition and all associated builds.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       */
      deleteDefinition(project, definitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "dbeaf647-6167-421a-bda9-c9327b25e2e6", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a definition, optionally at a specific revision.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       * @param {number} revision - The revision number to retrieve. If this is not specified, the latest version will be returned.
       * @param {Date} minMetricsTime - If specified, indicates the date from which metrics should be included.
       * @param {string[]} propertyFilters - A comma-delimited list of properties to include in the results.
       * @param {boolean} includeLatestBuilds
       */
      getDefinition(project, definitionId, revision, minMetricsTime, propertyFilters, includeLatestBuilds) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              revision,
              minMetricsTime,
              propertyFilters: propertyFilters && propertyFilters.join(","),
              includeLatestBuilds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "dbeaf647-6167-421a-bda9-c9327b25e2e6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of definitions.
       *
       * @param {string} project - Project ID or project name
       * @param {string} name - If specified, filters to definitions whose names match this pattern.
       * @param {string} repositoryId - A repository ID. If specified, filters to definitions that use this repository.
       * @param {string} repositoryType - If specified, filters to definitions that have a repository of this type.
       * @param {BuildInterfaces.DefinitionQueryOrder} queryOrder - Indicates the order in which definitions should be returned.
       * @param {number} top - The maximum number of definitions to return.
       * @param {string} continuationToken - A continuation token, returned by a previous call to this method, that can be used to return the next set of definitions.
       * @param {Date} minMetricsTime - If specified, indicates the date from which metrics should be included.
       * @param {number[]} definitionIds - A comma-delimited list that specifies the IDs of definitions to retrieve.
       * @param {string} path - If specified, filters to definitions under this folder.
       * @param {Date} builtAfter - If specified, filters to definitions that have builds after this date.
       * @param {Date} notBuiltAfter - If specified, filters to definitions that do not have builds after this date.
       * @param {boolean} includeAllProperties - Indicates whether the full definitions should be returned. By default, shallow representations of the definitions are returned.
       * @param {boolean} includeLatestBuilds - Indicates whether to return the latest and latest completed builds for this definition.
       * @param {string} taskIdFilter - If specified, filters to definitions that use the specified task.
       * @param {number} processType - If specified, filters to definitions with the given process type.
       * @param {string} yamlFilename - If specified, filters to YAML definitions that match the given filename. To use this filter includeAllProperties should be set to true
       */
      getDefinitions(project, name, repositoryId, repositoryType, queryOrder, top, continuationToken, minMetricsTime, definitionIds, path2, builtAfter, notBuiltAfter, includeAllProperties, includeLatestBuilds, taskIdFilter, processType, yamlFilename) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              name,
              repositoryId,
              repositoryType,
              queryOrder,
              "$top": top,
              continuationToken,
              minMetricsTime,
              definitionIds: definitionIds && definitionIds.join(","),
              path: path2,
              builtAfter,
              notBuiltAfter,
              includeAllProperties,
              includeLatestBuilds,
              taskIdFilter,
              processType,
              yamlFilename
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "dbeaf647-6167-421a-bda9-c9327b25e2e6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinitionReference, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Restores a deleted definition
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The identifier of the definition to restore.
       * @param {boolean} deleted - When false, restores a deleted definition.
       */
      restoreDefinition(project, definitionId, deleted) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (deleted == null) {
            throw new TypeError("deleted can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              deleted
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "dbeaf647-6167-421a-bda9-c9327b25e2e6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, null, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates an existing build definition.  In order for this operation to succeed, the value of the "Revision" property of the request body must match the existing build definition's. It is recommended that you obtain the existing build definition by using GET, modify the build definition as necessary, and then submit the modified definition with PUT.
       *
       * @param {BuildInterfaces.BuildDefinition} definition - The new version of the definition. Its "Revision" property must match the existing definition for the update to be accepted.
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       * @param {number} secretsSourceDefinitionId
       * @param {number} secretsSourceDefinitionRevision
       */
      updateDefinition(definition, project, definitionId, secretsSourceDefinitionId, secretsSourceDefinitionRevision) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              secretsSourceDefinitionId,
              secretsSourceDefinitionRevision
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "build", "dbeaf647-6167-421a-bda9-c9327b25e2e6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, definition, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the contents of a file in the given source code repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} providerName - The name of the source provider.
       * @param {string} serviceEndpointId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
       * @param {string} repository - If specified, the vendor-specific identifier or the name of the repository to get branches. Can only be omitted for providers that do not support multiple repositories.
       * @param {string} commitOrBranch - The identifier of the commit or branch from which a file's contents are retrieved.
       * @param {string} path - The path to the file to retrieve, relative to the root of the repository.
       */
      getFileContents(project, providerName, serviceEndpointId, repository, commitOrBranch, path2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              providerName
            };
            let queryValues = {
              serviceEndpointId,
              repository,
              commitOrBranch,
              path: path2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "29d12225-b1d9-425f-b668-6c594a981313", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new folder.
       *
       * @param {BuildInterfaces.Folder} folder - The folder.
       * @param {string} project - Project ID or project name
       * @param {string} path - The full path of the folder.
       */
      createFolder(folder, project, path2) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (path2 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              path: path2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "a906531b-d2da-4f55-bda7-f3e676cc50d9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, folder, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Folder, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a definition folder. Definitions and their corresponding builds will also be deleted.
       *
       * @param {string} project - Project ID or project name
       * @param {string} path - The full path to the folder.
       */
      deleteFolder(project, path2) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (path2 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              path: path2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "a906531b-d2da-4f55-bda7-f3e676cc50d9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of build definition folders.
       *
       * @param {string} project - Project ID or project name
       * @param {string} path - The path to start with.
       * @param {BuildInterfaces.FolderQueryOrder} queryOrder - The order in which folders should be returned.
       */
      getFolders(project, path2, queryOrder) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              path: path2
            };
            let queryValues = {
              queryOrder
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "a906531b-d2da-4f55-bda7-f3e676cc50d9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Folder, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates an existing folder at given  existing path
       *
       * @param {BuildInterfaces.Folder} folder - The new version of the folder.
       * @param {string} project - Project ID or project name
       * @param {string} path - The full path to the folder.
       */
      updateFolder(folder, project, path2) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (path2 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              path: path2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "a906531b-d2da-4f55-bda7-f3e676cc50d9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, folder, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Folder, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets pipeline general settings.
       *
       * @param {string} project - Project ID or project name
       */
      getBuildGeneralSettings(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "c4aefd19-30ff-405b-80ad-aca021e7242a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates pipeline general settings.
       *
       * @param {BuildInterfaces.PipelineGeneralSettings} newSettings
       * @param {string} project - Project ID or project name
       */
      updateBuildGeneralSettings(newSettings, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "c4aefd19-30ff-405b-80ad-aca021e7242a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, newSettings, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the retention history for the project collection. This includes pipelines that have custom retention rules that may prevent the retention job from cleaning them up, runs per pipeline with retention type, files associated with pipelines owned by the collection with retention type, and the number of files per pipeline.
       *
       * @param {number} daysToLookback
       */
      getRetentionHistory(daysToLookback) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              daysToLookback
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "1a9c48be-0ef5-4ec2-b94f-f053bdd2d3bf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildRetentionHistory, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the latest build for a definition, optionally scoped to a specific branch.
       *
       * @param {string} project - Project ID or project name
       * @param {string} definition - definition name with optional leading folder path, or the definition id
       * @param {string} branchName - optional parameter that indicates the specific branch to use. If not specified, the default branch is used.
       */
      getLatestBuild(project, definition, branchName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definition
            };
            let queryValues = {
              branchName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "54481611-01f4-47f3-998f-160da0f0c229", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Build, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds new leases for pipeline runs.
       *
       * @param {BuildInterfaces.NewRetentionLease[]} newLeases
       * @param {string} project - Project ID or project name
       */
      addRetentionLeases(newLeases, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "272051e4-9af1-45b5-ae22-8d960a5539d4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, newLeases, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.RetentionLease, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes specific retention leases.
       *
       * @param {string} project - Project ID or project name
       * @param {number[]} ids
       */
      deleteRetentionLeasesById(project, ids) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (ids == null) {
            throw new TypeError("ids can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              ids: ids && ids.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "272051e4-9af1-45b5-ae22-8d960a5539d4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the details of the retention lease given a lease id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} leaseId
       */
      getRetentionLease(project, leaseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              leaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "272051e4-9af1-45b5-ae22-8d960a5539d4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.RetentionLease, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns any leases matching the specified MinimalRetentionLeases
       *
       * @param {string} project - Project ID or project name
       * @param {BuildInterfaces.MinimalRetentionLease[]} leasesToFetch - List of JSON-serialized MinimalRetentionLeases separated by '|'
       */
      getRetentionLeasesByMinimalRetentionLeases(project, leasesToFetch) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (leasesToFetch == null) {
            throw new TypeError("leasesToFetch can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              leasesToFetch: leasesToFetch && leasesToFetch.join("|")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "272051e4-9af1-45b5-ae22-8d960a5539d4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.RetentionLease, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns any leases owned by the specified entity, optionally scoped to a single pipeline definition and run.
       *
       * @param {string} project - Project ID or project name
       * @param {string} ownerId
       * @param {number} definitionId - An optional parameter to limit the search to a specific pipeline definition.
       * @param {number} runId - An optional parameter to limit the search to a single pipeline run. Requires definitionId.
       */
      getRetentionLeasesByOwnerId(project, ownerId, definitionId, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              ownerId,
              definitionId,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "272051e4-9af1-45b5-ae22-8d960a5539d4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.RetentionLease, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns any leases owned by the specified user, optionally scoped to a single pipeline definition and run.
       *
       * @param {string} project - Project ID or project name
       * @param {string} userOwnerId - The user id to search for.
       * @param {number} definitionId - An optional parameter to limit the search to a specific pipeline definition.
       * @param {number} runId - An optional parameter to limit the search to a single pipeline run. Requires definitionId.
       */
      getRetentionLeasesByUserId(project, userOwnerId, definitionId, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (userOwnerId == null) {
            throw new TypeError("userOwnerId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              userOwnerId,
              definitionId,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "272051e4-9af1-45b5-ae22-8d960a5539d4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.RetentionLease, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates the duration or pipeline protection status of a retention lease.
       *
       * @param {BuildInterfaces.RetentionLeaseUpdate} leaseUpdate - The new data for the retention lease.
       * @param {string} project - Project ID or project name
       * @param {number} leaseId - The ID of the lease to update.
       */
      updateRetentionLease(leaseUpdate, project, leaseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              leaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "272051e4-9af1-45b5-ae22-8d960a5539d4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, leaseUpdate, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.RetentionLease, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets an individual log file for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {number} logId - The ID of the log file.
       * @param {number} startLine - The start line.
       * @param {number} endLine - The end line.
       */
      getBuildLog(project, buildId, logId, startLine, endLine) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              logId
            };
            let queryValues = {
              startLine,
              endLine
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "35a80daf-7f30-45fc-86e8-6b813d9c90df", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets an individual log file for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {number} logId - The ID of the log file.
       * @param {number} startLine - The start line.
       * @param {number} endLine - The end line.
       */
      getBuildLogLines(project, buildId, logId, startLine, endLine) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              logId
            };
            let queryValues = {
              startLine,
              endLine
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "35a80daf-7f30-45fc-86e8-6b813d9c90df", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the logs for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      getBuildLogs(project, buildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "35a80daf-7f30-45fc-86e8-6b813d9c90df", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildLog, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the logs for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      getBuildLogsZip(project, buildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "35a80daf-7f30-45fc-86e8-6b813d9c90df", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets an individual log file for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {number} logId - The ID of the log file.
       * @param {number} startLine - The start line.
       * @param {number} endLine - The end line.
       */
      getBuildLogZip(project, buildId, logId, startLine, endLine) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              logId
            };
            let queryValues = {
              startLine,
              endLine
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "35a80daf-7f30-45fc-86e8-6b813d9c90df", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets build metrics for a project.
       *
       * @param {string} project - Project ID or project name
       * @param {string} metricAggregationType - The aggregation type to use (hourly, daily).
       * @param {Date} minMetricsTime - The date from which to calculate metrics.
       */
      getProjectMetrics(project, metricAggregationType, minMetricsTime) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              metricAggregationType
            };
            let queryValues = {
              minMetricsTime
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "7433fae7-a6bc-41dc-a6e2-eef9005ce41a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildMetric, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets build metrics for a definition.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       * @param {Date} minMetricsTime - The date from which to calculate metrics.
       */
      getDefinitionMetrics(project, definitionId, minMetricsTime) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              minMetricsTime
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "d973b939-0ce0-4fec-91d8-da3940fa1827", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildMetric, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets all build definition options supported by the system.
       *
       * @param {string} project - Project ID or project name
       */
      getBuildOptionDefinitions(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "591cb5a4-2d46-4f3a-a697-5cd42b6bd332", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildOptionDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the contents of a directory in the given source code repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} providerName - The name of the source provider.
       * @param {string} serviceEndpointId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
       * @param {string} repository - If specified, the vendor-specific identifier or the name of the repository to get branches. Can only be omitted for providers that do not support multiple repositories.
       * @param {string} commitOrBranch - The identifier of the commit or branch from which a file's contents are retrieved.
       * @param {string} path - The path contents to list, relative to the root of the repository.
       */
      getPathContents(project, providerName, serviceEndpointId, repository, commitOrBranch, path2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              providerName
            };
            let queryValues = {
              serviceEndpointId,
              repository,
              commitOrBranch,
              path: path2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "7944d6fb-df01-4709-920a-7a189aa34037", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets properties for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string[]} filter - A comma-delimited list of properties. If specified, filters to these specific properties.
       */
      getBuildProperties(project, buildId, filter2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              filter: filter2 && filter2.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "0a6312e9-0627-49b7-8083-7d74a64849c9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates properties for a build.
       *
       * @param {VSSInterfaces.JsonPatchDocument} document - A json-patch document describing the properties to update.
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      updateBuildProperties(customHeaders, document, project, buildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/json-patch+json";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "0a6312e9-0627-49b7-8083-7d74a64849c9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.update(url, document, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets properties for a definition.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       * @param {string[]} filter - A comma-delimited list of properties. If specified, filters to these specific properties.
       */
      getDefinitionProperties(project, definitionId, filter2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              filter: filter2 && filter2.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "d9826ad7-2a68-46a9-a6e9-677698777895", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates properties for a definition.
       *
       * @param {VSSInterfaces.JsonPatchDocument} document - A json-patch document describing the properties to update.
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       */
      updateDefinitionProperties(customHeaders, document, project, definitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/json-patch+json";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "d9826ad7-2a68-46a9-a6e9-677698777895", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.update(url, document, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a pull request object from source provider.
       *
       * @param {string} project - Project ID or project name
       * @param {string} providerName - The name of the source provider.
       * @param {string} pullRequestId - Vendor-specific id of the pull request.
       * @param {string} repositoryId - Vendor-specific identifier or the name of the repository that contains the pull request.
       * @param {string} serviceEndpointId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
       */
      getPullRequest(project, providerName, pullRequestId, repositoryId, serviceEndpointId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              providerName,
              pullRequestId
            };
            let queryValues = {
              repositoryId,
              serviceEndpointId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "d8763ec7-9ff0-4fb4-b2b2-9d757906ff14", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a build report.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} type
       */
      getBuildReport(project, buildId, type) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "45bcaa88-67e1-4042-a035-56d3b4a7d44c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a build report.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} type
       */
      getBuildReportHtmlContent(project, buildId, type) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "45bcaa88-67e1-4042-a035-56d3b4a7d44c", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/html", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of source code repositories.
       *
       * @param {string} project - Project ID or project name
       * @param {string} providerName - The name of the source provider.
       * @param {string} serviceEndpointId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
       * @param {string} repository - If specified, the vendor-specific identifier or the name of a single repository to get.
       * @param {BuildInterfaces.ResultSet} resultSet - 'top' for the repositories most relevant for the endpoint. If not set, all repositories are returned. Ignored if 'repository' is set.
       * @param {boolean} pageResults - If set to true, this will limit the set of results and will return a continuation token to continue the query.
       * @param {string} continuationToken - When paging results, this is a continuation token, returned by a previous call to this method, that can be used to return the next set of repositories.
       */
      listRepositories(project, providerName, serviceEndpointId, repository, resultSet, pageResults, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              providerName
            };
            let queryValues = {
              serviceEndpointId,
              repository,
              resultSet,
              pageResults,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "d44d1680-f978-4834-9b93-8c6e132329c9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {BuildInterfaces.DefinitionResourceReference[]} resources
       * @param {string} project - Project ID or project name
       * @param {number} definitionId
       */
      authorizeDefinitionResources(resources, project, definitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "ea623316-1967-45eb-89ab-e9e6110cf2d6", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, resources, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} definitionId
       */
      getDefinitionResources(project, definitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "ea623316-1967-45eb-89ab-e9e6110cf2d6", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets information about build resources in the system.
       *
       */
      getResourceUsage() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "3813d06c-9e36-4ea1-aac3-61a485d60e3d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the project's retention settings.
       *
       * @param {string} project - Project ID or project name
       */
      getRetentionSettings(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "dadb46e7-5851-4c72-820e-ae8abb82f59f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates the project's retention settings.
       *
       * @param {BuildInterfaces.UpdateProjectRetentionSettingModel} updateModel
       * @param {string} project - Project ID or project name
       */
      updateRetentionSettings(updateModel, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "dadb46e7-5851-4c72-820e-ae8abb82f59f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateModel, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets all revisions of a definition.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       */
      getDefinitionRevisions(project, definitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "7c116775-52e5-453e-8c5d-914d9762d8c4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinitionRevision, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the build settings.
       *
       * @param {string} project - Project ID or project name
       */
      getBuildSettings(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "aa8c1c9c-ef8b-474a-b8c4-785c7b191d0d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates the build settings.
       *
       * @param {BuildInterfaces.BuildSettings} settings - The new settings.
       * @param {string} project - Project ID or project name
       */
      updateBuildSettings(settings, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "aa8c1c9c-ef8b-474a-b8c4-785c7b191d0d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, settings, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of source providers and their capabilities.
       *
       * @param {string} project - Project ID or project name
       */
      listSourceProviders(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "3ce81729-954f-423d-a581-9fea01d25186", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.SourceProviderAttributes, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a build stage
       *
       * @param {BuildInterfaces.UpdateStageParameters} updateParameters
       * @param {number} buildId
       * @param {string} stageRefName
       * @param {string} project - Project ID or project name
       */
      updateStage(updateParameters, buildId, stageRefName, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              stageRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "b8aac6c9-744b-46e1-88fc-3550969f9313", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateParameters, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * <p>Gets the build status for a definition, optionally scoped to a specific branch, stage, job, and configuration.</p> <p>If there are more than one, then it is required to pass in a stageName value when specifying a jobName, and the same rule then applies for both if passing a configuration parameter.</p>
       *
       * @param {string} project - Project ID or project name
       * @param {string} definition - Either the definition name with optional leading folder path, or the definition id.
       * @param {string} branchName - Only consider the most recent build for this branch. If not specified, the default branch is used.
       * @param {string} stageName - Use this stage within the pipeline to render the status.
       * @param {string} jobName - Use this job within a stage of the pipeline to render the status.
       * @param {string} configuration - Use this job configuration to render the status
       * @param {string} label - Replaces the default text on the left side of the badge.
       */
      getStatusBadge(project, definition, branchName, stageName, jobName, configuration, label) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definition
            };
            let queryValues = {
              branchName,
              stageName,
              jobName,
              configuration,
              label
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "07acfdce-4757-4439-b422-ddd13a2fcc10", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a tag to a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} tag - The tag to add.
       */
      addBuildTag(project, buildId, tag) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "6e6114b2-8161-44c8-8f6c-c5505782427f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds tags to a build.
       *
       * @param {string[]} tags - The tags to add. Request body is composed directly from listed tags.
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      addBuildTags(tags, project, buildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "6e6114b2-8161-44c8-8f6c-c5505782427f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, tags, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a tag from a build. NOTE: This API will not work for tags with special characters. To remove tags with special characters, use the PATCH method instead (in 6.0+)
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {string} tag - The tag to remove.
       */
      deleteBuildTag(project, buildId, tag) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "6e6114b2-8161-44c8-8f6c-c5505782427f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the tags for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      getBuildTags(project, buildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "6e6114b2-8161-44c8-8f6c-c5505782427f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds/Removes tags from a build.
       *
       * @param {BuildInterfaces.UpdateTagParameters} updateParameters - The tags to add/remove.
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       */
      updateBuildTags(updateParameters, project, buildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "6e6114b2-8161-44c8-8f6c-c5505782427f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateParameters, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a tag to a definition
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       * @param {string} tag - The tag to add.
       */
      addDefinitionTag(project, definitionId, tag) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "cb894432-134a-4d31-a839-83beceaace4b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds multiple tags to a definition.
       *
       * @param {string[]} tags - The tags to add.
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       */
      addDefinitionTags(tags, project, definitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "cb894432-134a-4d31-a839-83beceaace4b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, tags, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a tag from a definition. NOTE: This API will not work for tags with special characters. To remove tags with special characters, use the PATCH method instead (in 6.0+)
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       * @param {string} tag - The tag to remove.
       */
      deleteDefinitionTag(project, definitionId, tag) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "cb894432-134a-4d31-a839-83beceaace4b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the tags for a definition.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       * @param {number} revision - The definition revision number. If not specified, uses the latest revision of the definition.
       */
      getDefinitionTags(project, definitionId, revision) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              revision
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "cb894432-134a-4d31-a839-83beceaace4b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds/Removes tags from a definition.
       *
       * @param {BuildInterfaces.UpdateTagParameters} updateParameters - The tags to add/remove.
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       */
      updateDefinitionTags(updateParameters, project, definitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "cb894432-134a-4d31-a839-83beceaace4b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateParameters, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a tag from builds, definitions, and from the tag store
       *
       * @param {string} project - Project ID or project name
       * @param {string} tag - The tag to remove.
       */
      deleteTag(project, tag) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "d84ac5c6-edc7-43d5-adc9-1b34be5dea09", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of all build tags in the project.
       *
       * @param {string} project - Project ID or project name
       */
      getTags(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "d84ac5c6-edc7-43d5-adc9-1b34be5dea09", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a build definition template.
       *
       * @param {string} project - Project ID or project name
       * @param {string} templateId - The ID of the template.
       */
      deleteTemplate(project, templateId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "e884571e-7f92-4d6a-9274-3f5649900835", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a specific build definition template.
       *
       * @param {string} project - Project ID or project name
       * @param {string} templateId - The ID of the requested template.
       */
      getTemplate(project, templateId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "e884571e-7f92-4d6a-9274-3f5649900835", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinitionTemplate, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets all definition templates.
       *
       * @param {string} project - Project ID or project name
       */
      getTemplates(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "e884571e-7f92-4d6a-9274-3f5649900835", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinitionTemplate, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates an existing build definition template.
       *
       * @param {BuildInterfaces.BuildDefinitionTemplate} template - The new version of the template.
       * @param {string} project - Project ID or project name
       * @param {string} templateId - The ID of the template.
       */
      saveTemplate(template2, project, templateId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "build", "e884571e-7f92-4d6a-9274-3f5649900835", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, template2, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.BuildDefinitionTemplate, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets details for a build
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} timelineId
       * @param {number} changeId
       * @param {string} planId
       */
      getBuildTimeline(project, buildId, timelineId, changeId, planId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId,
              timelineId
            };
            let queryValues = {
              changeId,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "8baac422-4c6e-4de5-8532-db96d92acffa", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.Timeline, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Recreates the webhooks for the specified triggers in the given source code repository.
       *
       * @param {BuildInterfaces.DefinitionTriggerType[]} triggerTypes - The types of triggers to restore webhooks for.
       * @param {string} project - Project ID or project name
       * @param {string} providerName - The name of the source provider.
       * @param {string} serviceEndpointId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
       * @param {string} repository - If specified, the vendor-specific identifier or the name of the repository to get webhooks. Can only be omitted for providers that do not support multiple repositories.
       */
      restoreWebhooks(triggerTypes, project, providerName, serviceEndpointId, repository) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              providerName
            };
            let queryValues = {
              serviceEndpointId,
              repository
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "793bceb8-9736-4030-bd2f-fb3ce6d6b478", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, triggerTypes, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of webhooks installed in the given source code repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} providerName - The name of the source provider.
       * @param {string} serviceEndpointId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TFVC or TFGit.
       * @param {string} repository - If specified, the vendor-specific identifier or the name of the repository to get webhooks. Can only be omitted for providers that do not support multiple repositories.
       */
      listWebhooks(project, providerName, serviceEndpointId, repository) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              providerName
            };
            let queryValues = {
              serviceEndpointId,
              repository
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "8f20ff82-9498-4812-9f6e-9c01bdc50e99", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, BuildInterfaces.TypeInfo.RepositoryWebhook, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the work items associated with a build. Only work items in the same project are returned.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {number} top - The maximum number of work items to return.
       */
      getBuildWorkItemsRefs(project, buildId, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "5a21f5d2-5642-47e4-a0bd-1356e6731bee", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the work items associated with a build, filtered to specific commits.
       *
       * @param {string[]} commitIds - A comma-delimited list of commit IDs.
       * @param {string} project - Project ID or project name
       * @param {number} buildId - The ID of the build.
       * @param {number} top - The maximum number of work items to return, or the number of commits to consider if no commit IDs are specified.
       */
      getBuildWorkItemsRefsFromCommits(commitIds, project, buildId, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "5a21f5d2-5642-47e4-a0bd-1356e6731bee", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, commitIds, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets all the work items between two builds.
       *
       * @param {string} project - Project ID or project name
       * @param {number} fromBuildId - The ID of the first build.
       * @param {number} toBuildId - The ID of the last build.
       * @param {number} top - The maximum number of work items to return.
       */
      getWorkItemsBetweenBuilds(project, fromBuildId, toBuildId, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (fromBuildId == null) {
            throw new TypeError("fromBuildId can not be null or undefined");
          }
          if (toBuildId == null) {
            throw new TypeError("toBuildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              fromBuildId,
              toBuildId,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "build", "52ba8915-5518-42e3-a4bb-b0182d159e2d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Converts a definition to YAML, optionally at a specific revision.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - The ID of the definition.
       * @param {number} revision - The revision number to retrieve. If this is not specified, the latest version will be returned.
       * @param {Date} minMetricsTime - If specified, indicates the date from which metrics should be included.
       * @param {string[]} propertyFilters - A comma-delimited list of properties to include in the results.
       * @param {boolean} includeLatestBuilds
       */
      getDefinitionYaml(project, definitionId, revision, minMetricsTime, propertyFilters, includeLatestBuilds) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              revision,
              minMetricsTime,
              propertyFilters: propertyFilters && propertyFilters.join(","),
              includeLatestBuilds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "build", "7c3df3a1-7e51-4150-8cf7-540347f8697f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.BuildApi = BuildApi;
    BuildApi.RESOURCE_AREA_ID = "965220d5-5bb9-42cf-8d67-9b146df2a5a4";
  }
});

// ../node_modules/azure-devops-node-api/interfaces/common/OperationsInterfaces.js
var require_OperationsInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/common/OperationsInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.OperationStatus = void 0;
    var OperationStatus;
    (function(OperationStatus2) {
      OperationStatus2[OperationStatus2["NotSet"] = 0] = "NotSet";
      OperationStatus2[OperationStatus2["Queued"] = 1] = "Queued";
      OperationStatus2[OperationStatus2["InProgress"] = 2] = "InProgress";
      OperationStatus2[OperationStatus2["Cancelled"] = 3] = "Cancelled";
      OperationStatus2[OperationStatus2["Succeeded"] = 4] = "Succeeded";
      OperationStatus2[OperationStatus2["Failed"] = 5] = "Failed";
    })(OperationStatus = exports2.OperationStatus || (exports2.OperationStatus = {}));
    exports2.TypeInfo = {
      Operation: {},
      OperationReference: {},
      OperationStatus: {
        enumValues: {
          "notSet": 0,
          "queued": 1,
          "inProgress": 2,
          "cancelled": 3,
          "succeeded": 4,
          "failed": 5
        }
      }
    };
    exports2.TypeInfo.Operation.fields = {
      status: {
        enumType: exports2.TypeInfo.OperationStatus
      }
    };
    exports2.TypeInfo.OperationReference.fields = {
      status: {
        enumType: exports2.TypeInfo.OperationStatus
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/CoreApi.js
var require_CoreApi = __commonJS({
  "../node_modules/azure-devops-node-api/CoreApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CoreApi = void 0;
    var basem = require_ClientApiBases();
    var CoreInterfaces = require_CoreInterfaces();
    var OperationsInterfaces = require_OperationsInterfaces();
    var CoreApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Core-api", options);
      }
      /**
       * Removes the avatar for the project.
       *
       * @param {string} projectId - The ID or name of the project.
       */
      removeProjectAvatar(projectId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "54b2a2a0-859b-4d05-827c-ec4c862f641a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Sets the avatar for the project.
       *
       * @param {CoreInterfaces.ProjectAvatar} avatarBlob - The avatar blob data object to upload.
       * @param {string} projectId - The ID or name of the project.
       */
      setProjectAvatar(avatarBlob, projectId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "54b2a2a0-859b-4d05-827c-ec4c862f641a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, avatarBlob, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets list of user readable teams in a project and teams user is member of (excluded from readable list).
       *
       * @param {string} projectId - The name or ID (GUID) of the team project containing the teams to retrieve.
       * @param {boolean} expandIdentity - A value indicating whether or not to expand Identity information in the result WebApiTeam object.
       * @param {number} top - Maximum number of teams to return.
       * @param {number} skip - Number of teams to skip.
       */
      getProjectTeamsByCategory(projectId, expandIdentity, top, skip) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            let queryValues = {
              "$expandIdentity": expandIdentity,
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "6f9619ff-8b86-d011-b42d-00c04fc964ff", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {CoreInterfaces.WebApiConnectedServiceDetails} connectedServiceCreationData
       * @param {string} projectId
       */
      createConnectedService(connectedServiceCreationData, projectId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "b4f70219-e18b-42c5-abe3-98b07d35525e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, connectedServiceCreationData, options);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.WebApiConnectedService, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} projectId
       * @param {string} name
       */
      getConnectedServiceDetails(projectId, name) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId,
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "b4f70219-e18b-42c5-abe3-98b07d35525e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.WebApiConnectedServiceDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} projectId
       * @param {CoreInterfaces.ConnectedServiceKind} kind
       */
      getConnectedServices(projectId, kind) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            let queryValues = {
              kind
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "b4f70219-e18b-42c5-abe3-98b07d35525e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.WebApiConnectedService, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {CoreInterfaces.IdentityData} mruData
       * @param {string} mruName
       */
      createIdentityMru(mruData, mruName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              mruName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "5ead0b70-2572-4697-97e9-f341069a783a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, mruData, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {CoreInterfaces.IdentityData} mruData
       * @param {string} mruName
       */
      deleteIdentityMru(mruData, mruName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              mruName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "5ead0b70-2572-4697-97e9-f341069a783a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} mruName
       */
      getIdentityMru(mruName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              mruName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "5ead0b70-2572-4697-97e9-f341069a783a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {CoreInterfaces.IdentityData} mruData
       * @param {string} mruName
       */
      updateIdentityMru(mruData, mruName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              mruName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "5ead0b70-2572-4697-97e9-f341069a783a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, mruData, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of members for a specific team.
       *
       * @param {string} projectId - The name or ID (GUID) of the team project the team belongs to.
       * @param {string} teamId - The name or ID (GUID) of the team .
       * @param {number} top
       * @param {number} skip
       */
      getTeamMembersWithExtendedProperties(projectId, teamId, top, skip) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId,
              teamId
            };
            let queryValues = {
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "core", "294c494c-2600-4d7e-b76c-3dd50c3c95be", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a process by ID.
       *
       * @param {string} processId - ID for a process.
       */
      getProcessById(processId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "93878975-88c5-4e6a-8abb-7ddd77a8a7d8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.Process, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of processes.
       *
       */
      getProcesses() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "93878975-88c5-4e6a-8abb-7ddd77a8a7d8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.Process, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get project collection with the specified id or name.
       *
       * @param {string} collectionId
       */
      getProjectCollection(collectionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              collectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "core", "8031090f-ef1d-4af6-85fc-698cd75d42bf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.TeamProjectCollection, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get project collection references for this application.
       *
       * @param {number} top
       * @param {number} skip
       */
      getProjectCollections(top, skip) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "core", "8031090f-ef1d-4af6-85fc-698cd75d42bf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the history of changes to the project.
       *
       * @param {number} minRevision - The minimum revision number to return in the history.
       */
      getProjectHistoryEntries(minRevision) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              minRevision
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "core", "6488a877-4749-4954-82ea-7340d36be9f2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.ProjectInfo, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get project with the specified id or name, optionally including capabilities.
       *
       * @param {string} projectId
       * @param {boolean} includeCapabilities - Include capabilities (such as source control) in the team project result (default: false).
       * @param {boolean} includeHistory - Search within renamed projects (that had such name in the past).
       */
      getProject(projectId, includeCapabilities, includeHistory) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            let queryValues = {
              includeCapabilities,
              includeHistory
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "core", "603fe2ac-9723-48b9-88ad-09305aa6c6e1", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.TeamProject, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all projects in the organization that the authenticated user has access to.
       *
       * @param {any} stateFilter - Filter on team projects in a specific team project state (default: WellFormed).
       * @param {number} top
       * @param {number} skip
       * @param {number} continuationToken - Pointer that shows how many projects already been fetched.
       * @param {boolean} getDefaultTeamImageUrl
       */
      getProjects(stateFilter, top, skip, continuationToken, getDefaultTeamImageUrl) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              stateFilter,
              "$top": top,
              "$skip": skip,
              continuationToken,
              getDefaultTeamImageUrl
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "core", "603fe2ac-9723-48b9-88ad-09305aa6c6e1", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, CoreInterfaces.TypeInfo.TeamProjectReference, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Queues a project to be created. Use the [GetOperation](../../operations/operations/get) to periodically check for create project status.
       *
       * @param {CoreInterfaces.TeamProject} projectToCreate - The project to create.
       */
      queueCreateProject(projectToCreate) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "core", "603fe2ac-9723-48b9-88ad-09305aa6c6e1", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, projectToCreate, options);
              let ret = this.formatResponse(res.result, OperationsInterfaces.TypeInfo.OperationReference, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Queues a project to be deleted. Use the [GetOperation](../../operations/operations/get) to periodically check for delete project status.
       *
       * @param {string} projectId - The project id of the project to delete.
       */
      queueDeleteProject(projectId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "core", "603fe2ac-9723-48b9-88ad-09305aa6c6e1", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, OperationsInterfaces.TypeInfo.OperationReference, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update an existing project's name, abbreviation, description, or restore a project.
       *
       * @param {CoreInterfaces.TeamProject} projectUpdate - The updates for the project. The state must be set to wellFormed to restore the project.
       * @param {string} projectId - The project id of the project to update.
       */
      updateProject(projectUpdate, projectId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "core", "603fe2ac-9723-48b9-88ad-09305aa6c6e1", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, projectUpdate, options);
              let ret = this.formatResponse(res.result, OperationsInterfaces.TypeInfo.OperationReference, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a collection of team project properties for multiple projects.
       *
       * @param {string[]} projectIds - A comma-delimited string of team project IDs
       * @param {string[]} properties
       */
      getProjectsProperties(projectIds, properties) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (projectIds == null) {
            throw new TypeError("projectIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              projectIds: projectIds && projectIds.join(","),
              properties: properties && properties.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "0a3ffdfc-fe94-47a6-bb27-79bf3f762eac", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a collection of team project properties.
       *
       * @param {string} projectId - The team project ID.
       * @param {string[]} keys - A comma-delimited string of team project property names. Wildcard characters ("?" and "*") are supported. If no key is specified, all properties will be returned.
       */
      getProjectProperties(projectId, keys2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            let queryValues = {
              keys: keys2 && keys2.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "4976a71a-4487-49aa-8aab-a1eda469037a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create, update, and delete team project properties.
       *
       * @param {string} projectId - The team project ID.
       * @param {VSSInterfaces.JsonPatchDocument} patchDocument - A JSON Patch document that represents an array of property operations. See RFC 6902 for more details on JSON Patch. The accepted operation verbs are Add and Remove, where Add is used for both creating and updating properties. The path consists of a forward slash and a property name.
       */
      setProjectProperties(customHeaders, projectId, patchDocument) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/json-patch+json";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "core", "4976a71a-4487-49aa-8aab-a1eda469037a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.update(url, patchDocument, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {CoreInterfaces.Proxy} proxy
       */
      createOrUpdateProxy(proxy) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "core", "ec1f4311-f2b4-4c15-b2b8-8990b80d2908", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, proxy, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} proxyUrl
       * @param {string} site
       */
      deleteProxy(proxyUrl, site) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (proxyUrl == null) {
            throw new TypeError("proxyUrl can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              proxyUrl,
              site
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "core", "ec1f4311-f2b4-4c15-b2b8-8990b80d2908", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} proxyUrl
       */
      getProxies(proxyUrl) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              proxyUrl
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "core", "ec1f4311-f2b4-4c15-b2b8-8990b80d2908", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of all teams.
       *
       * @param {boolean} mine - If true, then return all teams requesting user is member. Otherwise return all teams user has read access.
       * @param {number} top - Maximum number of teams to return.
       * @param {number} skip - Number of teams to skip.
       * @param {boolean} expandIdentity - A value indicating whether or not to expand Identity information in the result WebApiTeam object.
       */
      getAllTeams(mine, top, skip, expandIdentity) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$mine": mine,
              "$top": top,
              "$skip": skip,
              "$expandIdentity": expandIdentity
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "core", "7a4d9ee9-3433-4347-b47a-7a80f1cf307e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a team in a team project.
       *
       * @param {CoreInterfaces.WebApiTeam} team - The team data used to create the team.
       * @param {string} projectId - The name or ID (GUID) of the team project in which to create the team.
       */
      createTeam(team, projectId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "core", "d30a3dd1-f8ba-442a-b86a-bd0c0c383e59", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, team, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a team.
       *
       * @param {string} projectId - The name or ID (GUID) of the team project containing the team to delete.
       * @param {string} teamId - The name or ID of the team to delete.
       */
      deleteTeam(projectId, teamId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId,
              teamId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "core", "d30a3dd1-f8ba-442a-b86a-bd0c0c383e59", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a specific team.
       *
       * @param {string} projectId - The name or ID (GUID) of the team project containing the team.
       * @param {string} teamId - The name or ID (GUID) of the team.
       * @param {boolean} expandIdentity - A value indicating whether or not to expand Identity information in the result WebApiTeam object.
       */
      getTeam(projectId, teamId, expandIdentity) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId,
              teamId
            };
            let queryValues = {
              "$expandIdentity": expandIdentity
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "core", "d30a3dd1-f8ba-442a-b86a-bd0c0c383e59", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of teams.
       *
       * @param {string} projectId
       * @param {boolean} mine - If true return all the teams requesting user is member, otherwise return all the teams user has read access.
       * @param {number} top - Maximum number of teams to return.
       * @param {number} skip - Number of teams to skip.
       * @param {boolean} expandIdentity - A value indicating whether or not to expand Identity information in the result WebApiTeam object.
       */
      getTeams(projectId, mine, top, skip, expandIdentity) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId
            };
            let queryValues = {
              "$mine": mine,
              "$top": top,
              "$skip": skip,
              "$expandIdentity": expandIdentity
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "core", "d30a3dd1-f8ba-442a-b86a-bd0c0c383e59", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a team's name and/or description.
       *
       * @param {CoreInterfaces.WebApiTeam} teamData
       * @param {string} projectId - The name or ID (GUID) of the team project containing the team to update.
       * @param {string} teamId - The name of ID of the team to update.
       */
      updateTeam(teamData, projectId, teamId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId,
              teamId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "core", "d30a3dd1-f8ba-442a-b86a-bd0c0c383e59", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, teamData, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.CoreApi = CoreApi;
    CoreApi.RESOURCE_AREA_ID = "79134c72-4a58-4b42-976c-04e7115f32bf";
  }
});

// ../node_modules/azure-devops-node-api/interfaces/DashboardInterfaces.js
var require_DashboardInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/DashboardInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.WidgetScope = exports2.TeamDashboardPermission = exports2.GroupMemberPermission = exports2.DashboardScope = void 0;
    var DashboardScope;
    (function(DashboardScope2) {
      DashboardScope2[DashboardScope2["Collection_User"] = 0] = "Collection_User";
      DashboardScope2[DashboardScope2["Project_Team"] = 1] = "Project_Team";
      DashboardScope2[DashboardScope2["Project"] = 2] = "Project";
    })(DashboardScope = exports2.DashboardScope || (exports2.DashboardScope = {}));
    var GroupMemberPermission;
    (function(GroupMemberPermission2) {
      GroupMemberPermission2[GroupMemberPermission2["None"] = 0] = "None";
      GroupMemberPermission2[GroupMemberPermission2["Edit"] = 1] = "Edit";
      GroupMemberPermission2[GroupMemberPermission2["Manage"] = 2] = "Manage";
      GroupMemberPermission2[GroupMemberPermission2["ManagePermissions"] = 3] = "ManagePermissions";
    })(GroupMemberPermission = exports2.GroupMemberPermission || (exports2.GroupMemberPermission = {}));
    var TeamDashboardPermission;
    (function(TeamDashboardPermission2) {
      TeamDashboardPermission2[TeamDashboardPermission2["None"] = 0] = "None";
      TeamDashboardPermission2[TeamDashboardPermission2["Read"] = 1] = "Read";
      TeamDashboardPermission2[TeamDashboardPermission2["Create"] = 2] = "Create";
      TeamDashboardPermission2[TeamDashboardPermission2["Edit"] = 4] = "Edit";
      TeamDashboardPermission2[TeamDashboardPermission2["Delete"] = 8] = "Delete";
      TeamDashboardPermission2[TeamDashboardPermission2["ManagePermissions"] = 16] = "ManagePermissions";
    })(TeamDashboardPermission = exports2.TeamDashboardPermission || (exports2.TeamDashboardPermission = {}));
    var WidgetScope;
    (function(WidgetScope2) {
      WidgetScope2[WidgetScope2["Collection_User"] = 0] = "Collection_User";
      WidgetScope2[WidgetScope2["Project_Team"] = 1] = "Project_Team";
    })(WidgetScope = exports2.WidgetScope || (exports2.WidgetScope = {}));
    exports2.TypeInfo = {
      CopyDashboardOptions: {},
      CopyDashboardResponse: {},
      Dashboard: {},
      DashboardGroup: {},
      DashboardGroupEntry: {},
      DashboardGroupEntryResponse: {},
      DashboardResponse: {},
      DashboardScope: {
        enumValues: {
          "collection_User": 0,
          "project_Team": 1,
          "project": 2
        }
      },
      GroupMemberPermission: {
        enumValues: {
          "none": 0,
          "edit": 1,
          "manage": 2,
          "managePermissions": 3
        }
      },
      TeamDashboardPermission: {
        enumValues: {
          "none": 0,
          "read": 1,
          "create": 2,
          "edit": 4,
          "delete": 8,
          "managePermissions": 16
        }
      },
      Widget: {},
      WidgetMetadata: {},
      WidgetMetadataResponse: {},
      WidgetResponse: {},
      WidgetScope: {
        enumValues: {
          "collection_User": 0,
          "project_Team": 1
        }
      },
      WidgetsVersionedList: {},
      WidgetTypesResponse: {}
    };
    exports2.TypeInfo.CopyDashboardOptions.fields = {
      copyDashboardScope: {
        enumType: exports2.TypeInfo.DashboardScope
      }
    };
    exports2.TypeInfo.CopyDashboardResponse.fields = {
      copiedDashboard: {
        typeInfo: exports2.TypeInfo.Dashboard
      },
      copyDashboardOptions: {
        typeInfo: exports2.TypeInfo.CopyDashboardOptions
      }
    };
    exports2.TypeInfo.Dashboard.fields = {
      dashboardScope: {
        enumType: exports2.TypeInfo.DashboardScope
      },
      lastAccessedDate: {
        isDate: true
      },
      modifiedDate: {
        isDate: true
      },
      widgets: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Widget
      }
    };
    exports2.TypeInfo.DashboardGroup.fields = {
      dashboardEntries: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DashboardGroupEntry
      },
      permission: {
        enumType: exports2.TypeInfo.GroupMemberPermission
      },
      teamDashboardPermission: {
        enumType: exports2.TypeInfo.TeamDashboardPermission
      }
    };
    exports2.TypeInfo.DashboardGroupEntry.fields = {
      dashboardScope: {
        enumType: exports2.TypeInfo.DashboardScope
      },
      lastAccessedDate: {
        isDate: true
      },
      modifiedDate: {
        isDate: true
      },
      widgets: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Widget
      }
    };
    exports2.TypeInfo.DashboardGroupEntryResponse.fields = {
      dashboardScope: {
        enumType: exports2.TypeInfo.DashboardScope
      },
      lastAccessedDate: {
        isDate: true
      },
      modifiedDate: {
        isDate: true
      },
      widgets: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Widget
      }
    };
    exports2.TypeInfo.DashboardResponse.fields = {
      dashboardScope: {
        enumType: exports2.TypeInfo.DashboardScope
      },
      lastAccessedDate: {
        isDate: true
      },
      modifiedDate: {
        isDate: true
      },
      widgets: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Widget
      }
    };
    exports2.TypeInfo.Widget.fields = {
      dashboard: {
        typeInfo: exports2.TypeInfo.Dashboard
      }
    };
    exports2.TypeInfo.WidgetMetadata.fields = {
      supportedScopes: {
        isArray: true,
        enumType: exports2.TypeInfo.WidgetScope
      }
    };
    exports2.TypeInfo.WidgetMetadataResponse.fields = {
      widgetMetadata: {
        typeInfo: exports2.TypeInfo.WidgetMetadata
      }
    };
    exports2.TypeInfo.WidgetResponse.fields = {
      dashboard: {
        typeInfo: exports2.TypeInfo.Dashboard
      }
    };
    exports2.TypeInfo.WidgetsVersionedList.fields = {
      widgets: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Widget
      }
    };
    exports2.TypeInfo.WidgetTypesResponse.fields = {
      widgetTypes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.WidgetMetadata
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/DashboardApi.js
var require_DashboardApi = __commonJS({
  "../node_modules/azure-devops-node-api/DashboardApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DashboardApi = void 0;
    var basem = require_ClientApiBases();
    var DashboardInterfaces = require_DashboardInterfaces();
    var DashboardApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Dashboard-api", options);
      }
      /**
       * Create the supplied dashboard.
       *
       * @param {DashboardInterfaces.Dashboard} dashboard - The initial state of the dashboard
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      createDashboard(dashboard, teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Dashboard", "454b3e51-2e6e-48d4-ad81-978154089351", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, dashboard, options);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Dashboard, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a dashboard given its ID. This also deletes the widgets associated with this dashboard.
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} dashboardId - ID of the dashboard to delete.
       */
      deleteDashboard(teamContext, dashboardId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              dashboardId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Dashboard", "454b3e51-2e6e-48d4-ad81-978154089351", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a dashboard by its ID.
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} dashboardId
       */
      getDashboard(teamContext, dashboardId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              dashboardId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Dashboard", "454b3e51-2e6e-48d4-ad81-978154089351", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Dashboard, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of dashboards under a project.
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      getDashboardsByProject(teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Dashboard", "454b3e51-2e6e-48d4-ad81-978154089351", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Dashboard, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Replace configuration for the specified dashboard. Replaces Widget list on Dashboard, only if property is supplied.
       *
       * @param {DashboardInterfaces.Dashboard} dashboard - The Configuration of the dashboard to replace.
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} dashboardId - ID of the dashboard to replace.
       */
      replaceDashboard(dashboard, teamContext, dashboardId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              dashboardId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Dashboard", "454b3e51-2e6e-48d4-ad81-978154089351", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, dashboard, options);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Dashboard, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the name and position of dashboards in the supplied group, and remove omitted dashboards. Does not modify dashboard content.
       *
       * @param {DashboardInterfaces.DashboardGroup} group
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      replaceDashboards(group2, teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Dashboard", "454b3e51-2e6e-48d4-ad81-978154089351", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, group2, options);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.DashboardGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a widget on the specified dashboard.
       *
       * @param {DashboardInterfaces.Widget} widget - State of the widget to add
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} dashboardId - ID of dashboard the widget will be added to.
       */
      createWidget(widget, teamContext, dashboardId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              dashboardId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Dashboard", "bdcff53a-8355-4172-a00a-40497ea23afc", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, widget, options);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Widget, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete the specified widget.
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} dashboardId - ID of the dashboard containing the widget.
       * @param {string} widgetId - ID of the widget to update.
       */
      deleteWidget(teamContext, dashboardId, widgetId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              dashboardId,
              widgetId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Dashboard", "bdcff53a-8355-4172-a00a-40497ea23afc", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Dashboard, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the current state of the specified widget.
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} dashboardId - ID of the dashboard containing the widget.
       * @param {string} widgetId - ID of the widget to read.
       */
      getWidget(teamContext, dashboardId, widgetId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              dashboardId,
              widgetId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Dashboard", "bdcff53a-8355-4172-a00a-40497ea23afc", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Widget, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Override the  state of the specified widget.
       *
       * @param {DashboardInterfaces.Widget} widget - State to be written for the widget.
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} dashboardId - ID of the dashboard containing the widget.
       * @param {string} widgetId - ID of the widget to update.
       */
      replaceWidget(widget, teamContext, dashboardId, widgetId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              dashboardId,
              widgetId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Dashboard", "bdcff53a-8355-4172-a00a-40497ea23afc", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, widget, options);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Widget, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Perform a partial update of the specified widget.
       *
       * @param {DashboardInterfaces.Widget} widget - Description of the widget changes to apply. All non-null fields will be replaced.
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} dashboardId - ID of the dashboard containing the widget.
       * @param {string} widgetId - ID of the widget to update.
       */
      updateWidget(widget, teamContext, dashboardId, widgetId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              dashboardId,
              widgetId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Dashboard", "bdcff53a-8355-4172-a00a-40497ea23afc", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, widget, options);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.Widget, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the widget metadata satisfying the specified contribution ID.
       *
       * @param {string} contributionId - The ID of Contribution for the Widget
       * @param {string} project - Project ID or project name
       */
      getWidgetMetadata(contributionId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              contributionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Dashboard", "6b3628d3-e96f-4fc7-b176-50240b03b515", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.WidgetMetadataResponse, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all available widget metadata in alphabetical order, including widgets marked with isVisibleFromCatalog == false.
       *
       * @param {DashboardInterfaces.WidgetScope} scope
       * @param {string} project - Project ID or project name
       */
      getWidgetTypes(scope, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (scope == null) {
            throw new TypeError("scope can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              "$scope": scope
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Dashboard", "6b3628d3-e96f-4fc7-b176-50240b03b515", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, DashboardInterfaces.TypeInfo.WidgetTypesResponse, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.DashboardApi = DashboardApi;
    DashboardApi.RESOURCE_AREA_ID = "31c84e0a-3ece-48fd-a29d-100849af99ba";
  }
});

// ../node_modules/azure-devops-node-api/interfaces/GalleryInterfaces.js
var require_GalleryInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/GalleryInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.VSCodeWebExtensionStatisicsType = exports2.SortOrderType = exports2.SortByType = exports2.ReviewResourceType = exports2.ReviewPatchOperation = exports2.ReviewFilterOptions = exports2.ReviewEventOperation = exports2.RestApiResponseStatus = exports2.QnAItemStatus = exports2.PublisherState = exports2.PublisherRoleAccess = exports2.PublisherQueryFlags = exports2.PublisherPermissions = exports2.PublisherFlags = exports2.PublishedExtensionFlags = exports2.PagingDirection = exports2.NotificationTemplateType = exports2.ExtensionVersionFlags = exports2.ExtensionStatsAggregateType = exports2.ExtensionStatisticOperation = exports2.ExtensionQueryFlags = exports2.ExtensionQueryFilterType = exports2.ExtensionPolicyFlags = exports2.ExtensionLifecycleEventType = exports2.ExtensionDeploymentTechnology = exports2.DraftStateType = exports2.DraftPatchOperation = exports2.ConcernCategory = exports2.AcquisitionOperationType = exports2.AcquisitionOperationState = exports2.AcquisitionAssignmentType = void 0;
    var AcquisitionAssignmentType;
    (function(AcquisitionAssignmentType2) {
      AcquisitionAssignmentType2[AcquisitionAssignmentType2["None"] = 0] = "None";
      AcquisitionAssignmentType2[AcquisitionAssignmentType2["Me"] = 1] = "Me";
      AcquisitionAssignmentType2[AcquisitionAssignmentType2["All"] = 2] = "All";
    })(AcquisitionAssignmentType = exports2.AcquisitionAssignmentType || (exports2.AcquisitionAssignmentType = {}));
    var AcquisitionOperationState;
    (function(AcquisitionOperationState2) {
      AcquisitionOperationState2[AcquisitionOperationState2["Disallow"] = 0] = "Disallow";
      AcquisitionOperationState2[AcquisitionOperationState2["Allow"] = 1] = "Allow";
      AcquisitionOperationState2[AcquisitionOperationState2["Completed"] = 3] = "Completed";
    })(AcquisitionOperationState = exports2.AcquisitionOperationState || (exports2.AcquisitionOperationState = {}));
    var AcquisitionOperationType;
    (function(AcquisitionOperationType2) {
      AcquisitionOperationType2[AcquisitionOperationType2["Get"] = 0] = "Get";
      AcquisitionOperationType2[AcquisitionOperationType2["Install"] = 1] = "Install";
      AcquisitionOperationType2[AcquisitionOperationType2["Buy"] = 2] = "Buy";
      AcquisitionOperationType2[AcquisitionOperationType2["Try"] = 3] = "Try";
      AcquisitionOperationType2[AcquisitionOperationType2["Request"] = 4] = "Request";
      AcquisitionOperationType2[AcquisitionOperationType2["None"] = 5] = "None";
      AcquisitionOperationType2[AcquisitionOperationType2["PurchaseRequest"] = 6] = "PurchaseRequest";
    })(AcquisitionOperationType = exports2.AcquisitionOperationType || (exports2.AcquisitionOperationType = {}));
    var ConcernCategory;
    (function(ConcernCategory2) {
      ConcernCategory2[ConcernCategory2["General"] = 1] = "General";
      ConcernCategory2[ConcernCategory2["Abusive"] = 2] = "Abusive";
      ConcernCategory2[ConcernCategory2["Spam"] = 4] = "Spam";
    })(ConcernCategory = exports2.ConcernCategory || (exports2.ConcernCategory = {}));
    var DraftPatchOperation;
    (function(DraftPatchOperation2) {
      DraftPatchOperation2[DraftPatchOperation2["Publish"] = 1] = "Publish";
      DraftPatchOperation2[DraftPatchOperation2["Cancel"] = 2] = "Cancel";
    })(DraftPatchOperation = exports2.DraftPatchOperation || (exports2.DraftPatchOperation = {}));
    var DraftStateType;
    (function(DraftStateType2) {
      DraftStateType2[DraftStateType2["Unpublished"] = 1] = "Unpublished";
      DraftStateType2[DraftStateType2["Published"] = 2] = "Published";
      DraftStateType2[DraftStateType2["Cancelled"] = 3] = "Cancelled";
      DraftStateType2[DraftStateType2["Error"] = 4] = "Error";
    })(DraftStateType = exports2.DraftStateType || (exports2.DraftStateType = {}));
    var ExtensionDeploymentTechnology;
    (function(ExtensionDeploymentTechnology2) {
      ExtensionDeploymentTechnology2[ExtensionDeploymentTechnology2["Exe"] = 1] = "Exe";
      ExtensionDeploymentTechnology2[ExtensionDeploymentTechnology2["Msi"] = 2] = "Msi";
      ExtensionDeploymentTechnology2[ExtensionDeploymentTechnology2["Vsix"] = 3] = "Vsix";
      ExtensionDeploymentTechnology2[ExtensionDeploymentTechnology2["ReferralLink"] = 4] = "ReferralLink";
    })(ExtensionDeploymentTechnology = exports2.ExtensionDeploymentTechnology || (exports2.ExtensionDeploymentTechnology = {}));
    var ExtensionLifecycleEventType;
    (function(ExtensionLifecycleEventType2) {
      ExtensionLifecycleEventType2[ExtensionLifecycleEventType2["Uninstall"] = 1] = "Uninstall";
      ExtensionLifecycleEventType2[ExtensionLifecycleEventType2["Install"] = 2] = "Install";
      ExtensionLifecycleEventType2[ExtensionLifecycleEventType2["Review"] = 3] = "Review";
      ExtensionLifecycleEventType2[ExtensionLifecycleEventType2["Acquisition"] = 4] = "Acquisition";
      ExtensionLifecycleEventType2[ExtensionLifecycleEventType2["Sales"] = 5] = "Sales";
      ExtensionLifecycleEventType2[ExtensionLifecycleEventType2["Other"] = 999] = "Other";
    })(ExtensionLifecycleEventType = exports2.ExtensionLifecycleEventType || (exports2.ExtensionLifecycleEventType = {}));
    var ExtensionPolicyFlags;
    (function(ExtensionPolicyFlags2) {
      ExtensionPolicyFlags2[ExtensionPolicyFlags2["None"] = 0] = "None";
      ExtensionPolicyFlags2[ExtensionPolicyFlags2["Private"] = 1] = "Private";
      ExtensionPolicyFlags2[ExtensionPolicyFlags2["Public"] = 2] = "Public";
      ExtensionPolicyFlags2[ExtensionPolicyFlags2["Preview"] = 4] = "Preview";
      ExtensionPolicyFlags2[ExtensionPolicyFlags2["Released"] = 8] = "Released";
      ExtensionPolicyFlags2[ExtensionPolicyFlags2["FirstParty"] = 16] = "FirstParty";
      ExtensionPolicyFlags2[ExtensionPolicyFlags2["All"] = 31] = "All";
    })(ExtensionPolicyFlags = exports2.ExtensionPolicyFlags || (exports2.ExtensionPolicyFlags = {}));
    var ExtensionQueryFilterType;
    (function(ExtensionQueryFilterType2) {
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["Tag"] = 1] = "Tag";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["DisplayName"] = 2] = "DisplayName";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["Private"] = 3] = "Private";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["Id"] = 4] = "Id";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["Category"] = 5] = "Category";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["ContributionType"] = 6] = "ContributionType";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["Name"] = 7] = "Name";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["InstallationTarget"] = 8] = "InstallationTarget";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["Featured"] = 9] = "Featured";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["SearchText"] = 10] = "SearchText";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["FeaturedInCategory"] = 11] = "FeaturedInCategory";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["ExcludeWithFlags"] = 12] = "ExcludeWithFlags";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["IncludeWithFlags"] = 13] = "IncludeWithFlags";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["Lcid"] = 14] = "Lcid";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["InstallationTargetVersion"] = 15] = "InstallationTargetVersion";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["InstallationTargetVersionRange"] = 16] = "InstallationTargetVersionRange";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["VsixMetadata"] = 17] = "VsixMetadata";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["PublisherName"] = 18] = "PublisherName";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["PublisherDisplayName"] = 19] = "PublisherDisplayName";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["IncludeWithPublisherFlags"] = 20] = "IncludeWithPublisherFlags";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["OrganizationSharedWith"] = 21] = "OrganizationSharedWith";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["ProductArchitecture"] = 22] = "ProductArchitecture";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["TargetPlatform"] = 23] = "TargetPlatform";
      ExtensionQueryFilterType2[ExtensionQueryFilterType2["ExtensionName"] = 24] = "ExtensionName";
    })(ExtensionQueryFilterType = exports2.ExtensionQueryFilterType || (exports2.ExtensionQueryFilterType = {}));
    var ExtensionQueryFlags;
    (function(ExtensionQueryFlags2) {
      ExtensionQueryFlags2[ExtensionQueryFlags2["None"] = 0] = "None";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeVersions"] = 1] = "IncludeVersions";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeFiles"] = 2] = "IncludeFiles";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeCategoryAndTags"] = 4] = "IncludeCategoryAndTags";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeSharedAccounts"] = 8] = "IncludeSharedAccounts";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeVersionProperties"] = 16] = "IncludeVersionProperties";
      ExtensionQueryFlags2[ExtensionQueryFlags2["ExcludeNonValidated"] = 32] = "ExcludeNonValidated";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeInstallationTargets"] = 64] = "IncludeInstallationTargets";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeAssetUri"] = 128] = "IncludeAssetUri";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeStatistics"] = 256] = "IncludeStatistics";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeLatestVersionOnly"] = 512] = "IncludeLatestVersionOnly";
      ExtensionQueryFlags2[ExtensionQueryFlags2["UseFallbackAssetUri"] = 1024] = "UseFallbackAssetUri";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeMetadata"] = 2048] = "IncludeMetadata";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeMinimalPayloadForVsIde"] = 4096] = "IncludeMinimalPayloadForVsIde";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeLcids"] = 8192] = "IncludeLcids";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeSharedOrganizations"] = 16384] = "IncludeSharedOrganizations";
      ExtensionQueryFlags2[ExtensionQueryFlags2["IncludeNameConflictInfo"] = 32768] = "IncludeNameConflictInfo";
      ExtensionQueryFlags2[ExtensionQueryFlags2["AllAttributes"] = 16863] = "AllAttributes";
    })(ExtensionQueryFlags = exports2.ExtensionQueryFlags || (exports2.ExtensionQueryFlags = {}));
    var ExtensionStatisticOperation;
    (function(ExtensionStatisticOperation2) {
      ExtensionStatisticOperation2[ExtensionStatisticOperation2["None"] = 0] = "None";
      ExtensionStatisticOperation2[ExtensionStatisticOperation2["Set"] = 1] = "Set";
      ExtensionStatisticOperation2[ExtensionStatisticOperation2["Increment"] = 2] = "Increment";
      ExtensionStatisticOperation2[ExtensionStatisticOperation2["Decrement"] = 3] = "Decrement";
      ExtensionStatisticOperation2[ExtensionStatisticOperation2["Delete"] = 4] = "Delete";
    })(ExtensionStatisticOperation = exports2.ExtensionStatisticOperation || (exports2.ExtensionStatisticOperation = {}));
    var ExtensionStatsAggregateType;
    (function(ExtensionStatsAggregateType2) {
      ExtensionStatsAggregateType2[ExtensionStatsAggregateType2["Daily"] = 1] = "Daily";
    })(ExtensionStatsAggregateType = exports2.ExtensionStatsAggregateType || (exports2.ExtensionStatsAggregateType = {}));
    var ExtensionVersionFlags;
    (function(ExtensionVersionFlags2) {
      ExtensionVersionFlags2[ExtensionVersionFlags2["None"] = 0] = "None";
      ExtensionVersionFlags2[ExtensionVersionFlags2["Validated"] = 1] = "Validated";
    })(ExtensionVersionFlags = exports2.ExtensionVersionFlags || (exports2.ExtensionVersionFlags = {}));
    var NotificationTemplateType;
    (function(NotificationTemplateType2) {
      NotificationTemplateType2[NotificationTemplateType2["ReviewNotification"] = 1] = "ReviewNotification";
      NotificationTemplateType2[NotificationTemplateType2["QnaNotification"] = 2] = "QnaNotification";
      NotificationTemplateType2[NotificationTemplateType2["CustomerContactNotification"] = 3] = "CustomerContactNotification";
      NotificationTemplateType2[NotificationTemplateType2["PublisherMemberUpdateNotification"] = 4] = "PublisherMemberUpdateNotification";
    })(NotificationTemplateType = exports2.NotificationTemplateType || (exports2.NotificationTemplateType = {}));
    var PagingDirection;
    (function(PagingDirection2) {
      PagingDirection2[PagingDirection2["Backward"] = 1] = "Backward";
      PagingDirection2[PagingDirection2["Forward"] = 2] = "Forward";
    })(PagingDirection = exports2.PagingDirection || (exports2.PagingDirection = {}));
    var PublishedExtensionFlags;
    (function(PublishedExtensionFlags2) {
      PublishedExtensionFlags2[PublishedExtensionFlags2["None"] = 0] = "None";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Disabled"] = 1] = "Disabled";
      PublishedExtensionFlags2[PublishedExtensionFlags2["BuiltIn"] = 2] = "BuiltIn";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Validated"] = 4] = "Validated";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Trusted"] = 8] = "Trusted";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Paid"] = 16] = "Paid";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Public"] = 256] = "Public";
      PublishedExtensionFlags2[PublishedExtensionFlags2["MultiVersion"] = 512] = "MultiVersion";
      PublishedExtensionFlags2[PublishedExtensionFlags2["System"] = 1024] = "System";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Preview"] = 2048] = "Preview";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Unpublished"] = 4096] = "Unpublished";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Trial"] = 8192] = "Trial";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Locked"] = 16384] = "Locked";
      PublishedExtensionFlags2[PublishedExtensionFlags2["Hidden"] = 32768] = "Hidden";
    })(PublishedExtensionFlags = exports2.PublishedExtensionFlags || (exports2.PublishedExtensionFlags = {}));
    var PublisherFlags;
    (function(PublisherFlags2) {
      PublisherFlags2[PublisherFlags2["UnChanged"] = 1073741824] = "UnChanged";
      PublisherFlags2[PublisherFlags2["None"] = 0] = "None";
      PublisherFlags2[PublisherFlags2["Disabled"] = 1] = "Disabled";
      PublisherFlags2[PublisherFlags2["Verified"] = 2] = "Verified";
      PublisherFlags2[PublisherFlags2["Certified"] = 4] = "Certified";
      PublisherFlags2[PublisherFlags2["ServiceFlags"] = 7] = "ServiceFlags";
    })(PublisherFlags = exports2.PublisherFlags || (exports2.PublisherFlags = {}));
    var PublisherPermissions;
    (function(PublisherPermissions2) {
      PublisherPermissions2[PublisherPermissions2["Read"] = 1] = "Read";
      PublisherPermissions2[PublisherPermissions2["UpdateExtension"] = 2] = "UpdateExtension";
      PublisherPermissions2[PublisherPermissions2["CreatePublisher"] = 4] = "CreatePublisher";
      PublisherPermissions2[PublisherPermissions2["PublishExtension"] = 8] = "PublishExtension";
      PublisherPermissions2[PublisherPermissions2["Admin"] = 16] = "Admin";
      PublisherPermissions2[PublisherPermissions2["TrustedPartner"] = 32] = "TrustedPartner";
      PublisherPermissions2[PublisherPermissions2["PrivateRead"] = 64] = "PrivateRead";
      PublisherPermissions2[PublisherPermissions2["DeleteExtension"] = 128] = "DeleteExtension";
      PublisherPermissions2[PublisherPermissions2["EditSettings"] = 256] = "EditSettings";
      PublisherPermissions2[PublisherPermissions2["ViewPermissions"] = 512] = "ViewPermissions";
      PublisherPermissions2[PublisherPermissions2["ManagePermissions"] = 1024] = "ManagePermissions";
      PublisherPermissions2[PublisherPermissions2["DeletePublisher"] = 2048] = "DeletePublisher";
    })(PublisherPermissions = exports2.PublisherPermissions || (exports2.PublisherPermissions = {}));
    var PublisherQueryFlags;
    (function(PublisherQueryFlags2) {
      PublisherQueryFlags2[PublisherQueryFlags2["None"] = 0] = "None";
      PublisherQueryFlags2[PublisherQueryFlags2["IncludeExtensions"] = 1] = "IncludeExtensions";
      PublisherQueryFlags2[PublisherQueryFlags2["IncludeEmailAddress"] = 2] = "IncludeEmailAddress";
    })(PublisherQueryFlags = exports2.PublisherQueryFlags || (exports2.PublisherQueryFlags = {}));
    var PublisherRoleAccess;
    (function(PublisherRoleAccess2) {
      PublisherRoleAccess2[PublisherRoleAccess2["Assigned"] = 1] = "Assigned";
      PublisherRoleAccess2[PublisherRoleAccess2["Inherited"] = 2] = "Inherited";
    })(PublisherRoleAccess = exports2.PublisherRoleAccess || (exports2.PublisherRoleAccess = {}));
    var PublisherState;
    (function(PublisherState2) {
      PublisherState2[PublisherState2["None"] = 0] = "None";
      PublisherState2[PublisherState2["VerificationPending"] = 1] = "VerificationPending";
      PublisherState2[PublisherState2["CertificationPending"] = 2] = "CertificationPending";
      PublisherState2[PublisherState2["CertificationRejected"] = 4] = "CertificationRejected";
      PublisherState2[PublisherState2["CertificationRevoked"] = 8] = "CertificationRevoked";
    })(PublisherState = exports2.PublisherState || (exports2.PublisherState = {}));
    var QnAItemStatus;
    (function(QnAItemStatus2) {
      QnAItemStatus2[QnAItemStatus2["None"] = 0] = "None";
      QnAItemStatus2[QnAItemStatus2["UserEditable"] = 1] = "UserEditable";
      QnAItemStatus2[QnAItemStatus2["PublisherCreated"] = 2] = "PublisherCreated";
    })(QnAItemStatus = exports2.QnAItemStatus || (exports2.QnAItemStatus = {}));
    var RestApiResponseStatus;
    (function(RestApiResponseStatus2) {
      RestApiResponseStatus2[RestApiResponseStatus2["Completed"] = 0] = "Completed";
      RestApiResponseStatus2[RestApiResponseStatus2["Failed"] = 1] = "Failed";
      RestApiResponseStatus2[RestApiResponseStatus2["Inprogress"] = 2] = "Inprogress";
      RestApiResponseStatus2[RestApiResponseStatus2["Skipped"] = 3] = "Skipped";
    })(RestApiResponseStatus = exports2.RestApiResponseStatus || (exports2.RestApiResponseStatus = {}));
    var ReviewEventOperation;
    (function(ReviewEventOperation2) {
      ReviewEventOperation2[ReviewEventOperation2["Create"] = 1] = "Create";
      ReviewEventOperation2[ReviewEventOperation2["Update"] = 2] = "Update";
      ReviewEventOperation2[ReviewEventOperation2["Delete"] = 3] = "Delete";
    })(ReviewEventOperation = exports2.ReviewEventOperation || (exports2.ReviewEventOperation = {}));
    var ReviewFilterOptions;
    (function(ReviewFilterOptions2) {
      ReviewFilterOptions2[ReviewFilterOptions2["None"] = 0] = "None";
      ReviewFilterOptions2[ReviewFilterOptions2["FilterEmptyReviews"] = 1] = "FilterEmptyReviews";
      ReviewFilterOptions2[ReviewFilterOptions2["FilterEmptyUserNames"] = 2] = "FilterEmptyUserNames";
    })(ReviewFilterOptions = exports2.ReviewFilterOptions || (exports2.ReviewFilterOptions = {}));
    var ReviewPatchOperation;
    (function(ReviewPatchOperation2) {
      ReviewPatchOperation2[ReviewPatchOperation2["FlagReview"] = 1] = "FlagReview";
      ReviewPatchOperation2[ReviewPatchOperation2["UpdateReview"] = 2] = "UpdateReview";
      ReviewPatchOperation2[ReviewPatchOperation2["ReplyToReview"] = 3] = "ReplyToReview";
      ReviewPatchOperation2[ReviewPatchOperation2["AdminResponseForReview"] = 4] = "AdminResponseForReview";
      ReviewPatchOperation2[ReviewPatchOperation2["DeleteAdminReply"] = 5] = "DeleteAdminReply";
      ReviewPatchOperation2[ReviewPatchOperation2["DeletePublisherReply"] = 6] = "DeletePublisherReply";
    })(ReviewPatchOperation = exports2.ReviewPatchOperation || (exports2.ReviewPatchOperation = {}));
    var ReviewResourceType;
    (function(ReviewResourceType2) {
      ReviewResourceType2[ReviewResourceType2["Review"] = 1] = "Review";
      ReviewResourceType2[ReviewResourceType2["PublisherReply"] = 2] = "PublisherReply";
      ReviewResourceType2[ReviewResourceType2["AdminReply"] = 3] = "AdminReply";
    })(ReviewResourceType = exports2.ReviewResourceType || (exports2.ReviewResourceType = {}));
    var SortByType;
    (function(SortByType2) {
      SortByType2[SortByType2["Relevance"] = 0] = "Relevance";
      SortByType2[SortByType2["LastUpdatedDate"] = 1] = "LastUpdatedDate";
      SortByType2[SortByType2["Title"] = 2] = "Title";
      SortByType2[SortByType2["Publisher"] = 3] = "Publisher";
      SortByType2[SortByType2["InstallCount"] = 4] = "InstallCount";
      SortByType2[SortByType2["PublishedDate"] = 5] = "PublishedDate";
      SortByType2[SortByType2["AverageRating"] = 6] = "AverageRating";
      SortByType2[SortByType2["TrendingDaily"] = 7] = "TrendingDaily";
      SortByType2[SortByType2["TrendingWeekly"] = 8] = "TrendingWeekly";
      SortByType2[SortByType2["TrendingMonthly"] = 9] = "TrendingMonthly";
      SortByType2[SortByType2["ReleaseDate"] = 10] = "ReleaseDate";
      SortByType2[SortByType2["Author"] = 11] = "Author";
      SortByType2[SortByType2["WeightedRating"] = 12] = "WeightedRating";
    })(SortByType = exports2.SortByType || (exports2.SortByType = {}));
    var SortOrderType;
    (function(SortOrderType2) {
      SortOrderType2[SortOrderType2["Default"] = 0] = "Default";
      SortOrderType2[SortOrderType2["Ascending"] = 1] = "Ascending";
      SortOrderType2[SortOrderType2["Descending"] = 2] = "Descending";
    })(SortOrderType = exports2.SortOrderType || (exports2.SortOrderType = {}));
    var VSCodeWebExtensionStatisicsType;
    (function(VSCodeWebExtensionStatisicsType2) {
      VSCodeWebExtensionStatisicsType2[VSCodeWebExtensionStatisicsType2["Install"] = 1] = "Install";
      VSCodeWebExtensionStatisicsType2[VSCodeWebExtensionStatisicsType2["Update"] = 2] = "Update";
      VSCodeWebExtensionStatisicsType2[VSCodeWebExtensionStatisicsType2["Uninstall"] = 3] = "Uninstall";
    })(VSCodeWebExtensionStatisicsType = exports2.VSCodeWebExtensionStatisicsType || (exports2.VSCodeWebExtensionStatisicsType = {}));
    exports2.TypeInfo = {
      AcquisitionAssignmentType: {
        enumValues: {
          "none": 0,
          "me": 1,
          "all": 2
        }
      },
      AcquisitionOperation: {},
      AcquisitionOperationState: {
        enumValues: {
          "disallow": 0,
          "allow": 1,
          "completed": 3
        }
      },
      AcquisitionOperationType: {
        enumValues: {
          "get": 0,
          "install": 1,
          "buy": 2,
          "try": 3,
          "request": 4,
          "none": 5,
          "purchaseRequest": 6
        }
      },
      AcquisitionOptions: {},
      AzureRestApiResponseModel: {},
      Concern: {},
      ConcernCategory: {
        enumValues: {
          "general": 1,
          "abusive": 2,
          "spam": 4
        }
      },
      CustomerLastContact: {},
      CustomerSupportRequest: {},
      DraftPatchOperation: {
        enumValues: {
          "publish": 1,
          "cancel": 2
        }
      },
      DraftStateType: {
        enumValues: {
          "unpublished": 1,
          "published": 2,
          "cancelled": 3,
          "error": 4
        }
      },
      ExtensionAcquisitionRequest: {},
      ExtensionDailyStat: {},
      ExtensionDailyStats: {},
      ExtensionDeploymentTechnology: {
        enumValues: {
          "exe": 1,
          "msi": 2,
          "vsix": 3,
          "referralLink": 4
        }
      },
      ExtensionDraft: {},
      ExtensionDraftPatch: {},
      ExtensionEvent: {},
      ExtensionEvents: {},
      ExtensionFilterResult: {},
      ExtensionLifecycleEventType: {
        enumValues: {
          "uninstall": 1,
          "install": 2,
          "review": 3,
          "acquisition": 4,
          "sales": 5,
          "other": 999
        }
      },
      ExtensionPayload: {},
      ExtensionPolicy: {},
      ExtensionPolicyFlags: {
        enumValues: {
          "none": 0,
          "private": 1,
          "public": 2,
          "preview": 4,
          "released": 8,
          "firstParty": 16,
          "all": 31
        }
      },
      ExtensionQuery: {},
      ExtensionQueryFilterType: {
        enumValues: {
          "tag": 1,
          "displayName": 2,
          "private": 3,
          "id": 4,
          "category": 5,
          "contributionType": 6,
          "name": 7,
          "installationTarget": 8,
          "featured": 9,
          "searchText": 10,
          "featuredInCategory": 11,
          "excludeWithFlags": 12,
          "includeWithFlags": 13,
          "lcid": 14,
          "installationTargetVersion": 15,
          "installationTargetVersionRange": 16,
          "vsixMetadata": 17,
          "publisherName": 18,
          "publisherDisplayName": 19,
          "includeWithPublisherFlags": 20,
          "organizationSharedWith": 21,
          "productArchitecture": 22,
          "targetPlatform": 23,
          "extensionName": 24
        }
      },
      ExtensionQueryFlags: {
        enumValues: {
          "none": 0,
          "includeVersions": 1,
          "includeFiles": 2,
          "includeCategoryAndTags": 4,
          "includeSharedAccounts": 8,
          "includeVersionProperties": 16,
          "excludeNonValidated": 32,
          "includeInstallationTargets": 64,
          "includeAssetUri": 128,
          "includeStatistics": 256,
          "includeLatestVersionOnly": 512,
          "useFallbackAssetUri": 1024,
          "includeMetadata": 2048,
          "includeMinimalPayloadForVsIde": 4096,
          "includeLcids": 8192,
          "includeSharedOrganizations": 16384,
          "includeNameConflictInfo": 32768,
          "allAttributes": 16863
        }
      },
      ExtensionQueryResult: {},
      ExtensionStatisticOperation: {
        enumValues: {
          "none": 0,
          "set": 1,
          "increment": 2,
          "decrement": 3,
          "delete": 4
        }
      },
      ExtensionStatisticUpdate: {},
      ExtensionStatsAggregateType: {
        enumValues: {
          "daily": 1
        }
      },
      ExtensionVersion: {},
      ExtensionVersionFlags: {
        enumValues: {
          "none": 0,
          "validated": 1
        }
      },
      NotificationsData: {},
      NotificationTemplateType: {
        enumValues: {
          "reviewNotification": 1,
          "qnaNotification": 2,
          "customerContactNotification": 3,
          "publisherMemberUpdateNotification": 4
        }
      },
      PagingDirection: {
        enumValues: {
          "backward": 1,
          "forward": 2
        }
      },
      PublishedExtension: {},
      PublishedExtensionFlags: {
        enumValues: {
          "none": 0,
          "disabled": 1,
          "builtIn": 2,
          "validated": 4,
          "trusted": 8,
          "paid": 16,
          "public": 256,
          "multiVersion": 512,
          "system": 1024,
          "preview": 2048,
          "unpublished": 4096,
          "trial": 8192,
          "locked": 16384,
          "hidden": 32768
        }
      },
      Publisher: {},
      PublisherBase: {},
      PublisherFacts: {},
      PublisherFilterResult: {},
      PublisherFlags: {
        enumValues: {
          "unChanged": 1073741824,
          "none": 0,
          "disabled": 1,
          "verified": 2,
          "certified": 4,
          "serviceFlags": 7
        }
      },
      PublisherPermissions: {
        enumValues: {
          "read": 1,
          "updateExtension": 2,
          "createPublisher": 4,
          "publishExtension": 8,
          "admin": 16,
          "trustedPartner": 32,
          "privateRead": 64,
          "deleteExtension": 128,
          "editSettings": 256,
          "viewPermissions": 512,
          "managePermissions": 1024,
          "deletePublisher": 2048
        }
      },
      PublisherQuery: {},
      PublisherQueryFlags: {
        enumValues: {
          "none": 0,
          "includeExtensions": 1,
          "includeEmailAddress": 2
        }
      },
      PublisherQueryResult: {},
      PublisherRoleAccess: {
        enumValues: {
          "assigned": 1,
          "inherited": 2
        }
      },
      PublisherRoleAssignment: {},
      PublisherState: {
        enumValues: {
          "none": 0,
          "verificationPending": 1,
          "certificationPending": 2,
          "certificationRejected": 4,
          "certificationRevoked": 8
        }
      },
      QnAItem: {},
      QnAItemStatus: {
        enumValues: {
          "none": 0,
          "userEditable": 1,
          "publisherCreated": 2
        }
      },
      QueryFilter: {},
      Question: {},
      QuestionsResult: {},
      Response: {},
      RestApiResponseStatus: {
        enumValues: {
          "completed": 0,
          "failed": 1,
          "inprogress": 2,
          "skipped": 3
        }
      },
      RestApiResponseStatusModel: {},
      Review: {},
      ReviewEventOperation: {
        enumValues: {
          "create": 1,
          "update": 2,
          "delete": 3
        }
      },
      ReviewEventProperties: {},
      ReviewFilterOptions: {
        enumValues: {
          "none": 0,
          "filterEmptyReviews": 1,
          "filterEmptyUserNames": 2
        }
      },
      ReviewPatch: {},
      ReviewPatchOperation: {
        enumValues: {
          "flagReview": 1,
          "updateReview": 2,
          "replyToReview": 3,
          "adminResponseForReview": 4,
          "deleteAdminReply": 5,
          "deletePublisherReply": 6
        }
      },
      ReviewReply: {},
      ReviewResourceType: {
        enumValues: {
          "review": 1,
          "publisherReply": 2,
          "adminReply": 3
        }
      },
      ReviewsResult: {},
      SortByType: {
        enumValues: {
          "relevance": 0,
          "lastUpdatedDate": 1,
          "title": 2,
          "publisher": 3,
          "installCount": 4,
          "publishedDate": 5,
          "averageRating": 6,
          "trendingDaily": 7,
          "trendingWeekly": 8,
          "trendingMonthly": 9,
          "releaseDate": 10,
          "author": 11,
          "weightedRating": 12
        }
      },
      SortOrderType: {
        enumValues: {
          "default": 0,
          "ascending": 1,
          "descending": 2
        }
      },
      UserExtensionPolicy: {},
      UserReportedConcern: {},
      VSCodeWebExtensionStatisicsType: {
        enumValues: {
          "install": 1,
          "update": 2,
          "uninstall": 3
        }
      }
    };
    exports2.TypeInfo.AcquisitionOperation.fields = {
      operationState: {
        enumType: exports2.TypeInfo.AcquisitionOperationState
      },
      operationType: {
        enumType: exports2.TypeInfo.AcquisitionOperationType
      }
    };
    exports2.TypeInfo.AcquisitionOptions.fields = {
      defaultOperation: {
        typeInfo: exports2.TypeInfo.AcquisitionOperation
      },
      operations: {
        isArray: true,
        typeInfo: exports2.TypeInfo.AcquisitionOperation
      }
    };
    exports2.TypeInfo.AzureRestApiResponseModel.fields = {
      operationStatus: {
        typeInfo: exports2.TypeInfo.RestApiResponseStatusModel
      }
    };
    exports2.TypeInfo.Concern.fields = {
      category: {
        enumType: exports2.TypeInfo.ConcernCategory
      },
      createdDate: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.QnAItemStatus
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.CustomerLastContact.fields = {
      lastContactDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.CustomerSupportRequest.fields = {
      review: {
        typeInfo: exports2.TypeInfo.Review
      }
    };
    exports2.TypeInfo.ExtensionAcquisitionRequest.fields = {
      assignmentType: {
        enumType: exports2.TypeInfo.AcquisitionAssignmentType
      },
      operationType: {
        enumType: exports2.TypeInfo.AcquisitionOperationType
      }
    };
    exports2.TypeInfo.ExtensionDailyStat.fields = {
      statisticDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ExtensionDailyStats.fields = {
      dailyStats: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ExtensionDailyStat
      }
    };
    exports2.TypeInfo.ExtensionDraft.fields = {
      createdDate: {
        isDate: true
      },
      draftState: {
        enumType: exports2.TypeInfo.DraftStateType
      },
      lastUpdated: {
        isDate: true
      },
      payload: {
        typeInfo: exports2.TypeInfo.ExtensionPayload
      }
    };
    exports2.TypeInfo.ExtensionDraftPatch.fields = {
      operation: {
        enumType: exports2.TypeInfo.DraftPatchOperation
      }
    };
    exports2.TypeInfo.ExtensionEvent.fields = {
      statisticDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ExtensionEvents.fields = {
      events: {
        isDictionary: true,
        dictionaryValueFieldInfo: {
          isArray: true,
          typeInfo: exports2.TypeInfo.ExtensionEvent
        }
      }
    };
    exports2.TypeInfo.ExtensionFilterResult.fields = {
      extensions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.PublishedExtension
      }
    };
    exports2.TypeInfo.ExtensionPayload.fields = {
      type: {
        enumType: exports2.TypeInfo.ExtensionDeploymentTechnology
      }
    };
    exports2.TypeInfo.ExtensionPolicy.fields = {
      install: {
        enumType: exports2.TypeInfo.ExtensionPolicyFlags
      },
      request: {
        enumType: exports2.TypeInfo.ExtensionPolicyFlags
      }
    };
    exports2.TypeInfo.ExtensionQuery.fields = {
      filters: {
        isArray: true,
        typeInfo: exports2.TypeInfo.QueryFilter
      },
      flags: {
        enumType: exports2.TypeInfo.ExtensionQueryFlags
      }
    };
    exports2.TypeInfo.ExtensionQueryResult.fields = {
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ExtensionFilterResult
      }
    };
    exports2.TypeInfo.ExtensionStatisticUpdate.fields = {
      operation: {
        enumType: exports2.TypeInfo.ExtensionStatisticOperation
      }
    };
    exports2.TypeInfo.ExtensionVersion.fields = {
      flags: {
        enumType: exports2.TypeInfo.ExtensionVersionFlags
      },
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.NotificationsData.fields = {
      type: {
        enumType: exports2.TypeInfo.NotificationTemplateType
      }
    };
    exports2.TypeInfo.PublishedExtension.fields = {
      deploymentType: {
        enumType: exports2.TypeInfo.ExtensionDeploymentTechnology
      },
      flags: {
        enumType: exports2.TypeInfo.PublishedExtensionFlags
      },
      lastUpdated: {
        isDate: true
      },
      publishedDate: {
        isDate: true
      },
      publisher: {
        typeInfo: exports2.TypeInfo.PublisherFacts
      },
      releaseDate: {
        isDate: true
      },
      versions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ExtensionVersion
      }
    };
    exports2.TypeInfo.Publisher.fields = {
      extensions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.PublishedExtension
      },
      flags: {
        enumType: exports2.TypeInfo.PublisherFlags
      },
      lastUpdated: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.PublisherState
      }
    };
    exports2.TypeInfo.PublisherBase.fields = {
      extensions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.PublishedExtension
      },
      flags: {
        enumType: exports2.TypeInfo.PublisherFlags
      },
      lastUpdated: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.PublisherState
      }
    };
    exports2.TypeInfo.PublisherFacts.fields = {
      flags: {
        enumType: exports2.TypeInfo.PublisherFlags
      }
    };
    exports2.TypeInfo.PublisherFilterResult.fields = {
      publishers: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Publisher
      }
    };
    exports2.TypeInfo.PublisherQuery.fields = {
      filters: {
        isArray: true,
        typeInfo: exports2.TypeInfo.QueryFilter
      },
      flags: {
        enumType: exports2.TypeInfo.PublisherQueryFlags
      }
    };
    exports2.TypeInfo.PublisherQueryResult.fields = {
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.PublisherFilterResult
      }
    };
    exports2.TypeInfo.PublisherRoleAssignment.fields = {
      access: {
        enumType: exports2.TypeInfo.PublisherRoleAccess
      }
    };
    exports2.TypeInfo.QnAItem.fields = {
      createdDate: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.QnAItemStatus
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.QueryFilter.fields = {
      direction: {
        enumType: exports2.TypeInfo.PagingDirection
      }
    };
    exports2.TypeInfo.Question.fields = {
      createdDate: {
        isDate: true
      },
      responses: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Response
      },
      status: {
        enumType: exports2.TypeInfo.QnAItemStatus
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.QuestionsResult.fields = {
      questions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Question
      }
    };
    exports2.TypeInfo.Response.fields = {
      createdDate: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.QnAItemStatus
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.RestApiResponseStatusModel.fields = {
      status: {
        enumType: exports2.TypeInfo.RestApiResponseStatus
      }
    };
    exports2.TypeInfo.Review.fields = {
      adminReply: {
        typeInfo: exports2.TypeInfo.ReviewReply
      },
      reply: {
        typeInfo: exports2.TypeInfo.ReviewReply
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReviewEventProperties.fields = {
      eventOperation: {
        enumType: exports2.TypeInfo.ReviewEventOperation
      },
      replyDate: {
        isDate: true
      },
      resourceType: {
        enumType: exports2.TypeInfo.ReviewResourceType
      },
      reviewDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReviewPatch.fields = {
      operation: {
        enumType: exports2.TypeInfo.ReviewPatchOperation
      },
      reportedConcern: {
        typeInfo: exports2.TypeInfo.UserReportedConcern
      },
      reviewItem: {
        typeInfo: exports2.TypeInfo.Review
      }
    };
    exports2.TypeInfo.ReviewReply.fields = {
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReviewsResult.fields = {
      reviews: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Review
      }
    };
    exports2.TypeInfo.UserExtensionPolicy.fields = {
      permissions: {
        typeInfo: exports2.TypeInfo.ExtensionPolicy
      }
    };
    exports2.TypeInfo.UserReportedConcern.fields = {
      category: {
        enumType: exports2.TypeInfo.ConcernCategory
      },
      submittedDate: {
        isDate: true
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/interfaces/ExtensionManagementInterfaces.js
var require_ExtensionManagementInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/ExtensionManagementInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.InstalledExtensionStateIssueType = exports2.ExtensionUpdateType = exports2.ExtensionStateFlags = exports2.ExtensionRequestUpdateType = exports2.ExtensionRequestState = exports2.ExtensionFlags = exports2.ContributionQueryOptions = exports2.ContributionPropertyType = exports2.ContributionLicensingBehaviorType = exports2.AcquisitionOperationType = exports2.AcquisitionOperationState = exports2.AcquisitionAssignmentType = void 0;
    var GalleryInterfaces = require_GalleryInterfaces();
    var AcquisitionAssignmentType;
    (function(AcquisitionAssignmentType2) {
      AcquisitionAssignmentType2[AcquisitionAssignmentType2["None"] = 0] = "None";
      AcquisitionAssignmentType2[AcquisitionAssignmentType2["Me"] = 1] = "Me";
      AcquisitionAssignmentType2[AcquisitionAssignmentType2["All"] = 2] = "All";
    })(AcquisitionAssignmentType = exports2.AcquisitionAssignmentType || (exports2.AcquisitionAssignmentType = {}));
    var AcquisitionOperationState;
    (function(AcquisitionOperationState2) {
      AcquisitionOperationState2[AcquisitionOperationState2["Disallow"] = 0] = "Disallow";
      AcquisitionOperationState2[AcquisitionOperationState2["Allow"] = 1] = "Allow";
      AcquisitionOperationState2[AcquisitionOperationState2["Completed"] = 3] = "Completed";
    })(AcquisitionOperationState = exports2.AcquisitionOperationState || (exports2.AcquisitionOperationState = {}));
    var AcquisitionOperationType;
    (function(AcquisitionOperationType2) {
      AcquisitionOperationType2[AcquisitionOperationType2["Get"] = 0] = "Get";
      AcquisitionOperationType2[AcquisitionOperationType2["Install"] = 1] = "Install";
      AcquisitionOperationType2[AcquisitionOperationType2["Buy"] = 2] = "Buy";
      AcquisitionOperationType2[AcquisitionOperationType2["Try"] = 3] = "Try";
      AcquisitionOperationType2[AcquisitionOperationType2["Request"] = 4] = "Request";
      AcquisitionOperationType2[AcquisitionOperationType2["None"] = 5] = "None";
      AcquisitionOperationType2[AcquisitionOperationType2["PurchaseRequest"] = 6] = "PurchaseRequest";
    })(AcquisitionOperationType = exports2.AcquisitionOperationType || (exports2.AcquisitionOperationType = {}));
    var ContributionLicensingBehaviorType;
    (function(ContributionLicensingBehaviorType2) {
      ContributionLicensingBehaviorType2[ContributionLicensingBehaviorType2["OnlyIfLicensed"] = 0] = "OnlyIfLicensed";
      ContributionLicensingBehaviorType2[ContributionLicensingBehaviorType2["OnlyIfUnlicensed"] = 1] = "OnlyIfUnlicensed";
      ContributionLicensingBehaviorType2[ContributionLicensingBehaviorType2["AlwaysInclude"] = 2] = "AlwaysInclude";
    })(ContributionLicensingBehaviorType = exports2.ContributionLicensingBehaviorType || (exports2.ContributionLicensingBehaviorType = {}));
    var ContributionPropertyType;
    (function(ContributionPropertyType2) {
      ContributionPropertyType2[ContributionPropertyType2["Unknown"] = 0] = "Unknown";
      ContributionPropertyType2[ContributionPropertyType2["String"] = 1] = "String";
      ContributionPropertyType2[ContributionPropertyType2["Uri"] = 2] = "Uri";
      ContributionPropertyType2[ContributionPropertyType2["Guid"] = 4] = "Guid";
      ContributionPropertyType2[ContributionPropertyType2["Boolean"] = 8] = "Boolean";
      ContributionPropertyType2[ContributionPropertyType2["Integer"] = 16] = "Integer";
      ContributionPropertyType2[ContributionPropertyType2["Double"] = 32] = "Double";
      ContributionPropertyType2[ContributionPropertyType2["DateTime"] = 64] = "DateTime";
      ContributionPropertyType2[ContributionPropertyType2["Dictionary"] = 128] = "Dictionary";
      ContributionPropertyType2[ContributionPropertyType2["Array"] = 256] = "Array";
      ContributionPropertyType2[ContributionPropertyType2["Object"] = 512] = "Object";
    })(ContributionPropertyType = exports2.ContributionPropertyType || (exports2.ContributionPropertyType = {}));
    var ContributionQueryOptions;
    (function(ContributionQueryOptions2) {
      ContributionQueryOptions2[ContributionQueryOptions2["None"] = 0] = "None";
      ContributionQueryOptions2[ContributionQueryOptions2["IncludeSelf"] = 16] = "IncludeSelf";
      ContributionQueryOptions2[ContributionQueryOptions2["IncludeChildren"] = 32] = "IncludeChildren";
      ContributionQueryOptions2[ContributionQueryOptions2["IncludeSubTree"] = 96] = "IncludeSubTree";
      ContributionQueryOptions2[ContributionQueryOptions2["IncludeAll"] = 112] = "IncludeAll";
      ContributionQueryOptions2[ContributionQueryOptions2["IgnoreConstraints"] = 256] = "IgnoreConstraints";
    })(ContributionQueryOptions = exports2.ContributionQueryOptions || (exports2.ContributionQueryOptions = {}));
    var ExtensionFlags;
    (function(ExtensionFlags2) {
      ExtensionFlags2[ExtensionFlags2["BuiltIn"] = 1] = "BuiltIn";
      ExtensionFlags2[ExtensionFlags2["Trusted"] = 2] = "Trusted";
    })(ExtensionFlags = exports2.ExtensionFlags || (exports2.ExtensionFlags = {}));
    var ExtensionRequestState;
    (function(ExtensionRequestState2) {
      ExtensionRequestState2[ExtensionRequestState2["Open"] = 0] = "Open";
      ExtensionRequestState2[ExtensionRequestState2["Accepted"] = 1] = "Accepted";
      ExtensionRequestState2[ExtensionRequestState2["Rejected"] = 2] = "Rejected";
    })(ExtensionRequestState = exports2.ExtensionRequestState || (exports2.ExtensionRequestState = {}));
    var ExtensionRequestUpdateType;
    (function(ExtensionRequestUpdateType2) {
      ExtensionRequestUpdateType2[ExtensionRequestUpdateType2["Created"] = 1] = "Created";
      ExtensionRequestUpdateType2[ExtensionRequestUpdateType2["Approved"] = 2] = "Approved";
      ExtensionRequestUpdateType2[ExtensionRequestUpdateType2["Rejected"] = 3] = "Rejected";
      ExtensionRequestUpdateType2[ExtensionRequestUpdateType2["Deleted"] = 4] = "Deleted";
    })(ExtensionRequestUpdateType = exports2.ExtensionRequestUpdateType || (exports2.ExtensionRequestUpdateType = {}));
    var ExtensionStateFlags;
    (function(ExtensionStateFlags2) {
      ExtensionStateFlags2[ExtensionStateFlags2["None"] = 0] = "None";
      ExtensionStateFlags2[ExtensionStateFlags2["Disabled"] = 1] = "Disabled";
      ExtensionStateFlags2[ExtensionStateFlags2["BuiltIn"] = 2] = "BuiltIn";
      ExtensionStateFlags2[ExtensionStateFlags2["MultiVersion"] = 4] = "MultiVersion";
      ExtensionStateFlags2[ExtensionStateFlags2["UnInstalled"] = 8] = "UnInstalled";
      ExtensionStateFlags2[ExtensionStateFlags2["VersionCheckError"] = 16] = "VersionCheckError";
      ExtensionStateFlags2[ExtensionStateFlags2["Trusted"] = 32] = "Trusted";
      ExtensionStateFlags2[ExtensionStateFlags2["Error"] = 64] = "Error";
      ExtensionStateFlags2[ExtensionStateFlags2["NeedsReauthorization"] = 128] = "NeedsReauthorization";
      ExtensionStateFlags2[ExtensionStateFlags2["AutoUpgradeError"] = 256] = "AutoUpgradeError";
      ExtensionStateFlags2[ExtensionStateFlags2["Warning"] = 512] = "Warning";
    })(ExtensionStateFlags = exports2.ExtensionStateFlags || (exports2.ExtensionStateFlags = {}));
    var ExtensionUpdateType;
    (function(ExtensionUpdateType2) {
      ExtensionUpdateType2[ExtensionUpdateType2["Installed"] = 1] = "Installed";
      ExtensionUpdateType2[ExtensionUpdateType2["Uninstalled"] = 2] = "Uninstalled";
      ExtensionUpdateType2[ExtensionUpdateType2["Enabled"] = 3] = "Enabled";
      ExtensionUpdateType2[ExtensionUpdateType2["Disabled"] = 4] = "Disabled";
      ExtensionUpdateType2[ExtensionUpdateType2["VersionUpdated"] = 5] = "VersionUpdated";
      ExtensionUpdateType2[ExtensionUpdateType2["ActionRequired"] = 6] = "ActionRequired";
      ExtensionUpdateType2[ExtensionUpdateType2["ActionResolved"] = 7] = "ActionResolved";
    })(ExtensionUpdateType = exports2.ExtensionUpdateType || (exports2.ExtensionUpdateType = {}));
    var InstalledExtensionStateIssueType;
    (function(InstalledExtensionStateIssueType2) {
      InstalledExtensionStateIssueType2[InstalledExtensionStateIssueType2["Warning"] = 0] = "Warning";
      InstalledExtensionStateIssueType2[InstalledExtensionStateIssueType2["Error"] = 1] = "Error";
    })(InstalledExtensionStateIssueType = exports2.InstalledExtensionStateIssueType || (exports2.InstalledExtensionStateIssueType = {}));
    exports2.TypeInfo = {
      AcquisitionAssignmentType: {
        enumValues: {
          "none": 0,
          "me": 1,
          "all": 2
        }
      },
      AcquisitionOperation: {},
      AcquisitionOperationState: {
        enumValues: {
          "disallow": 0,
          "allow": 1,
          "completed": 3
        }
      },
      AcquisitionOperationType: {
        enumValues: {
          "get": 0,
          "install": 1,
          "buy": 2,
          "try": 3,
          "request": 4,
          "none": 5,
          "purchaseRequest": 6
        }
      },
      AcquisitionOptions: {},
      ContributionLicensingBehaviorType: {
        enumValues: {
          "onlyIfLicensed": 0,
          "onlyIfUnlicensed": 1,
          "alwaysInclude": 2
        }
      },
      ContributionNodeQuery: {},
      ContributionPropertyDescription: {},
      ContributionPropertyType: {
        enumValues: {
          "unknown": 0,
          "string": 1,
          "uri": 2,
          "guid": 4,
          "boolean": 8,
          "integer": 16,
          "double": 32,
          "dateTime": 64,
          "dictionary": 128,
          "array": 256,
          "object": 512
        }
      },
      ContributionQueryOptions: {
        enumValues: {
          "none": 0,
          "includeSelf": 16,
          "includeChildren": 32,
          "includeSubTree": 96,
          "includeAll": 112,
          "ignoreConstraints": 256
        }
      },
      ContributionType: {},
      ExtensionAcquisitionRequest: {},
      ExtensionAuditLog: {},
      ExtensionAuditLogEntry: {},
      ExtensionEvent: {},
      ExtensionFlags: {
        enumValues: {
          "builtIn": 1,
          "trusted": 2
        }
      },
      ExtensionLicensing: {},
      ExtensionManifest: {},
      ExtensionRequest: {},
      ExtensionRequestEvent: {},
      ExtensionRequestsEvent: {},
      ExtensionRequestState: {
        enumValues: {
          "open": 0,
          "accepted": 1,
          "rejected": 2
        }
      },
      ExtensionRequestUpdateType: {
        enumValues: {
          "created": 1,
          "approved": 2,
          "rejected": 3,
          "deleted": 4
        }
      },
      ExtensionState: {},
      ExtensionStateFlags: {
        enumValues: {
          "none": 0,
          "disabled": 1,
          "builtIn": 2,
          "multiVersion": 4,
          "unInstalled": 8,
          "versionCheckError": 16,
          "trusted": 32,
          "error": 64,
          "needsReauthorization": 128,
          "autoUpgradeError": 256,
          "warning": 512
        }
      },
      ExtensionUpdateType: {
        enumValues: {
          "installed": 1,
          "uninstalled": 2,
          "enabled": 3,
          "disabled": 4,
          "versionUpdated": 5,
          "actionRequired": 6,
          "actionResolved": 7
        }
      },
      InstalledExtension: {},
      InstalledExtensionState: {},
      InstalledExtensionStateIssue: {},
      InstalledExtensionStateIssueType: {
        enumValues: {
          "warning": 0,
          "error": 1
        }
      },
      LicensingOverride: {},
      RequestedExtension: {}
    };
    exports2.TypeInfo.AcquisitionOperation.fields = {
      operationState: {
        enumType: exports2.TypeInfo.AcquisitionOperationState
      },
      operationType: {
        enumType: exports2.TypeInfo.AcquisitionOperationType
      }
    };
    exports2.TypeInfo.AcquisitionOptions.fields = {
      defaultOperation: {
        typeInfo: exports2.TypeInfo.AcquisitionOperation
      },
      operations: {
        isArray: true,
        typeInfo: exports2.TypeInfo.AcquisitionOperation
      }
    };
    exports2.TypeInfo.ContributionNodeQuery.fields = {
      queryOptions: {
        enumType: exports2.TypeInfo.ContributionQueryOptions
      }
    };
    exports2.TypeInfo.ContributionPropertyDescription.fields = {
      type: {
        enumType: exports2.TypeInfo.ContributionPropertyType
      }
    };
    exports2.TypeInfo.ContributionType.fields = {
      properties: {
        isDictionary: true,
        dictionaryValueTypeInfo: exports2.TypeInfo.ContributionPropertyDescription
      }
    };
    exports2.TypeInfo.ExtensionAcquisitionRequest.fields = {
      assignmentType: {
        enumType: exports2.TypeInfo.AcquisitionAssignmentType
      },
      operationType: {
        enumType: exports2.TypeInfo.AcquisitionOperationType
      }
    };
    exports2.TypeInfo.ExtensionAuditLog.fields = {
      entries: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ExtensionAuditLogEntry
      }
    };
    exports2.TypeInfo.ExtensionAuditLogEntry.fields = {
      auditDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ExtensionEvent.fields = {
      extension: {
        typeInfo: GalleryInterfaces.TypeInfo.PublishedExtension
      },
      updateType: {
        enumType: exports2.TypeInfo.ExtensionUpdateType
      }
    };
    exports2.TypeInfo.ExtensionLicensing.fields = {
      overrides: {
        isArray: true,
        typeInfo: exports2.TypeInfo.LicensingOverride
      }
    };
    exports2.TypeInfo.ExtensionManifest.fields = {
      contributionTypes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ContributionType
      },
      licensing: {
        typeInfo: exports2.TypeInfo.ExtensionLicensing
      }
    };
    exports2.TypeInfo.ExtensionRequest.fields = {
      requestDate: {
        isDate: true
      },
      requestState: {
        enumType: exports2.TypeInfo.ExtensionRequestState
      },
      resolveDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ExtensionRequestEvent.fields = {
      extension: {
        typeInfo: GalleryInterfaces.TypeInfo.PublishedExtension
      },
      request: {
        typeInfo: exports2.TypeInfo.ExtensionRequest
      },
      updateType: {
        enumType: exports2.TypeInfo.ExtensionRequestUpdateType
      }
    };
    exports2.TypeInfo.ExtensionRequestsEvent.fields = {
      extension: {
        typeInfo: GalleryInterfaces.TypeInfo.PublishedExtension
      },
      requests: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ExtensionRequest
      },
      updateType: {
        enumType: exports2.TypeInfo.ExtensionRequestUpdateType
      }
    };
    exports2.TypeInfo.ExtensionState.fields = {
      flags: {
        enumType: exports2.TypeInfo.ExtensionStateFlags
      },
      installationIssues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.InstalledExtensionStateIssue
      },
      lastUpdated: {
        isDate: true
      },
      lastVersionCheck: {
        isDate: true
      }
    };
    exports2.TypeInfo.InstalledExtension.fields = {
      contributionTypes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ContributionType
      },
      flags: {
        enumType: exports2.TypeInfo.ExtensionFlags
      },
      installState: {
        typeInfo: exports2.TypeInfo.InstalledExtensionState
      },
      lastPublished: {
        isDate: true
      },
      licensing: {
        typeInfo: exports2.TypeInfo.ExtensionLicensing
      }
    };
    exports2.TypeInfo.InstalledExtensionState.fields = {
      flags: {
        enumType: exports2.TypeInfo.ExtensionStateFlags
      },
      installationIssues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.InstalledExtensionStateIssue
      },
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.InstalledExtensionStateIssue.fields = {
      type: {
        enumType: exports2.TypeInfo.InstalledExtensionStateIssueType
      }
    };
    exports2.TypeInfo.LicensingOverride.fields = {
      behavior: {
        enumType: exports2.TypeInfo.ContributionLicensingBehaviorType
      }
    };
    exports2.TypeInfo.RequestedExtension.fields = {
      extensionRequests: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ExtensionRequest
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/ExtensionManagementApi.js
var require_ExtensionManagementApi = __commonJS({
  "../node_modules/azure-devops-node-api/ExtensionManagementApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ExtensionManagementApi = void 0;
    var basem = require_ClientApiBases();
    var ExtensionManagementInterfaces = require_ExtensionManagementInterfaces();
    var GalleryInterfaces = require_GalleryInterfaces();
    var ExtensionManagementApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-ExtensionManagement-api", options);
      }
      /**
       * This API is called by acquisition/install page to get possible user actions like Buy/Request
       *
       * @param {string} itemId - Fully qualified name of extension (<publisher_id>.<extension_id>)
       * @param {boolean} testCommerce - Parameter to test paid preview extension without making azure plans public
       * @param {boolean} isFreeOrTrialInstall - Parameter represents install or trial workflow (required for legacy install flows)
       * @param {boolean} isAccountOwner - Parameter represents whether user is owner or PCA of an account
       * @param {boolean} isLinked - Parameter represents whether account is linked with a subscription
       * @param {boolean} isConnectedServer - Parameter represents whether Buy operation should be evaluated
       * @param {boolean} isBuyOperationValid
       */
      getAcquisitionOptions(itemId, testCommerce, isFreeOrTrialInstall, isAccountOwner, isLinked, isConnectedServer, isBuyOperationValid) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (itemId == null) {
            throw new TypeError("itemId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              itemId,
              testCommerce,
              isFreeOrTrialInstall,
              isAccountOwner,
              isLinked,
              isConnectedServer,
              isBuyOperationValid
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "288dff58-d13b-468e-9671-0fb754e9398c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.AcquisitionOptions, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {ExtensionManagementInterfaces.ExtensionAcquisitionRequest} acquisitionRequest
       */
      requestAcquisition(acquisitionRequest) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "da616457-eed3-4672-92d7-18d21f5c1658", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, acquisitionRequest, options);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.ExtensionAcquisitionRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       */
      getAuditLog(publisherName, extensionName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "23a312e0-562d-42fb-a505-5a046b5635db", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.ExtensionAuditLog, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} registrationId
       */
      registerAuthorization(publisherName, extensionName, registrationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              registrationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "f21cfc80-d2d2-4248-98bb-7820c74c4606", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {any} doc
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} scopeType
       * @param {string} scopeValue
       * @param {string} collectionName
       */
      createDocumentByName(doc, publisherName, extensionName, scopeType, scopeValue, collectionName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              scopeType,
              scopeValue,
              collectionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "bbe06c18-1c8b-4fcd-b9c6-1535aaab8749", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, doc, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} scopeType
       * @param {string} scopeValue
       * @param {string} collectionName
       * @param {string} documentId
       */
      deleteDocumentByName(publisherName, extensionName, scopeType, scopeValue, collectionName, documentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              scopeType,
              scopeValue,
              collectionName,
              documentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "bbe06c18-1c8b-4fcd-b9c6-1535aaab8749", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} scopeType
       * @param {string} scopeValue
       * @param {string} collectionName
       * @param {string} documentId
       */
      getDocumentByName(publisherName, extensionName, scopeType, scopeValue, collectionName, documentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              scopeType,
              scopeValue,
              collectionName,
              documentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "bbe06c18-1c8b-4fcd-b9c6-1535aaab8749", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} scopeType
       * @param {string} scopeValue
       * @param {string} collectionName
       */
      getDocumentsByName(publisherName, extensionName, scopeType, scopeValue, collectionName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              scopeType,
              scopeValue,
              collectionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "bbe06c18-1c8b-4fcd-b9c6-1535aaab8749", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {any} doc
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} scopeType
       * @param {string} scopeValue
       * @param {string} collectionName
       */
      setDocumentByName(doc, publisherName, extensionName, scopeType, scopeValue, collectionName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              scopeType,
              scopeValue,
              collectionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "bbe06c18-1c8b-4fcd-b9c6-1535aaab8749", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, doc, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {any} doc
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} scopeType
       * @param {string} scopeValue
       * @param {string} collectionName
       */
      updateDocumentByName(doc, publisherName, extensionName, scopeType, scopeValue, collectionName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              scopeType,
              scopeValue,
              collectionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "bbe06c18-1c8b-4fcd-b9c6-1535aaab8749", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, doc, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Query for one or more data collections for the specified extension.  Note: the token used for authorization must have been issued on behalf of the specified extension.
       *
       * @param {ExtensionManagementInterfaces.ExtensionDataCollectionQuery} collectionQuery
       * @param {string} publisherName - Name of the publisher. Example: "fabrikam".
       * @param {string} extensionName - Name of the extension. Example: "ops-tools".
       */
      queryCollectionsByName(collectionQuery, publisherName, extensionName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "56c331f1-ce53-4318-adfd-4db5c52a7a2e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, collectionQuery, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * List state and version information for all installed extensions.
       *
       * @param {boolean} includeDisabled - If true (the default), include disabled extensions in the results.
       * @param {boolean} includeErrors - If true, include installed extensions in an error state in the results.
       * @param {boolean} includeInstallationIssues
       * @param {boolean} forceRefresh
       */
      getStates(includeDisabled, includeErrors, includeInstallationIssues, forceRefresh) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              includeDisabled,
              includeErrors,
              includeInstallationIssues,
              forceRefresh
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "92755d3d-9a8a-42b3-8a4d-87359fe5aa93", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.ExtensionState, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {ExtensionManagementInterfaces.InstalledExtensionQuery} query
       */
      queryExtensions(query) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "046c980f-1345-4ce2-bf85-b46d10ff4cfd", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, query, options);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.InstalledExtension, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * List the installed extensions in the account / project collection.
       *
       * @param {boolean} includeDisabledExtensions - If true (the default), include disabled extensions in the results.
       * @param {boolean} includeErrors - If true, include installed extensions with errors.
       * @param {string[]} assetTypes - Determines which files are returned in the files array.  Provide the wildcard '*' to return all files, or a colon separated list to retrieve files with specific asset types.
       * @param {boolean} includeInstallationIssues
       */
      getInstalledExtensions(includeDisabledExtensions, includeErrors, assetTypes, includeInstallationIssues) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              includeDisabledExtensions,
              includeErrors,
              assetTypes: assetTypes && assetTypes.join(":"),
              includeInstallationIssues
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "275424d0-c844-4fe2-bda6-04933a1357d8", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.InstalledExtension, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update an installed extension. Typically this API is used to enable or disable an extension.
       *
       * @param {ExtensionManagementInterfaces.InstalledExtension} extension
       */
      updateInstalledExtension(extension) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "275424d0-c844-4fe2-bda6-04933a1357d8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, extension, options);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.InstalledExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get an installed extension by its publisher and extension name.
       *
       * @param {string} publisherName - Name of the publisher. Example: "fabrikam".
       * @param {string} extensionName - Name of the extension. Example: "ops-tools".
       * @param {string[]} assetTypes - Determines which files are returned in the files array.  Provide the wildcard '*' to return all files, or a colon separated list to retrieve files with specific asset types.
       */
      getInstalledExtensionByName(publisherName, extensionName, assetTypes) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              assetTypes: assetTypes && assetTypes.join(":")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "fb0da285-f23e-4b56-8b53-3ef5f9f6de66", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.InstalledExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Install the specified extension into the account / project collection.
       *
       * @param {string} publisherName - Name of the publisher. Example: "fabrikam".
       * @param {string} extensionName - Name of the extension. Example: "ops-tools".
       * @param {string} version
       */
      installExtensionByName(publisherName, extensionName, version2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version: version2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "fb0da285-f23e-4b56-8b53-3ef5f9f6de66", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.InstalledExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Uninstall the specified extension from the account / project collection.
       *
       * @param {string} publisherName - Name of the publisher. Example: "fabrikam".
       * @param {string} extensionName - Name of the extension. Example: "ops-tools".
       * @param {string} reason
       * @param {string} reasonCode
       */
      uninstallExtensionByName(publisherName, extensionName, reason, reasonCode) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              reason,
              reasonCode
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "fb0da285-f23e-4b56-8b53-3ef5f9f6de66", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} userId
       */
      getPolicies(userId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              userId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "e5cc8c09-407b-4867-8319-2ae3338cbf6f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.UserExtensionPolicy, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} rejectMessage
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} requesterId
       * @param {ExtensionManagementInterfaces.ExtensionRequestState} state
       */
      resolveRequest(rejectMessage, publisherName, extensionName, requesterId, state) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (state == null) {
            throw new TypeError("state can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              requesterId
            };
            let queryValues = {
              state
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "aa93e1f3-511c-4364-8b9c-eb98818f2e0b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, rejectMessage, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       */
      getRequests() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "216b978f-b164-424e-ada2-b77561e842b7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.RequestedExtension, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} rejectMessage
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {ExtensionManagementInterfaces.ExtensionRequestState} state
       */
      resolveAllRequests(rejectMessage, publisherName, extensionName, state) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (state == null) {
            throw new TypeError("state can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              state
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "ba93e1f3-511c-4364-8b9c-eb98818f2e0b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, rejectMessage, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       */
      deleteRequest(publisherName, extensionName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "f5afca1e-a728-4294-aa2d-4af0173431b5", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} requestMessage
       */
      requestExtension(publisherName, extensionName, requestMessage) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "f5afca1e-a728-4294-aa2d-4af0173431b5", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, requestMessage, options);
              let ret = this.formatResponse(res.result, ExtensionManagementInterfaces.TypeInfo.RequestedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       */
      getToken() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "ExtensionManagement", "3a2e24ed-1d6f-4cb2-9f3b-45a96bbfaf50", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.ExtensionManagementApi = ExtensionManagementApi;
    ExtensionManagementApi.RESOURCE_AREA_ID = "6c2b0933-3600-42ae-bf8b-93d4f7e83594";
  }
});

// ../node_modules/azure-devops-node-api/interfaces/FeatureManagementInterfaces.js
var require_FeatureManagementInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/FeatureManagementInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.ContributedFeatureEnabledValue = void 0;
    var ContributedFeatureEnabledValue;
    (function(ContributedFeatureEnabledValue2) {
      ContributedFeatureEnabledValue2[ContributedFeatureEnabledValue2["Undefined"] = -1] = "Undefined";
      ContributedFeatureEnabledValue2[ContributedFeatureEnabledValue2["Disabled"] = 0] = "Disabled";
      ContributedFeatureEnabledValue2[ContributedFeatureEnabledValue2["Enabled"] = 1] = "Enabled";
    })(ContributedFeatureEnabledValue = exports2.ContributedFeatureEnabledValue || (exports2.ContributedFeatureEnabledValue = {}));
    exports2.TypeInfo = {
      ContributedFeatureEnabledValue: {
        enumValues: {
          "undefined": -1,
          "disabled": 0,
          "enabled": 1
        }
      },
      ContributedFeatureState: {},
      ContributedFeatureStateQuery: {}
    };
    exports2.TypeInfo.ContributedFeatureState.fields = {
      state: {
        enumType: exports2.TypeInfo.ContributedFeatureEnabledValue
      }
    };
    exports2.TypeInfo.ContributedFeatureStateQuery.fields = {
      featureStates: {
        isDictionary: true,
        dictionaryValueTypeInfo: exports2.TypeInfo.ContributedFeatureState
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/FeatureManagementApi.js
var require_FeatureManagementApi = __commonJS({
  "../node_modules/azure-devops-node-api/FeatureManagementApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FeatureManagementApi = void 0;
    var basem = require_ClientApiBases();
    var FeatureManagementInterfaces = require_FeatureManagementInterfaces();
    var FeatureManagementApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-FeatureManagement-api", options);
      }
      /**
       * Get a specific feature by its id
       *
       * @param {string} featureId - The contribution id of the feature
       */
      getFeature(featureId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              featureId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "c4209f25-7a27-41dd-9f04-06080c7b6afd", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of all defined features
       *
       * @param {string} targetContributionId - Optional target contribution. If null/empty, return all features. If specified include the features that target the specified contribution.
       */
      getFeatures(targetContributionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              targetContributionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "c4209f25-7a27-41dd-9f04-06080c7b6afd", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the state of the specified feature for the given user/all-users scope
       *
       * @param {string} featureId - Contribution id of the feature
       * @param {string} userScope - User-Scope at which to get the value. Should be "me" for the current user or "host" for all users.
       */
      getFeatureState(featureId, userScope) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              featureId,
              userScope
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "98911314-3f9b-4eaf-80e8-83900d8e85d9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, FeatureManagementInterfaces.TypeInfo.ContributedFeatureState, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Set the state of a feature
       *
       * @param {FeatureManagementInterfaces.ContributedFeatureState} feature - Posted feature state object. Should specify the effective value.
       * @param {string} featureId - Contribution id of the feature
       * @param {string} userScope - User-Scope at which to set the value. Should be "me" for the current user or "host" for all users.
       * @param {string} reason - Reason for changing the state
       * @param {string} reasonCode - Short reason code
       */
      setFeatureState(feature, featureId, userScope, reason, reasonCode) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              featureId,
              userScope
            };
            let queryValues = {
              reason,
              reasonCode
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "98911314-3f9b-4eaf-80e8-83900d8e85d9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, feature, options);
              let ret = this.formatResponse(res.result, FeatureManagementInterfaces.TypeInfo.ContributedFeatureState, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the state of the specified feature for the given named scope
       *
       * @param {string} featureId - Contribution id of the feature
       * @param {string} userScope - User-Scope at which to get the value. Should be "me" for the current user or "host" for all users.
       * @param {string} scopeName - Scope at which to get the feature setting for (e.g. "project" or "team")
       * @param {string} scopeValue - Value of the scope (e.g. the project or team id)
       */
      getFeatureStateForScope(featureId, userScope, scopeName, scopeValue) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              featureId,
              userScope,
              scopeName,
              scopeValue
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "dd291e43-aa9f-4cee-8465-a93c78e414a4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, FeatureManagementInterfaces.TypeInfo.ContributedFeatureState, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Set the state of a feature at a specific scope
       *
       * @param {FeatureManagementInterfaces.ContributedFeatureState} feature - Posted feature state object. Should specify the effective value.
       * @param {string} featureId - Contribution id of the feature
       * @param {string} userScope - User-Scope at which to set the value. Should be "me" for the current user or "host" for all users.
       * @param {string} scopeName - Scope at which to get the feature setting for (e.g. "project" or "team")
       * @param {string} scopeValue - Value of the scope (e.g. the project or team id)
       * @param {string} reason - Reason for changing the state
       * @param {string} reasonCode - Short reason code
       */
      setFeatureStateForScope(feature, featureId, userScope, scopeName, scopeValue, reason, reasonCode) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              featureId,
              userScope,
              scopeName,
              scopeValue
            };
            let queryValues = {
              reason,
              reasonCode
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "dd291e43-aa9f-4cee-8465-a93c78e414a4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, feature, options);
              let ret = this.formatResponse(res.result, FeatureManagementInterfaces.TypeInfo.ContributedFeatureState, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the effective state for a list of feature ids
       *
       * @param {FeatureManagementInterfaces.ContributedFeatureStateQuery} query - Features to query along with current scope values
       */
      queryFeatureStates(query) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "2b4486ad-122b-400c-ae65-17b6672c1f9d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, query, options);
              let ret = this.formatResponse(res.result, FeatureManagementInterfaces.TypeInfo.ContributedFeatureStateQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the states of the specified features for the default scope
       *
       * @param {FeatureManagementInterfaces.ContributedFeatureStateQuery} query - Query describing the features to query.
       * @param {string} userScope
       */
      queryFeatureStatesForDefaultScope(query, userScope) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              userScope
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "3f810f28-03e2-4239-b0bc-788add3005e5", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, query, options);
              let ret = this.formatResponse(res.result, FeatureManagementInterfaces.TypeInfo.ContributedFeatureStateQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the states of the specified features for the specific named scope
       *
       * @param {FeatureManagementInterfaces.ContributedFeatureStateQuery} query - Query describing the features to query.
       * @param {string} userScope
       * @param {string} scopeName
       * @param {string} scopeValue
       */
      queryFeatureStatesForNamedScope(query, userScope, scopeName, scopeValue) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              userScope,
              scopeName,
              scopeValue
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "FeatureManagement", "f29e997b-c2da-4d15-8380-765788a1a74c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, query, options);
              let ret = this.formatResponse(res.result, FeatureManagementInterfaces.TypeInfo.ContributedFeatureStateQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.FeatureManagementApi = FeatureManagementApi;
  }
});

// ../node_modules/azure-devops-node-api/interfaces/FileContainerInterfaces.js
var require_FileContainerInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/FileContainerInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.ContainerOptions = exports2.ContainerItemType = exports2.ContainerItemStatus = exports2.BlobCompressionType = void 0;
    var BlobCompressionType;
    (function(BlobCompressionType2) {
      BlobCompressionType2[BlobCompressionType2["None"] = 0] = "None";
      BlobCompressionType2[BlobCompressionType2["GZip"] = 1] = "GZip";
    })(BlobCompressionType = exports2.BlobCompressionType || (exports2.BlobCompressionType = {}));
    var ContainerItemStatus;
    (function(ContainerItemStatus2) {
      ContainerItemStatus2[ContainerItemStatus2["Created"] = 1] = "Created";
      ContainerItemStatus2[ContainerItemStatus2["PendingUpload"] = 2] = "PendingUpload";
    })(ContainerItemStatus = exports2.ContainerItemStatus || (exports2.ContainerItemStatus = {}));
    var ContainerItemType;
    (function(ContainerItemType2) {
      ContainerItemType2[ContainerItemType2["Any"] = 0] = "Any";
      ContainerItemType2[ContainerItemType2["Folder"] = 1] = "Folder";
      ContainerItemType2[ContainerItemType2["File"] = 2] = "File";
    })(ContainerItemType = exports2.ContainerItemType || (exports2.ContainerItemType = {}));
    var ContainerOptions;
    (function(ContainerOptions2) {
      ContainerOptions2[ContainerOptions2["None"] = 0] = "None";
    })(ContainerOptions = exports2.ContainerOptions || (exports2.ContainerOptions = {}));
    exports2.TypeInfo = {
      BlobCompressionType: {
        enumValues: {
          "none": 0,
          "gZip": 1
        }
      },
      ContainerItemBlobReference: {},
      ContainerItemStatus: {
        enumValues: {
          "created": 1,
          "pendingUpload": 2
        }
      },
      ContainerItemType: {
        enumValues: {
          "any": 0,
          "folder": 1,
          "file": 2
        }
      },
      ContainerOptions: {
        enumValues: {
          "none": 0
        }
      },
      FileContainer: {},
      FileContainerItem: {}
    };
    exports2.TypeInfo.ContainerItemBlobReference.fields = {
      compressionType: {
        enumType: exports2.TypeInfo.BlobCompressionType
      }
    };
    exports2.TypeInfo.FileContainer.fields = {
      dateCreated: {
        isDate: true
      },
      options: {
        enumType: exports2.TypeInfo.ContainerOptions
      }
    };
    exports2.TypeInfo.FileContainerItem.fields = {
      blobMetadata: {
        typeInfo: exports2.TypeInfo.ContainerItemBlobReference
      },
      dateCreated: {
        isDate: true
      },
      dateLastModified: {
        isDate: true
      },
      itemType: {
        enumType: exports2.TypeInfo.ContainerItemType
      },
      status: {
        enumType: exports2.TypeInfo.ContainerItemStatus
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/FileContainerApiBase.js
var require_FileContainerApiBase = __commonJS({
  "../node_modules/azure-devops-node-api/FileContainerApiBase.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileContainerApiBase = void 0;
    var basem = require_ClientApiBases();
    var FileContainerInterfaces = require_FileContainerInterfaces();
    var FileContainerApiBase = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-FileContainer-api", options);
      }
      /**
       * Creates the specified items in the referenced container.
       *
       * @param {VSSInterfaces.VssJsonCollectionWrapperV<FileContainerInterfaces.FileContainerItem[]>} items
       * @param {number} containerId
       * @param {string} scope - A guid representing the scope of the container. This is often the project id.
       */
      createItems(items, containerId, scope) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              containerId
            };
            let queryValues = {
              scope
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, items, options);
              let ret = this.formatResponse(res.result, FileContainerInterfaces.TypeInfo.FileContainerItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes the specified items in a container.
       *
       * @param {number} containerId - Container Id.
       * @param {string} itemPath - Path to delete.
       * @param {string} scope - A guid representing the scope of the container. This is often the project id.
       */
      deleteItem(containerId, itemPath, scope) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (itemPath == null) {
            throw new TypeError("itemPath can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              containerId
            };
            let queryValues = {
              itemPath,
              scope
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets containers filtered by a comma separated list of artifact uris within the same scope, if not specified returns all containers
       *
       * @param {string} scope - A guid representing the scope of the container. This is often the project id.
       * @param {string} artifactUris
       */
      getContainers(scope, artifactUris) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              scope,
              artifactUris
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, FileContainerInterfaces.TypeInfo.FileContainer, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the specified file container object in a format dependent upon the given parameters or HTTP Accept request header
       *
       * @param {number} containerId - The requested container Id
       * @param {string} scope - A guid representing the scope of the container. This is often the project id.
       * @param {string} itemPath - The path to the item of interest
       * @param {boolean} metadata - If true, this overrides any specified format parameter or HTTP Accept request header to provide non-recursive information for the given itemPath
       * @param {string} format - If specified, this overrides the HTTP Accept request header to return either 'json' or 'zip'.  If $format is specified, then api-version should also be specified as a query parameter.
       * @param {string} downloadFileName - If specified and returning other than JSON format, then this download name will be used (else defaults to itemPath)
       * @param {boolean} includeDownloadTickets
       * @param {boolean} isShallow - If true, returns only immediate children(files & folders) for the given itemPath. False will return all items recursively within itemPath.
       * @param {boolean} ignoreRequestedMediaType - Set to true to ignore the HTTP Accept request header. Default is false.
       * @param {boolean} includeBlobMetadata
       * @param {boolean} saveAbsolutePath - Set to false to not save the absolute path to the specified directory of the artifact in the returned archive. Works only for artifact directories. Default is true.
       * @param {boolean} preferRedirect - Set to true to get the redirect response which leads to the stream with content. Default is false.
       */
      getItems(containerId, scope, itemPath, metadata, format, downloadFileName, includeDownloadTickets, isShallow, ignoreRequestedMediaType, includeBlobMetadata, saveAbsolutePath, preferRedirect) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              containerId
            };
            let queryValues = {
              scope,
              itemPath,
              metadata,
              "$format": format,
              downloadFileName,
              includeDownloadTickets,
              isShallow,
              ignoreRequestedMediaType,
              includeBlobMetadata,
              saveAbsolutePath,
              preferRedirect
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, FileContainerInterfaces.TypeInfo.FileContainerItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.FileContainerApiBase = FileContainerApiBase;
  }
});

// ../node_modules/azure-devops-node-api/FileContainerApi.js
var require_FileContainerApi = __commonJS({
  "../node_modules/azure-devops-node-api/FileContainerApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.FileContainerApi = void 0;
    var stream = require("stream");
    var zlib = require("zlib");
    var httpm = require_HttpClient2();
    var FileContainerApiBase = require_FileContainerApiBase();
    var FileContainerInterfaces = require_FileContainerInterfaces();
    var FileContainerApi = class extends FileContainerApiBase.FileContainerApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, options);
      }
      /**
       * @param {number} containerId
       * @param {string} scope
       * @param {string} itemPath
       * @param {string} downloadFileName
       */
      getItem(containerId, scope, itemPath, downloadFileName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              containerId
            };
            let queryValues = {
              scope,
              itemPath,
              "$format": "OctetStream",
              downloadFileName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("4.0-preview.4", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/octet-stream", verData.apiVersion);
              let res = yield this.http.get(url);
              let rres = {};
              let statusCode = res.message.statusCode;
              rres.statusCode = statusCode;
              if (statusCode == httpm.HttpCodes.NotFound) {
                resolve(rres);
              }
              if (statusCode > 299) {
                let msg;
                let contents = yield res.readBody();
                let obj;
                if (contents && contents.length > 0) {
                  obj = JSON.parse(contents);
                  if (options && options.responseProcessor) {
                    rres.result = options.responseProcessor(obj);
                  } else {
                    rres.result = obj;
                  }
                }
                if (obj && obj.message) {
                  msg = obj.message;
                } else {
                  msg = "Failed request: (" + statusCode + ") " + res.message.url;
                }
                reject2(new Error(msg));
              } else {
                if (res.message.headers["content-encoding"] === "gzip") {
                  let unzipStream = zlib.createGunzip();
                  res.message.pipe(unzipStream);
                  rres.result = unzipStream;
                } else {
                  rres.result = res.message;
                }
                resolve(rres);
              }
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      createItem(contentStream, uncompressedLength, containerId, itemPath, scope, options) {
        return new Promise((resolve, reject2) => {
          let chunkStream = new ChunkStream(this, uncompressedLength, containerId, itemPath, scope, options);
          chunkStream.on("finish", () => {
            resolve(chunkStream.getItem());
          });
          contentStream.pipe(chunkStream);
        });
      }
      // used by ChunkStream
      _createItem(customHeaders, contentStream, containerId, itemPath, scope, onResult) {
        var routeValues = {
          containerId
        };
        var queryValues = {
          itemPath,
          scope
        };
        customHeaders = customHeaders || {};
        customHeaders["Content-Type"] = "";
        this.vsoClient.getVersioningData("4.0-preview.4", "Container", "e4f5c81e-e250-447b-9fef-bd48471bea5e", routeValues, queryValues).then((versioningData) => {
          var url = versioningData.requestUrl;
          var serializationData = { responseTypeMetadata: FileContainerInterfaces.TypeInfo.FileContainerItem, responseIsCollection: false };
          let options = this.createRequestOptions("application/octet-stream", versioningData.apiVersion);
          options.additionalHeaders = customHeaders;
          this.rest.uploadStream("PUT", url, contentStream, options).then((res) => {
            let ret = this.formatResponse(res.result, FileContainerInterfaces.TypeInfo.FileContainerItem, false);
            onResult(null, res.statusCode, ret);
          }).catch((err) => {
            onResult(err, err.statusCode, null);
          });
        }, (error) => {
          onResult(error, error.statusCode, null);
        });
      }
    };
    exports2.FileContainerApi = FileContainerApi;
    var ChunkStream = class _ChunkStream extends stream.Writable {
      constructor(api, uncompressedLength, containerId, itemPath, scope, options) {
        super();
        this._buffer = new Buffer(_ChunkStream.ChunkSize);
        this._length = 0;
        this._startRange = 0;
        this._bytesToSend = 0;
        this._totalReceived = 0;
        this._api = api;
        this._options = options || {};
        this._uncompressedLength = uncompressedLength;
        this._containerId = containerId;
        this._itemPath = itemPath;
        this._scope = scope;
        this._bytesToSend = this._options.isGzipped ? this._options.compressedLength : uncompressedLength;
      }
      _write(data, encoding, callback) {
        let chunk2 = data;
        if (!chunk2) {
          if (this._length == 0) {
            callback();
          } else {
            this._sendChunk(callback);
          }
          return;
        }
        let newBuffer = null;
        if (this._length + chunk2.length > _ChunkStream.ChunkSize) {
          let overflowPosition = chunk2.length - (_ChunkStream.ChunkSize - this._length);
          chunk2.copy(this._buffer, this._length, 0, overflowPosition);
          this._length += overflowPosition;
          newBuffer = chunk2.slice(overflowPosition);
        } else {
          chunk2.copy(this._buffer, this._length, 0, chunk2.length);
          this._length += chunk2.length;
        }
        this._totalReceived += chunk2.length;
        if (this._length >= _ChunkStream.ChunkSize || this._totalReceived >= this._bytesToSend) {
          this._sendChunk(callback, newBuffer);
        } else {
          callback();
        }
      }
      _sendChunk(callback, newBuffer) {
        let endRange = this._startRange + this._length;
        let headers = {
          "Content-Range": "bytes " + this._startRange + "-" + (endRange - 1) + "/" + this._bytesToSend,
          "Content-Length": this._length
        };
        if (this._options.isGzipped) {
          headers["Accept-Encoding"] = "gzip";
          headers["Content-Encoding"] = "gzip";
          headers["x-tfs-filelength"] = this._uncompressedLength;
        }
        this._startRange = endRange;
        this._api._createItem(headers, new BufferStream(this._buffer, this._length), this._containerId, this._itemPath, this._scope, (err, statusCode, item) => {
          if (newBuffer) {
            this._length = newBuffer.length;
            newBuffer.copy(this._buffer);
          } else {
            this._length = 0;
          }
          this._item = item;
          callback(err);
        });
      }
      getItem() {
        return this._item;
      }
    };
    ChunkStream.ChunkSize = 16 * 1024 * 1024;
    var BufferStream = class extends stream.Readable {
      constructor(buffer, length) {
        super();
        this._position = 0;
        this._length = 0;
        this._buffer = buffer;
        this._length = length;
      }
      _read(size2) {
        if (this._position >= this._length) {
          this.push(null);
          return;
        }
        let end = Math.min(this._position + size2, this._length);
        this.push(this._buffer.slice(this._position, end));
        this._position = end;
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/GalleryCompatHttpClientBase.js
var require_GalleryCompatHttpClientBase = __commonJS({
  "../node_modules/azure-devops-node-api/GalleryCompatHttpClientBase.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GalleryCompatHttpClientBase = void 0;
    var basem = require_ClientApiBases();
    var GalleryInterfaces = require_GalleryInterfaces();
    var GalleryCompatHttpClientBase = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, userAgent, options) {
        super(baseUrl, handlers, userAgent, options);
      }
      /**
      * @param {GalleryInterfaces.ExtensionPackage} extensionPackage
      */
      createExtensionJson(extensionPackage) {
        return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
          let routeValues = {};
          try {
            let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "gallery", "a41192c8-9525-4b58-bc86-179fa549d80d", routeValues);
            let url = verData.requestUrl;
            let options = this.createRequestOptions("application/json", verData.apiVersion);
            let res;
            res = yield this.rest.create(url, extensionPackage, options);
            let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
            resolve(ret);
          } catch (err) {
            reject2(err);
          }
        }));
      }
      /**
      * @param {GalleryInterfaces.ExtensionPackage} extensionPackage
      * @param {string} extensionId
      */
      updateExtensionByIdJson(extensionPackage, extensionId) {
        return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
          let routeValues = {
            extensionId
          };
          try {
            let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "gallery", "a41192c8-9525-4b58-bc86-179fa549d80d", routeValues);
            let url = verData.requestUrl;
            let options = this.createRequestOptions("application/json", verData.apiVersion);
            let res;
            res = yield this.rest.replace(url, extensionPackage, options);
            let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
            resolve(ret);
          } catch (err) {
            reject2(err);
          }
        }));
      }
      /**
      * @param {GalleryInterfaces.ExtensionPackage} extensionPackage
      * @param {string} publisherName
      */
      createExtensionWithPublisherJson(extensionPackage, publisherName) {
        return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
          let routeValues = {
            publisherName
          };
          try {
            let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "gallery", "e11ea35a-16fe-4b80-ab11-c4cab88a0966", routeValues);
            let url = verData.requestUrl;
            let options = this.createRequestOptions("application/json", verData.apiVersion);
            let res;
            res = yield this.rest.create(url, extensionPackage, options);
            let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
            resolve(ret);
          } catch (err) {
            reject2(err);
          }
        }));
      }
      /**
      * @param {GalleryInterfaces.ExtensionPackage} extensionPackage
      * @param {string} publisherName
      * @param {string} extensionName
      */
      updateExtensionJson(extensionPackage, publisherName, extensionName) {
        return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
          let routeValues = {
            publisherName,
            extensionName
          };
          try {
            let verData = yield this.vsoClient.getVersioningData("3.1-preview.1", "gallery", "e11ea35a-16fe-4b80-ab11-c4cab88a0966", routeValues);
            let url = verData.requestUrl;
            let options = this.createRequestOptions("application/json", verData.apiVersion);
            let res;
            res = yield this.rest.replace(url, extensionPackage, options);
            let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
            resolve(ret);
          } catch (err) {
            reject2(err);
          }
        }));
      }
    };
    exports2.GalleryCompatHttpClientBase = GalleryCompatHttpClientBase;
  }
});

// ../node_modules/azure-devops-node-api/GalleryApi.js
var require_GalleryApi = __commonJS({
  "../node_modules/azure-devops-node-api/GalleryApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GalleryApi = void 0;
    var compatBase = require_GalleryCompatHttpClientBase();
    var GalleryInterfaces = require_GalleryInterfaces();
    var GalleryApi = class extends compatBase.GalleryCompatHttpClientBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Gallery-api", options);
      }
      /**
       * @param {string} extensionId
       * @param {string} accountName
       */
      shareExtensionById(extensionId, accountName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              extensionId,
              accountName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "1f19631b-a0b4-4a03-89c2-d79785d24360", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} extensionId
       * @param {string} accountName
       */
      unshareExtensionById(extensionId, accountName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              extensionId,
              accountName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "1f19631b-a0b4-4a03-89c2-d79785d24360", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} accountName
       */
      shareExtension(publisherName, extensionName, accountName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              accountName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "a1e66d8f-f5de-4d16-8309-91a4e015ee46", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} accountName
       */
      unshareExtension(publisherName, extensionName, accountName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              accountName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "a1e66d8f-f5de-4d16-8309-91a4e015ee46", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} itemId
       * @param {string} installationTarget
       * @param {boolean} testCommerce
       * @param {boolean} isFreeOrTrialInstall
       */
      getAcquisitionOptions(itemId, installationTarget, testCommerce, isFreeOrTrialInstall) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (installationTarget == null) {
            throw new TypeError("installationTarget can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              itemId
            };
            let queryValues = {
              installationTarget,
              testCommerce,
              isFreeOrTrialInstall
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "9d0a0105-075e-4760-aa15-8bcf54d1bd7d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.AcquisitionOptions, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.ExtensionAcquisitionRequest} acquisitionRequest
       */
      requestAcquisition(acquisitionRequest) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "3adb1f2d-e328-446e-be73-9f6d98071c45", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, acquisitionRequest, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionAcquisitionRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} version
       * @param {string} assetType
       * @param {string} accountToken
       * @param {boolean} acceptDefault
       * @param {String} accountTokenHeader - Header to pass the account token
       */
      getAssetByName(customHeaders, publisherName, extensionName, version2, assetType, accountToken, acceptDefault, accountTokenHeader) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version: version2,
              assetType
            };
            let queryValues = {
              accountToken,
              acceptDefault
            };
            customHeaders = customHeaders || {};
            customHeaders["X-Market-AccountToken"] = "accountTokenHeader";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "7529171f-a002-4180-93ba-685f358a0482", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} extensionId
       * @param {string} version
       * @param {string} assetType
       * @param {string} accountToken
       * @param {boolean} acceptDefault
       * @param {String} accountTokenHeader - Header to pass the account token
       */
      getAsset(customHeaders, extensionId, version2, assetType, accountToken, acceptDefault, accountTokenHeader) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              extensionId,
              version: version2,
              assetType
            };
            let queryValues = {
              accountToken,
              acceptDefault
            };
            customHeaders = customHeaders || {};
            customHeaders["X-Market-AccountToken"] = "accountTokenHeader";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "5d545f3d-ef47-488b-8be3-f5ee1517856c", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} version
       * @param {string} assetType
       * @param {string} accountToken
       * @param {String} accountTokenHeader - Header to pass the account token
       */
      getAssetAuthenticated(customHeaders, publisherName, extensionName, version2, assetType, accountToken, accountTokenHeader) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version: version2,
              assetType
            };
            let queryValues = {
              accountToken
            };
            customHeaders = customHeaders || {};
            customHeaders["X-Market-AccountToken"] = "accountTokenHeader";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "506aff36-2622-4f70-8063-77cce6366d20", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} azurePublisherId
       */
      associateAzurePublisher(publisherName, azurePublisherId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (azurePublisherId == null) {
            throw new TypeError("azurePublisherId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            let queryValues = {
              azurePublisherId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "efd202a6-9d87-4ebc-9229-d2b8ae2fdb6d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       */
      queryAssociatedAzurePublisher(publisherName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "efd202a6-9d87-4ebc-9229-d2b8ae2fdb6d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} languages
       */
      getCategories(languages) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              languages
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "e0a5a71e-3ac3-43a0-ae7d-0bb5c3046a2a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} categoryName
       * @param {string} languages
       * @param {string} product
       */
      getCategoryDetails(categoryName, languages, product) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              categoryName
            };
            let queryValues = {
              languages,
              product
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "75d3c04d-84d2-4973-acd2-22627587dabc", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} product
       * @param {string} categoryId
       * @param {number} lcid
       * @param {string} source
       * @param {string} productVersion
       * @param {string} skus
       * @param {string} subSkus
       * @param {string} productArchitecture
       */
      getCategoryTree(product, categoryId, lcid, source, productVersion, skus, subSkus, productArchitecture) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              product,
              categoryId
            };
            let queryValues = {
              lcid,
              source,
              productVersion,
              skus,
              subSkus,
              productArchitecture
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "1102bb42-82b0-4955-8d8a-435d6b4cedd3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} product
       * @param {number} lcid
       * @param {string} source
       * @param {string} productVersion
       * @param {string} skus
       * @param {string} subSkus
       */
      getRootCategories(product, lcid, source, productVersion, skus, subSkus) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              product
            };
            let queryValues = {
              lcid,
              source,
              productVersion,
              skus,
              subSkus
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "31fba831-35b2-46f6-a641-d05de5a877d8", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} version
       */
      getCertificate(publisherName, extensionName, version2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version: version2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "e905ad6a-3f1f-4d08-9f6d-7d357ff8b7d0", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       */
      getContentVerificationLog(publisherName, extensionName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "c0f1c7c4-3557-4ffb-b774-1e48c4865e99", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.CustomerSupportRequest} customerSupportRequest
       */
      createSupportRequest(customerSupportRequest) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "8eded385-026a-4c15-b810-b8eb402771f1", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, customerSupportRequest, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       */
      createDraftForEditExtension(publisherName, extensionName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "02b33873-4e61-496e-83a2-59d1df46b7d8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionDraft, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.ExtensionDraftPatch} draftPatch
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} draftId
       */
      performEditExtensionDraftOperation(draftPatch, publisherName, extensionName, draftId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              draftId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "02b33873-4e61-496e-83a2-59d1df46b7d8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, draftPatch, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionDraft, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} draftId
       * @param {String} fileName - Header to pass the filename of the uploaded data
       */
      updatePayloadInDraftForEditExtension(customHeaders, contentStream, publisherName, extensionName, draftId, fileName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              draftId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            customHeaders["X-Market-UploadFileName"] = "fileName";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "02b33873-4e61-496e-83a2-59d1df46b7d8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url, contentStream, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionDraft, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} draftId
       * @param {string} assetType
       */
      addAssetForEditExtensionDraft(customHeaders, contentStream, publisherName, extensionName, draftId, assetType) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              draftId,
              assetType
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "f1db9c47-6619-4998-a7e5-d7f9f41a4617", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url, contentStream, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName
       * @param {String} product - Header to pass the product type of the payload file
       * @param {String} fileName - Header to pass the filename of the uploaded data
       */
      createDraftForNewExtension(customHeaders, contentStream, publisherName, product, fileName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            customHeaders["X-Market-UploadFileProduct"] = "product";
            customHeaders["X-Market-UploadFileName"] = "fileName";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "b3ab127d-ebb9-4d22-b611-4e09593c8d79", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionDraft, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.ExtensionDraftPatch} draftPatch
       * @param {string} publisherName
       * @param {string} draftId
       */
      performNewExtensionDraftOperation(draftPatch, publisherName, draftId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              draftId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "b3ab127d-ebb9-4d22-b611-4e09593c8d79", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, draftPatch, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionDraft, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName
       * @param {string} draftId
       * @param {String} fileName - Header to pass the filename of the uploaded data
       */
      updatePayloadInDraftForNewExtension(customHeaders, contentStream, publisherName, draftId, fileName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              draftId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            customHeaders["X-Market-UploadFileName"] = "fileName";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "b3ab127d-ebb9-4d22-b611-4e09593c8d79", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url, contentStream, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionDraft, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName
       * @param {string} draftId
       * @param {string} assetType
       */
      addAssetForNewExtensionDraft(customHeaders, contentStream, publisherName, draftId, assetType) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              draftId,
              assetType
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "88c0b1c8-b4f1-498a-9b2a-8446ef9f32e7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url, contentStream, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} draftId
       * @param {string} assetType
       * @param {string} extensionName
       */
      getAssetFromEditExtensionDraft(publisherName, draftId, assetType, extensionName) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (extensionName == null) {
            throw new TypeError("extensionName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              draftId,
              assetType
            };
            let queryValues = {
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "88c0b1c8-b4f1-498a-9b2a-8446ef9f32e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} draftId
       * @param {string} assetType
       */
      getAssetFromNewExtensionDraft(publisherName, draftId, assetType) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              draftId,
              assetType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "88c0b1c8-b4f1-498a-9b2a-8446ef9f32e7", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get install/uninstall events of an extension. If both count and afterDate parameters are specified, count takes precedence.
       *
       * @param {string} publisherName - Name of the publisher
       * @param {string} extensionName - Name of the extension
       * @param {number} count - Count of events to fetch, applies to each event type.
       * @param {Date} afterDate - Fetch events that occurred on or after this date
       * @param {string} include - Filter options. Supported values: install, uninstall, review, acquisition, sales. Default is to fetch all types of events
       * @param {string} includeProperty - Event properties to include. Currently only 'lastContactDetails' is supported for uninstall events
       */
      getExtensionEvents(publisherName, extensionName, count, afterDate, include, includeProperty) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              count,
              afterDate,
              include,
              includeProperty
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "3d13c499-2168-4d06-bef4-14aba185dcd5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionEvents, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * API endpoint to publish extension install/uninstall events. This is meant to be invoked by EMS only for sending us data related to install/uninstall of an extension.
       *
       * @param {GalleryInterfaces.ExtensionEvents[]} extensionEvents
       */
      publishExtensionEvents(extensionEvents) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "0bf2bd3a-70e0-4d5d-8bf7-bd4a9c2ab6e7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, extensionEvents, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.ExtensionQuery} extensionQuery
       * @param {string} accountToken
       * @param {String} accountTokenHeader - Header to pass the account token
       */
      queryExtensions(customHeaders, extensionQuery, accountToken, accountTokenHeader) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              accountToken
            };
            customHeaders = customHeaders || {};
            customHeaders["X-Market-AccountToken"] = "accountTokenHeader";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "eb9d5ee1-6d43-456b-b80e-8a96fbc014b6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.create(url, extensionQuery, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionQueryResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} extensionType
       * @param {string} reCaptchaToken
       */
      createExtension(customHeaders, contentStream, extensionType, reCaptchaToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              extensionType,
              reCaptchaToken
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "a41192c8-9525-4b58-bc86-179fa549d80d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} extensionId
       * @param {string} version
       */
      deleteExtensionById(extensionId, version2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              extensionId
            };
            let queryValues = {
              version: version2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "a41192c8-9525-4b58-bc86-179fa549d80d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} extensionId
       * @param {string} version
       * @param {GalleryInterfaces.ExtensionQueryFlags} flags
       */
      getExtensionById(extensionId, version2, flags) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              extensionId
            };
            let queryValues = {
              version: version2,
              flags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "a41192c8-9525-4b58-bc86-179fa549d80d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} extensionId
       * @param {string} reCaptchaToken
       */
      updateExtensionById(extensionId, reCaptchaToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              extensionId
            };
            let queryValues = {
              reCaptchaToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "a41192c8-9525-4b58-bc86-179fa549d80d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName
       * @param {string} extensionType
       * @param {string} reCaptchaToken
       */
      createExtensionWithPublisher(customHeaders, contentStream, publisherName, extensionType, reCaptchaToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            let queryValues = {
              extensionType,
              reCaptchaToken
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "e11ea35a-16fe-4b80-ab11-c4cab88a0966", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} version
       */
      deleteExtension(publisherName, extensionName, version2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              version: version2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "e11ea35a-16fe-4b80-ab11-c4cab88a0966", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} version
       * @param {GalleryInterfaces.ExtensionQueryFlags} flags
       * @param {string} accountToken
       * @param {String} accountTokenHeader - Header to pass the account token
       */
      getExtension(customHeaders, publisherName, extensionName, version2, flags, accountToken, accountTokenHeader) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              version: version2,
              flags,
              accountToken
            };
            customHeaders = customHeaders || {};
            customHeaders["X-Market-AccountToken"] = "accountTokenHeader";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "e11ea35a-16fe-4b80-ab11-c4cab88a0966", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * REST endpoint to update an extension.
       *
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName - Name of the publisher
       * @param {string} extensionName - Name of the extension
       * @param {string} extensionType
       * @param {string} reCaptchaToken
       * @param {boolean} bypassScopeCheck - This parameter decides if the scope change check needs to be invoked or not
       */
      updateExtension(customHeaders, contentStream, publisherName, extensionName, extensionType, reCaptchaToken, bypassScopeCheck) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              extensionType,
              reCaptchaToken,
              bypassScopeCheck
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "e11ea35a-16fe-4b80-ab11-c4cab88a0966", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url, contentStream, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {GalleryInterfaces.PublishedExtensionFlags} flags
       */
      updateExtensionProperties(publisherName, extensionName, flags) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (flags == null) {
            throw new TypeError("flags can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              flags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "gallery", "e11ea35a-16fe-4b80-ab11-c4cab88a0966", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, null, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} hostType
       * @param {string} hostName
       */
      shareExtensionWithHost(publisherName, extensionName, hostType, hostName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              hostType,
              hostName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "328a3af8-d124-46e9-9483-01690cd415b9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} hostType
       * @param {string} hostName
       */
      unshareExtensionWithHost(publisherName, extensionName, hostType, hostName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              hostType,
              hostName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "328a3af8-d124-46e9-9483-01690cd415b9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Rest end point to validate if an Azure publisher owns an extension for 3rd party commerce scenario. Azure only supports POST operations and the above signature is not typical of the REST operations. http://sharepoint/sites/AzureUX/_layouts/15/WopiFrame2.aspx?sourcedoc={A793D31E-6DC6-4174-8FA3-DE3F82B51642}&file=Data%20Market%20Partner%20integration%20with%20Marketplace%20service.docx&action=default
       *
       * @param {GalleryInterfaces.AzureRestApiRequestModel} azureRestApiRequestModel - All the parameters are sent in the request body
       */
      extensionValidator(azureRestApiRequestModel) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "05e8a5e1-8c59-4c2c-8856-0ff087d1a844", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, azureRestApiRequestModel, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Send Notification
       *
       * @param {GalleryInterfaces.NotificationsData} notificationData - Denoting the data needed to send notification
       */
      sendNotifications(notificationData) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "eab39817-413c-4602-a49f-07ad00844980", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, notificationData, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * This endpoint gets hit when you download a VSTS extension from the Web UI
       *
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} version
       * @param {string} accountToken
       * @param {boolean} acceptDefault
       * @param {String} accountTokenHeader - Header to pass the account token
       */
      getPackage(customHeaders, publisherName, extensionName, version2, accountToken, acceptDefault, accountTokenHeader) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version: version2
            };
            let queryValues = {
              accountToken,
              acceptDefault
            };
            customHeaders = customHeaders || {};
            customHeaders["X-Market-AccountToken"] = "accountTokenHeader";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "7cb576f8-1cae-4c4b-b7b1-e4af5759e965", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} version
       * @param {string} assetType
       * @param {string} assetToken
       * @param {string} accountToken
       * @param {boolean} acceptDefault
       * @param {String} accountTokenHeader - Header to pass the account token
       */
      getAssetWithToken(customHeaders, publisherName, extensionName, version2, assetType, assetToken, accountToken, acceptDefault, accountTokenHeader) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version: version2,
              assetType,
              assetToken
            };
            let queryValues = {
              accountToken,
              acceptDefault
            };
            customHeaders = customHeaders || {};
            customHeaders["X-Market-AccountToken"] = "accountTokenHeader";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "364415a1-0077-4a41-a7a0-06edd4497492", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete publisher asset like logo
       *
       * @param {string} publisherName - Internal name of the publisher
       * @param {string} assetType - Type of asset. Default value is 'logo'.
       */
      deletePublisherAsset(publisherName, assetType) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            let queryValues = {
              assetType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "21143299-34f9-4c62-8ca8-53da691192f9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get publisher asset like logo as a stream
       *
       * @param {string} publisherName - Internal name of the publisher
       * @param {string} assetType - Type of asset. Default value is 'logo'.
       */
      getPublisherAsset(publisherName, assetType) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            let queryValues = {
              assetType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "21143299-34f9-4c62-8ca8-53da691192f9", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update publisher asset like logo. It accepts asset file as an octet stream and file name is passed in header values.
       *
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName - Internal name of the publisher
       * @param {string} assetType - Type of asset. Default value is 'logo'.
       * @param {String} fileName - Header to pass the filename of the uploaded data
       */
      updatePublisherAsset(customHeaders, contentStream, publisherName, assetType, fileName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            let queryValues = {
              assetType
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            customHeaders["X-Market-UploadFileName"] = "fileName";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "21143299-34f9-4c62-8ca8-53da691192f9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url, contentStream, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       */
      fetchDomainToken(publisherName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "67a609ef-fa74-4b52-8664-78d76f7b3634", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       */
      verifyDomainToken(publisherName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "67a609ef-fa74-4b52-8664-78d76f7b3634", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.PublisherQuery} publisherQuery
       */
      queryPublishers(publisherQuery) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "2ad6ee0a-b53f-4034-9d1d-d009fda1212e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, publisherQuery, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublisherQueryResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.Publisher} publisher
       */
      createPublisher(publisher) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "4ddec66a-e4f6-4f5d-999e-9e77710d7ff4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, publisher, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Publisher, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       */
      deletePublisher(publisherName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "4ddec66a-e4f6-4f5d-999e-9e77710d7ff4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {number} flags
       */
      getPublisher(publisherName, flags) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            let queryValues = {
              flags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "4ddec66a-e4f6-4f5d-999e-9e77710d7ff4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Publisher, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.Publisher} publisher
       * @param {string} publisherName
       */
      updatePublisher(publisher, publisherName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "4ddec66a-e4f6-4f5d-999e-9e77710d7ff4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, publisher, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Publisher, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Endpoint to add/modify publisher membership. Currently Supports only addition/modification of 1 user at a time Works only for adding members of same tenant.
       *
       * @param {GalleryInterfaces.PublisherUserRoleAssignmentRef[]} roleAssignments - List of user identifiers(email address) and role to be added. Currently only one entry is supported.
       * @param {string} publisherName - The name/id of publisher to which users have to be added
       * @param {boolean} limitToCallerIdentityDomain - Should cross tenant addtions be allowed or not.
       */
      updatePublisherMembers(roleAssignments, publisherName, limitToCallerIdentityDomain) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            let queryValues = {
              limitToCallerIdentityDomain
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "4ddec66a-e4f6-4f5d-999e-9e77710d7ff4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, roleAssignments, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublisherRoleAssignment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} extensionType
       * @param {string} reCaptchaToken
       * @param {boolean} bypassScopeCheck
       */
      publishExtensionWithPublisherSignature(customHeaders, contentStream, publisherName, extensionName, extensionType, reCaptchaToken, bypassScopeCheck) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              extensionType,
              reCaptchaToken,
              bypassScopeCheck
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "multipart/related";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "e11ea35a-16fe-4b80-ab11-c4cab88a0969", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url, contentStream, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.PublishedExtension, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       */
      getPublisherWithoutToken(publisherName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "215a2ed8-458a-4850-ad5a-45f1dabc3461", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Publisher, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of questions with their responses associated with an extension.
       *
       * @param {string} publisherName - Name of the publisher who published the extension.
       * @param {string} extensionName - Name of the extension.
       * @param {number} count - Number of questions to retrieve (defaults to 10).
       * @param {number} page - Page number from which set of questions are to be retrieved.
       * @param {Date} afterDate - If provided, results questions are returned which were posted after this date
       */
      getQuestions(publisherName, extensionName, count, page, afterDate) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              count,
              page,
              afterDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "c010d03d-812c-4ade-ae07-c1862475eda5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.QuestionsResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Flags a concern with an existing question for an extension.
       *
       * @param {GalleryInterfaces.Concern} concern - User reported concern with a question for the extension.
       * @param {string} pubName - Name of the publisher who published the extension.
       * @param {string} extName - Name of the extension.
       * @param {number} questionId - Identifier of the question to be updated for the extension.
       */
      reportQuestion(concern, pubName, extName, questionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              pubName,
              extName,
              questionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "784910cd-254a-494d-898b-0728549b2f10", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, concern, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Concern, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new question for an extension.
       *
       * @param {GalleryInterfaces.Question} question - Question to be created for the extension.
       * @param {string} publisherName - Name of the publisher who published the extension.
       * @param {string} extensionName - Name of the extension.
       */
      createQuestion(question, publisherName, extensionName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "6d1d9741-eca8-4701-a3a5-235afc82dfa4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, question, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Question, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes an existing question and all its associated responses for an extension. (soft delete)
       *
       * @param {string} publisherName - Name of the publisher who published the extension.
       * @param {string} extensionName - Name of the extension.
       * @param {number} questionId - Identifier of the question to be deleted for the extension.
       */
      deleteQuestion(publisherName, extensionName, questionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              questionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "6d1d9741-eca8-4701-a3a5-235afc82dfa4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates an existing question for an extension.
       *
       * @param {GalleryInterfaces.Question} question - Updated question to be set for the extension.
       * @param {string} publisherName - Name of the publisher who published the extension.
       * @param {string} extensionName - Name of the extension.
       * @param {number} questionId - Identifier of the question to be updated for the extension.
       */
      updateQuestion(question, publisherName, extensionName, questionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              questionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "6d1d9741-eca8-4701-a3a5-235afc82dfa4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, question, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Question, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new response for a given question for an extension.
       *
       * @param {GalleryInterfaces.Response} response - Response to be created for the extension.
       * @param {string} publisherName - Name of the publisher who published the extension.
       * @param {string} extensionName - Name of the extension.
       * @param {number} questionId - Identifier of the question for which response is to be created for the extension.
       */
      createResponse(response, publisherName, extensionName, questionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              questionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "7f8ae5e0-46b0-438f-b2e8-13e8513517bd", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, response, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Response, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a response for an extension. (soft delete)
       *
       * @param {string} publisherName - Name of the publisher who published the extension.
       * @param {string} extensionName - Name of the extension.
       * @param {number} questionId - Identifies the question whose response is to be deleted.
       * @param {number} responseId - Identifies the response to be deleted.
       */
      deleteResponse(publisherName, extensionName, questionId, responseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              questionId,
              responseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "7f8ae5e0-46b0-438f-b2e8-13e8513517bd", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates an existing response for a given question for an extension.
       *
       * @param {GalleryInterfaces.Response} response - Updated response to be set for the extension.
       * @param {string} publisherName - Name of the publisher who published the extension.
       * @param {string} extensionName - Name of the extension.
       * @param {number} questionId - Identifier of the question for which response is to be updated for the extension.
       * @param {number} responseId - Identifier of the response which has to be updated.
       */
      updateResponse(response, publisherName, extensionName, questionId, responseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              questionId,
              responseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "7f8ae5e0-46b0-438f-b2e8-13e8513517bd", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, response, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Response, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns extension reports
       *
       * @param {string} publisherName - Name of the publisher who published the extension
       * @param {string} extensionName - Name of the extension
       * @param {number} days - Last n days report. If afterDate and days are specified, days will take priority
       * @param {number} count - Number of events to be returned
       * @param {Date} afterDate - Use if you want to fetch events newer than the specified date
       */
      getExtensionReports(publisherName, extensionName, days, count, afterDate) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              days,
              count,
              afterDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "79e0c74f-157f-437e-845f-74fbb4121d4c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of reviews associated with an extension
       *
       * @param {string} publisherName - Name of the publisher who published the extension
       * @param {string} extensionName - Name of the extension
       * @param {number} count - Number of reviews to retrieve (defaults to 5)
       * @param {GalleryInterfaces.ReviewFilterOptions} filterOptions - FilterOptions to filter out empty reviews etcetera, defaults to none
       * @param {Date} beforeDate - Use if you want to fetch reviews older than the specified date, defaults to null
       * @param {Date} afterDate - Use if you want to fetch reviews newer than the specified date, defaults to null
       */
      getReviews(publisherName, extensionName, count, filterOptions, beforeDate, afterDate) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              count,
              filterOptions,
              beforeDate,
              afterDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "5b3f819f-f247-42ad-8c00-dd9ab9ab246d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ReviewsResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a summary of the reviews
       *
       * @param {string} pubName - Name of the publisher who published the extension
       * @param {string} extName - Name of the extension
       * @param {Date} beforeDate - Use if you want to fetch summary of reviews older than the specified date, defaults to null
       * @param {Date} afterDate - Use if you want to fetch summary of reviews newer than the specified date, defaults to null
       */
      getReviewsSummary(pubName, extName, beforeDate, afterDate) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              pubName,
              extName
            };
            let queryValues = {
              beforeDate,
              afterDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "b7b44e21-209e-48f0-ae78-04727fc37d77", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new review for an extension
       *
       * @param {GalleryInterfaces.Review} review - Review to be created for the extension
       * @param {string} pubName - Name of the publisher who published the extension
       * @param {string} extName - Name of the extension
       */
      createReview(review, pubName, extName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              pubName,
              extName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "e6e85b9d-aa70-40e6-aa28-d0fbf40b91a3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, review, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.Review, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a review
       *
       * @param {string} pubName - Name of the publisher who published the extension
       * @param {string} extName - Name of the extension
       * @param {number} reviewId - Id of the review which needs to be updated
       */
      deleteReview(pubName, extName, reviewId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              pubName,
              extName,
              reviewId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "e6e85b9d-aa70-40e6-aa28-d0fbf40b91a3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates or Flags a review
       *
       * @param {GalleryInterfaces.ReviewPatch} reviewPatch - ReviewPatch object which contains the changes to be applied to the review
       * @param {string} pubName - Name of the publisher who published the extension
       * @param {string} extName - Name of the extension
       * @param {number} reviewId - Id of the review which needs to be updated
       */
      updateReview(reviewPatch, pubName, extName, reviewId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              pubName,
              extName,
              reviewId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "e6e85b9d-aa70-40e6-aa28-d0fbf40b91a3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, reviewPatch, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ReviewPatch, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.ExtensionCategory} category
       */
      createCategory(category) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "476531a3-7024-4516-a76a-ed64d3008ad6", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, category, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all setting entries for the given user/all-users scope
       *
       * @param {string} userScope - User-Scope at which to get the value. Should be "me" for the current user or "host" for all users.
       * @param {string} key - Optional key under which to filter all the entries
       */
      getGalleryUserSettings(userScope, key) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              userScope,
              key
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "9b75ece3-7960-401c-848b-148ac01ca350", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Set all setting entries for the given user/all-users scope
       *
       * @param {{ [key: string] : any; }} entries - A key-value pair of all settings that need to be set
       * @param {string} userScope - User-Scope at which to get the value. Should be "me" for the current user or "host" for all users.
       */
      setGalleryUserSettings(entries, userScope) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              userScope
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "9b75ece3-7960-401c-848b-148ac01ca350", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, entries, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} keyType
       * @param {number} expireCurrentSeconds
       */
      generateKey(keyType, expireCurrentSeconds) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              keyType
            };
            let queryValues = {
              expireCurrentSeconds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "92ed5cf4-c38b-465a-9059-2f2fb7c624b5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} keyType
       */
      getSigningKey(keyType) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              keyType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "92ed5cf4-c38b-465a-9059-2f2fb7c624b5", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {GalleryInterfaces.ExtensionStatisticUpdate} extensionStatisticsUpdate
       * @param {string} publisherName
       * @param {string} extensionName
       */
      updateExtensionStatistics(extensionStatisticsUpdate, publisherName, extensionName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "a0ea3204-11e9-422d-a9ca-45851cc41400", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, extensionStatisticsUpdate, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {number} days
       * @param {GalleryInterfaces.ExtensionStatsAggregateType} aggregate
       * @param {Date} afterDate
       */
      getExtensionDailyStats(publisherName, extensionName, days, aggregate, afterDate) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName
            };
            let queryValues = {
              days,
              aggregate,
              afterDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "ae06047e-51c5-4fb4-ab65-7be488544416", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionDailyStats, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * This route/location id only supports HTTP POST anonymously, so that the page view daily stat can be incremented from Marketplace client. Trying to call GET on this route should result in an exception. Without this explicit implementation, calling GET on this public route invokes the above GET implementation GetExtensionDailyStats.
       *
       * @param {string} publisherName - Name of the publisher
       * @param {string} extensionName - Name of the extension
       * @param {string} version - Version of the extension
       */
      getExtensionDailyStatsAnonymous(publisherName, extensionName, version2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version: version2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "4fa7adb6-ca65-4075-a232-5f28323288ea", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GalleryInterfaces.TypeInfo.ExtensionDailyStats, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Increments a daily statistic associated with the extension
       *
       * @param {string} publisherName - Name of the publisher
       * @param {string} extensionName - Name of the extension
       * @param {string} version - Version of the extension
       * @param {string} statType - Type of stat to increment
       * @param {string} targetPlatform
       */
      incrementExtensionDailyStat(publisherName, extensionName, version2, statType, targetPlatform) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (statType == null) {
            throw new TypeError("statType can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version: version2
            };
            let queryValues = {
              statType,
              targetPlatform
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "4fa7adb6-ca65-4075-a232-5f28323288ea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} publisherName
       * @param {string} extensionName
       * @param {string} version
       * @param {string} targetPlatform
       */
      getVerificationLog(publisherName, extensionName, version2, targetPlatform) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              publisherName,
              extensionName,
              version: version2
            };
            let queryValues = {
              targetPlatform
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "c5523abe-b843-437f-875b-5833064efe4d", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} itemName
       * @param {string} version
       * @param {GalleryInterfaces.VSCodeWebExtensionStatisicsType} statType
       */
      updateVSCodeWebExtensionStatistics(itemName, version2, statType) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              itemName,
              version: version2,
              statType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "gallery", "205c91a8-7841-4fd3-ae4f-5a745d5a8df5", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.GalleryApi = GalleryApi;
    GalleryApi.RESOURCE_AREA_ID = "69d21c00-f135-441b-b5ce-3626378e0819";
  }
});

// ../node_modules/azure-devops-node-api/GitApi.js
var require_GitApi = __commonJS({
  "../node_modules/azure-devops-node-api/GitApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.GitApi = void 0;
    var basem = require_ClientApiBases();
    var GitInterfaces = require_GitInterfaces();
    var GitApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Git-api", options);
      }
      /**
       * DELETE Deletes Enablement status and BillableCommitters data from DB. Deleting the enablement data will effectively disable it for the repositories affected.
       *
       * @param {boolean} allProjects
       * @param {boolean} includeBillableCommitters
       * @param {string[]} projectIds
       */
      deleteEnablementStatus(allProjects, includeBillableCommitters, projectIds) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (allProjects == null) {
            throw new TypeError("allProjects can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$allProjects": allProjects,
              "$includeBillableCommitters": includeBillableCommitters,
              projectIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "b43dd56f-a1b4-47a5-a857-73fc1b6c700c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * GET Enablement status for project's repositories.
       *
       * @param {string[]} projectIds - Null defaults to all projects in the host, list of project's repos status to return
       * @param {Date} billingDate - UTC expected, Null defaults to UtcNow(), can be provided for a point in time status
       * @param {number} skip - Skip X rows of resultset to simulate paging.
       * @param {number} take - Return Y rows of resultset to simulate paging.
       */
      getEnablementStatus(projectIds, billingDate, skip, take) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              projectIds,
              "$billingDate": billingDate,
              "$skip": skip,
              "$take": take
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "b43dd56f-a1b4-47a5-a857-73fc1b6c700c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.AdvSecEnablementStatus, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {boolean} enableOnCreateHost
       */
      getEnableOnCreateHost(enableOnCreateHost) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (enableOnCreateHost == null) {
            throw new TypeError("enableOnCreateHost can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$enableOnCreateHost": enableOnCreateHost
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "b43dd56f-a1b4-47a5-a857-73fc1b6c700c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} enableOnCreateProjectId
       */
      getEnableOnCreateProject(enableOnCreateProjectId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (enableOnCreateProjectId == null) {
            throw new TypeError("enableOnCreateProjectId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$enableOnCreateProjectId": enableOnCreateProjectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "b43dd56f-a1b4-47a5-a857-73fc1b6c700c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {boolean} enableOnCreateHost
       */
      setEnableOnCreateHost(enableOnCreateHost) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (enableOnCreateHost == null) {
            throw new TypeError("enableOnCreateHost can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$enableOnCreateHost": enableOnCreateHost
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "b43dd56f-a1b4-47a5-a857-73fc1b6c700c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} enableOnCreateProjectId
       * @param {boolean} enableOnStatus
       */
      setEnableOnCreateProject(enableOnCreateProjectId, enableOnStatus) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (enableOnCreateProjectId == null) {
            throw new TypeError("enableOnCreateProjectId can not be null or undefined");
          }
          if (enableOnStatus == null) {
            throw new TypeError("enableOnStatus can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$enableOnCreateProjectId": enableOnCreateProjectId,
              "$enableOnStatus": enableOnStatus
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "b43dd56f-a1b4-47a5-a857-73fc1b6c700c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * POST Enablement status for repositories.
       *
       * @param {GitInterfaces.AdvSecEnablementUpdate[]} enablementUpdates
       */
      updateEnablementStatus(enablementUpdates) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "b43dd56f-a1b4-47a5-a857-73fc1b6c700c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, enablementUpdates, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get estimated billable pushers for an Organization for last 90 days.
       *
       */
      getEstimatedBillablePushersOrg() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "2277ffbe-28d4-40d6-9c26-40baf26d1408", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get estimated billable pushers for a project for last 90 days.
       *
       * @param {string} project - Project ID or project name
       */
      getEstimatedBillablePushersProject(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "1df7833e-1eed-447b-81a3-390c74923900", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get estimated billable committers for a repository for the last 90 days.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId
       */
      getEstimatedBillableCommittersRepo(project, repositoryId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5dcec07b-a844-4efb-9fc1-968fd1f149db", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * GET Advanced Security Permission status.
       *
       * @param {string} projectName
       * @param {string} repositoryId - Repository user is trying to access
       * @param {string} permission - Permission being requestd, must be "viewAlert" "dismissAlert" "manage" "viewEnablement" or "repoRead"
       */
      getPermission(projectName, repositoryId, permission) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$projectName": projectName,
              "$repositoryId": repositoryId,
              "$permission": permission
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "61b21a05-a60f-4910-a733-ba5347c2142d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create an annotated tag.
       *
       * @param {GitInterfaces.GitAnnotatedTag} tagObject - Object containing details of tag to be created.
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - ID or name of the repository.
       */
      createAnnotatedTag(tagObject, project, repositoryId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5e8a8081-3851-4626-b677-9891cc04102e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, tagObject, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitAnnotatedTag, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get an annotated tag.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - ID or name of the repository.
       * @param {string} objectId - ObjectId (Sha1Id) of tag to get.
       */
      getAnnotatedTag(project, repositoryId, objectId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              objectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5e8a8081-3851-4626-b677-9891cc04102e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitAnnotatedTag, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve actual billable committers for Advanced Security service for a given date.
       *
       * @param {string} project - Project ID or project name
       * @param {Date} billingDate - UTC expected.  If not specified defaults to the previous billing day.
       * @param {number} skip - Skip X rows of resultset to simulate paging.
       * @param {number} take - Return Y rows of resultset to simulate paging.
       */
      getBillableCommitters(project, billingDate, skip, take) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              "$billingDate": billingDate,
              "$skip": skip,
              "$take": take
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5c5e3ebc-37b0-4547-a957-945912d44922", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve detailed actual billable committers for Advanced Security service for a given date. Detailed results intentionally does not filter out soft deleted projects and repositories to help diagnose billing issues.
       *
       * @param {string} project - Project ID or project name
       * @param {string} includeDetails - Return all the details on the billable committers.
       * @param {Date} billingDate - UTC expected. If not specified defaults to the previous billing day.
       */
      getBillableCommittersDetail(project, includeDetails, billingDate) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (includeDetails == null) {
            throw new TypeError("includeDetails can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              "$includeDetails": includeDetails,
              "$billingDate": billingDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5c5e3ebc-37b0-4547-a957-945912d44922", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.BillableCommitterDetail, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a single blob.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} sha1 - SHA1 hash of the file. You can get the SHA1 of a file using the "Git/Items/Get Item" endpoint.
       * @param {string} project - Project ID or project name
       * @param {boolean} download - If true, prompt for a download rather than rendering in a browser. Note: this value defaults to true if $format is zip
       * @param {string} fileName - Provide a fileName to use for a download.
       * @param {boolean} resolveLfs - If true, try to resolve a blob to its LFS contents, if it's an LFS pointer file. Only compatible with octet-stream Accept headers or $format types
       */
      getBlob(repositoryId, sha1, project, download, fileName, resolveLfs) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              sha1
            };
            let queryValues = {
              download,
              fileName,
              resolveLfs
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "7b28e929-2c99-405d-9c5c-6167a06e6816", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a single blob.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} sha1 - SHA1 hash of the file. You can get the SHA1 of a file using the "Git/Items/Get Item" endpoint.
       * @param {string} project - Project ID or project name
       * @param {boolean} download - If true, prompt for a download rather than rendering in a browser. Note: this value defaults to true if $format is zip
       * @param {string} fileName - Provide a fileName to use for a download.
       * @param {boolean} resolveLfs - If true, try to resolve a blob to its LFS contents, if it's an LFS pointer file. Only compatible with octet-stream Accept headers or $format types
       */
      getBlobContent(repositoryId, sha1, project, download, fileName, resolveLfs) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              sha1
            };
            let queryValues = {
              download,
              fileName,
              resolveLfs
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "7b28e929-2c99-405d-9c5c-6167a06e6816", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets one or more blobs in a zip file download.
       *
       * @param {string[]} blobIds - Blob IDs (SHA1 hashes) to be returned in the zip file.
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {string} filename
       */
      getBlobsZip(blobIds, repositoryId, project, filename) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              filename
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "7b28e929-2c99-405d-9c5c-6167a06e6816", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a single blob.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} sha1 - SHA1 hash of the file. You can get the SHA1 of a file using the "Git/Items/Get Item" endpoint.
       * @param {string} project - Project ID or project name
       * @param {boolean} download - If true, prompt for a download rather than rendering in a browser. Note: this value defaults to true if $format is zip
       * @param {string} fileName - Provide a fileName to use for a download.
       * @param {boolean} resolveLfs - If true, try to resolve a blob to its LFS contents, if it's an LFS pointer file. Only compatible with octet-stream Accept headers or $format types
       */
      getBlobZip(repositoryId, sha1, project, download, fileName, resolveLfs) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              sha1
            };
            let queryValues = {
              download,
              fileName,
              resolveLfs
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "7b28e929-2c99-405d-9c5c-6167a06e6816", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve statistics about a single branch.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} name - Name of the branch.
       * @param {string} project - Project ID or project name
       * @param {GitInterfaces.GitVersionDescriptor} baseVersionDescriptor - Identifies the commit or branch to use as the base.
       */
      getBranch(repositoryId, name, project, baseVersionDescriptor) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (name == null) {
            throw new TypeError("name can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              name,
              baseVersionDescriptor
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "d5b216de-d8d5-4d32-ae76-51df755b16d3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitBranchStats, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve statistics about all branches within a repository.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {GitInterfaces.GitVersionDescriptor} baseVersionDescriptor - Identifies the commit or branch to use as the base.
       */
      getBranches(repositoryId, project, baseVersionDescriptor) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              baseVersionDescriptor
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "d5b216de-d8d5-4d32-ae76-51df755b16d3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitBranchStats, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve statistics for multiple commits
       *
       * @param {GitInterfaces.GitQueryBranchStatsCriteria} searchCriteria - Base Commit and List of Target Commits to compare.
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       */
      getBranchStatsBatch(searchCriteria, repositoryId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "d5b216de-d8d5-4d32-ae76-51df755b16d3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, searchCriteria, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitBranchStats, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve changes for a particular commit.
       *
       * @param {string} commitId - The id of the commit.
       * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
       * @param {string} project - Project ID or project name
       * @param {number} top - The maximum number of changes to return.
       * @param {number} skip - The number of changes to skip.
       */
      getChanges(commitId, repositoryId, project, top, skip) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              commitId,
              repositoryId
            };
            let queryValues = {
              top,
              skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5bf884f5-3e07-42e9-afb8-1b872267bf16", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitChanges, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve one conflict for a cherry pick by ID
       *
       * @param {string} repositoryId
       * @param {number} cherryPickId
       * @param {number} conflictId
       * @param {string} project - Project ID or project name
       */
      getCherryPickConflict(repositoryId, cherryPickId, conflictId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              cherryPickId,
              conflictId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "1fe5aab2-d4c0-4b2f-a030-f3831e7aca26", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all conflicts for a cherry pick
       *
       * @param {string} repositoryId
       * @param {number} cherryPickId
       * @param {string} project - Project ID or project name
       * @param {string} continuationToken
       * @param {number} top
       * @param {boolean} excludeResolved
       * @param {boolean} onlyResolved
       * @param {boolean} includeObsolete
       */
      getCherryPickConflicts(repositoryId, cherryPickId, project, continuationToken, top, excludeResolved, onlyResolved, includeObsolete) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              cherryPickId
            };
            let queryValues = {
              continuationToken,
              "$top": top,
              excludeResolved,
              onlyResolved,
              includeObsolete
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "1fe5aab2-d4c0-4b2f-a030-f3831e7aca26", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update merge conflict resolution
       *
       * @param {GitInterfaces.GitConflict} conflict
       * @param {string} repositoryId
       * @param {number} cherryPickId
       * @param {number} conflictId
       * @param {string} project - Project ID or project name
       */
      updateCherryPickConflict(conflict, repositoryId, cherryPickId, conflictId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              cherryPickId,
              conflictId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "1fe5aab2-d4c0-4b2f-a030-f3831e7aca26", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, conflict, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update multiple merge conflict resolutions
       *
       * @param {GitInterfaces.GitConflict[]} conflictUpdates
       * @param {string} repositoryId
       * @param {number} cherryPickId
       * @param {string} project - Project ID or project name
       */
      updateCherryPickConflicts(conflictUpdates, repositoryId, cherryPickId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              cherryPickId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "1fe5aab2-d4c0-4b2f-a030-f3831e7aca26", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, conflictUpdates, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflictUpdateResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Given a commitId, returns a list of commits that are in the same cherry-pick family.
       *
       * @param {string} repositoryNameOrId
       * @param {string} commitId
       * @param {string} project - Project ID or project name
       * @param {boolean} includeLinks
       */
      getCherryPickRelationships(repositoryNameOrId, commitId, project, includeLinks) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryNameOrId,
              commitId
            };
            let queryValues = {
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "8af142a4-27c2-4168-9e82-46b8629aaa0d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Cherry pick a specific commit or commits that are associated to a pull request into a new branch.
       *
       * @param {GitInterfaces.GitAsyncRefOperationParameters} cherryPickToCreate
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - ID of the repository.
       */
      createCherryPick(cherryPickToCreate, project, repositoryId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "033bad68-9a14-43d1-90e0-59cb8856fef6", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, cherryPickToCreate, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCherryPick, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve information about a cherry pick operation by cherry pick Id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} cherryPickId - ID of the cherry pick.
       * @param {string} repositoryId - ID of the repository.
       */
      getCherryPick(project, cherryPickId, repositoryId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              cherryPickId,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "033bad68-9a14-43d1-90e0-59cb8856fef6", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCherryPick, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve information about a cherry pick operation for a specific branch. This operation is expensive due to the underlying object structure, so this API only looks at the 1000 most recent cherry pick operations.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - ID of the repository.
       * @param {string} refName - The GitAsyncRefOperationParameters generatedRefName used for the cherry pick operation.
       */
      getCherryPickForRefName(project, repositoryId, refName) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (refName == null) {
            throw new TypeError("refName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              refName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "033bad68-9a14-43d1-90e0-59cb8856fef6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCherryPick, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Find the closest common commit (the merge base) between base and target commits, and get the diff between either the base and target commits or common and target commits.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {boolean} diffCommonCommit - If true, diff between common and target commits. If false, diff between base and target commits.
       * @param {number} top - Maximum number of changes to return. Defaults to 100.
       * @param {number} skip - Number of changes to skip
       * @param {GitInterfaces.GitBaseVersionDescriptor} baseVersionDescriptor - Descriptor for base commit.
       * @param {GitInterfaces.GitTargetVersionDescriptor} targetVersionDescriptor - Descriptor for target commit.
       */
      getCommitDiffs(repositoryId, project, diffCommonCommit, top, skip, baseVersionDescriptor, targetVersionDescriptor) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              diffCommonCommit,
              "$top": top,
              "$skip": skip
            };
            if (baseVersionDescriptor) {
              queryValues.baseVersionType = baseVersionDescriptor.versionType;
              queryValues.baseVersion = baseVersionDescriptor.version;
              queryValues.baseVersionOptions = baseVersionDescriptor.versionOptions;
            }
            if (targetVersionDescriptor) {
              queryValues.targetVersionType = targetVersionDescriptor.versionType;
              queryValues.targetVersion = targetVersionDescriptor.version;
              queryValues.targetVersionOptions = targetVersionDescriptor.versionOptions;
            }
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "615588d5-c0c7-4b88-88f8-e625306446e8", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitDiffs, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a particular commit.
       *
       * @param {string} commitId - The id of the commit.
       * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
       * @param {string} project - Project ID or project name
       * @param {number} changeCount - The number of changes to include in the result.
       */
      getCommit(commitId, repositoryId, project, changeCount) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              commitId,
              repositoryId
            };
            let queryValues = {
              changeCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "c2570c3b-5b3f-41b8-98bf-5407bfde8d58", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommit, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve git commits for a project
       *
       * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
       * @param {GitInterfaces.GitQueryCommitsCriteria} searchCriteria
       * @param {string} project - Project ID or project name
       * @param {number} skip
       * @param {number} top
       */
      getCommits(repositoryId, searchCriteria, project, skip, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (searchCriteria == null) {
            throw new TypeError("searchCriteria can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              searchCriteria,
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "c2570c3b-5b3f-41b8-98bf-5407bfde8d58", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a list of commits associated with a particular push.
       *
       * @param {string} repositoryId - The id or friendly name of the repository. To use the friendly name, projectId must also be specified.
       * @param {number} pushId - The id of the push.
       * @param {string} project - Project ID or project name
       * @param {number} top - The maximum number of commits to return ("get the top x commits").
       * @param {number} skip - The number of commits to skip.
       * @param {boolean} includeLinks - Set to false to avoid including REST Url links for resources. Defaults to true.
       */
      getPushCommits(repositoryId, pushId, project, top, skip, includeLinks) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (pushId == null) {
            throw new TypeError("pushId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              pushId,
              top,
              skip,
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "c2570c3b-5b3f-41b8-98bf-5407bfde8d58", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve git commits for a project matching the search criteria
       *
       * @param {GitInterfaces.GitQueryCommitsCriteria} searchCriteria - Search options
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {number} skip - Number of commits to skip. The value cannot exceed 3,000,000.
       * @param {number} top - Maximum number of commits to return. The value cannot exceed 50,000.
       * @param {boolean} includeStatuses - True to include additional commit status information.
       */
      getCommitsBatch(searchCriteria, repositoryId, project, skip, top, includeStatuses) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              "$skip": skip,
              "$top": top,
              includeStatuses
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "6400dfb2-0bcb-462b-b992-5a57f8f1416c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, searchCriteria, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve deleted git repositories.
       *
       * @param {string} project - Project ID or project name
       */
      getDeletedRepositories(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "2b6869c4-cb25-42b5-b7a3-0d3e6be0a11a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitDeletedRepository, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the file diffs for each of the specified files
       *
       * @param {GitInterfaces.FileDiffsCriteria} fileDiffsCriteria - List of file parameters objects
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - The name or ID of the repository
       */
      getFileDiffs(fileDiffsCriteria, project, repositoryId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "c4c5a7e6-e9f3-4730-a92b-84baacff694b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, fileDiffsCriteria, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.FileDiff, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all forks of a repository in the collection.
       *
       * @param {string} repositoryNameOrId - The name or ID of the repository.
       * @param {string} collectionId - Team project collection ID.
       * @param {string} project - Project ID or project name
       * @param {boolean} includeLinks - True to include links.
       */
      getForks(repositoryNameOrId, collectionId, project, includeLinks) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryNameOrId,
              collectionId
            };
            let queryValues = {
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "158c0340-bf6f-489c-9625-d572a1480d57", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRepositoryRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Request that another repository's refs be fetched into this one. It syncs two existing forks. To create a fork, please see the <a href="https://docs.microsoft.com/en-us/rest/api/vsts/git/repositories/create?view=azure-devops-rest-5.1"> repositories endpoint</a>
       *
       * @param {GitInterfaces.GitForkSyncRequestParameters} syncParams - Source repository and ref mapping.
       * @param {string} repositoryNameOrId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {boolean} includeLinks - True to include links
       */
      createForkSyncRequest(syncParams, repositoryNameOrId, project, includeLinks) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryNameOrId
            };
            let queryValues = {
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "1703f858-b9d1-46af-ab62-483e9e1055b5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, syncParams, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitForkSyncRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a specific fork sync operation's details.
       *
       * @param {string} repositoryNameOrId - The name or ID of the repository.
       * @param {number} forkSyncOperationId - OperationId of the sync request.
       * @param {string} project - Project ID or project name
       * @param {boolean} includeLinks - True to include links.
       */
      getForkSyncRequest(repositoryNameOrId, forkSyncOperationId, project, includeLinks) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryNameOrId,
              forkSyncOperationId
            };
            let queryValues = {
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "1703f858-b9d1-46af-ab62-483e9e1055b5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitForkSyncRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all requested fork sync operations on this repository.
       *
       * @param {string} repositoryNameOrId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {boolean} includeAbandoned - True to include abandoned requests.
       * @param {boolean} includeLinks - True to include links.
       */
      getForkSyncRequests(repositoryNameOrId, project, includeAbandoned, includeLinks) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryNameOrId
            };
            let queryValues = {
              includeAbandoned,
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "1703f858-b9d1-46af-ab62-483e9e1055b5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitForkSyncRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create an import request.
       *
       * @param {GitInterfaces.GitImportRequest} importRequest - The import request to create.
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - The name or ID of the repository.
       */
      createImportRequest(importRequest, project, repositoryId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "01828ddc-3600-4a41-8633-99b3a73a0eb3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, importRequest, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitImportRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a particular import request.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {number} importRequestId - The unique identifier for the import request.
       */
      getImportRequest(project, repositoryId, importRequestId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              importRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "01828ddc-3600-4a41-8633-99b3a73a0eb3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitImportRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve import requests for a repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {boolean} includeAbandoned - True to include abandoned import requests in the results.
       */
      queryImportRequests(project, repositoryId, includeAbandoned) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              includeAbandoned
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "01828ddc-3600-4a41-8633-99b3a73a0eb3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitImportRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retry or abandon a failed import request.
       *
       * @param {GitInterfaces.GitImportRequest} importRequestToUpdate - The updated version of the import request. Currently, the only change allowed is setting the Status to Queued or Abandoned.
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {number} importRequestId - The unique identifier for the import request to update.
       */
      updateImportRequest(importRequestToUpdate, project, repositoryId, importRequestId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              importRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "01828ddc-3600-4a41-8633-99b3a73a0eb3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, importRequestToUpdate, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitImportRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content, which is always returned as a download.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} path - The item path.
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - The path scope.  The default is null.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - The recursion level of this request. The default is 'none', no recursion.
       * @param {boolean} includeContentMetadata - Set to true to include content metadata.  Default is false.
       * @param {boolean} latestProcessedChange - Set to true to include the latest changes.  Default is false.
       * @param {boolean} download - Set to true to download the response as a file.  Default is false.
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - Version descriptor.  Default is the default branch for the repository.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       * @param {boolean} resolveLfs - Set to true to resolve Git LFS pointer files to return actual content from Git LFS.  Default is false.
       * @param {boolean} sanitize - Set to true to sanitize an svg file and return it as image. Useful only if requested for svg file. Default is false.
       */
      getItem(repositoryId, path2, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, includeContent, resolveLfs, sanitize) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (path2 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              path: path2,
              scopePath,
              recursionLevel,
              includeContentMetadata,
              latestProcessedChange,
              download,
              versionDescriptor,
              includeContent,
              resolveLfs,
              sanitize
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitItem, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content, which is always returned as a download.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} path - The item path.
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - The path scope.  The default is null.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - The recursion level of this request. The default is 'none', no recursion.
       * @param {boolean} includeContentMetadata - Set to true to include content metadata.  Default is false.
       * @param {boolean} latestProcessedChange - Set to true to include the latest changes.  Default is false.
       * @param {boolean} download - Set to true to download the response as a file.  Default is false.
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - Version descriptor.  Default is the default branch for the repository.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       * @param {boolean} resolveLfs - Set to true to resolve Git LFS pointer files to return actual content from Git LFS.  Default is false.
       * @param {boolean} sanitize - Set to true to sanitize an svg file and return it as image. Useful only if requested for svg file. Default is false.
       */
      getItemContent(repositoryId, path2, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, includeContent, resolveLfs, sanitize) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (path2 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              path: path2,
              scopePath,
              recursionLevel,
              includeContentMetadata,
              latestProcessedChange,
              download,
              versionDescriptor,
              includeContent,
              resolveLfs,
              sanitize
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a collection of items. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - The path scope.  The default is null.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - The recursion level of this request. The default is 'none', no recursion.
       * @param {boolean} includeContentMetadata - Set to true to include content metadata.  Default is false.
       * @param {boolean} latestProcessedChange - Set to true to include the latest changes.  Default is false.
       * @param {boolean} download - Set to true to download the response as a file.  Default is false.
       * @param {boolean} includeLinks - Set to true to include links to items.  Default is false.
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - Version descriptor.  Default is the default branch for the repository.
       * @param {boolean} zipForUnix - Set to true to keep the file permissions for unix (and POSIX) systems like executables and symlinks
       */
      getItems(repositoryId, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, includeLinks, versionDescriptor, zipForUnix) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              scopePath,
              recursionLevel,
              includeContentMetadata,
              latestProcessedChange,
              download,
              includeLinks,
              versionDescriptor,
              zipForUnix
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content, which is always returned as a download.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} path - The item path.
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - The path scope.  The default is null.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - The recursion level of this request. The default is 'none', no recursion.
       * @param {boolean} includeContentMetadata - Set to true to include content metadata.  Default is false.
       * @param {boolean} latestProcessedChange - Set to true to include the latest changes.  Default is false.
       * @param {boolean} download - Set to true to download the response as a file.  Default is false.
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - Version descriptor.  Default is the default branch for the repository.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       * @param {boolean} resolveLfs - Set to true to resolve Git LFS pointer files to return actual content from Git LFS.  Default is false.
       * @param {boolean} sanitize - Set to true to sanitize an svg file and return it as image. Useful only if requested for svg file. Default is false.
       */
      getItemText(repositoryId, path2, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, includeContent, resolveLfs, sanitize) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (path2 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              path: path2,
              scopePath,
              recursionLevel,
              includeContentMetadata,
              latestProcessedChange,
              download,
              versionDescriptor,
              includeContent,
              resolveLfs,
              sanitize
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content, which is always returned as a download.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} path - The item path.
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - The path scope.  The default is null.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - The recursion level of this request. The default is 'none', no recursion.
       * @param {boolean} includeContentMetadata - Set to true to include content metadata.  Default is false.
       * @param {boolean} latestProcessedChange - Set to true to include the latest changes.  Default is false.
       * @param {boolean} download - Set to true to download the response as a file.  Default is false.
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - Version descriptor.  Default is the default branch for the repository.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       * @param {boolean} resolveLfs - Set to true to resolve Git LFS pointer files to return actual content from Git LFS.  Default is false.
       * @param {boolean} sanitize - Set to true to sanitize an svg file and return it as image. Useful only if requested for svg file. Default is false.
       */
      getItemZip(repositoryId, path2, project, scopePath, recursionLevel, includeContentMetadata, latestProcessedChange, download, versionDescriptor, includeContent, resolveLfs, sanitize) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (path2 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              path: path2,
              scopePath,
              recursionLevel,
              includeContentMetadata,
              latestProcessedChange,
              download,
              versionDescriptor,
              includeContent,
              resolveLfs,
              sanitize
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "fb93c0db-47ed-4a31-8c20-47552878fb44", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Post for retrieving a creating a batch out of a set of items in a repo / project given a list of paths or a long path
       *
       * @param {GitInterfaces.GitItemRequestData} requestData - Request data attributes: ItemDescriptors, IncludeContentMetadata, LatestProcessedChange, IncludeLinks. ItemDescriptors: Collection of items to fetch, including path, version, and recursion level. IncludeContentMetadata: Whether to include metadata for all items LatestProcessedChange: Whether to include shallow ref to commit that last changed each item. IncludeLinks: Whether to include the _links field on the shallow references.
       * @param {string} repositoryId - The name or ID of the repository
       * @param {string} project - Project ID or project name
       */
      getItemsBatch(requestData, repositoryId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "630fd2e4-fb88-4f85-ad21-13f3fd1fbca9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, requestData, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Find the merge bases of two commits, optionally across forks. If otherRepositoryId is not specified, the merge bases will only be calculated within the context of the local repositoryNameOrId.
       *
       * @param {string} repositoryNameOrId - ID or name of the local repository.
       * @param {string} commitId - First commit, usually the tip of the target branch of the potential merge.
       * @param {string} otherCommitId - Other commit, usually the tip of the source branch of the potential merge.
       * @param {string} project - Project ID or project name
       * @param {string} otherCollectionId - The collection ID where otherCommitId lives.
       * @param {string} otherRepositoryId - The repository ID where otherCommitId lives.
       */
      getMergeBases(repositoryNameOrId, commitId, otherCommitId, project, otherCollectionId, otherRepositoryId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (otherCommitId == null) {
            throw new TypeError("otherCommitId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryNameOrId,
              commitId
            };
            let queryValues = {
              otherCommitId,
              otherCollectionId,
              otherRepositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "7cf2abb6-c964-4f7e-9872-f78c66e72e9c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Request a git merge operation. Currently we support merging only 2 commits.
       *
       * @param {GitInterfaces.GitMergeParameters} mergeParameters - Parents commitIds and merge commit messsage.
       * @param {string} project - Project ID or project name
       * @param {string} repositoryNameOrId - The name or ID of the repository.
       * @param {boolean} includeLinks - True to include links
       */
      createMergeRequest(mergeParameters, project, repositoryNameOrId, includeLinks) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryNameOrId
            };
            let queryValues = {
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "985f7ae9-844f-4906-9897-7ef41516c0e2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, mergeParameters, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitMerge, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a specific merge operation's details.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryNameOrId - The name or ID of the repository.
       * @param {number} mergeOperationId - OperationId of the merge request.
       * @param {boolean} includeLinks - True to include links
       */
      getMergeRequest(project, repositoryNameOrId, mergeOperationId, includeLinks) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryNameOrId,
              mergeOperationId
            };
            let queryValues = {
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "985f7ae9-844f-4906-9897-7ef41516c0e2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitMerge, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Attach a new file to a pull request.
       *
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} fileName - The name of the file.
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      createAttachment(customHeaders, contentStream, fileName, repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              fileName,
              repositoryId,
              pullRequestId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965d9361-878b-413b-a494-45d5b5fd8ab7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.Attachment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a pull request attachment.
       *
       * @param {string} fileName - The name of the attachment to delete.
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      deleteAttachment(fileName, repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              fileName,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965d9361-878b-413b-a494-45d5b5fd8ab7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the file content of a pull request attachment.
       *
       * @param {string} fileName - The name of the attachment.
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      getAttachmentContent(fileName, repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              fileName,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965d9361-878b-413b-a494-45d5b5fd8ab7", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of files attached to a given pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      getAttachments(repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965d9361-878b-413b-a494-45d5b5fd8ab7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.Attachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the file content of a pull request attachment.
       *
       * @param {string} fileName - The name of the attachment.
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      getAttachmentZip(fileName, repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              fileName,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965d9361-878b-413b-a494-45d5b5fd8ab7", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add a like on a comment.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - The ID of the thread that contains the comment.
       * @param {number} commentId - The ID of the comment.
       * @param {string} project - Project ID or project name
       */
      createLike(repositoryId, pullRequestId, threadId, commentId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5f2e2851-1389-425b-a00b-fb2adb3ef31b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a like on a comment.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - The ID of the thread that contains the comment.
       * @param {number} commentId - The ID of the comment.
       * @param {string} project - Project ID or project name
       */
      deleteLike(repositoryId, pullRequestId, threadId, commentId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5f2e2851-1389-425b-a00b-fb2adb3ef31b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get likes for a comment.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - The ID of the thread that contains the comment.
       * @param {number} commentId - The ID of the comment.
       * @param {string} project - Project ID or project name
       */
      getLikes(repositoryId, pullRequestId, threadId, commentId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "5f2e2851-1389-425b-a00b-fb2adb3ef31b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the commits for the specified iteration of a pull request.
       *
       * @param {string} repositoryId - ID or name of the repository.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} iterationId - ID of the iteration from which to get the commits.
       * @param {string} project - Project ID or project name
       * @param {number} top - Maximum number of commits to return. The maximum number of commits that can be returned per batch is 500.
       * @param {number} skip - Number of commits to skip.
       */
      getPullRequestIterationCommits(repositoryId, pullRequestId, iterationId, project, top, skip) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              iterationId
            };
            let queryValues = {
              top,
              skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "e7ea0883-095f-4926-b5fb-f24691c26fb9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the commits for the specified pull request.
       *
       * @param {string} repositoryId - ID or name of the repository.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      getPullRequestCommits(repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "52823034-34a8-4576-922c-8d8b77e9e4c4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitCommitRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve one conflict for a pull request by ID
       *
       * @param {string} repositoryId
       * @param {number} pullRequestId
       * @param {number} conflictId
       * @param {string} project - Project ID or project name
       */
      getPullRequestConflict(repositoryId, pullRequestId, conflictId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              conflictId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "d840fb74-bbef-42d3-b250-564604c054a4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all conflicts for a pull request
       *
       * @param {string} repositoryId - The repository of the Pull Request.
       * @param {number} pullRequestId - The pull request ID.
       * @param {string} project - Project ID or project name
       * @param {number} skip - Conflicts to skip.
       * @param {number} top - Conflicts to return after skip.
       * @param {boolean} includeObsolete - Includes obsolete conflicts.
       * @param {boolean} excludeResolved - Excludes conflicts already resolved.
       * @param {boolean} onlyResolved - Returns only the conflicts that are resolved.
       */
      getPullRequestConflicts(repositoryId, pullRequestId, project, skip, top, includeObsolete, excludeResolved, onlyResolved) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            let queryValues = {
              "$skip": skip,
              "$top": top,
              includeObsolete,
              excludeResolved,
              onlyResolved
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "d840fb74-bbef-42d3-b250-564604c054a4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update merge conflict resolution
       *
       * @param {GitInterfaces.GitConflict} conflict
       * @param {string} repositoryId
       * @param {number} pullRequestId
       * @param {number} conflictId
       * @param {string} project - Project ID or project name
       */
      updatePullRequestConflict(conflict, repositoryId, pullRequestId, conflictId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              conflictId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "d840fb74-bbef-42d3-b250-564604c054a4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, conflict, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update multiple merge conflict resolutions
       *
       * @param {GitInterfaces.GitConflict[]} conflictUpdates
       * @param {string} repositoryId
       * @param {number} pullRequestId
       * @param {string} project - Project ID or project name
       */
      updatePullRequestConflicts(conflictUpdates, repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "d840fb74-bbef-42d3-b250-564604c054a4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, conflictUpdates, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflictUpdateResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve the changes made in a pull request between two iterations.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} iterationId - ID of the pull request iteration. <br /> Iteration one is the head of the source branch at the time the pull request is created and subsequent iterations are created when there are pushes to the source branch. Allowed values are between 1 and the maximum iteration on this pull request.
       * @param {string} project - Project ID or project name
       * @param {number} top - Optional. The number of changes to retrieve.  The default value is 100 and the maximum value is 2000.
       * @param {number} skip - Optional. The number of changes to ignore.  For example, to retrieve changes 101-150, set top 50 and skip to 100.
       * @param {number} compareTo - ID of the pull request iteration to compare against.  The default value is zero which indicates the comparison is made against the common commit between the source and target branches
       */
      getPullRequestIterationChanges(repositoryId, pullRequestId, iterationId, project, top, skip, compareTo) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              iterationId
            };
            let queryValues = {
              "$top": top,
              "$skip": skip,
              "$compareTo": compareTo
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4216bdcf-b6b1-4d59-8b82-c34cc183fc8b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestIterationChanges, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the specified iteration for a pull request.
       *
       * @param {string} repositoryId - ID or name of the repository.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} iterationId - ID of the pull request iteration to return.
       * @param {string} project - Project ID or project name
       */
      getPullRequestIteration(repositoryId, pullRequestId, iterationId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "d43911ee-6958-46b0-a42b-8445b8a0d004", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestIteration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the list of iterations for the specified pull request.
       *
       * @param {string} repositoryId - ID or name of the repository.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       * @param {boolean} includeCommits - If true, include the commits associated with each iteration in the response.
       */
      getPullRequestIterations(repositoryId, pullRequestId, project, includeCommits) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            let queryValues = {
              includeCommits
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "d43911ee-6958-46b0-a42b-8445b8a0d004", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestIteration, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a pull request status on the iteration. This operation will have the same result as Create status on pull request with specified iteration ID in the request body.
       *
       * @param {GitInterfaces.GitPullRequestStatus} status - Pull request status to create.
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} iterationId - ID of the pull request iteration.
       * @param {string} project - Project ID or project name
       */
      createPullRequestIterationStatus(status, repositoryId, pullRequestId, iterationId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "75cf11c5-979f-4038-a76e-058a06adf2bf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, status, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestStatus, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete pull request iteration status.
       *
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} iterationId - ID of the pull request iteration.
       * @param {number} statusId - ID of the pull request status.
       * @param {string} project - Project ID or project name
       */
      deletePullRequestIterationStatus(repositoryId, pullRequestId, iterationId, statusId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              iterationId,
              statusId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "75cf11c5-979f-4038-a76e-058a06adf2bf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the specific pull request iteration status by ID. The status ID is unique within the pull request across all iterations.
       *
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} iterationId - ID of the pull request iteration.
       * @param {number} statusId - ID of the pull request status.
       * @param {string} project - Project ID or project name
       */
      getPullRequestIterationStatus(repositoryId, pullRequestId, iterationId, statusId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              iterationId,
              statusId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "75cf11c5-979f-4038-a76e-058a06adf2bf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestStatus, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the statuses associated with a pull request iteration.
       *
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} iterationId - ID of the pull request iteration.
       * @param {string} project - Project ID or project name
       */
      getPullRequestIterationStatuses(repositoryId, pullRequestId, iterationId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "75cf11c5-979f-4038-a76e-058a06adf2bf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestStatus, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update pull request iteration statuses collection. The only supported operation type is `remove`.
       *
       * @param {VSSInterfaces.JsonPatchDocument} patchDocument - Operations to apply to the pull request statuses in JSON Patch format.
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} iterationId - ID of the pull request iteration.
       * @param {string} project - Project ID or project name
       */
      updatePullRequestIterationStatuses(customHeaders, patchDocument, repositoryId, pullRequestId, iterationId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              iterationId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/json-patch+json";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "75cf11c5-979f-4038-a76e-058a06adf2bf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.update(url, patchDocument, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a tag (if that does not exists yet) and add that as a label (tag) for a specified pull request. The only required field is the name of the new label (tag).
       *
       * @param {TfsCoreInterfaces.WebApiCreateTagRequestData} label - Label to assign to the pull request.
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       * @param {string} projectId - Project ID or project name.
       */
      createPullRequestLabel(label, repositoryId, pullRequestId, project, projectId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            let queryValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "f22387e3-984e-4c52-9c6d-fbb8f14c812d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, label, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a label (tag) from the set of those assigned to the pull request. The tag itself will not be deleted.
       *
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} labelIdOrName - The name or ID of the label requested.
       * @param {string} project - Project ID or project name
       * @param {string} projectId - Project ID or project name.
       */
      deletePullRequestLabels(repositoryId, pullRequestId, labelIdOrName, project, projectId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              labelIdOrName
            };
            let queryValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "f22387e3-984e-4c52-9c6d-fbb8f14c812d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves a single label (tag) that has been assigned to a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} labelIdOrName - The name or ID of the label requested.
       * @param {string} project - Project ID or project name
       * @param {string} projectId - Project ID or project name.
       */
      getPullRequestLabel(repositoryId, pullRequestId, labelIdOrName, project, projectId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              labelIdOrName
            };
            let queryValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "f22387e3-984e-4c52-9c6d-fbb8f14c812d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the labels (tags) assigned to a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       * @param {string} projectId - Project ID or project name.
       */
      getPullRequestLabels(repositoryId, pullRequestId, project, projectId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            let queryValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "f22387e3-984e-4c52-9c6d-fbb8f14c812d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get external properties of the pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      getPullRequestProperties(repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "48a52185-5b9e-4736-9dc1-bb1e2feac80b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create or update pull request external properties. The patch operation can be `add`, `replace` or `remove`. For `add` operation, the path can be empty. If the path is empty, the value must be a list of key value pairs. For `replace` operation, the path cannot be empty. If the path does not exist, the property will be added to the collection. For `remove` operation, the path cannot be empty. If the path does not exist, no action will be performed.
       *
       * @param {VSSInterfaces.JsonPatchDocument} patchDocument - Properties to add, replace or remove in JSON Patch format.
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      updatePullRequestProperties(customHeaders, patchDocument, repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/json-patch+json";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "48a52185-5b9e-4736-9dc1-bb1e2feac80b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.update(url, patchDocument, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * This API is used to find what pull requests are related to a given commit.  It can be used to either find the pull request that created a particular merge commit or it can be used to find all pull requests that have ever merged a particular commit.  The input is a list of queries which each contain a list of commits. For each commit that you search against, you will get back a dictionary of commit -> pull requests.
       *
       * @param {GitInterfaces.GitPullRequestQuery} queries - The list of queries to perform.
       * @param {string} repositoryId - ID of the repository.
       * @param {string} project - Project ID or project name
       */
      getPullRequestQuery(queries, repositoryId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "b3a6eebe-9cf0-49ea-b6cb-1a4c5f5007b0", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, queries, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add a reviewer to a pull request or cast a vote.
       *
       * @param {GitInterfaces.IdentityRefWithVote} reviewer - Reviewer's vote.<br />If the reviewer's ID is included here, it must match the reviewerID parameter.<br />Reviewers can set their own vote with this method.  When adding other reviewers, vote must be set to zero.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} reviewerId - ID of the reviewer.
       * @param {string} project - Project ID or project name
       */
      createPullRequestReviewer(reviewer, repositoryId, pullRequestId, reviewerId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              reviewerId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, reviewer, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add reviewers to a pull request.
       *
       * @param {VSSInterfaces.IdentityRef[]} reviewers - Reviewers to add to the pull request.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      createPullRequestReviewers(reviewers, repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, reviewers, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add an unmaterialized identity to the reviewers of a pull request.
       *
       * @param {GitInterfaces.IdentityRefWithVote} reviewer - Reviewer to add to the pull request.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      createUnmaterializedPullRequestReviewer(reviewer, repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, reviewer, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Remove a reviewer from a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} reviewerId - ID of the reviewer to remove.
       * @param {string} project - Project ID or project name
       */
      deletePullRequestReviewer(repositoryId, pullRequestId, reviewerId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              reviewerId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve information about a particular reviewer on a pull request
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} reviewerId - ID of the reviewer.
       * @param {string} project - Project ID or project name
       */
      getPullRequestReviewer(repositoryId, pullRequestId, reviewerId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              reviewerId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve the reviewers for a pull request
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      getPullRequestReviewers(repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Edit a reviewer entry. These fields are patchable: isFlagged, hasDeclined
       *
       * @param {GitInterfaces.IdentityRefWithVote} reviewer - Reviewer data.<br />If the reviewer's ID is included here, it must match the reviewerID parameter.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} reviewerId - ID of the reviewer.
       * @param {string} project - Project ID or project name
       */
      updatePullRequestReviewer(reviewer, repositoryId, pullRequestId, reviewerId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              reviewerId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, reviewer, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Reset the votes of multiple reviewers on a pull request.  NOTE: This endpoint only supports updating votes, but does not support updating required reviewers (use policy) or display names.
       *
       * @param {GitInterfaces.IdentityRefWithVote[]} patchVotes - IDs of the reviewers whose votes will be reset to zero
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request
       * @param {string} project - Project ID or project name
       */
      updatePullRequestReviewers(patchVotes, repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4b6702c7-aa35-4b89-9c96-b9abf6d3e540", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, patchVotes, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a pull request.
       *
       * @param {number} pullRequestId - The ID of the pull request to retrieve.
       * @param {string} project - Project ID or project name
       */
      getPullRequestById(pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "01a46dea-7d46-4d40-bc84-319e7c260d99", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all pull requests matching a specified criteria.
       *
       * @param {string} project - Project ID or project name
       * @param {GitInterfaces.GitPullRequestSearchCriteria} searchCriteria - Pull requests will be returned that match this search criteria.
       * @param {number} maxCommentLength - Not used.
       * @param {number} skip - The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100.
       * @param {number} top - The number of pull requests to retrieve.
       */
      getPullRequestsByProject(project, searchCriteria, maxCommentLength, skip, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (searchCriteria == null) {
            throw new TypeError("searchCriteria can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              searchCriteria,
              maxCommentLength,
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "a5d28130-9cd2-40fa-9f08-902e7daa9efb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a pull request.
       *
       * @param {GitInterfaces.GitPullRequest} gitPullRequestToCreate - The pull request to create.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {string} project - Project ID or project name
       * @param {boolean} supportsIterations - If true, subsequent pushes to the pull request will be individually reviewable. Set this to false for large pull requests for performance reasons if this functionality is not needed.
       */
      createPullRequest(gitPullRequestToCreate, repositoryId, project, supportsIterations) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              supportsIterations
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "9946fd70-0d40-406e-b686-b4744cbbcc37", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, gitPullRequestToCreate, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - The ID of the pull request to retrieve.
       * @param {string} project - Project ID or project name
       * @param {number} maxCommentLength - Not used.
       * @param {number} skip - Not used.
       * @param {number} top - Not used.
       * @param {boolean} includeCommits - If true, the pull request will be returned with the associated commits.
       * @param {boolean} includeWorkItemRefs - If true, the pull request will be returned with the associated work item references.
       */
      getPullRequest(repositoryId, pullRequestId, project, maxCommentLength, skip, top, includeCommits, includeWorkItemRefs) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            let queryValues = {
              maxCommentLength,
              "$skip": skip,
              "$top": top,
              includeCommits,
              includeWorkItemRefs
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "9946fd70-0d40-406e-b686-b4744cbbcc37", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all pull requests matching a specified criteria.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {GitInterfaces.GitPullRequestSearchCriteria} searchCriteria - Pull requests will be returned that match this search criteria.
       * @param {string} project - Project ID or project name
       * @param {number} maxCommentLength - Not used.
       * @param {number} skip - The number of pull requests to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100.
       * @param {number} top - The number of pull requests to retrieve.
       */
      getPullRequests(repositoryId, searchCriteria, project, maxCommentLength, skip, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (searchCriteria == null) {
            throw new TypeError("searchCriteria can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              searchCriteria,
              maxCommentLength,
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "9946fd70-0d40-406e-b686-b4744cbbcc37", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a pull request
       *
       * @param {GitInterfaces.GitPullRequest} gitPullRequestToUpdate - The pull request content that should be updated.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request to update.
       * @param {string} project - Project ID or project name
       */
      updatePullRequest(gitPullRequestToUpdate, repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "9946fd70-0d40-406e-b686-b4744cbbcc37", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, gitPullRequestToUpdate, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Sends an e-mail notification about a specific pull request to a set of recipients
       *
       * @param {GitInterfaces.ShareNotificationContext} userMessage
       * @param {string} repositoryId - ID of the git repository.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      sharePullRequest(userMessage, repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "696f3a82-47c9-487f-9117-b9d00972ca84", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, userMessage, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a pull request status.
       *
       * @param {GitInterfaces.GitPullRequestStatus} status - Pull request status to create.
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      createPullRequestStatus(status, repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "b5f6bb4f-8d1e-4d79-8d11-4c9172c99c35", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, status, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestStatus, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete pull request status.
       *
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} statusId - ID of the pull request status.
       * @param {string} project - Project ID or project name
       */
      deletePullRequestStatus(repositoryId, pullRequestId, statusId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              statusId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "b5f6bb4f-8d1e-4d79-8d11-4c9172c99c35", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the specific pull request status by ID. The status ID is unique within the pull request across all iterations.
       *
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} statusId - ID of the pull request status.
       * @param {string} project - Project ID or project name
       */
      getPullRequestStatus(repositoryId, pullRequestId, statusId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              statusId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "b5f6bb4f-8d1e-4d79-8d11-4c9172c99c35", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestStatus, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the statuses associated with a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      getPullRequestStatuses(repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "b5f6bb4f-8d1e-4d79-8d11-4c9172c99c35", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestStatus, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update pull request statuses collection. The only supported operation type is `remove`.
       *
       * @param {VSSInterfaces.JsonPatchDocument} patchDocument - Operations to apply to the pull request statuses in JSON Patch format.
       * @param {string} repositoryId - The repository ID of the pull request’s target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      updatePullRequestStatuses(customHeaders, patchDocument, repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/json-patch+json";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "b5f6bb4f-8d1e-4d79-8d11-4c9172c99c35", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.update(url, patchDocument, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a comment on a specific thread in a pull request (up to 500 comments can be created per thread).
       *
       * @param {GitInterfaces.Comment} comment - The comment to create. Comments can be up to 150,000 characters.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - ID of the thread that the desired comment is in.
       * @param {string} project - Project ID or project name
       */
      createComment(comment, repositoryId, pullRequestId, threadId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965a3ec7-5ed8-455a-bdcb-835a5ea7fe7b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, comment, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a comment associated with a specific thread in a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - ID of the thread that the desired comment is in.
       * @param {number} commentId - ID of the comment.
       * @param {string} project - Project ID or project name
       */
      deleteComment(repositoryId, pullRequestId, threadId, commentId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965a3ec7-5ed8-455a-bdcb-835a5ea7fe7b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a comment associated with a specific thread in a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - ID of the thread that the desired comment is in.
       * @param {number} commentId - ID of the comment.
       * @param {string} project - Project ID or project name
       */
      getComment(repositoryId, pullRequestId, threadId, commentId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965a3ec7-5ed8-455a-bdcb-835a5ea7fe7b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all comments associated with a specific thread in a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - ID of the thread.
       * @param {string} project - Project ID or project name
       */
      getComments(repositoryId, pullRequestId, threadId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965a3ec7-5ed8-455a-bdcb-835a5ea7fe7b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.Comment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a comment associated with a specific thread in a pull request.
       *
       * @param {GitInterfaces.Comment} comment - The comment content that should be updated. Comments can be up to 150,000 characters.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - ID of the thread that the desired comment is in.
       * @param {number} commentId - ID of the comment to update.
       * @param {string} project - Project ID or project name
       */
      updateComment(comment, repositoryId, pullRequestId, threadId, commentId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "965a3ec7-5ed8-455a-bdcb-835a5ea7fe7b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, comment, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a thread in a pull request.
       *
       * @param {GitInterfaces.GitPullRequestCommentThread} commentThread - The thread to create. Thread must contain at least one comment.
       * @param {string} repositoryId - Repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      createThread(commentThread, repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "ab6e2e5d-a0b7-4153-b64a-a4efe0d49449", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, commentThread, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestCommentThread, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a thread in a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - ID of the thread.
       * @param {string} project - Project ID or project name
       * @param {number} iteration - If specified, thread position will be tracked using this iteration as the right side of the diff.
       * @param {number} baseIteration - If specified, thread position will be tracked using this iteration as the left side of the diff.
       */
      getPullRequestThread(repositoryId, pullRequestId, threadId, project, iteration, baseIteration) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId
            };
            let queryValues = {
              "$iteration": iteration,
              "$baseIteration": baseIteration
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "ab6e2e5d-a0b7-4153-b64a-a4efe0d49449", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestCommentThread, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all threads in a pull request.
       *
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       * @param {number} iteration - If specified, thread positions will be tracked using this iteration as the right side of the diff.
       * @param {number} baseIteration - If specified, thread positions will be tracked using this iteration as the left side of the diff.
       */
      getThreads(repositoryId, pullRequestId, project, iteration, baseIteration) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            let queryValues = {
              "$iteration": iteration,
              "$baseIteration": baseIteration
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "ab6e2e5d-a0b7-4153-b64a-a4efe0d49449", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestCommentThread, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a thread in a pull request.
       *
       * @param {GitInterfaces.GitPullRequestCommentThread} commentThread - The thread content that should be updated.
       * @param {string} repositoryId - The repository ID of the pull request's target branch.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {number} threadId - ID of the thread to update.
       * @param {string} project - Project ID or project name
       */
      updateThread(commentThread, repositoryId, pullRequestId, threadId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId,
              threadId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "ab6e2e5d-a0b7-4153-b64a-a4efe0d49449", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, commentThread, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPullRequestCommentThread, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a list of work items associated with a pull request.
       *
       * @param {string} repositoryId - ID or name of the repository.
       * @param {number} pullRequestId - ID of the pull request.
       * @param {string} project - Project ID or project name
       */
      getPullRequestWorkItemRefs(repositoryId, pullRequestId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pullRequestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "0a637fcc-5370-4ce8-b0e8-98091f5f9482", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Push changes to the repository.
       *
       * @param {GitInterfaces.GitPush} push
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       */
      createPush(push2, repositoryId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "git", "ea98d07b-3c87-4971-8ede-a613694ffb55", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, push2, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPush, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves a particular push.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {number} pushId - ID of the push.
       * @param {string} project - Project ID or project name
       * @param {number} includeCommits - The number of commits to include in the result.
       * @param {boolean} includeRefUpdates - If true, include the list of refs that were updated by the push.
       */
      getPush(repositoryId, pushId, project, includeCommits, includeRefUpdates) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              pushId
            };
            let queryValues = {
              includeCommits,
              includeRefUpdates
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "git", "ea98d07b-3c87-4971-8ede-a613694ffb55", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPush, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves pushes associated with the specified repository.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {number} skip - Number of pushes to skip.
       * @param {number} top - Number of pushes to return.
       * @param {GitInterfaces.GitPushSearchCriteria} searchCriteria - Search criteria attributes: fromDate, toDate, pusherId, refName, includeRefUpdates or includeLinks. fromDate: Start date to search from. toDate: End date to search to. pusherId: Identity of the person who submitted the push. refName: Branch name to consider. includeRefUpdates: If true, include the list of refs that were updated by the push. includeLinks: Whether to include the _links field on the shallow references.
       */
      getPushes(repositoryId, project, skip, top, searchCriteria) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              "$skip": skip,
              "$top": top,
              searchCriteria
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "git", "ea98d07b-3c87-4971-8ede-a613694ffb55", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitPush, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Destroy (hard delete) a soft-deleted Git repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - The ID of the repository.
       */
      deleteRepositoryFromRecycleBin(project, repositoryId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "a663da97-81db-4eb3-8b83-287670f63073", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve soft-deleted git repositories from the recycle bin.
       *
       * @param {string} project - Project ID or project name
       */
      getRecycleBinRepositories(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "a663da97-81db-4eb3-8b83-287670f63073", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitDeletedRepository, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Recover a soft-deleted Git repository. Recently deleted repositories go into a soft-delete state for a period of time before they are hard deleted and become unrecoverable.
       *
       * @param {GitInterfaces.GitRecycleBinRepositoryDetails} repositoryDetails
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - The ID of the repository.
       */
      restoreRepositoryFromRecycleBin(repositoryDetails, project, repositoryId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "a663da97-81db-4eb3-8b83-287670f63073", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, repositoryDetails, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRepository, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Queries the provided repository for its refs and returns them.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {string} filter - [optional] A filter to apply to the refs (starts with).
       * @param {boolean} includeLinks - [optional] Specifies if referenceLinks should be included in the result. default is false.
       * @param {boolean} includeStatuses - [optional] Includes up to the first 1000 commit statuses for each ref. The default value is false.
       * @param {boolean} includeMyBranches - [optional] Includes only branches that the user owns, the branches the user favorites, and the default branch. The default value is false. Cannot be combined with the filter parameter.
       * @param {boolean} latestStatusesOnly - [optional] True to include only the tip commit status for each ref. This option requires `includeStatuses` to be true. The default value is false.
       * @param {boolean} peelTags - [optional] Annotated tags will populate the PeeledObjectId property. default is false.
       * @param {string} filterContains - [optional] A filter to apply to the refs (contains).
       */
      getRefs(repositoryId, project, filter2, includeLinks, includeStatuses, includeMyBranches, latestStatusesOnly, peelTags, filterContains) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              filter: filter2,
              includeLinks,
              includeStatuses,
              includeMyBranches,
              latestStatusesOnly,
              peelTags,
              filterContains
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "2d874a60-a811-4f62-9c9f-963a6ea0a55b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Lock or Unlock a branch.
       *
       * @param {GitInterfaces.GitRefUpdate} newRefInfo - The ref update action (lock/unlock) to perform
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} filter - The name of the branch to lock/unlock
       * @param {string} project - Project ID or project name
       * @param {string} projectId - ID or name of the team project. Optional if specifying an ID for repository.
       */
      updateRef(newRefInfo, repositoryId, filter2, project, projectId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (filter2 == null) {
            throw new TypeError("filter can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              filter: filter2,
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "2d874a60-a811-4f62-9c9f-963a6ea0a55b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, newRefInfo, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRef, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creating, updating, or deleting refs(branches).
       *
       * @param {GitInterfaces.GitRefUpdate[]} refUpdates - List of ref updates to attempt to perform
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {string} projectId - ID or name of the team project. Optional if specifying an ID for repository.
       */
      updateRefs(refUpdates, repositoryId, project, projectId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              projectId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "2d874a60-a811-4f62-9c9f-963a6ea0a55b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, refUpdates, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRefUpdateResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a ref favorite
       *
       * @param {GitInterfaces.GitRefFavorite} favorite - The ref favorite to create.
       * @param {string} project - Project ID or project name
       */
      createFavorite(favorite, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "876f70af-5792-485a-a1c7-d0a7b2f42bbb", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, favorite, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRefFavorite, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes the refs favorite specified
       *
       * @param {string} project - Project ID or project name
       * @param {number} favoriteId - The Id of the ref favorite to delete.
       */
      deleteRefFavorite(project, favoriteId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              favoriteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "876f70af-5792-485a-a1c7-d0a7b2f42bbb", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the refs favorite for a favorite Id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} favoriteId - The Id of the requested ref favorite.
       */
      getRefFavorite(project, favoriteId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              favoriteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "876f70af-5792-485a-a1c7-d0a7b2f42bbb", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRefFavorite, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the refs favorites for a repo and an identity.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - The id of the repository.
       * @param {string} identityId - The id of the identity whose favorites are to be retrieved. If null, the requesting identity is used.
       */
      getRefFavorites(project, repositoryId, identityId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              repositoryId,
              identityId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "876f70af-5792-485a-a1c7-d0a7b2f42bbb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRefFavorite, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} identityId
       */
      getRefFavoritesForProject(project, identityId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              identityId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "4720896c-594c-4a6d-b94c-12eddd80b34a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRefFavorite, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a git repository in a team project.
       *
       * @param {GitInterfaces.GitRepositoryCreateOptions} gitRepositoryToCreate - Specify the repo name, team project and/or parent repository. Team project information can be omitted from gitRepositoryToCreate if the request is project-scoped (i.e., includes project Id).
       * @param {string} project - Project ID or project name
       * @param {string} sourceRef - [optional] Specify the source refs to use while creating a fork repo
       */
      createRepository(gitRepositoryToCreate, project, sourceRef) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              sourceRef
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, gitRepositoryToCreate, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRepository, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a git repository
       *
       * @param {string} repositoryId - The ID of the repository.
       * @param {string} project - Project ID or project name
       */
      deleteRepository(repositoryId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve git repositories.
       *
       * @param {string} project - Project ID or project name
       * @param {boolean} includeLinks - [optional] True to include reference links. The default value is false.
       * @param {boolean} includeAllUrls - [optional] True to include all remote URLs. The default value is false.
       * @param {boolean} includeHidden - [optional] True to include hidden repositories. The default value is false.
       */
      getRepositories(project, includeLinks, includeAllUrls, includeHidden) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              includeLinks,
              includeAllUrls,
              includeHidden
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRepository, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a git repository.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {string} project - Project ID or project name
       */
      getRepository(repositoryId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRepository, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a git repository.
       *
       * @param {string} repositoryId - The name or ID of the repository.
       * @param {boolean} includeParent - True to include parent repository. Only available in authenticated calls.
       * @param {string} project - Project ID or project name
       */
      getRepositoryWithParent(repositoryId, includeParent, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (includeParent == null) {
            throw new TypeError("includeParent can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              includeParent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRepository, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates the Git repository with either a new repo name or a new default branch.
       *
       * @param {GitInterfaces.GitRepository} newRepositoryInfo - Specify a new repo name or a new default branch of the repository
       * @param {string} repositoryId - The ID of the repository.
       * @param {string} project - Project ID or project name
       */
      updateRepository(newRepositoryInfo, repositoryId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "225f7195-f9c7-4d14-ab28-a83f7ff77e1f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, newRepositoryInfo, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRepository, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve one conflict for a revert by ID
       *
       * @param {string} repositoryId
       * @param {number} revertId
       * @param {number} conflictId
       * @param {string} project - Project ID or project name
       */
      getRevertConflict(repositoryId, revertId, conflictId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              revertId,
              conflictId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "10d7ae6d-1050-446d-852a-bd5d99f834bf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all conflicts for a revert
       *
       * @param {string} repositoryId
       * @param {number} revertId
       * @param {string} project - Project ID or project name
       * @param {string} continuationToken
       * @param {number} top
       * @param {boolean} excludeResolved
       * @param {boolean} onlyResolved
       * @param {boolean} includeObsolete
       */
      getRevertConflicts(repositoryId, revertId, project, continuationToken, top, excludeResolved, onlyResolved, includeObsolete) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              revertId
            };
            let queryValues = {
              continuationToken,
              "$top": top,
              excludeResolved,
              onlyResolved,
              includeObsolete
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "10d7ae6d-1050-446d-852a-bd5d99f834bf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update merge conflict resolution
       *
       * @param {GitInterfaces.GitConflict} conflict
       * @param {string} repositoryId
       * @param {number} revertId
       * @param {number} conflictId
       * @param {string} project - Project ID or project name
       */
      updateRevertConflict(conflict, repositoryId, revertId, conflictId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              revertId,
              conflictId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "10d7ae6d-1050-446d-852a-bd5d99f834bf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, conflict, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflict, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update multiple merge conflict resolutions
       *
       * @param {GitInterfaces.GitConflict[]} conflictUpdates
       * @param {string} repositoryId
       * @param {number} revertId
       * @param {string} project - Project ID or project name
       */
      updateRevertConflicts(conflictUpdates, repositoryId, revertId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              revertId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "10d7ae6d-1050-446d-852a-bd5d99f834bf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, conflictUpdates, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitConflictUpdateResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Starts the operation to create a new branch which reverts changes introduced by either a specific commit or commits that are associated to a pull request.
       *
       * @param {GitInterfaces.GitAsyncRefOperationParameters} revertToCreate
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - ID of the repository.
       */
      createRevert(revertToCreate, project, repositoryId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "bc866058-5449-4715-9cf1-a510b6ff193c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, revertToCreate, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRevert, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve information about a revert operation by revert Id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} revertId - ID of the revert operation.
       * @param {string} repositoryId - ID of the repository.
       */
      getRevert(project, revertId, repositoryId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              revertId,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "bc866058-5449-4715-9cf1-a510b6ff193c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRevert, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve information about a revert operation for a specific branch.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId - ID of the repository.
       * @param {string} refName - The GitAsyncRefOperationParameters generatedRefName used for the revert operation.
       */
      getRevertForRefName(project, repositoryId, refName) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (refName == null) {
            throw new TypeError("refName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              refName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "bc866058-5449-4715-9cf1-a510b6ff193c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitRevert, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create Git commit status.
       *
       * @param {GitInterfaces.GitStatus} gitCommitStatusToCreate - Git commit status object to create.
       * @param {string} commitId - ID of the Git commit.
       * @param {string} repositoryId - ID of the repository.
       * @param {string} project - Project ID or project name
       */
      createCommitStatus(gitCommitStatusToCreate, commitId, repositoryId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              commitId,
              repositoryId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "428dd4fb-fda5-4722-af02-9313b80305da", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, gitCommitStatusToCreate, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitStatus, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get statuses associated with the Git commit.
       *
       * @param {string} commitId - ID of the Git commit.
       * @param {string} repositoryId - ID of the repository.
       * @param {string} project - Project ID or project name
       * @param {number} top - Optional. The number of statuses to retrieve. Default is 1000.
       * @param {number} skip - Optional. The number of statuses to ignore. Default is 0. For example, to retrieve results 101-150, set top to 50 and skip to 100.
       * @param {boolean} latestOnly - The flag indicates whether to get only latest statuses grouped by `Context.Name` and `Context.Genre`.
       */
      getStatuses(commitId, repositoryId, project, top, skip, latestOnly) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              commitId,
              repositoryId
            };
            let queryValues = {
              top,
              skip,
              latestOnly
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "git", "428dd4fb-fda5-4722-af02-9313b80305da", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitStatus, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a pull request suggestion for a particular repository or team project.
       *
       * @param {string} repositoryId - ID of the git repository.
       * @param {string} project - Project ID or project name
       * @param {boolean} preferCompareBranch - If true, prefer the compare branch over the default branch as target branch for pull requests.
       */
      getSuggestions(repositoryId, project, preferCompareBranch) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              preferCompareBranch
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "9393b4fb-4445-4919-972b-9ad16f442d83", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * The Tree endpoint returns the collection of objects underneath the specified tree. Trees are folders in a Git repository.
       *
       * @param {string} repositoryId - Repository Id.
       * @param {string} sha1 - SHA1 hash of the tree object.
       * @param {string} project - Project ID or project name
       * @param {string} projectId - Project Id.
       * @param {boolean} recursive - Search recursively. Include trees underneath this tree. Default is false.
       * @param {string} fileName - Name to use if a .zip file is returned. Default is the object ID.
       */
      getTree(repositoryId, sha1, project, projectId, recursive, fileName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              sha1
            };
            let queryValues = {
              projectId,
              recursive,
              fileName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "729f6437-6f92-44ec-8bee-273a7111063c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, GitInterfaces.TypeInfo.GitTreeRef, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * The Tree endpoint returns the collection of objects underneath the specified tree. Trees are folders in a Git repository.
       *
       * @param {string} repositoryId - Repository Id.
       * @param {string} sha1 - SHA1 hash of the tree object.
       * @param {string} project - Project ID or project name
       * @param {string} projectId - Project Id.
       * @param {boolean} recursive - Search recursively. Include trees underneath this tree. Default is false.
       * @param {string} fileName - Name to use if a .zip file is returned. Default is the object ID.
       */
      getTreeZip(repositoryId, sha1, project, projectId, recursive, fileName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId,
              sha1
            };
            let queryValues = {
              projectId,
              recursive,
              fileName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "git", "729f6437-6f92-44ec-8bee-273a7111063c", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.GitApi = GitApi;
    GitApi.RESOURCE_AREA_ID = "4e080c62-fa21-4fbc-8fef-2a10a2b38049";
  }
});

// ../node_modules/azure-devops-node-api/interfaces/common/VSSInterfaces.js
var require_VSSInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/common/VSSInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.UserProfileSyncState = exports2.UserProfileBackupState = exports2.Operation = exports2.JWTAlgorithm = exports2.DeploymentFlags = exports2.ConnectOptions = void 0;
    var ConnectOptions;
    (function(ConnectOptions2) {
      ConnectOptions2[ConnectOptions2["None"] = 0] = "None";
      ConnectOptions2[ConnectOptions2["IncludeServices"] = 1] = "IncludeServices";
      ConnectOptions2[ConnectOptions2["IncludeLastUserAccess"] = 2] = "IncludeLastUserAccess";
      ConnectOptions2[ConnectOptions2["IncludeInheritedDefinitionsOnly"] = 4] = "IncludeInheritedDefinitionsOnly";
      ConnectOptions2[ConnectOptions2["IncludeNonInheritedDefinitionsOnly"] = 8] = "IncludeNonInheritedDefinitionsOnly";
    })(ConnectOptions = exports2.ConnectOptions || (exports2.ConnectOptions = {}));
    var DeploymentFlags;
    (function(DeploymentFlags2) {
      DeploymentFlags2[DeploymentFlags2["None"] = 0] = "None";
      DeploymentFlags2[DeploymentFlags2["Hosted"] = 1] = "Hosted";
      DeploymentFlags2[DeploymentFlags2["OnPremises"] = 2] = "OnPremises";
    })(DeploymentFlags = exports2.DeploymentFlags || (exports2.DeploymentFlags = {}));
    var JWTAlgorithm;
    (function(JWTAlgorithm2) {
      JWTAlgorithm2[JWTAlgorithm2["None"] = 0] = "None";
      JWTAlgorithm2[JWTAlgorithm2["HS256"] = 1] = "HS256";
      JWTAlgorithm2[JWTAlgorithm2["RS256"] = 2] = "RS256";
    })(JWTAlgorithm = exports2.JWTAlgorithm || (exports2.JWTAlgorithm = {}));
    var Operation;
    (function(Operation2) {
      Operation2[Operation2["Add"] = 0] = "Add";
      Operation2[Operation2["Remove"] = 1] = "Remove";
      Operation2[Operation2["Replace"] = 2] = "Replace";
      Operation2[Operation2["Move"] = 3] = "Move";
      Operation2[Operation2["Copy"] = 4] = "Copy";
      Operation2[Operation2["Test"] = 5] = "Test";
    })(Operation = exports2.Operation || (exports2.Operation = {}));
    var UserProfileBackupState;
    (function(UserProfileBackupState2) {
      UserProfileBackupState2[UserProfileBackupState2["Inactive"] = 0] = "Inactive";
      UserProfileBackupState2[UserProfileBackupState2["Active"] = 1] = "Active";
    })(UserProfileBackupState = exports2.UserProfileBackupState || (exports2.UserProfileBackupState = {}));
    var UserProfileSyncState;
    (function(UserProfileSyncState2) {
      UserProfileSyncState2[UserProfileSyncState2["None"] = 0] = "None";
      UserProfileSyncState2[UserProfileSyncState2["Completed"] = 1] = "Completed";
      UserProfileSyncState2[UserProfileSyncState2["NewProfileDataAndImageRetrieved"] = 2] = "NewProfileDataAndImageRetrieved";
      UserProfileSyncState2[UserProfileSyncState2["ProfileDataBackupDone"] = 3] = "ProfileDataBackupDone";
      UserProfileSyncState2[UserProfileSyncState2["NewProfileDataSet"] = 4] = "NewProfileDataSet";
      UserProfileSyncState2[UserProfileSyncState2["NewProfileDataUpdateFailed"] = 5] = "NewProfileDataUpdateFailed";
      UserProfileSyncState2[UserProfileSyncState2["NewProfileImageUpdateFailed"] = 6] = "NewProfileImageUpdateFailed";
    })(UserProfileSyncState = exports2.UserProfileSyncState || (exports2.UserProfileSyncState = {}));
    exports2.TypeInfo = {
      ConnectOptions: {
        enumValues: {
          "none": 0,
          "includeServices": 1,
          "includeLastUserAccess": 2,
          "includeInheritedDefinitionsOnly": 4,
          "includeNonInheritedDefinitionsOnly": 8
        }
      },
      DeploymentFlags: {
        enumValues: {
          "none": 0,
          "hosted": 1,
          "onPremises": 2
        }
      },
      JsonPatchOperation: {},
      JWTAlgorithm: {
        enumValues: {
          "none": 0,
          "hS256": 1,
          "rS256": 2
        }
      },
      Operation: {
        enumValues: {
          "add": 0,
          "remove": 1,
          "replace": 2,
          "move": 3,
          "copy": 4,
          "test": 5
        }
      },
      SignedUrl: {},
      TraceFilter: {},
      UserProfileBackupState: {
        enumValues: {
          "inactive": 0,
          "active": 1
        }
      },
      UserProfileSyncState: {
        enumValues: {
          "none": 0,
          "completed": 1,
          "newProfileDataAndImageRetrieved": 2,
          "profileDataBackupDone": 3,
          "newProfileDataSet": 4,
          "newProfileDataUpdateFailed": 5,
          "newProfileImageUpdateFailed": 6
        }
      },
      VssNotificationEvent: {}
    };
    exports2.TypeInfo.JsonPatchOperation.fields = {
      op: {
        enumType: exports2.TypeInfo.Operation
      }
    };
    exports2.TypeInfo.SignedUrl.fields = {
      signatureExpires: {
        isDate: true
      }
    };
    exports2.TypeInfo.TraceFilter.fields = {
      timeCreated: {
        isDate: true
      }
    };
    exports2.TypeInfo.VssNotificationEvent.fields = {
      sourceEventCreatedTime: {
        isDate: true
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/interfaces/LocationsInterfaces.js
var require_LocationsInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/LocationsInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.ServiceStatus = exports2.RelativeToSetting = exports2.InheritLevel = void 0;
    var VSSInterfaces = require_VSSInterfaces();
    var InheritLevel;
    (function(InheritLevel2) {
      InheritLevel2[InheritLevel2["None"] = 0] = "None";
      InheritLevel2[InheritLevel2["Deployment"] = 1] = "Deployment";
      InheritLevel2[InheritLevel2["Account"] = 2] = "Account";
      InheritLevel2[InheritLevel2["Collection"] = 4] = "Collection";
      InheritLevel2[InheritLevel2["All"] = 7] = "All";
    })(InheritLevel = exports2.InheritLevel || (exports2.InheritLevel = {}));
    var RelativeToSetting;
    (function(RelativeToSetting2) {
      RelativeToSetting2[RelativeToSetting2["Context"] = 0] = "Context";
      RelativeToSetting2[RelativeToSetting2["WebApplication"] = 2] = "WebApplication";
      RelativeToSetting2[RelativeToSetting2["FullyQualified"] = 3] = "FullyQualified";
    })(RelativeToSetting = exports2.RelativeToSetting || (exports2.RelativeToSetting = {}));
    var ServiceStatus;
    (function(ServiceStatus2) {
      ServiceStatus2[ServiceStatus2["Assigned"] = 0] = "Assigned";
      ServiceStatus2[ServiceStatus2["Active"] = 1] = "Active";
      ServiceStatus2[ServiceStatus2["Moving"] = 2] = "Moving";
    })(ServiceStatus = exports2.ServiceStatus || (exports2.ServiceStatus = {}));
    exports2.TypeInfo = {
      ConnectionData: {},
      InheritLevel: {
        enumValues: {
          "none": 0,
          "deployment": 1,
          "account": 2,
          "collection": 4,
          "all": 7
        }
      },
      LocationServiceData: {},
      RelativeToSetting: {
        enumValues: {
          "context": 0,
          "webApplication": 2,
          "fullyQualified": 3
        }
      },
      ServiceDefinition: {},
      ServiceStatus: {
        enumValues: {
          "assigned": 0,
          "active": 1,
          "moving": 2
        }
      }
    };
    exports2.TypeInfo.ConnectionData.fields = {
      deploymentType: {
        enumType: VSSInterfaces.TypeInfo.DeploymentFlags
      },
      lastUserAccess: {
        isDate: true
      },
      locationServiceData: {
        typeInfo: exports2.TypeInfo.LocationServiceData
      }
    };
    exports2.TypeInfo.LocationServiceData.fields = {
      serviceDefinitions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ServiceDefinition
      }
    };
    exports2.TypeInfo.ServiceDefinition.fields = {
      inheritLevel: {
        enumType: exports2.TypeInfo.InheritLevel
      },
      relativeToSetting: {
        enumType: exports2.TypeInfo.RelativeToSetting
      },
      status: {
        enumType: exports2.TypeInfo.ServiceStatus
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/LocationsApi.js
var require_LocationsApi = __commonJS({
  "../node_modules/azure-devops-node-api/LocationsApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.LocationsApi = void 0;
    var basem = require_ClientApiBases();
    var LocationsInterfaces = require_LocationsInterfaces();
    var LocationsApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Locations-api", options);
      }
      /**
       * This was copied and adapted from TeamFoundationConnectionService.Connect()
       *
       * @param {VSSInterfaces.ConnectOptions} connectOptions
       * @param {number} lastChangeId - Obsolete 32-bit LastChangeId
       * @param {number} lastChangeId64 - Non-truncated 64-bit LastChangeId
       */
      getConnectionData(connectOptions, lastChangeId, lastChangeId64) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              connectOptions,
              lastChangeId,
              lastChangeId64
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "00d9565f-ed9c-4a06-9a50-00e7896ccab4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, LocationsInterfaces.TypeInfo.ConnectionData, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} areaId
       * @param {string} enterpriseName
       * @param {string} organizationName
       */
      getResourceArea(areaId, enterpriseName, organizationName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              areaId
            };
            let queryValues = {
              enterpriseName,
              organizationName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "e81700f7-3be2-46de-8624-2eb35882fcaa", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} areaId
       * @param {string} hostId
       */
      getResourceAreaByHost(areaId, hostId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (hostId == null) {
            throw new TypeError("hostId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              areaId
            };
            let queryValues = {
              hostId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "e81700f7-3be2-46de-8624-2eb35882fcaa", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} enterpriseName
       * @param {string} organizationName
       */
      getResourceAreas(enterpriseName, organizationName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              enterpriseName,
              organizationName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "e81700f7-3be2-46de-8624-2eb35882fcaa", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} hostId
       */
      getResourceAreasByHost(hostId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (hostId == null) {
            throw new TypeError("hostId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              hostId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "e81700f7-3be2-46de-8624-2eb35882fcaa", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} serviceType
       * @param {string} identifier
       */
      deleteServiceDefinition(serviceType, identifier) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              serviceType,
              identifier
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "d810a47d-f4f4-4a62-a03f-fa1860585c4c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Finds a given service definition.
       *
       * @param {string} serviceType
       * @param {string} identifier
       * @param {boolean} allowFaultIn - If true, we will attempt to fault in a host instance mapping if in SPS.
       * @param {boolean} previewFaultIn - If true, we will calculate and return a host instance mapping, but not persist it.
       */
      getServiceDefinition(serviceType, identifier, allowFaultIn, previewFaultIn) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              serviceType,
              identifier
            };
            let queryValues = {
              allowFaultIn,
              previewFaultIn
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "d810a47d-f4f4-4a62-a03f-fa1860585c4c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, LocationsInterfaces.TypeInfo.ServiceDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} serviceType
       */
      getServiceDefinitions(serviceType) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              serviceType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "d810a47d-f4f4-4a62-a03f-fa1860585c4c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, LocationsInterfaces.TypeInfo.ServiceDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {VSSInterfaces.VssJsonCollectionWrapperV<LocationsInterfaces.ServiceDefinition[]>} serviceDefinitions
       */
      updateServiceDefinitions(serviceDefinitions) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Location", "d810a47d-f4f4-4a62-a03f-fa1860585c4c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, serviceDefinitions, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.LocationsApi = LocationsApi;
  }
});

// ../node_modules/azure-devops-node-api/interfaces/ManagementInterfaces.js
var require_ManagementInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/ManagementInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.BillingMode = void 0;
    var BillingMode;
    (function(BillingMode2) {
      BillingMode2[BillingMode2["None"] = 0] = "None";
      BillingMode2[BillingMode2["SingleOrg"] = 1] = "SingleOrg";
      BillingMode2[BillingMode2["MultiOrg"] = 2] = "MultiOrg";
    })(BillingMode = exports2.BillingMode || (exports2.BillingMode = {}));
    exports2.TypeInfo = {
      AdvSecEnablementSettings: {},
      AdvSecEnablementStatus: {},
      BillableCommitterDetails: {},
      BillingInfo: {},
      BillingMode: {
        enumValues: {
          "none": 0,
          "singleOrg": 1,
          "multiOrg": 2
        }
      },
      MeterUsage: {}
    };
    exports2.TypeInfo.AdvSecEnablementSettings.fields = {
      reposEnablementStatus: {
        isArray: true,
        typeInfo: exports2.TypeInfo.AdvSecEnablementStatus
      }
    };
    exports2.TypeInfo.AdvSecEnablementStatus.fields = {
      advSecEnablementLastChangedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.BillableCommitterDetails.fields = {
      commitTime: {
        isDate: true
      },
      pushedTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.BillingInfo.fields = {
      advSecEnabledChangedOnDate: {
        isDate: true
      },
      advSecEnabledFirstChangedOnDate: {
        isDate: true
      },
      billingMode: {
        enumType: exports2.TypeInfo.BillingMode
      }
    };
    exports2.TypeInfo.MeterUsage.fields = {
      billingDate: {
        isDate: true
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/ManagementApi.js
var require_ManagementApi = __commonJS({
  "../node_modules/azure-devops-node-api/ManagementApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ManagementApi = void 0;
    var basem = require_ClientApiBases();
    var ManagementInterfaces = require_ManagementInterfaces();
    var ManagementApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Management-api", options);
      }
      /**
       * Delete the billing info for an organization.
       *
       * @param {string} organizationId
       */
      deleteBillingInfo(organizationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Default",
              organizationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "de45fbc6-60fd-46e2-95ef-490ad08d656a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete the meter usage history from Primary SU for an organization.
       *
       * @param {string} organizationId
       */
      deleteMeterUsageHistory(organizationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              action: "MeterUsageHistory",
              organizationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "de45fbc6-60fd-46e2-95ef-490ad08d656a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the billing info for an organization.
       *
       * @param {string} organizationId - Organization ID to get billing info for.
       */
      getBillingInfo(organizationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Default",
              organizationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "de45fbc6-60fd-46e2-95ef-490ad08d656a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.BillingInfo, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Save the billing info for an organization.
       *
       * @param {ManagementInterfaces.BillingInfo} billingInfo
       * @param {string} organizationId
       */
      saveBillingInfo(billingInfo, organizationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Default",
              organizationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "de45fbc6-60fd-46e2-95ef-490ad08d656a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, billingInfo, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * During multi-org billing computation in primary scale unit(EUS21), this API is used to create billing snapshot for a specific org. Primary scale unit will call this API for each org in different scsle units to create billing snapshot. Data will be stored in the org specific partition DB -> billing snapshot table. This is needed as customers will fetch billing data from their org specific partition DB.
       *
       * @param {ManagementInterfaces.MeterUsage} meterUsage
       */
      createBillingSnapshot(meterUsage) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Default"
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "e58d8091-3d07-48b1-9527-7d6295fd4081", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, meterUsage, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all billable committers details, including those not matched with a VSID.
       *
       * @param {Date} billingDate - The date to query, or if not provided, today
       */
      getBillableCommitterDetails(billingDate) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Details"
            };
            let queryValues = {
              billingDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "e58d8091-3d07-48b1-9527-7d6295fd4081", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.BillableCommitterDetails, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       */
      getLastMeterUsage() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Last"
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "e58d8091-3d07-48b1-9527-7d6295fd4081", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.MeterUsage, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get commiters used when calculating billing information.
       *
       * @param {Date} billingDate - The date to query, or if not provided, today
       */
      getMeterUsage(billingDate) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              action: "Default"
            };
            let queryValues = {
              billingDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "e58d8091-3d07-48b1-9527-7d6295fd4081", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.MeterUsage, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the current status of Advanced Security for the organization
       *
       * @param {boolean} includeAllProperties - When true, also determine if pushes are blocked if they contain secrets
       */
      getOrgEnablementStatus(includeAllProperties) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              includeAllProperties
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "d0c0450f-8882-46f4-a5a8-e48fea3095b0", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.AdvSecEnablementSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the status of Advanced Security for the organization
       *
       * @param {ManagementInterfaces.AdvSecEnablementSettingsUpdate} savedAdvSecEnablementStatus - The new status
       */
      updateOrgEnablementStatus(savedAdvSecEnablementStatus) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "d0c0450f-8882-46f4-a5a8-e48fea3095b0", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, savedAdvSecEnablementStatus, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Estimate the committers that would be added to the customer's usage if Advanced Security was enabled for this organization.
       *
       */
      getEstimatedOrgBillablePushers() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "10a9e9c3-89bf-4312-92ed-139ddbcd2e28", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the current status of Advanced Security for a project
       *
       * @param {string} project - Project ID or project name
       * @param {boolean} includeAllProperties - When true, also determine if pushes are blocked if they contain secrets
       */
      getProjectEnablementStatus(project, includeAllProperties) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              includeAllProperties
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "6b9a4b47-5f2d-40f3-8286-b0152079074d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.AdvSecEnablementSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the status of Advanced Security for the project
       *
       * @param {ManagementInterfaces.AdvSecEnablementSettingsUpdate} savedAdvSecEnablementStatus - The new status
       * @param {string} project - Project ID or project name
       */
      updateProjectEnablementStatus(savedAdvSecEnablementStatus, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "6b9a4b47-5f2d-40f3-8286-b0152079074d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, savedAdvSecEnablementStatus, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Estimate the number of committers that would be added to the customer's usage if Advanced Security was enabled for this project.
       *
       * @param {string} project - Project ID or project name
       */
      getEstimatedProjectBillablePushers(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "bf09cb40-ecf4-4496-8cf7-9ec60c64fd3e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Determine if Advanced Security is enabled for a repository
       *
       * @param {string} project - Project ID or project name
       * @param {string} repository - The name or ID of the repository
       * @param {boolean} includeAllProperties - When true, will also determine if pushes are blocked when secrets are detected
       */
      getRepoEnablementStatus(project, repository, includeAllProperties) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repository
            };
            let queryValues = {
              includeAllProperties
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "d11a1c2b-b904-43dc-b970-bf42486262db", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ManagementInterfaces.TypeInfo.AdvSecEnablementStatus, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the enablement of Advanced Security for a repository
       *
       * @param {ManagementInterfaces.AdvSecEnablementStatusUpdate} savedAdvSecEnablementStatus - new status
       * @param {string} project - Project ID or project name
       * @param {string} repository - Name or ID of the repository
       */
      updateRepoAdvSecEnablementStatus(savedAdvSecEnablementStatus, project, repository) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repository
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "d11a1c2b-b904-43dc-b970-bf42486262db", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, savedAdvSecEnablementStatus, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Estimate the committers that would be added to the customer's usage if Advanced Security was enabled for this repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repository - The name or ID of the repository
       */
      getEstimatedRepoBillableCommitters(project, repository) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repository
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Management", "b60f1ebf-ae77-4557-bd7f-ae3d5598dd1f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.ManagementApi = ManagementApi;
  }
});

// ../node_modules/azure-devops-node-api/interfaces/NotificationInterfaces.js
var require_NotificationInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/NotificationInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.SubscriptionTemplateType = exports2.SubscriptionTemplateQueryFlags = exports2.SubscriptionStatus = exports2.SubscriptionQueryFlags = exports2.SubscriptionPermissions = exports2.SubscriptionFlags = exports2.SubscriptionFieldType = exports2.SubscriberFlags = exports2.NotificationSubscriberDeliveryPreference = exports2.NotificationStatisticType = exports2.NotificationReasonType = exports2.NotificationOperation = exports2.EventTypeQueryFlags = exports2.EventPublisherQueryFlags = exports2.EvaluationOperationStatus = exports2.DefaultGroupDeliveryPreference = void 0;
    var DefaultGroupDeliveryPreference;
    (function(DefaultGroupDeliveryPreference2) {
      DefaultGroupDeliveryPreference2[DefaultGroupDeliveryPreference2["NoDelivery"] = -1] = "NoDelivery";
      DefaultGroupDeliveryPreference2[DefaultGroupDeliveryPreference2["EachMember"] = 2] = "EachMember";
    })(DefaultGroupDeliveryPreference = exports2.DefaultGroupDeliveryPreference || (exports2.DefaultGroupDeliveryPreference = {}));
    var EvaluationOperationStatus;
    (function(EvaluationOperationStatus2) {
      EvaluationOperationStatus2[EvaluationOperationStatus2["NotSet"] = 0] = "NotSet";
      EvaluationOperationStatus2[EvaluationOperationStatus2["Queued"] = 1] = "Queued";
      EvaluationOperationStatus2[EvaluationOperationStatus2["InProgress"] = 2] = "InProgress";
      EvaluationOperationStatus2[EvaluationOperationStatus2["Cancelled"] = 3] = "Cancelled";
      EvaluationOperationStatus2[EvaluationOperationStatus2["Succeeded"] = 4] = "Succeeded";
      EvaluationOperationStatus2[EvaluationOperationStatus2["Failed"] = 5] = "Failed";
      EvaluationOperationStatus2[EvaluationOperationStatus2["TimedOut"] = 6] = "TimedOut";
      EvaluationOperationStatus2[EvaluationOperationStatus2["NotFound"] = 7] = "NotFound";
    })(EvaluationOperationStatus = exports2.EvaluationOperationStatus || (exports2.EvaluationOperationStatus = {}));
    var EventPublisherQueryFlags;
    (function(EventPublisherQueryFlags2) {
      EventPublisherQueryFlags2[EventPublisherQueryFlags2["None"] = 0] = "None";
      EventPublisherQueryFlags2[EventPublisherQueryFlags2["IncludeRemoteServices"] = 2] = "IncludeRemoteServices";
    })(EventPublisherQueryFlags = exports2.EventPublisherQueryFlags || (exports2.EventPublisherQueryFlags = {}));
    var EventTypeQueryFlags;
    (function(EventTypeQueryFlags2) {
      EventTypeQueryFlags2[EventTypeQueryFlags2["None"] = 0] = "None";
      EventTypeQueryFlags2[EventTypeQueryFlags2["IncludeFields"] = 1] = "IncludeFields";
    })(EventTypeQueryFlags = exports2.EventTypeQueryFlags || (exports2.EventTypeQueryFlags = {}));
    var NotificationOperation;
    (function(NotificationOperation2) {
      NotificationOperation2[NotificationOperation2["None"] = 0] = "None";
      NotificationOperation2[NotificationOperation2["SuspendUnprocessed"] = 1] = "SuspendUnprocessed";
    })(NotificationOperation = exports2.NotificationOperation || (exports2.NotificationOperation = {}));
    var NotificationReasonType;
    (function(NotificationReasonType2) {
      NotificationReasonType2[NotificationReasonType2["Unknown"] = 0] = "Unknown";
      NotificationReasonType2[NotificationReasonType2["Follows"] = 1] = "Follows";
      NotificationReasonType2[NotificationReasonType2["Personal"] = 2] = "Personal";
      NotificationReasonType2[NotificationReasonType2["PersonalAlias"] = 3] = "PersonalAlias";
      NotificationReasonType2[NotificationReasonType2["DirectMember"] = 4] = "DirectMember";
      NotificationReasonType2[NotificationReasonType2["IndirectMember"] = 5] = "IndirectMember";
      NotificationReasonType2[NotificationReasonType2["GroupAlias"] = 6] = "GroupAlias";
      NotificationReasonType2[NotificationReasonType2["SubscriptionAlias"] = 7] = "SubscriptionAlias";
      NotificationReasonType2[NotificationReasonType2["SingleRole"] = 8] = "SingleRole";
      NotificationReasonType2[NotificationReasonType2["DirectMemberGroupRole"] = 9] = "DirectMemberGroupRole";
      NotificationReasonType2[NotificationReasonType2["InDirectMemberGroupRole"] = 10] = "InDirectMemberGroupRole";
      NotificationReasonType2[NotificationReasonType2["AliasMemberGroupRole"] = 11] = "AliasMemberGroupRole";
    })(NotificationReasonType = exports2.NotificationReasonType || (exports2.NotificationReasonType = {}));
    var NotificationStatisticType;
    (function(NotificationStatisticType2) {
      NotificationStatisticType2[NotificationStatisticType2["NotificationBySubscription"] = 0] = "NotificationBySubscription";
      NotificationStatisticType2[NotificationStatisticType2["EventsByEventType"] = 1] = "EventsByEventType";
      NotificationStatisticType2[NotificationStatisticType2["NotificationByEventType"] = 2] = "NotificationByEventType";
      NotificationStatisticType2[NotificationStatisticType2["EventsByEventTypePerUser"] = 3] = "EventsByEventTypePerUser";
      NotificationStatisticType2[NotificationStatisticType2["NotificationByEventTypePerUser"] = 4] = "NotificationByEventTypePerUser";
      NotificationStatisticType2[NotificationStatisticType2["Events"] = 5] = "Events";
      NotificationStatisticType2[NotificationStatisticType2["Notifications"] = 6] = "Notifications";
      NotificationStatisticType2[NotificationStatisticType2["NotificationFailureBySubscription"] = 7] = "NotificationFailureBySubscription";
      NotificationStatisticType2[NotificationStatisticType2["UnprocessedRangeStart"] = 100] = "UnprocessedRangeStart";
      NotificationStatisticType2[NotificationStatisticType2["UnprocessedEventsByPublisher"] = 101] = "UnprocessedEventsByPublisher";
      NotificationStatisticType2[NotificationStatisticType2["UnprocessedEventDelayByPublisher"] = 102] = "UnprocessedEventDelayByPublisher";
      NotificationStatisticType2[NotificationStatisticType2["UnprocessedNotificationsByChannelByPublisher"] = 103] = "UnprocessedNotificationsByChannelByPublisher";
      NotificationStatisticType2[NotificationStatisticType2["UnprocessedNotificationDelayByChannelByPublisher"] = 104] = "UnprocessedNotificationDelayByChannelByPublisher";
      NotificationStatisticType2[NotificationStatisticType2["DelayRangeStart"] = 200] = "DelayRangeStart";
      NotificationStatisticType2[NotificationStatisticType2["TotalPipelineTime"] = 201] = "TotalPipelineTime";
      NotificationStatisticType2[NotificationStatisticType2["NotificationPipelineTime"] = 202] = "NotificationPipelineTime";
      NotificationStatisticType2[NotificationStatisticType2["EventPipelineTime"] = 203] = "EventPipelineTime";
      NotificationStatisticType2[NotificationStatisticType2["HourlyRangeStart"] = 1e3] = "HourlyRangeStart";
      NotificationStatisticType2[NotificationStatisticType2["HourlyNotificationBySubscription"] = 1001] = "HourlyNotificationBySubscription";
      NotificationStatisticType2[NotificationStatisticType2["HourlyEventsByEventTypePerUser"] = 1002] = "HourlyEventsByEventTypePerUser";
      NotificationStatisticType2[NotificationStatisticType2["HourlyEvents"] = 1003] = "HourlyEvents";
      NotificationStatisticType2[NotificationStatisticType2["HourlyNotifications"] = 1004] = "HourlyNotifications";
      NotificationStatisticType2[NotificationStatisticType2["HourlyUnprocessedEventsByPublisher"] = 1101] = "HourlyUnprocessedEventsByPublisher";
      NotificationStatisticType2[NotificationStatisticType2["HourlyUnprocessedEventDelayByPublisher"] = 1102] = "HourlyUnprocessedEventDelayByPublisher";
      NotificationStatisticType2[NotificationStatisticType2["HourlyUnprocessedNotificationsByChannelByPublisher"] = 1103] = "HourlyUnprocessedNotificationsByChannelByPublisher";
      NotificationStatisticType2[NotificationStatisticType2["HourlyUnprocessedNotificationDelayByChannelByPublisher"] = 1104] = "HourlyUnprocessedNotificationDelayByChannelByPublisher";
      NotificationStatisticType2[NotificationStatisticType2["HourlyTotalPipelineTime"] = 1201] = "HourlyTotalPipelineTime";
      NotificationStatisticType2[NotificationStatisticType2["HourlyNotificationPipelineTime"] = 1202] = "HourlyNotificationPipelineTime";
      NotificationStatisticType2[NotificationStatisticType2["HourlyEventPipelineTime"] = 1203] = "HourlyEventPipelineTime";
    })(NotificationStatisticType = exports2.NotificationStatisticType || (exports2.NotificationStatisticType = {}));
    var NotificationSubscriberDeliveryPreference;
    (function(NotificationSubscriberDeliveryPreference2) {
      NotificationSubscriberDeliveryPreference2[NotificationSubscriberDeliveryPreference2["NoDelivery"] = -1] = "NoDelivery";
      NotificationSubscriberDeliveryPreference2[NotificationSubscriberDeliveryPreference2["PreferredEmailAddress"] = 1] = "PreferredEmailAddress";
      NotificationSubscriberDeliveryPreference2[NotificationSubscriberDeliveryPreference2["EachMember"] = 2] = "EachMember";
      NotificationSubscriberDeliveryPreference2[NotificationSubscriberDeliveryPreference2["UseDefault"] = 3] = "UseDefault";
    })(NotificationSubscriberDeliveryPreference = exports2.NotificationSubscriberDeliveryPreference || (exports2.NotificationSubscriberDeliveryPreference = {}));
    var SubscriberFlags;
    (function(SubscriberFlags2) {
      SubscriberFlags2[SubscriberFlags2["None"] = 0] = "None";
      SubscriberFlags2[SubscriberFlags2["DeliveryPreferencesEditable"] = 2] = "DeliveryPreferencesEditable";
      SubscriberFlags2[SubscriberFlags2["SupportsPreferredEmailAddressDelivery"] = 4] = "SupportsPreferredEmailAddressDelivery";
      SubscriberFlags2[SubscriberFlags2["SupportsEachMemberDelivery"] = 8] = "SupportsEachMemberDelivery";
      SubscriberFlags2[SubscriberFlags2["SupportsNoDelivery"] = 16] = "SupportsNoDelivery";
      SubscriberFlags2[SubscriberFlags2["IsUser"] = 32] = "IsUser";
      SubscriberFlags2[SubscriberFlags2["IsGroup"] = 64] = "IsGroup";
      SubscriberFlags2[SubscriberFlags2["IsTeam"] = 128] = "IsTeam";
    })(SubscriberFlags = exports2.SubscriberFlags || (exports2.SubscriberFlags = {}));
    var SubscriptionFieldType;
    (function(SubscriptionFieldType2) {
      SubscriptionFieldType2[SubscriptionFieldType2["String"] = 1] = "String";
      SubscriptionFieldType2[SubscriptionFieldType2["Integer"] = 2] = "Integer";
      SubscriptionFieldType2[SubscriptionFieldType2["DateTime"] = 3] = "DateTime";
      SubscriptionFieldType2[SubscriptionFieldType2["PlainText"] = 5] = "PlainText";
      SubscriptionFieldType2[SubscriptionFieldType2["Html"] = 7] = "Html";
      SubscriptionFieldType2[SubscriptionFieldType2["TreePath"] = 8] = "TreePath";
      SubscriptionFieldType2[SubscriptionFieldType2["History"] = 9] = "History";
      SubscriptionFieldType2[SubscriptionFieldType2["Double"] = 10] = "Double";
      SubscriptionFieldType2[SubscriptionFieldType2["Guid"] = 11] = "Guid";
      SubscriptionFieldType2[SubscriptionFieldType2["Boolean"] = 12] = "Boolean";
      SubscriptionFieldType2[SubscriptionFieldType2["Identity"] = 13] = "Identity";
      SubscriptionFieldType2[SubscriptionFieldType2["PicklistInteger"] = 14] = "PicklistInteger";
      SubscriptionFieldType2[SubscriptionFieldType2["PicklistString"] = 15] = "PicklistString";
      SubscriptionFieldType2[SubscriptionFieldType2["PicklistDouble"] = 16] = "PicklistDouble";
      SubscriptionFieldType2[SubscriptionFieldType2["TeamProject"] = 17] = "TeamProject";
    })(SubscriptionFieldType = exports2.SubscriptionFieldType || (exports2.SubscriptionFieldType = {}));
    var SubscriptionFlags;
    (function(SubscriptionFlags2) {
      SubscriptionFlags2[SubscriptionFlags2["None"] = 0] = "None";
      SubscriptionFlags2[SubscriptionFlags2["GroupSubscription"] = 1] = "GroupSubscription";
      SubscriptionFlags2[SubscriptionFlags2["ContributedSubscription"] = 2] = "ContributedSubscription";
      SubscriptionFlags2[SubscriptionFlags2["CanOptOut"] = 4] = "CanOptOut";
      SubscriptionFlags2[SubscriptionFlags2["TeamSubscription"] = 8] = "TeamSubscription";
      SubscriptionFlags2[SubscriptionFlags2["OneActorMatches"] = 16] = "OneActorMatches";
    })(SubscriptionFlags = exports2.SubscriptionFlags || (exports2.SubscriptionFlags = {}));
    var SubscriptionPermissions;
    (function(SubscriptionPermissions2) {
      SubscriptionPermissions2[SubscriptionPermissions2["None"] = 0] = "None";
      SubscriptionPermissions2[SubscriptionPermissions2["View"] = 1] = "View";
      SubscriptionPermissions2[SubscriptionPermissions2["Edit"] = 2] = "Edit";
      SubscriptionPermissions2[SubscriptionPermissions2["Delete"] = 4] = "Delete";
    })(SubscriptionPermissions = exports2.SubscriptionPermissions || (exports2.SubscriptionPermissions = {}));
    var SubscriptionQueryFlags;
    (function(SubscriptionQueryFlags2) {
      SubscriptionQueryFlags2[SubscriptionQueryFlags2["None"] = 0] = "None";
      SubscriptionQueryFlags2[SubscriptionQueryFlags2["IncludeInvalidSubscriptions"] = 2] = "IncludeInvalidSubscriptions";
      SubscriptionQueryFlags2[SubscriptionQueryFlags2["IncludeDeletedSubscriptions"] = 4] = "IncludeDeletedSubscriptions";
      SubscriptionQueryFlags2[SubscriptionQueryFlags2["IncludeFilterDetails"] = 8] = "IncludeFilterDetails";
      SubscriptionQueryFlags2[SubscriptionQueryFlags2["AlwaysReturnBasicInformation"] = 16] = "AlwaysReturnBasicInformation";
      SubscriptionQueryFlags2[SubscriptionQueryFlags2["IncludeSystemSubscriptions"] = 32] = "IncludeSystemSubscriptions";
    })(SubscriptionQueryFlags = exports2.SubscriptionQueryFlags || (exports2.SubscriptionQueryFlags = {}));
    var SubscriptionStatus;
    (function(SubscriptionStatus2) {
      SubscriptionStatus2[SubscriptionStatus2["JailedByNotificationsVolume"] = -200] = "JailedByNotificationsVolume";
      SubscriptionStatus2[SubscriptionStatus2["PendingDeletion"] = -100] = "PendingDeletion";
      SubscriptionStatus2[SubscriptionStatus2["DisabledArgumentException"] = -12] = "DisabledArgumentException";
      SubscriptionStatus2[SubscriptionStatus2["DisabledProjectInvalid"] = -11] = "DisabledProjectInvalid";
      SubscriptionStatus2[SubscriptionStatus2["DisabledMissingPermissions"] = -10] = "DisabledMissingPermissions";
      SubscriptionStatus2[SubscriptionStatus2["DisabledFromProbation"] = -9] = "DisabledFromProbation";
      SubscriptionStatus2[SubscriptionStatus2["DisabledInactiveIdentity"] = -8] = "DisabledInactiveIdentity";
      SubscriptionStatus2[SubscriptionStatus2["DisabledMessageQueueNotSupported"] = -7] = "DisabledMessageQueueNotSupported";
      SubscriptionStatus2[SubscriptionStatus2["DisabledMissingIdentity"] = -6] = "DisabledMissingIdentity";
      SubscriptionStatus2[SubscriptionStatus2["DisabledInvalidRoleExpression"] = -5] = "DisabledInvalidRoleExpression";
      SubscriptionStatus2[SubscriptionStatus2["DisabledInvalidPathClause"] = -4] = "DisabledInvalidPathClause";
      SubscriptionStatus2[SubscriptionStatus2["DisabledAsDuplicateOfDefault"] = -3] = "DisabledAsDuplicateOfDefault";
      SubscriptionStatus2[SubscriptionStatus2["DisabledByAdmin"] = -2] = "DisabledByAdmin";
      SubscriptionStatus2[SubscriptionStatus2["Disabled"] = -1] = "Disabled";
      SubscriptionStatus2[SubscriptionStatus2["Enabled"] = 0] = "Enabled";
      SubscriptionStatus2[SubscriptionStatus2["EnabledOnProbation"] = 1] = "EnabledOnProbation";
    })(SubscriptionStatus = exports2.SubscriptionStatus || (exports2.SubscriptionStatus = {}));
    var SubscriptionTemplateQueryFlags;
    (function(SubscriptionTemplateQueryFlags2) {
      SubscriptionTemplateQueryFlags2[SubscriptionTemplateQueryFlags2["None"] = 0] = "None";
      SubscriptionTemplateQueryFlags2[SubscriptionTemplateQueryFlags2["IncludeUser"] = 1] = "IncludeUser";
      SubscriptionTemplateQueryFlags2[SubscriptionTemplateQueryFlags2["IncludeGroup"] = 2] = "IncludeGroup";
      SubscriptionTemplateQueryFlags2[SubscriptionTemplateQueryFlags2["IncludeUserAndGroup"] = 4] = "IncludeUserAndGroup";
      SubscriptionTemplateQueryFlags2[SubscriptionTemplateQueryFlags2["IncludeEventTypeInformation"] = 22] = "IncludeEventTypeInformation";
    })(SubscriptionTemplateQueryFlags = exports2.SubscriptionTemplateQueryFlags || (exports2.SubscriptionTemplateQueryFlags = {}));
    var SubscriptionTemplateType;
    (function(SubscriptionTemplateType2) {
      SubscriptionTemplateType2[SubscriptionTemplateType2["User"] = 0] = "User";
      SubscriptionTemplateType2[SubscriptionTemplateType2["Team"] = 1] = "Team";
      SubscriptionTemplateType2[SubscriptionTemplateType2["Both"] = 2] = "Both";
      SubscriptionTemplateType2[SubscriptionTemplateType2["None"] = 3] = "None";
    })(SubscriptionTemplateType = exports2.SubscriptionTemplateType || (exports2.SubscriptionTemplateType = {}));
    exports2.TypeInfo = {
      ActorNotificationReason: {},
      BatchNotificationOperation: {},
      DefaultGroupDeliveryPreference: {
        enumValues: {
          "noDelivery": -1,
          "eachMember": 2
        }
      },
      EvaluationOperationStatus: {
        enumValues: {
          "notSet": 0,
          "queued": 1,
          "inProgress": 2,
          "cancelled": 3,
          "succeeded": 4,
          "failed": 5,
          "timedOut": 6,
          "notFound": 7
        }
      },
      EventBacklogStatus: {},
      EventProcessingLog: {},
      EventPublisherQueryFlags: {
        enumValues: {
          "none": 0,
          "includeRemoteServices": 2
        }
      },
      EventTypeQueryFlags: {
        enumValues: {
          "none": 0,
          "includeFields": 1
        }
      },
      INotificationDiagnosticLog: {},
      NotificationAdminSettings: {},
      NotificationAdminSettingsUpdateParameters: {},
      NotificationBacklogStatus: {},
      NotificationDeliveryLog: {},
      NotificationDiagnosticLog: {},
      NotificationEventBacklogStatus: {},
      NotificationEventField: {},
      NotificationEventFieldType: {},
      NotificationEventType: {},
      NotificationJobDiagnosticLog: {},
      NotificationOperation: {
        enumValues: {
          "none": 0,
          "suspendUnprocessed": 1
        }
      },
      NotificationReason: {},
      NotificationReasonType: {
        enumValues: {
          "unknown": 0,
          "follows": 1,
          "personal": 2,
          "personalAlias": 3,
          "directMember": 4,
          "indirectMember": 5,
          "groupAlias": 6,
          "subscriptionAlias": 7,
          "singleRole": 8,
          "directMemberGroupRole": 9,
          "inDirectMemberGroupRole": 10,
          "aliasMemberGroupRole": 11
        }
      },
      NotificationStatistic: {},
      NotificationStatisticsQuery: {},
      NotificationStatisticsQueryConditions: {},
      NotificationStatisticType: {
        enumValues: {
          "notificationBySubscription": 0,
          "eventsByEventType": 1,
          "notificationByEventType": 2,
          "eventsByEventTypePerUser": 3,
          "notificationByEventTypePerUser": 4,
          "events": 5,
          "notifications": 6,
          "notificationFailureBySubscription": 7,
          "unprocessedRangeStart": 100,
          "unprocessedEventsByPublisher": 101,
          "unprocessedEventDelayByPublisher": 102,
          "unprocessedNotificationsByChannelByPublisher": 103,
          "unprocessedNotificationDelayByChannelByPublisher": 104,
          "delayRangeStart": 200,
          "totalPipelineTime": 201,
          "notificationPipelineTime": 202,
          "eventPipelineTime": 203,
          "hourlyRangeStart": 1e3,
          "hourlyNotificationBySubscription": 1001,
          "hourlyEventsByEventTypePerUser": 1002,
          "hourlyEvents": 1003,
          "hourlyNotifications": 1004,
          "hourlyUnprocessedEventsByPublisher": 1101,
          "hourlyUnprocessedEventDelayByPublisher": 1102,
          "hourlyUnprocessedNotificationsByChannelByPublisher": 1103,
          "hourlyUnprocessedNotificationDelayByChannelByPublisher": 1104,
          "hourlyTotalPipelineTime": 1201,
          "hourlyNotificationPipelineTime": 1202,
          "hourlyEventPipelineTime": 1203
        }
      },
      NotificationSubscriber: {},
      NotificationSubscriberDeliveryPreference: {
        enumValues: {
          "noDelivery": -1,
          "preferredEmailAddress": 1,
          "eachMember": 2,
          "useDefault": 3
        }
      },
      NotificationSubscriberUpdateParameters: {},
      NotificationSubscription: {},
      NotificationSubscriptionTemplate: {},
      NotificationSubscriptionUpdateParameters: {},
      SubscriberFlags: {
        enumValues: {
          "none": 0,
          "deliveryPreferencesEditable": 2,
          "supportsPreferredEmailAddressDelivery": 4,
          "supportsEachMemberDelivery": 8,
          "supportsNoDelivery": 16,
          "isUser": 32,
          "isGroup": 64,
          "isTeam": 128
        }
      },
      SubscriptionDiagnostics: {},
      SubscriptionEvaluationRequest: {},
      SubscriptionEvaluationResult: {},
      SubscriptionFieldType: {
        enumValues: {
          "string": 1,
          "integer": 2,
          "dateTime": 3,
          "plainText": 5,
          "html": 7,
          "treePath": 8,
          "history": 9,
          "double": 10,
          "guid": 11,
          "boolean": 12,
          "identity": 13,
          "picklistInteger": 14,
          "picklistString": 15,
          "picklistDouble": 16,
          "teamProject": 17
        }
      },
      SubscriptionFlags: {
        enumValues: {
          "none": 0,
          "groupSubscription": 1,
          "contributedSubscription": 2,
          "canOptOut": 4,
          "teamSubscription": 8,
          "oneActorMatches": 16
        }
      },
      SubscriptionPermissions: {
        enumValues: {
          "none": 0,
          "view": 1,
          "edit": 2,
          "delete": 4
        }
      },
      SubscriptionQuery: {},
      SubscriptionQueryCondition: {},
      SubscriptionQueryFlags: {
        enumValues: {
          "none": 0,
          "includeInvalidSubscriptions": 2,
          "includeDeletedSubscriptions": 4,
          "includeFilterDetails": 8,
          "alwaysReturnBasicInformation": 16,
          "includeSystemSubscriptions": 32
        }
      },
      SubscriptionStatus: {
        enumValues: {
          "jailedByNotificationsVolume": -200,
          "pendingDeletion": -100,
          "disabledArgumentException": -12,
          "disabledProjectInvalid": -11,
          "disabledMissingPermissions": -10,
          "disabledFromProbation": -9,
          "disabledInactiveIdentity": -8,
          "disabledMessageQueueNotSupported": -7,
          "disabledMissingIdentity": -6,
          "disabledInvalidRoleExpression": -5,
          "disabledInvalidPathClause": -4,
          "disabledAsDuplicateOfDefault": -3,
          "disabledByAdmin": -2,
          "disabled": -1,
          "enabled": 0,
          "enabledOnProbation": 1
        }
      },
      SubscriptionTemplateQueryFlags: {
        enumValues: {
          "none": 0,
          "includeUser": 1,
          "includeGroup": 2,
          "includeUserAndGroup": 4,
          "includeEventTypeInformation": 22
        }
      },
      SubscriptionTemplateType: {
        enumValues: {
          "user": 0,
          "team": 1,
          "both": 2,
          "none": 3
        }
      },
      SubscriptionTraceDiagnosticLog: {},
      SubscriptionTraceEventProcessingLog: {},
      SubscriptionTraceNotificationDeliveryLog: {},
      SubscriptionTracing: {}
    };
    exports2.TypeInfo.ActorNotificationReason.fields = {
      notificationReasonType: {
        enumType: exports2.TypeInfo.NotificationReasonType
      }
    };
    exports2.TypeInfo.BatchNotificationOperation.fields = {
      notificationOperation: {
        enumType: exports2.TypeInfo.NotificationOperation
      }
    };
    exports2.TypeInfo.EventBacklogStatus.fields = {
      captureTime: {
        isDate: true
      },
      lastEventBatchStartTime: {
        isDate: true
      },
      lastEventProcessedTime: {
        isDate: true
      },
      lastJobBatchStartTime: {
        isDate: true
      },
      lastJobProcessedTime: {
        isDate: true
      },
      oldestPendingEventTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.EventProcessingLog.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.INotificationDiagnosticLog.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.NotificationAdminSettings.fields = {
      defaultGroupDeliveryPreference: {
        enumType: exports2.TypeInfo.DefaultGroupDeliveryPreference
      }
    };
    exports2.TypeInfo.NotificationAdminSettingsUpdateParameters.fields = {
      defaultGroupDeliveryPreference: {
        enumType: exports2.TypeInfo.DefaultGroupDeliveryPreference
      }
    };
    exports2.TypeInfo.NotificationBacklogStatus.fields = {
      captureTime: {
        isDate: true
      },
      lastJobBatchStartTime: {
        isDate: true
      },
      lastJobProcessedTime: {
        isDate: true
      },
      lastNotificationBatchStartTime: {
        isDate: true
      },
      lastNotificationProcessedTime: {
        isDate: true
      },
      oldestPendingNotificationTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.NotificationDeliveryLog.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.NotificationDiagnosticLog.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.NotificationEventBacklogStatus.fields = {
      eventBacklogStatus: {
        isArray: true,
        typeInfo: exports2.TypeInfo.EventBacklogStatus
      },
      notificationBacklogStatus: {
        isArray: true,
        typeInfo: exports2.TypeInfo.NotificationBacklogStatus
      }
    };
    exports2.TypeInfo.NotificationEventField.fields = {
      fieldType: {
        typeInfo: exports2.TypeInfo.NotificationEventFieldType
      }
    };
    exports2.TypeInfo.NotificationEventFieldType.fields = {
      subscriptionFieldType: {
        enumType: exports2.TypeInfo.SubscriptionFieldType
      }
    };
    exports2.TypeInfo.NotificationEventType.fields = {
      fields: {
        isDictionary: true,
        dictionaryValueTypeInfo: exports2.TypeInfo.NotificationEventField
      }
    };
    exports2.TypeInfo.NotificationJobDiagnosticLog.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.NotificationReason.fields = {
      notificationReasonType: {
        enumType: exports2.TypeInfo.NotificationReasonType
      }
    };
    exports2.TypeInfo.NotificationStatistic.fields = {
      date: {
        isDate: true
      },
      type: {
        enumType: exports2.TypeInfo.NotificationStatisticType
      }
    };
    exports2.TypeInfo.NotificationStatisticsQuery.fields = {
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.NotificationStatisticsQueryConditions
      }
    };
    exports2.TypeInfo.NotificationStatisticsQueryConditions.fields = {
      endDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      },
      type: {
        enumType: exports2.TypeInfo.NotificationStatisticType
      }
    };
    exports2.TypeInfo.NotificationSubscriber.fields = {
      deliveryPreference: {
        enumType: exports2.TypeInfo.NotificationSubscriberDeliveryPreference
      },
      flags: {
        enumType: exports2.TypeInfo.SubscriberFlags
      }
    };
    exports2.TypeInfo.NotificationSubscriberUpdateParameters.fields = {
      deliveryPreference: {
        enumType: exports2.TypeInfo.NotificationSubscriberDeliveryPreference
      }
    };
    exports2.TypeInfo.NotificationSubscription.fields = {
      diagnostics: {
        typeInfo: exports2.TypeInfo.SubscriptionDiagnostics
      },
      flags: {
        enumType: exports2.TypeInfo.SubscriptionFlags
      },
      modifiedDate: {
        isDate: true
      },
      permissions: {
        enumType: exports2.TypeInfo.SubscriptionPermissions
      },
      status: {
        enumType: exports2.TypeInfo.SubscriptionStatus
      }
    };
    exports2.TypeInfo.NotificationSubscriptionTemplate.fields = {
      notificationEventInformation: {
        typeInfo: exports2.TypeInfo.NotificationEventType
      },
      type: {
        enumType: exports2.TypeInfo.SubscriptionTemplateType
      }
    };
    exports2.TypeInfo.NotificationSubscriptionUpdateParameters.fields = {
      status: {
        enumType: exports2.TypeInfo.SubscriptionStatus
      }
    };
    exports2.TypeInfo.SubscriptionDiagnostics.fields = {
      deliveryResults: {
        typeInfo: exports2.TypeInfo.SubscriptionTracing
      },
      deliveryTracing: {
        typeInfo: exports2.TypeInfo.SubscriptionTracing
      },
      evaluationTracing: {
        typeInfo: exports2.TypeInfo.SubscriptionTracing
      }
    };
    exports2.TypeInfo.SubscriptionEvaluationRequest.fields = {
      minEventsCreatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.SubscriptionEvaluationResult.fields = {
      evaluationJobStatus: {
        enumType: exports2.TypeInfo.EvaluationOperationStatus
      }
    };
    exports2.TypeInfo.SubscriptionQuery.fields = {
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.SubscriptionQueryCondition
      },
      queryFlags: {
        enumType: exports2.TypeInfo.SubscriptionQueryFlags
      }
    };
    exports2.TypeInfo.SubscriptionQueryCondition.fields = {
      flags: {
        enumType: exports2.TypeInfo.SubscriptionFlags
      }
    };
    exports2.TypeInfo.SubscriptionTraceDiagnosticLog.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.SubscriptionTraceEventProcessingLog.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.SubscriptionTraceNotificationDeliveryLog.fields = {
      endTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.SubscriptionTracing.fields = {
      endDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/NotificationApi.js
var require_NotificationApi = __commonJS({
  "../node_modules/azure-devops-node-api/NotificationApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NotificationApi = void 0;
    var basem = require_ClientApiBases();
    var NotificationInterfaces = require_NotificationInterfaces();
    var VSSInterfaces = require_VSSInterfaces();
    var NotificationApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Notification-api", options);
      }
      /**
       * @param {NotificationInterfaces.BatchNotificationOperation} operation
       */
      performBatchNotificationOperations(operation) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "8f3c6ab2-5bae-4537-b16e-f84e0955599e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, operation, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of diagnostic logs for this service.
       *
       * @param {string} source - ID specifying which type of logs to check diagnostics for.
       * @param {string} entryId - The ID of the specific log to query for.
       * @param {Date} startTime - Start time for the time range to query in.
       * @param {Date} endTime - End time for the time range to query in.
       */
      listLogs(source, entryId, startTime, endTime) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              source,
              entryId
            };
            let queryValues = {
              startTime,
              endTime
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "991842f3-eb16-4aea-ac81-81353ef2b75c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.INotificationDiagnosticLog, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the diagnostics settings for a subscription.
       *
       * @param {string} subscriptionId - The id of the notifications subscription.
       */
      getSubscriptionDiagnostics(subscriptionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              subscriptionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "20f1929d-4be7-4c2e-a74e-d47640ff3418", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.SubscriptionDiagnostics, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the diagnostics settings for a subscription.
       *
       * @param {NotificationInterfaces.UpdateSubscripitonDiagnosticsParameters} updateParameters
       * @param {string} subscriptionId - The id of the notifications subscription.
       */
      updateSubscriptionDiagnostics(updateParameters, subscriptionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              subscriptionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "20f1929d-4be7-4c2e-a74e-d47640ff3418", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, updateParameters, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.SubscriptionDiagnostics, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Publish an event. This request must be directed to the service "extmgmt".
       *
       * @param {VSSInterfaces.VssNotificationEvent} notificationEvent
       */
      publishEvent(notificationEvent) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "14c57b7a-c0e6-4555-9f51-e067188fdd8e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, notificationEvent, options);
              let ret = this.formatResponse(res.result, VSSInterfaces.TypeInfo.VssNotificationEvent, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Tranform a notification event.
       *
       * @param {NotificationInterfaces.EventTransformRequest} transformRequest - Object to be transformed.
       */
      transformEvent(transformRequest) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "9463a800-1b44-450e-9083-f948ea174b45", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, transformRequest, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NotificationInterfaces.FieldValuesQuery} inputValuesQuery
       * @param {string} eventType
       */
      queryEventTypes(inputValuesQuery, eventType) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              eventType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "b5bbdd21-c178-4398-b6db-0166d910028a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, inputValuesQuery, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationEventField, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a specific event type.
       *
       * @param {string} eventType - The ID of the event type.
       */
      getEventType(eventType) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              eventType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "cc84fb5f-6247-4c7a-aeae-e5a3c3fddb21", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationEventType, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * List available event types for this service. Optionally filter by only event types for the specified publisher.
       *
       * @param {string} publisherId - Limit to event types for this publisher
       */
      listEventTypes(publisherId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              publisherId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "cc84fb5f-6247-4c7a-aeae-e5a3c3fddb21", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationEventType, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} notificationId
       */
      getNotificationReasons(notificationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              notificationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "19824fa9-1c76-40e6-9cce-cf0b9ca1cb60", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationReason, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} notificationIds
       */
      listNotificationReasons(notificationIds) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              notificationIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "19824fa9-1c76-40e6-9cce-cf0b9ca1cb60", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationReason, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       */
      getSettings() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "cbe076d8-2803-45ff-8d8d-44653686ea2a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationAdminSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NotificationInterfaces.NotificationAdminSettingsUpdateParameters} updateParameters
       */
      updateSettings(updateParameters) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "cbe076d8-2803-45ff-8d8d-44653686ea2a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateParameters, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationAdminSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get delivery preferences of a notifications subscriber.
       *
       * @param {string} subscriberId - ID of the user or group.
       */
      getSubscriber(subscriberId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              subscriberId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "4d5caff1-25ba-430b-b808-7a1f352cc197", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationSubscriber, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update delivery preferences of a notifications subscriber.
       *
       * @param {NotificationInterfaces.NotificationSubscriberUpdateParameters} updateParameters
       * @param {string} subscriberId - ID of the user or group.
       */
      updateSubscriber(updateParameters, subscriberId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              subscriberId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "4d5caff1-25ba-430b-b808-7a1f352cc197", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateParameters, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationSubscriber, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Query for subscriptions. A subscription is returned if it matches one or more of the specified conditions.
       *
       * @param {NotificationInterfaces.SubscriptionQuery} subscriptionQuery
       */
      querySubscriptions(subscriptionQuery) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "6864db85-08c0-4006-8e8e-cc1bebe31675", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, subscriptionQuery, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationSubscription, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a new subscription.
       *
       * @param {NotificationInterfaces.NotificationSubscriptionCreateParameters} createParameters
       */
      createSubscription(createParameters) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "70f911d6-abac-488c-85b3-a206bf57e165", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, createParameters, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationSubscription, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a subscription.
       *
       * @param {string} subscriptionId
       */
      deleteSubscription(subscriptionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              subscriptionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "70f911d6-abac-488c-85b3-a206bf57e165", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a notification subscription by its ID.
       *
       * @param {string} subscriptionId
       * @param {NotificationInterfaces.SubscriptionQueryFlags} queryFlags
       */
      getSubscription(subscriptionId, queryFlags) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              subscriptionId
            };
            let queryValues = {
              queryFlags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "70f911d6-abac-488c-85b3-a206bf57e165", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationSubscription, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of notification subscriptions, either by subscription IDs or by all subscriptions for a given user or group.
       *
       * @param {string} targetId - User or Group ID
       * @param {string[]} ids - List of subscription IDs
       * @param {NotificationInterfaces.SubscriptionQueryFlags} queryFlags
       */
      listSubscriptions(targetId, ids, queryFlags) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              targetId,
              ids: ids && ids.join(","),
              queryFlags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "70f911d6-abac-488c-85b3-a206bf57e165", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationSubscription, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update an existing subscription. Depending on the type of subscription and permissions, the caller can update the description, filter settings, channel (delivery) settings and more.
       *
       * @param {NotificationInterfaces.NotificationSubscriptionUpdateParameters} updateParameters
       * @param {string} subscriptionId
       */
      updateSubscription(updateParameters, subscriptionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              subscriptionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "70f911d6-abac-488c-85b3-a206bf57e165", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateParameters, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationSubscription, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get available subscription templates.
       *
       */
      getSubscriptionTemplates() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "fa5d24ba-7484-4f3d-888d-4ec6b1974082", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, NotificationInterfaces.TypeInfo.NotificationSubscriptionTemplate, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Publish an event. This request is only for the Token service since it's a deploy only service.
       *
       * @param {VSSInterfaces.VssNotificationEvent} notificationEvent
       */
      publishTokenEvent(notificationEvent) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "31dc86a2-67e8-4452-99a4-2b301ba28291", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, notificationEvent, options);
              let ret = this.formatResponse(res.result, VSSInterfaces.TypeInfo.VssNotificationEvent, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the specified user's settings for the specified subscription. This API is typically used to opt in or out of a shared subscription. User settings can only be applied to shared subscriptions, like team subscriptions or default subscriptions.
       *
       * @param {NotificationInterfaces.SubscriptionUserSettings} userSettings
       * @param {string} subscriptionId
       * @param {string} userId - ID of the user
       */
      updateSubscriptionUserSettings(userSettings, subscriptionId, userId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              subscriptionId,
              userId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "notification", "ed5a3dff-aeb5-41b1-b4f7-89e66e58b62e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, userSettings, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.NotificationApi = NotificationApi;
  }
});

// ../node_modules/azure-devops-node-api/PolicyApi.js
var require_PolicyApi = __commonJS({
  "../node_modules/azure-devops-node-api/PolicyApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PolicyApi = void 0;
    var basem = require_ClientApiBases();
    var PolicyInterfaces = require_PolicyInterfaces();
    var PolicyApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Policy-api", options);
      }
      /**
       * Create a policy configuration of a given policy type.
       *
       * @param {PolicyInterfaces.PolicyConfiguration} configuration - The policy configuration to create.
       * @param {string} project - Project ID or project name
       */
      createPolicyConfiguration(configuration, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "dad91cbe-d183-45f8-9c6e-9c1164472121", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, configuration, options);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a policy configuration by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} configurationId - ID of the policy configuration to delete.
       */
      deletePolicyConfiguration(project, configurationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              configurationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "dad91cbe-d183-45f8-9c6e-9c1164472121", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a policy configuration by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} configurationId - ID of the policy configuration
       */
      getPolicyConfiguration(project, configurationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              configurationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "dad91cbe-d183-45f8-9c6e-9c1164472121", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of policy configurations in a project.
       *
       * @param {string} project - Project ID or project name
       * @param {string} scope - [Provided for legacy reasons] The scope on which a subset of policies is defined.
       * @param {string} policyType - Filter returned policies to only this type
       */
      getPolicyConfigurations(project, scope, policyType) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              scope,
              policyType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "dad91cbe-d183-45f8-9c6e-9c1164472121", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyConfiguration, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a policy configuration by its ID.
       *
       * @param {PolicyInterfaces.PolicyConfiguration} configuration - The policy configuration to update.
       * @param {string} project - Project ID or project name
       * @param {number} configurationId - ID of the existing policy configuration to be updated.
       */
      updatePolicyConfiguration(configuration, project, configurationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              configurationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "dad91cbe-d183-45f8-9c6e-9c1164472121", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, configuration, options);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the present evaluation state of a policy.
       *
       * @param {string} project - Project ID or project name
       * @param {string} evaluationId - ID of the policy evaluation to be retrieved.
       */
      getPolicyEvaluation(project, evaluationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              evaluationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "46aecb7a-5d2c-4647-897b-0209505a9fe4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyEvaluationRecord, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Requeue the policy evaluation.
       *
       * @param {string} project - Project ID or project name
       * @param {string} evaluationId - ID of the policy evaluation to be retrieved.
       */
      requeuePolicyEvaluation(project, evaluationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              evaluationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "46aecb7a-5d2c-4647-897b-0209505a9fe4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, null, options);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyEvaluationRecord, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves a list of all the policy evaluation statuses for a specific pull request.
       *
       * @param {string} project - Project ID or project name
       * @param {string} artifactId - A string which uniquely identifies the target of a policy evaluation.
       * @param {boolean} includeNotApplicable - Some policies might determine that they do not apply to a specific pull request. Setting this parameter to true will return evaluation records even for policies which don't apply to this pull request.
       * @param {number} top - The number of policy evaluation records to retrieve.
       * @param {number} skip - The number of policy evaluation records to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100.
       */
      getPolicyEvaluations(project, artifactId, includeNotApplicable, top, skip) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (artifactId == null) {
            throw new TypeError("artifactId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              artifactId,
              includeNotApplicable,
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "c23ddff5-229c-4d04-a80b-0fdce9f360c8", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyEvaluationRecord, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a specific revision of a given policy by ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} configurationId - The policy configuration ID.
       * @param {number} revisionId - The revision ID.
       */
      getPolicyConfigurationRevision(project, configurationId, revisionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              configurationId,
              revisionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "fe1e68a2-60d3-43cb-855b-85e41ae97c95", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all revisions for a given policy.
       *
       * @param {string} project - Project ID or project name
       * @param {number} configurationId - The policy configuration ID.
       * @param {number} top - The number of revisions to retrieve.
       * @param {number} skip - The number of revisions to ignore. For example, to retrieve results 101-150, set top to 50 and skip to 100.
       */
      getPolicyConfigurationRevisions(project, configurationId, top, skip) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              configurationId
            };
            let queryValues = {
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "fe1e68a2-60d3-43cb-855b-85e41ae97c95", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, PolicyInterfaces.TypeInfo.PolicyConfiguration, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a specific policy type by ID.
       *
       * @param {string} project - Project ID or project name
       * @param {string} typeId - The policy ID.
       */
      getPolicyType(project, typeId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              typeId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "44096322-2d3d-466a-bb30-d1b7de69f61f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve all available policy types.
       *
       * @param {string} project - Project ID or project name
       */
      getPolicyTypes(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "policy", "44096322-2d3d-466a-bb30-d1b7de69f61f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.PolicyApi = PolicyApi;
    PolicyApi.RESOURCE_AREA_ID = "fb13a388-40dd-4a04-b530-013a739c72ef";
  }
});

// ../node_modules/azure-devops-node-api/interfaces/ProfileInterfaces.js
var require_ProfileInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/ProfileInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.AvatarSize = void 0;
    var AvatarSize;
    (function(AvatarSize2) {
      AvatarSize2[AvatarSize2["Small"] = 0] = "Small";
      AvatarSize2[AvatarSize2["Medium"] = 1] = "Medium";
      AvatarSize2[AvatarSize2["Large"] = 2] = "Large";
    })(AvatarSize = exports2.AvatarSize || (exports2.AvatarSize = {}));
    exports2.TypeInfo = {
      AttributeDescriptor: {
        fields: null
      },
      AttributesContainer: {
        fields: null
      },
      Avatar: {
        fields: null
      },
      AvatarSize: {
        enumValues: {
          "small": 0,
          "medium": 1,
          "large": 2
        }
      },
      CoreProfileAttribute: {
        fields: null
      },
      Country: {
        fields: null
      },
      CreateProfileContext: {
        fields: null
      },
      GeoRegion: {
        fields: null
      },
      Profile: {
        fields: null
      },
      ProfileAttribute: {
        fields: null
      },
      ProfileAttributeBase: {
        fields: null
      },
      ProfileRegion: {
        fields: null
      },
      ProfileRegions: {
        fields: null
      }
    };
    exports2.TypeInfo.AttributeDescriptor.fields = {};
    exports2.TypeInfo.AttributesContainer.fields = {
      attributes: {}
    };
    exports2.TypeInfo.Avatar.fields = {
      size: {
        enumType: exports2.TypeInfo.AvatarSize
      },
      timeStamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.CoreProfileAttribute.fields = {
      descriptor: {
        typeInfo: exports2.TypeInfo.AttributeDescriptor
      },
      timeStamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.Country.fields = {};
    exports2.TypeInfo.CreateProfileContext.fields = {};
    exports2.TypeInfo.GeoRegion.fields = {};
    exports2.TypeInfo.Profile.fields = {
      applicationContainer: {
        typeInfo: exports2.TypeInfo.AttributesContainer
      },
      coreAttributes: {},
      timeStamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.ProfileAttribute.fields = {
      descriptor: {
        typeInfo: exports2.TypeInfo.AttributeDescriptor
      },
      timeStamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.ProfileAttributeBase.fields = {
      descriptor: {
        typeInfo: exports2.TypeInfo.AttributeDescriptor
      },
      timeStamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.ProfileRegion.fields = {};
    exports2.TypeInfo.ProfileRegions.fields = {
      regions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ProfileRegion
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/ProfileApi.js
var require_ProfileApi = __commonJS({
  "../node_modules/azure-devops-node-api/ProfileApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProfileApi = void 0;
    var basem = require_ClientApiBases();
    var ProfileInterfaces = require_ProfileInterfaces();
    var ProfileApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Profile-api", options);
      }
      /**
      * @param {string} id
      * @param {string} descriptor
      */
      deleteProfileAttribute(id, descriptor) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            let queryValues = {
              descriptor
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.2", "Profile", "1392b6ac-d511-492e-af5b-2263e5545a5d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {string} id
      * @param {string} descriptor
      */
      getProfileAttribute(id, descriptor) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            let queryValues = {
              descriptor
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.2", "Profile", "1392b6ac-d511-492e-af5b-2263e5545a5d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ProfileInterfaces.TypeInfo.ProfileAttribute, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {string} id
      * @param {string} partition
      * @param {string} modifiedSince
      * @param {string} modifiedAfterRevision
      * @param {boolean} withCoreAttributes
      * @param {string} coreAttributes
      */
      getProfileAttributes(id, partition, modifiedSince, modifiedAfterRevision, withCoreAttributes, coreAttributes) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            let queryValues = {
              partition,
              modifiedSince,
              modifiedAfterRevision,
              withCoreAttributes,
              coreAttributes
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.2", "Profile", "1392b6ac-d511-492e-af5b-2263e5545a5d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ProfileInterfaces.TypeInfo.ProfileAttribute, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {any} container
      * @param {string} id
      * @param {string} descriptor
      */
      setProfileAttribute(container, id, descriptor) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            let queryValues = {
              descriptor
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.2", "Profile", "1392b6ac-d511-492e-af5b-2263e5545a5d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, container, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {VSSInterfaces.VssJsonCollectionWrapperV<ProfileInterfaces.ProfileAttributeBase<any>[]>} attributesCollection
      * @param {string} id
      */
      setProfileAttributes(attributesCollection, id) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.2", "Profile", "1392b6ac-d511-492e-af5b-2263e5545a5d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, attributesCollection, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {string} id
      * @param {string} size
      * @param {string} format
      */
      getAvatar(id, size2, format) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            let queryValues = {
              size: size2,
              format
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "67436615-b382-462a-b659-5367a492fb3c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ProfileInterfaces.TypeInfo.Avatar, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {any} container
      * @param {string} id
      * @param {string} size
      * @param {string} format
      * @param {string} displayName
      */
      getAvatarPreview(container, id, size2, format, displayName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            let queryValues = {
              size: size2,
              format,
              displayName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "67436615-b382-462a-b659-5367a492fb3c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, container, options);
              let ret = this.formatResponse(res.result, ProfileInterfaces.TypeInfo.Avatar, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {string} id
      */
      resetAvatar(id) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "67436615-b382-462a-b659-5367a492fb3c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {any} container
      * @param {string} id
      */
      setAvatar(container, id) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "67436615-b382-462a-b659-5367a492fb3c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, container, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * Lookup up country/region based on provided IPv4, null if using the remote IPv4 address.
      *
      * @param {string} ipaddress - IPv4 address to be used for reverse lookup, null if using RemoteIPAddress in request context
      */
      getGeoRegion(ipaddress) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              ipaddress
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "3bcda9c0-3078-48a5-a1e0-83bd05931ad0", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * Create profile
      *
      * @param {ProfileInterfaces.CreateProfileContext} createProfileContext - Context for profile creation
      * @param {boolean} autoCreate - Create profile automatically
      */
      createProfile(createProfileContext, autoCreate) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              autoCreate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.3", "Profile", "f83735dc-483f-4238-a291-d45f6080a9af", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, createProfileContext, options);
              let ret = this.formatResponse(res.result, ProfileInterfaces.TypeInfo.Profile, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {string} id
      * @param {boolean} details
      * @param {boolean} withAttributes
      * @param {string} partition
      * @param {string} coreAttributes
      * @param {boolean} forceRefresh
      */
      getProfile(id, details, withAttributes, partition, coreAttributes, forceRefresh) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            let queryValues = {
              details,
              withAttributes,
              partition,
              coreAttributes,
              forceRefresh
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.3", "Profile", "f83735dc-483f-4238-a291-d45f6080a9af", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ProfileInterfaces.TypeInfo.Profile, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * Update profile
      *
      * @param {ProfileInterfaces.Profile} profile - Update profile
      * @param {string} id - Profile ID
      */
      updateProfile(profile, id) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.3", "Profile", "f83735dc-483f-4238-a291-d45f6080a9af", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, profile, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      */
      getRegions() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "92d8d1c9-26b8-4774-a929-d640a73da524", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      */
      getSupportedLcids() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "d5bd1aa6-c269-4bcd-ad32-75fa17475584", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {boolean} includeAvatar
      */
      getUserDefaults(includeAvatar) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              includeAvatar
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "b583a356-1da7-4237-9f4c-1deb2edbc7e8", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ProfileInterfaces.TypeInfo.Profile, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
      * @param {string} id
      */
      refreshUserDefaults(id) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "Profile", "b583a356-1da7-4237-9f4c-1deb2edbc7e8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, options);
              let ret = this.formatResponse(res.result, ProfileInterfaces.TypeInfo.Profile, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.ProfileApi = ProfileApi;
  }
});

// ../node_modules/azure-devops-node-api/interfaces/ProjectAnalysisInterfaces.js
var require_ProjectAnalysisInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/ProjectAnalysisInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.ResultPhase = exports2.AggregationType = void 0;
    var AggregationType;
    (function(AggregationType2) {
      AggregationType2[AggregationType2["Hourly"] = 0] = "Hourly";
      AggregationType2[AggregationType2["Daily"] = 1] = "Daily";
    })(AggregationType = exports2.AggregationType || (exports2.AggregationType = {}));
    var ResultPhase;
    (function(ResultPhase2) {
      ResultPhase2[ResultPhase2["Preliminary"] = 0] = "Preliminary";
      ResultPhase2[ResultPhase2["Full"] = 1] = "Full";
    })(ResultPhase = exports2.ResultPhase || (exports2.ResultPhase = {}));
    exports2.TypeInfo = {
      AggregationType: {
        enumValues: {
          "hourly": 0,
          "daily": 1
        }
      },
      CodeChangeTrendItem: {},
      ProjectActivityMetrics: {},
      ProjectLanguageAnalytics: {},
      RepositoryActivityMetrics: {},
      RepositoryLanguageAnalytics: {},
      ResultPhase: {
        enumValues: {
          "preliminary": 0,
          "full": 1
        }
      }
    };
    exports2.TypeInfo.CodeChangeTrendItem.fields = {
      time: {
        isDate: true
      }
    };
    exports2.TypeInfo.ProjectActivityMetrics.fields = {
      codeChangesTrend: {
        isArray: true,
        typeInfo: exports2.TypeInfo.CodeChangeTrendItem
      }
    };
    exports2.TypeInfo.ProjectLanguageAnalytics.fields = {
      repositoryLanguageAnalytics: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RepositoryLanguageAnalytics
      },
      resultPhase: {
        enumType: exports2.TypeInfo.ResultPhase
      }
    };
    exports2.TypeInfo.RepositoryActivityMetrics.fields = {
      codeChangesTrend: {
        isArray: true,
        typeInfo: exports2.TypeInfo.CodeChangeTrendItem
      }
    };
    exports2.TypeInfo.RepositoryLanguageAnalytics.fields = {
      resultPhase: {
        enumType: exports2.TypeInfo.ResultPhase
      },
      updatedTime: {
        isDate: true
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/ProjectAnalysisApi.js
var require_ProjectAnalysisApi = __commonJS({
  "../node_modules/azure-devops-node-api/ProjectAnalysisApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ProjectAnalysisApi = void 0;
    var basem = require_ClientApiBases();
    var ProjectAnalysisInterfaces = require_ProjectAnalysisInterfaces();
    var ProjectAnalysisApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-ProjectAnalysis-api", options);
      }
      /**
       * @param {string} project - Project ID or project name
       */
      getProjectLanguageAnalytics(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "projectanalysis", "5b02a779-1867-433f-90b7-d23ed5e33e57", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ProjectAnalysisInterfaces.TypeInfo.ProjectLanguageAnalytics, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {Date} fromDate
       * @param {ProjectAnalysisInterfaces.AggregationType} aggregationType
       */
      getProjectActivityMetrics(project, fromDate, aggregationType) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (fromDate == null) {
            throw new TypeError("fromDate can not be null or undefined");
          }
          if (aggregationType == null) {
            throw new TypeError("aggregationType can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              fromDate,
              aggregationType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "projectanalysis", "e40ae584-9ea6-4f06-a7c7-6284651b466b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ProjectAnalysisInterfaces.TypeInfo.ProjectActivityMetrics, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves git activity metrics for repositories matching a specified criteria.
       *
       * @param {string} project - Project ID or project name
       * @param {Date} fromDate - Date from which, the trends are to be fetched.
       * @param {ProjectAnalysisInterfaces.AggregationType} aggregationType - Bucket size on which, trends are to be aggregated.
       * @param {number} skip - The number of repositories to ignore.
       * @param {number} top - The number of repositories for which activity metrics are to be retrieved.
       */
      getGitRepositoriesActivityMetrics(project, fromDate, aggregationType, skip, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (fromDate == null) {
            throw new TypeError("fromDate can not be null or undefined");
          }
          if (aggregationType == null) {
            throw new TypeError("aggregationType can not be null or undefined");
          }
          if (skip == null) {
            throw new TypeError("skip can not be null or undefined");
          }
          if (top == null) {
            throw new TypeError("top can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              fromDate,
              aggregationType,
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "projectanalysis", "df7fbbca-630a-40e3-8aa3-7a3faf66947e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ProjectAnalysisInterfaces.TypeInfo.RepositoryActivityMetrics, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} repositoryId
       * @param {Date} fromDate
       * @param {ProjectAnalysisInterfaces.AggregationType} aggregationType
       */
      getRepositoryActivityMetrics(project, repositoryId, fromDate, aggregationType) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (fromDate == null) {
            throw new TypeError("fromDate can not be null or undefined");
          }
          if (aggregationType == null) {
            throw new TypeError("aggregationType can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              repositoryId
            };
            let queryValues = {
              fromDate,
              aggregationType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "projectanalysis", "df7fbbca-630a-40e3-8aa3-7a3faf66947e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ProjectAnalysisInterfaces.TypeInfo.RepositoryActivityMetrics, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.ProjectAnalysisApi = ProjectAnalysisApi;
    ProjectAnalysisApi.RESOURCE_AREA_ID = "7658fa33-b1bf-4580-990f-fac5896773d3";
  }
});

// ../node_modules/azure-devops-node-api/interfaces/common/FormInputInterfaces.js
var require_FormInputInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/common/FormInputInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.InputMode = exports2.InputFilterOperator = exports2.InputDataType = void 0;
    var InputDataType;
    (function(InputDataType2) {
      InputDataType2[InputDataType2["None"] = 0] = "None";
      InputDataType2[InputDataType2["String"] = 10] = "String";
      InputDataType2[InputDataType2["Number"] = 20] = "Number";
      InputDataType2[InputDataType2["Boolean"] = 30] = "Boolean";
      InputDataType2[InputDataType2["Guid"] = 40] = "Guid";
      InputDataType2[InputDataType2["Uri"] = 50] = "Uri";
    })(InputDataType = exports2.InputDataType || (exports2.InputDataType = {}));
    var InputFilterOperator;
    (function(InputFilterOperator2) {
      InputFilterOperator2[InputFilterOperator2["Equals"] = 0] = "Equals";
      InputFilterOperator2[InputFilterOperator2["NotEquals"] = 1] = "NotEquals";
    })(InputFilterOperator = exports2.InputFilterOperator || (exports2.InputFilterOperator = {}));
    var InputMode;
    (function(InputMode2) {
      InputMode2[InputMode2["None"] = 0] = "None";
      InputMode2[InputMode2["TextBox"] = 10] = "TextBox";
      InputMode2[InputMode2["PasswordBox"] = 20] = "PasswordBox";
      InputMode2[InputMode2["Combo"] = 30] = "Combo";
      InputMode2[InputMode2["RadioButtons"] = 40] = "RadioButtons";
      InputMode2[InputMode2["CheckBox"] = 50] = "CheckBox";
      InputMode2[InputMode2["TextArea"] = 60] = "TextArea";
    })(InputMode = exports2.InputMode || (exports2.InputMode = {}));
    exports2.TypeInfo = {
      InputDataType: {
        enumValues: {
          "none": 0,
          "string": 10,
          "number": 20,
          "boolean": 30,
          "guid": 40,
          "uri": 50
        }
      },
      InputDescriptor: {
        fields: null
      },
      InputFilter: {
        fields: null
      },
      InputFilterCondition: {
        fields: null
      },
      InputFilterOperator: {
        enumValues: {
          "equals": 0,
          "notEquals": 1
        }
      },
      InputMode: {
        enumValues: {
          "none": 0,
          "textBox": 10,
          "passwordBox": 20,
          "combo": 30,
          "radioButtons": 40,
          "checkBox": 50,
          "textArea": 60
        }
      },
      InputValidation: {
        fields: null
      },
      InputValue: {
        fields: null
      },
      InputValues: {
        fields: null
      },
      InputValuesError: {
        fields: null
      },
      InputValuesQuery: {
        fields: null
      }
    };
    exports2.TypeInfo.InputDescriptor.fields = {
      inputMode: {
        enumType: exports2.TypeInfo.InputMode
      },
      validation: {
        typeInfo: exports2.TypeInfo.InputValidation
      },
      values: {
        typeInfo: exports2.TypeInfo.InputValues
      }
    };
    exports2.TypeInfo.InputFilter.fields = {
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.InputFilterCondition
      }
    };
    exports2.TypeInfo.InputFilterCondition.fields = {
      operator: {
        enumType: exports2.TypeInfo.InputFilterOperator
      }
    };
    exports2.TypeInfo.InputValidation.fields = {
      dataType: {
        enumType: exports2.TypeInfo.InputDataType
      }
    };
    exports2.TypeInfo.InputValue.fields = {};
    exports2.TypeInfo.InputValues.fields = {
      error: {
        typeInfo: exports2.TypeInfo.InputValuesError
      },
      possibleValues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.InputValue
      }
    };
    exports2.TypeInfo.InputValuesError.fields = {};
    exports2.TypeInfo.InputValuesQuery.fields = {
      inputValues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.InputValues
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/interfaces/ReleaseInterfaces.js
var require_ReleaseInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/ReleaseInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.YamlFileSourceTypes = exports2.VariableGroupActionFilter = exports2.TaskStatus = exports2.SingleReleaseExpands = exports2.SenderType = exports2.ScheduleDays = exports2.ReleaseTriggerType = exports2.ReleaseStatus = exports2.ReleaseReason = exports2.ReleaseQueryOrder = exports2.ReleaseExpands = exports2.ReleaseEnvironmentExpands = exports2.ReleaseDefinitionSource = exports2.ReleaseDefinitionQueryOrder = exports2.ReleaseDefinitionExpands = exports2.PullRequestSystemType = exports2.PropertySelectorType = exports2.PipelineProcessTypes = exports2.ParallelExecutionTypes = exports2.ManualInterventionStatus = exports2.MailSectionType = exports2.IssueSource = exports2.GateStatus = exports2.FolderPathQueryOrder = exports2.EnvironmentTriggerType = exports2.EnvironmentStatus = exports2.DeployPhaseTypes = exports2.DeployPhaseStatus = exports2.DeploymentStatus = exports2.DeploymentsQueryType = exports2.DeploymentReason = exports2.DeploymentOperationStatus = exports2.DeploymentExpands = exports2.DeploymentAuthorizationOwner = exports2.ConditionType = exports2.AuthorizationHeaderFor = exports2.AuditAction = exports2.ApprovalType = exports2.ApprovalStatus = exports2.ApprovalFilters = exports2.ApprovalExecutionOrder = exports2.AgentArtifactType = void 0;
    var FormInputInterfaces = require_FormInputInterfaces();
    var AgentArtifactType;
    (function(AgentArtifactType2) {
      AgentArtifactType2[AgentArtifactType2["XamlBuild"] = 0] = "XamlBuild";
      AgentArtifactType2[AgentArtifactType2["Build"] = 1] = "Build";
      AgentArtifactType2[AgentArtifactType2["Jenkins"] = 2] = "Jenkins";
      AgentArtifactType2[AgentArtifactType2["FileShare"] = 3] = "FileShare";
      AgentArtifactType2[AgentArtifactType2["Nuget"] = 4] = "Nuget";
      AgentArtifactType2[AgentArtifactType2["TfsOnPrem"] = 5] = "TfsOnPrem";
      AgentArtifactType2[AgentArtifactType2["GitHub"] = 6] = "GitHub";
      AgentArtifactType2[AgentArtifactType2["TFGit"] = 7] = "TFGit";
      AgentArtifactType2[AgentArtifactType2["ExternalTfsBuild"] = 8] = "ExternalTfsBuild";
      AgentArtifactType2[AgentArtifactType2["Custom"] = 9] = "Custom";
      AgentArtifactType2[AgentArtifactType2["Tfvc"] = 10] = "Tfvc";
    })(AgentArtifactType = exports2.AgentArtifactType || (exports2.AgentArtifactType = {}));
    var ApprovalExecutionOrder;
    (function(ApprovalExecutionOrder2) {
      ApprovalExecutionOrder2[ApprovalExecutionOrder2["BeforeGates"] = 1] = "BeforeGates";
      ApprovalExecutionOrder2[ApprovalExecutionOrder2["AfterSuccessfulGates"] = 2] = "AfterSuccessfulGates";
      ApprovalExecutionOrder2[ApprovalExecutionOrder2["AfterGatesAlways"] = 4] = "AfterGatesAlways";
    })(ApprovalExecutionOrder = exports2.ApprovalExecutionOrder || (exports2.ApprovalExecutionOrder = {}));
    var ApprovalFilters;
    (function(ApprovalFilters2) {
      ApprovalFilters2[ApprovalFilters2["None"] = 0] = "None";
      ApprovalFilters2[ApprovalFilters2["ManualApprovals"] = 1] = "ManualApprovals";
      ApprovalFilters2[ApprovalFilters2["AutomatedApprovals"] = 2] = "AutomatedApprovals";
      ApprovalFilters2[ApprovalFilters2["ApprovalSnapshots"] = 4] = "ApprovalSnapshots";
      ApprovalFilters2[ApprovalFilters2["All"] = 7] = "All";
    })(ApprovalFilters = exports2.ApprovalFilters || (exports2.ApprovalFilters = {}));
    var ApprovalStatus;
    (function(ApprovalStatus2) {
      ApprovalStatus2[ApprovalStatus2["Undefined"] = 0] = "Undefined";
      ApprovalStatus2[ApprovalStatus2["Pending"] = 1] = "Pending";
      ApprovalStatus2[ApprovalStatus2["Approved"] = 2] = "Approved";
      ApprovalStatus2[ApprovalStatus2["Rejected"] = 4] = "Rejected";
      ApprovalStatus2[ApprovalStatus2["Reassigned"] = 6] = "Reassigned";
      ApprovalStatus2[ApprovalStatus2["Canceled"] = 7] = "Canceled";
      ApprovalStatus2[ApprovalStatus2["Skipped"] = 8] = "Skipped";
    })(ApprovalStatus = exports2.ApprovalStatus || (exports2.ApprovalStatus = {}));
    var ApprovalType;
    (function(ApprovalType2) {
      ApprovalType2[ApprovalType2["Undefined"] = 0] = "Undefined";
      ApprovalType2[ApprovalType2["PreDeploy"] = 1] = "PreDeploy";
      ApprovalType2[ApprovalType2["PostDeploy"] = 2] = "PostDeploy";
      ApprovalType2[ApprovalType2["All"] = 3] = "All";
    })(ApprovalType = exports2.ApprovalType || (exports2.ApprovalType = {}));
    var AuditAction;
    (function(AuditAction2) {
      AuditAction2[AuditAction2["Add"] = 1] = "Add";
      AuditAction2[AuditAction2["Update"] = 2] = "Update";
      AuditAction2[AuditAction2["Delete"] = 3] = "Delete";
      AuditAction2[AuditAction2["Undelete"] = 4] = "Undelete";
    })(AuditAction = exports2.AuditAction || (exports2.AuditAction = {}));
    var AuthorizationHeaderFor;
    (function(AuthorizationHeaderFor2) {
      AuthorizationHeaderFor2[AuthorizationHeaderFor2["RevalidateApproverIdentity"] = 0] = "RevalidateApproverIdentity";
      AuthorizationHeaderFor2[AuthorizationHeaderFor2["OnBehalfOf"] = 1] = "OnBehalfOf";
    })(AuthorizationHeaderFor = exports2.AuthorizationHeaderFor || (exports2.AuthorizationHeaderFor = {}));
    var ConditionType;
    (function(ConditionType2) {
      ConditionType2[ConditionType2["Undefined"] = 0] = "Undefined";
      ConditionType2[ConditionType2["Event"] = 1] = "Event";
      ConditionType2[ConditionType2["EnvironmentState"] = 2] = "EnvironmentState";
      ConditionType2[ConditionType2["Artifact"] = 4] = "Artifact";
    })(ConditionType = exports2.ConditionType || (exports2.ConditionType = {}));
    var DeploymentAuthorizationOwner;
    (function(DeploymentAuthorizationOwner2) {
      DeploymentAuthorizationOwner2[DeploymentAuthorizationOwner2["Automatic"] = 0] = "Automatic";
      DeploymentAuthorizationOwner2[DeploymentAuthorizationOwner2["DeploymentSubmitter"] = 1] = "DeploymentSubmitter";
      DeploymentAuthorizationOwner2[DeploymentAuthorizationOwner2["FirstPreDeploymentApprover"] = 2] = "FirstPreDeploymentApprover";
    })(DeploymentAuthorizationOwner = exports2.DeploymentAuthorizationOwner || (exports2.DeploymentAuthorizationOwner = {}));
    var DeploymentExpands;
    (function(DeploymentExpands2) {
      DeploymentExpands2[DeploymentExpands2["All"] = 0] = "All";
      DeploymentExpands2[DeploymentExpands2["DeploymentOnly"] = 1] = "DeploymentOnly";
      DeploymentExpands2[DeploymentExpands2["Approvals"] = 2] = "Approvals";
      DeploymentExpands2[DeploymentExpands2["Artifacts"] = 4] = "Artifacts";
    })(DeploymentExpands = exports2.DeploymentExpands || (exports2.DeploymentExpands = {}));
    var DeploymentOperationStatus;
    (function(DeploymentOperationStatus2) {
      DeploymentOperationStatus2[DeploymentOperationStatus2["Undefined"] = 0] = "Undefined";
      DeploymentOperationStatus2[DeploymentOperationStatus2["Queued"] = 1] = "Queued";
      DeploymentOperationStatus2[DeploymentOperationStatus2["Scheduled"] = 2] = "Scheduled";
      DeploymentOperationStatus2[DeploymentOperationStatus2["Pending"] = 4] = "Pending";
      DeploymentOperationStatus2[DeploymentOperationStatus2["Approved"] = 8] = "Approved";
      DeploymentOperationStatus2[DeploymentOperationStatus2["Rejected"] = 16] = "Rejected";
      DeploymentOperationStatus2[DeploymentOperationStatus2["Deferred"] = 32] = "Deferred";
      DeploymentOperationStatus2[DeploymentOperationStatus2["QueuedForAgent"] = 64] = "QueuedForAgent";
      DeploymentOperationStatus2[DeploymentOperationStatus2["PhaseInProgress"] = 128] = "PhaseInProgress";
      DeploymentOperationStatus2[DeploymentOperationStatus2["PhaseSucceeded"] = 256] = "PhaseSucceeded";
      DeploymentOperationStatus2[DeploymentOperationStatus2["PhasePartiallySucceeded"] = 512] = "PhasePartiallySucceeded";
      DeploymentOperationStatus2[DeploymentOperationStatus2["PhaseFailed"] = 1024] = "PhaseFailed";
      DeploymentOperationStatus2[DeploymentOperationStatus2["Canceled"] = 2048] = "Canceled";
      DeploymentOperationStatus2[DeploymentOperationStatus2["PhaseCanceled"] = 4096] = "PhaseCanceled";
      DeploymentOperationStatus2[DeploymentOperationStatus2["ManualInterventionPending"] = 8192] = "ManualInterventionPending";
      DeploymentOperationStatus2[DeploymentOperationStatus2["QueuedForPipeline"] = 16384] = "QueuedForPipeline";
      DeploymentOperationStatus2[DeploymentOperationStatus2["Cancelling"] = 32768] = "Cancelling";
      DeploymentOperationStatus2[DeploymentOperationStatus2["EvaluatingGates"] = 65536] = "EvaluatingGates";
      DeploymentOperationStatus2[DeploymentOperationStatus2["GateFailed"] = 131072] = "GateFailed";
      DeploymentOperationStatus2[DeploymentOperationStatus2["All"] = 258047] = "All";
    })(DeploymentOperationStatus = exports2.DeploymentOperationStatus || (exports2.DeploymentOperationStatus = {}));
    var DeploymentReason;
    (function(DeploymentReason2) {
      DeploymentReason2[DeploymentReason2["None"] = 0] = "None";
      DeploymentReason2[DeploymentReason2["Manual"] = 1] = "Manual";
      DeploymentReason2[DeploymentReason2["Automated"] = 2] = "Automated";
      DeploymentReason2[DeploymentReason2["Scheduled"] = 4] = "Scheduled";
      DeploymentReason2[DeploymentReason2["RedeployTrigger"] = 8] = "RedeployTrigger";
    })(DeploymentReason = exports2.DeploymentReason || (exports2.DeploymentReason = {}));
    var DeploymentsQueryType;
    (function(DeploymentsQueryType2) {
      DeploymentsQueryType2[DeploymentsQueryType2["Regular"] = 1] = "Regular";
      DeploymentsQueryType2[DeploymentsQueryType2["FailingSince"] = 2] = "FailingSince";
    })(DeploymentsQueryType = exports2.DeploymentsQueryType || (exports2.DeploymentsQueryType = {}));
    var DeploymentStatus;
    (function(DeploymentStatus2) {
      DeploymentStatus2[DeploymentStatus2["Undefined"] = 0] = "Undefined";
      DeploymentStatus2[DeploymentStatus2["NotDeployed"] = 1] = "NotDeployed";
      DeploymentStatus2[DeploymentStatus2["InProgress"] = 2] = "InProgress";
      DeploymentStatus2[DeploymentStatus2["Succeeded"] = 4] = "Succeeded";
      DeploymentStatus2[DeploymentStatus2["PartiallySucceeded"] = 8] = "PartiallySucceeded";
      DeploymentStatus2[DeploymentStatus2["Failed"] = 16] = "Failed";
      DeploymentStatus2[DeploymentStatus2["All"] = 31] = "All";
    })(DeploymentStatus = exports2.DeploymentStatus || (exports2.DeploymentStatus = {}));
    var DeployPhaseStatus;
    (function(DeployPhaseStatus2) {
      DeployPhaseStatus2[DeployPhaseStatus2["Undefined"] = 0] = "Undefined";
      DeployPhaseStatus2[DeployPhaseStatus2["NotStarted"] = 1] = "NotStarted";
      DeployPhaseStatus2[DeployPhaseStatus2["InProgress"] = 2] = "InProgress";
      DeployPhaseStatus2[DeployPhaseStatus2["PartiallySucceeded"] = 4] = "PartiallySucceeded";
      DeployPhaseStatus2[DeployPhaseStatus2["Succeeded"] = 8] = "Succeeded";
      DeployPhaseStatus2[DeployPhaseStatus2["Failed"] = 16] = "Failed";
      DeployPhaseStatus2[DeployPhaseStatus2["Canceled"] = 32] = "Canceled";
      DeployPhaseStatus2[DeployPhaseStatus2["Skipped"] = 64] = "Skipped";
      DeployPhaseStatus2[DeployPhaseStatus2["Cancelling"] = 128] = "Cancelling";
    })(DeployPhaseStatus = exports2.DeployPhaseStatus || (exports2.DeployPhaseStatus = {}));
    var DeployPhaseTypes;
    (function(DeployPhaseTypes2) {
      DeployPhaseTypes2[DeployPhaseTypes2["Undefined"] = 0] = "Undefined";
      DeployPhaseTypes2[DeployPhaseTypes2["AgentBasedDeployment"] = 1] = "AgentBasedDeployment";
      DeployPhaseTypes2[DeployPhaseTypes2["RunOnServer"] = 2] = "RunOnServer";
      DeployPhaseTypes2[DeployPhaseTypes2["MachineGroupBasedDeployment"] = 4] = "MachineGroupBasedDeployment";
      DeployPhaseTypes2[DeployPhaseTypes2["DeploymentGates"] = 8] = "DeploymentGates";
    })(DeployPhaseTypes = exports2.DeployPhaseTypes || (exports2.DeployPhaseTypes = {}));
    var EnvironmentStatus;
    (function(EnvironmentStatus2) {
      EnvironmentStatus2[EnvironmentStatus2["Undefined"] = 0] = "Undefined";
      EnvironmentStatus2[EnvironmentStatus2["NotStarted"] = 1] = "NotStarted";
      EnvironmentStatus2[EnvironmentStatus2["InProgress"] = 2] = "InProgress";
      EnvironmentStatus2[EnvironmentStatus2["Succeeded"] = 4] = "Succeeded";
      EnvironmentStatus2[EnvironmentStatus2["Canceled"] = 8] = "Canceled";
      EnvironmentStatus2[EnvironmentStatus2["Rejected"] = 16] = "Rejected";
      EnvironmentStatus2[EnvironmentStatus2["Queued"] = 32] = "Queued";
      EnvironmentStatus2[EnvironmentStatus2["Scheduled"] = 64] = "Scheduled";
      EnvironmentStatus2[EnvironmentStatus2["PartiallySucceeded"] = 128] = "PartiallySucceeded";
    })(EnvironmentStatus = exports2.EnvironmentStatus || (exports2.EnvironmentStatus = {}));
    var EnvironmentTriggerType;
    (function(EnvironmentTriggerType2) {
      EnvironmentTriggerType2[EnvironmentTriggerType2["Undefined"] = 0] = "Undefined";
      EnvironmentTriggerType2[EnvironmentTriggerType2["DeploymentGroupRedeploy"] = 1] = "DeploymentGroupRedeploy";
      EnvironmentTriggerType2[EnvironmentTriggerType2["RollbackRedeploy"] = 2] = "RollbackRedeploy";
    })(EnvironmentTriggerType = exports2.EnvironmentTriggerType || (exports2.EnvironmentTriggerType = {}));
    var FolderPathQueryOrder;
    (function(FolderPathQueryOrder2) {
      FolderPathQueryOrder2[FolderPathQueryOrder2["None"] = 0] = "None";
      FolderPathQueryOrder2[FolderPathQueryOrder2["Ascending"] = 1] = "Ascending";
      FolderPathQueryOrder2[FolderPathQueryOrder2["Descending"] = 2] = "Descending";
    })(FolderPathQueryOrder = exports2.FolderPathQueryOrder || (exports2.FolderPathQueryOrder = {}));
    var GateStatus;
    (function(GateStatus2) {
      GateStatus2[GateStatus2["None"] = 0] = "None";
      GateStatus2[GateStatus2["Pending"] = 1] = "Pending";
      GateStatus2[GateStatus2["InProgress"] = 2] = "InProgress";
      GateStatus2[GateStatus2["Succeeded"] = 4] = "Succeeded";
      GateStatus2[GateStatus2["Failed"] = 8] = "Failed";
      GateStatus2[GateStatus2["Canceled"] = 16] = "Canceled";
    })(GateStatus = exports2.GateStatus || (exports2.GateStatus = {}));
    var IssueSource;
    (function(IssueSource2) {
      IssueSource2[IssueSource2["None"] = 0] = "None";
      IssueSource2[IssueSource2["User"] = 1] = "User";
      IssueSource2[IssueSource2["System"] = 2] = "System";
    })(IssueSource = exports2.IssueSource || (exports2.IssueSource = {}));
    var MailSectionType;
    (function(MailSectionType2) {
      MailSectionType2[MailSectionType2["Details"] = 0] = "Details";
      MailSectionType2[MailSectionType2["Environments"] = 1] = "Environments";
      MailSectionType2[MailSectionType2["Issues"] = 2] = "Issues";
      MailSectionType2[MailSectionType2["TestResults"] = 3] = "TestResults";
      MailSectionType2[MailSectionType2["WorkItems"] = 4] = "WorkItems";
      MailSectionType2[MailSectionType2["ReleaseInfo"] = 5] = "ReleaseInfo";
    })(MailSectionType = exports2.MailSectionType || (exports2.MailSectionType = {}));
    var ManualInterventionStatus;
    (function(ManualInterventionStatus2) {
      ManualInterventionStatus2[ManualInterventionStatus2["Unknown"] = 0] = "Unknown";
      ManualInterventionStatus2[ManualInterventionStatus2["Pending"] = 1] = "Pending";
      ManualInterventionStatus2[ManualInterventionStatus2["Rejected"] = 2] = "Rejected";
      ManualInterventionStatus2[ManualInterventionStatus2["Approved"] = 4] = "Approved";
      ManualInterventionStatus2[ManualInterventionStatus2["Canceled"] = 8] = "Canceled";
    })(ManualInterventionStatus = exports2.ManualInterventionStatus || (exports2.ManualInterventionStatus = {}));
    var ParallelExecutionTypes;
    (function(ParallelExecutionTypes2) {
      ParallelExecutionTypes2[ParallelExecutionTypes2["None"] = 0] = "None";
      ParallelExecutionTypes2[ParallelExecutionTypes2["MultiConfiguration"] = 1] = "MultiConfiguration";
      ParallelExecutionTypes2[ParallelExecutionTypes2["MultiMachine"] = 2] = "MultiMachine";
    })(ParallelExecutionTypes = exports2.ParallelExecutionTypes || (exports2.ParallelExecutionTypes = {}));
    var PipelineProcessTypes;
    (function(PipelineProcessTypes2) {
      PipelineProcessTypes2[PipelineProcessTypes2["Designer"] = 1] = "Designer";
      PipelineProcessTypes2[PipelineProcessTypes2["Yaml"] = 2] = "Yaml";
    })(PipelineProcessTypes = exports2.PipelineProcessTypes || (exports2.PipelineProcessTypes = {}));
    var PropertySelectorType;
    (function(PropertySelectorType2) {
      PropertySelectorType2[PropertySelectorType2["Inclusion"] = 0] = "Inclusion";
      PropertySelectorType2[PropertySelectorType2["Exclusion"] = 1] = "Exclusion";
    })(PropertySelectorType = exports2.PropertySelectorType || (exports2.PropertySelectorType = {}));
    var PullRequestSystemType;
    (function(PullRequestSystemType2) {
      PullRequestSystemType2[PullRequestSystemType2["None"] = 0] = "None";
      PullRequestSystemType2[PullRequestSystemType2["TfsGit"] = 1] = "TfsGit";
      PullRequestSystemType2[PullRequestSystemType2["GitHub"] = 2] = "GitHub";
    })(PullRequestSystemType = exports2.PullRequestSystemType || (exports2.PullRequestSystemType = {}));
    var ReleaseDefinitionExpands;
    (function(ReleaseDefinitionExpands2) {
      ReleaseDefinitionExpands2[ReleaseDefinitionExpands2["None"] = 0] = "None";
      ReleaseDefinitionExpands2[ReleaseDefinitionExpands2["Environments"] = 2] = "Environments";
      ReleaseDefinitionExpands2[ReleaseDefinitionExpands2["Artifacts"] = 4] = "Artifacts";
      ReleaseDefinitionExpands2[ReleaseDefinitionExpands2["Triggers"] = 8] = "Triggers";
      ReleaseDefinitionExpands2[ReleaseDefinitionExpands2["Variables"] = 16] = "Variables";
      ReleaseDefinitionExpands2[ReleaseDefinitionExpands2["Tags"] = 32] = "Tags";
      ReleaseDefinitionExpands2[ReleaseDefinitionExpands2["LastRelease"] = 64] = "LastRelease";
    })(ReleaseDefinitionExpands = exports2.ReleaseDefinitionExpands || (exports2.ReleaseDefinitionExpands = {}));
    var ReleaseDefinitionQueryOrder;
    (function(ReleaseDefinitionQueryOrder2) {
      ReleaseDefinitionQueryOrder2[ReleaseDefinitionQueryOrder2["IdAscending"] = 0] = "IdAscending";
      ReleaseDefinitionQueryOrder2[ReleaseDefinitionQueryOrder2["IdDescending"] = 1] = "IdDescending";
      ReleaseDefinitionQueryOrder2[ReleaseDefinitionQueryOrder2["NameAscending"] = 2] = "NameAscending";
      ReleaseDefinitionQueryOrder2[ReleaseDefinitionQueryOrder2["NameDescending"] = 3] = "NameDescending";
    })(ReleaseDefinitionQueryOrder = exports2.ReleaseDefinitionQueryOrder || (exports2.ReleaseDefinitionQueryOrder = {}));
    var ReleaseDefinitionSource;
    (function(ReleaseDefinitionSource2) {
      ReleaseDefinitionSource2[ReleaseDefinitionSource2["Undefined"] = 0] = "Undefined";
      ReleaseDefinitionSource2[ReleaseDefinitionSource2["RestApi"] = 1] = "RestApi";
      ReleaseDefinitionSource2[ReleaseDefinitionSource2["UserInterface"] = 2] = "UserInterface";
      ReleaseDefinitionSource2[ReleaseDefinitionSource2["Ibiza"] = 4] = "Ibiza";
      ReleaseDefinitionSource2[ReleaseDefinitionSource2["PortalExtensionApi"] = 8] = "PortalExtensionApi";
    })(ReleaseDefinitionSource = exports2.ReleaseDefinitionSource || (exports2.ReleaseDefinitionSource = {}));
    var ReleaseEnvironmentExpands;
    (function(ReleaseEnvironmentExpands2) {
      ReleaseEnvironmentExpands2[ReleaseEnvironmentExpands2["None"] = 0] = "None";
      ReleaseEnvironmentExpands2[ReleaseEnvironmentExpands2["Tasks"] = 1] = "Tasks";
    })(ReleaseEnvironmentExpands = exports2.ReleaseEnvironmentExpands || (exports2.ReleaseEnvironmentExpands = {}));
    var ReleaseExpands;
    (function(ReleaseExpands2) {
      ReleaseExpands2[ReleaseExpands2["None"] = 0] = "None";
      ReleaseExpands2[ReleaseExpands2["Environments"] = 2] = "Environments";
      ReleaseExpands2[ReleaseExpands2["Artifacts"] = 4] = "Artifacts";
      ReleaseExpands2[ReleaseExpands2["Approvals"] = 8] = "Approvals";
      ReleaseExpands2[ReleaseExpands2["ManualInterventions"] = 16] = "ManualInterventions";
      ReleaseExpands2[ReleaseExpands2["Variables"] = 32] = "Variables";
      ReleaseExpands2[ReleaseExpands2["Tags"] = 64] = "Tags";
    })(ReleaseExpands = exports2.ReleaseExpands || (exports2.ReleaseExpands = {}));
    var ReleaseQueryOrder;
    (function(ReleaseQueryOrder2) {
      ReleaseQueryOrder2[ReleaseQueryOrder2["Descending"] = 0] = "Descending";
      ReleaseQueryOrder2[ReleaseQueryOrder2["Ascending"] = 1] = "Ascending";
    })(ReleaseQueryOrder = exports2.ReleaseQueryOrder || (exports2.ReleaseQueryOrder = {}));
    var ReleaseReason;
    (function(ReleaseReason2) {
      ReleaseReason2[ReleaseReason2["None"] = 0] = "None";
      ReleaseReason2[ReleaseReason2["Manual"] = 1] = "Manual";
      ReleaseReason2[ReleaseReason2["ContinuousIntegration"] = 2] = "ContinuousIntegration";
      ReleaseReason2[ReleaseReason2["Schedule"] = 3] = "Schedule";
      ReleaseReason2[ReleaseReason2["PullRequest"] = 4] = "PullRequest";
    })(ReleaseReason = exports2.ReleaseReason || (exports2.ReleaseReason = {}));
    var ReleaseStatus;
    (function(ReleaseStatus2) {
      ReleaseStatus2[ReleaseStatus2["Undefined"] = 0] = "Undefined";
      ReleaseStatus2[ReleaseStatus2["Draft"] = 1] = "Draft";
      ReleaseStatus2[ReleaseStatus2["Active"] = 2] = "Active";
      ReleaseStatus2[ReleaseStatus2["Abandoned"] = 4] = "Abandoned";
    })(ReleaseStatus = exports2.ReleaseStatus || (exports2.ReleaseStatus = {}));
    var ReleaseTriggerType;
    (function(ReleaseTriggerType2) {
      ReleaseTriggerType2[ReleaseTriggerType2["Undefined"] = 0] = "Undefined";
      ReleaseTriggerType2[ReleaseTriggerType2["ArtifactSource"] = 1] = "ArtifactSource";
      ReleaseTriggerType2[ReleaseTriggerType2["Schedule"] = 2] = "Schedule";
      ReleaseTriggerType2[ReleaseTriggerType2["SourceRepo"] = 3] = "SourceRepo";
      ReleaseTriggerType2[ReleaseTriggerType2["ContainerImage"] = 4] = "ContainerImage";
      ReleaseTriggerType2[ReleaseTriggerType2["Package"] = 5] = "Package";
      ReleaseTriggerType2[ReleaseTriggerType2["PullRequest"] = 6] = "PullRequest";
    })(ReleaseTriggerType = exports2.ReleaseTriggerType || (exports2.ReleaseTriggerType = {}));
    var ScheduleDays;
    (function(ScheduleDays2) {
      ScheduleDays2[ScheduleDays2["None"] = 0] = "None";
      ScheduleDays2[ScheduleDays2["Monday"] = 1] = "Monday";
      ScheduleDays2[ScheduleDays2["Tuesday"] = 2] = "Tuesday";
      ScheduleDays2[ScheduleDays2["Wednesday"] = 4] = "Wednesday";
      ScheduleDays2[ScheduleDays2["Thursday"] = 8] = "Thursday";
      ScheduleDays2[ScheduleDays2["Friday"] = 16] = "Friday";
      ScheduleDays2[ScheduleDays2["Saturday"] = 32] = "Saturday";
      ScheduleDays2[ScheduleDays2["Sunday"] = 64] = "Sunday";
      ScheduleDays2[ScheduleDays2["All"] = 127] = "All";
    })(ScheduleDays = exports2.ScheduleDays || (exports2.ScheduleDays = {}));
    var SenderType;
    (function(SenderType2) {
      SenderType2[SenderType2["ServiceAccount"] = 1] = "ServiceAccount";
      SenderType2[SenderType2["RequestingUser"] = 2] = "RequestingUser";
    })(SenderType = exports2.SenderType || (exports2.SenderType = {}));
    var SingleReleaseExpands;
    (function(SingleReleaseExpands2) {
      SingleReleaseExpands2[SingleReleaseExpands2["None"] = 0] = "None";
      SingleReleaseExpands2[SingleReleaseExpands2["Tasks"] = 1] = "Tasks";
    })(SingleReleaseExpands = exports2.SingleReleaseExpands || (exports2.SingleReleaseExpands = {}));
    var TaskStatus;
    (function(TaskStatus2) {
      TaskStatus2[TaskStatus2["Unknown"] = 0] = "Unknown";
      TaskStatus2[TaskStatus2["Pending"] = 1] = "Pending";
      TaskStatus2[TaskStatus2["InProgress"] = 2] = "InProgress";
      TaskStatus2[TaskStatus2["Success"] = 3] = "Success";
      TaskStatus2[TaskStatus2["Failure"] = 4] = "Failure";
      TaskStatus2[TaskStatus2["Canceled"] = 5] = "Canceled";
      TaskStatus2[TaskStatus2["Skipped"] = 6] = "Skipped";
      TaskStatus2[TaskStatus2["Succeeded"] = 7] = "Succeeded";
      TaskStatus2[TaskStatus2["Failed"] = 8] = "Failed";
      TaskStatus2[TaskStatus2["PartiallySucceeded"] = 9] = "PartiallySucceeded";
    })(TaskStatus = exports2.TaskStatus || (exports2.TaskStatus = {}));
    var VariableGroupActionFilter;
    (function(VariableGroupActionFilter2) {
      VariableGroupActionFilter2[VariableGroupActionFilter2["None"] = 0] = "None";
      VariableGroupActionFilter2[VariableGroupActionFilter2["Manage"] = 2] = "Manage";
      VariableGroupActionFilter2[VariableGroupActionFilter2["Use"] = 16] = "Use";
    })(VariableGroupActionFilter = exports2.VariableGroupActionFilter || (exports2.VariableGroupActionFilter = {}));
    var YamlFileSourceTypes;
    (function(YamlFileSourceTypes2) {
      YamlFileSourceTypes2[YamlFileSourceTypes2["None"] = 0] = "None";
      YamlFileSourceTypes2[YamlFileSourceTypes2["TFSGit"] = 1] = "TFSGit";
    })(YamlFileSourceTypes = exports2.YamlFileSourceTypes || (exports2.YamlFileSourceTypes = {}));
    exports2.TypeInfo = {
      AgentArtifactDefinition: {},
      AgentArtifactType: {
        enumValues: {
          "xamlBuild": 0,
          "build": 1,
          "jenkins": 2,
          "fileShare": 3,
          "nuget": 4,
          "tfsOnPrem": 5,
          "gitHub": 6,
          "tfGit": 7,
          "externalTfsBuild": 8,
          "custom": 9,
          "tfvc": 10
        }
      },
      AgentBasedDeployPhase: {},
      AgentDeploymentInput: {},
      ApprovalExecutionOrder: {
        enumValues: {
          "beforeGates": 1,
          "afterSuccessfulGates": 2,
          "afterGatesAlways": 4
        }
      },
      ApprovalFilters: {
        enumValues: {
          "none": 0,
          "manualApprovals": 1,
          "automatedApprovals": 2,
          "approvalSnapshots": 4,
          "all": 7
        }
      },
      ApprovalOptions: {},
      ApprovalStatus: {
        enumValues: {
          "undefined": 0,
          "pending": 1,
          "approved": 2,
          "rejected": 4,
          "reassigned": 6,
          "canceled": 7,
          "skipped": 8
        }
      },
      ApprovalType: {
        enumValues: {
          "undefined": 0,
          "preDeploy": 1,
          "postDeploy": 2,
          "all": 3
        }
      },
      ArtifactContributionDefinition: {},
      ArtifactMetadata: {},
      ArtifactSourceTrigger: {},
      ArtifactTypeDefinition: {},
      ArtifactVersion: {},
      ArtifactVersionQueryResult: {},
      AuditAction: {
        enumValues: {
          "add": 1,
          "update": 2,
          "delete": 3,
          "undelete": 4
        }
      },
      AuthorizationHeaderFor: {
        enumValues: {
          "revalidateApproverIdentity": 0,
          "onBehalfOf": 1
        }
      },
      AutoTriggerIssue: {},
      AzureKeyVaultVariableGroupProviderData: {},
      AzureKeyVaultVariableValue: {},
      BuildVersion: {},
      Change: {},
      CodeRepositoryReference: {},
      Condition: {},
      ConditionType: {
        enumValues: {
          "undefined": 0,
          "event": 1,
          "environmentState": 2,
          "artifact": 4
        }
      },
      ContainerImageTrigger: {},
      ContinuousDeploymentTriggerIssue: {},
      Deployment: {},
      DeploymentApprovalCompletedEvent: {},
      DeploymentApprovalPendingEvent: {},
      DeploymentAttempt: {},
      DeploymentAuthorizationInfo: {},
      DeploymentAuthorizationOwner: {
        enumValues: {
          "automatic": 0,
          "deploymentSubmitter": 1,
          "firstPreDeploymentApprover": 2
        }
      },
      DeploymentCompletedEvent: {},
      DeploymentExpands: {
        enumValues: {
          "all": 0,
          "deploymentOnly": 1,
          "approvals": 2,
          "artifacts": 4
        }
      },
      DeploymentJob: {},
      DeploymentManualInterventionPendingEvent: {},
      DeploymentOperationStatus: {
        enumValues: {
          "undefined": 0,
          "queued": 1,
          "scheduled": 2,
          "pending": 4,
          "approved": 8,
          "rejected": 16,
          "deferred": 32,
          "queuedForAgent": 64,
          "phaseInProgress": 128,
          "phaseSucceeded": 256,
          "phasePartiallySucceeded": 512,
          "phaseFailed": 1024,
          "canceled": 2048,
          "phaseCanceled": 4096,
          "manualInterventionPending": 8192,
          "queuedForPipeline": 16384,
          "cancelling": 32768,
          "evaluatingGates": 65536,
          "gateFailed": 131072,
          "all": 258047
        }
      },
      DeploymentQueryParameters: {},
      DeploymentReason: {
        enumValues: {
          "none": 0,
          "manual": 1,
          "automated": 2,
          "scheduled": 4,
          "redeployTrigger": 8
        }
      },
      DeploymentsQueryType: {
        enumValues: {
          "regular": 1,
          "failingSince": 2
        }
      },
      DeploymentStartedEvent: {},
      DeploymentStatus: {
        enumValues: {
          "undefined": 0,
          "notDeployed": 1,
          "inProgress": 2,
          "succeeded": 4,
          "partiallySucceeded": 8,
          "failed": 16,
          "all": 31
        }
      },
      DeployPhase: {},
      DeployPhaseStatus: {
        enumValues: {
          "undefined": 0,
          "notStarted": 1,
          "inProgress": 2,
          "partiallySucceeded": 4,
          "succeeded": 8,
          "failed": 16,
          "canceled": 32,
          "skipped": 64,
          "cancelling": 128
        }
      },
      DeployPhaseTypes: {
        enumValues: {
          "undefined": 0,
          "agentBasedDeployment": 1,
          "runOnServer": 2,
          "machineGroupBasedDeployment": 4,
          "deploymentGates": 8
        }
      },
      EnvironmentStatus: {
        enumValues: {
          "undefined": 0,
          "notStarted": 1,
          "inProgress": 2,
          "succeeded": 4,
          "canceled": 8,
          "rejected": 16,
          "queued": 32,
          "scheduled": 64,
          "partiallySucceeded": 128
        }
      },
      EnvironmentTrigger: {},
      EnvironmentTriggerType: {
        enumValues: {
          "undefined": 0,
          "deploymentGroupRedeploy": 1,
          "rollbackRedeploy": 2
        }
      },
      ExecutionInput: {},
      Folder: {},
      FolderPathQueryOrder: {
        enumValues: {
          "none": 0,
          "ascending": 1,
          "descending": 2
        }
      },
      GatesDeployPhase: {},
      GateStatus: {
        enumValues: {
          "none": 0,
          "pending": 1,
          "inProgress": 2,
          "succeeded": 4,
          "failed": 8,
          "canceled": 16
        }
      },
      IgnoredGate: {},
      IssueSource: {
        enumValues: {
          "none": 0,
          "user": 1,
          "system": 2
        }
      },
      MachineGroupBasedDeployPhase: {},
      MailMessage: {},
      MailSectionType: {
        enumValues: {
          "details": 0,
          "environments": 1,
          "issues": 2,
          "testResults": 3,
          "workItems": 4,
          "releaseInfo": 5
        }
      },
      ManualIntervention: {},
      ManualInterventionStatus: {
        enumValues: {
          "unknown": 0,
          "pending": 1,
          "rejected": 2,
          "approved": 4,
          "canceled": 8
        }
      },
      ManualInterventionUpdateMetadata: {},
      MultiConfigInput: {},
      MultiMachineInput: {},
      PackageTrigger: {},
      ParallelExecutionInputBase: {},
      ParallelExecutionTypes: {
        enumValues: {
          "none": 0,
          "multiConfiguration": 1,
          "multiMachine": 2
        }
      },
      PipelineProcess: {},
      PipelineProcessTypes: {
        enumValues: {
          "designer": 1,
          "yaml": 2
        }
      },
      PropertySelector: {},
      PropertySelectorType: {
        enumValues: {
          "inclusion": 0,
          "exclusion": 1
        }
      },
      PullRequestConfiguration: {},
      PullRequestSystemType: {
        enumValues: {
          "none": 0,
          "tfsGit": 1,
          "gitHub": 2
        }
      },
      PullRequestTrigger: {},
      Release: {},
      ReleaseAbandonedEvent: {},
      ReleaseApproval: {},
      ReleaseApprovalHistory: {},
      ReleaseApprovalPendingEvent: {},
      ReleaseCondition: {},
      ReleaseCreatedEvent: {},
      ReleaseDefinition: {},
      ReleaseDefinitionApprovals: {},
      ReleaseDefinitionEnvironment: {},
      ReleaseDefinitionEnvironmentTemplate: {},
      ReleaseDefinitionExpands: {
        enumValues: {
          "none": 0,
          "environments": 2,
          "artifacts": 4,
          "triggers": 8,
          "variables": 16,
          "tags": 32,
          "lastRelease": 64
        }
      },
      ReleaseDefinitionQueryOrder: {
        enumValues: {
          "idAscending": 0,
          "idDescending": 1,
          "nameAscending": 2,
          "nameDescending": 3
        }
      },
      ReleaseDefinitionRevision: {},
      ReleaseDefinitionSource: {
        enumValues: {
          "undefined": 0,
          "restApi": 1,
          "userInterface": 2,
          "ibiza": 4,
          "portalExtensionApi": 8
        }
      },
      ReleaseDefinitionSummary: {},
      ReleaseDeployPhase: {},
      ReleaseEnvironment: {},
      ReleaseEnvironmentCompletedEvent: {},
      ReleaseEnvironmentExpands: {
        enumValues: {
          "none": 0,
          "tasks": 1
        }
      },
      ReleaseEnvironmentStatusUpdatedEvent: {},
      ReleaseEnvironmentUpdateMetadata: {},
      ReleaseExpands: {
        enumValues: {
          "none": 0,
          "environments": 2,
          "artifacts": 4,
          "approvals": 8,
          "manualInterventions": 16,
          "variables": 32,
          "tags": 64
        }
      },
      ReleaseGates: {},
      ReleaseGatesPhase: {},
      ReleaseNotCreatedEvent: {},
      ReleaseQueryOrder: {
        enumValues: {
          "descending": 0,
          "ascending": 1
        }
      },
      ReleaseReason: {
        enumValues: {
          "none": 0,
          "manual": 1,
          "continuousIntegration": 2,
          "schedule": 3,
          "pullRequest": 4
        }
      },
      ReleaseReference: {},
      ReleaseRevision: {},
      ReleaseSchedule: {},
      ReleaseStartMetadata: {},
      ReleaseStatus: {
        enumValues: {
          "undefined": 0,
          "draft": 1,
          "active": 2,
          "abandoned": 4
        }
      },
      ReleaseTask: {},
      ReleaseTaskAttachment: {},
      ReleaseTasksUpdatedEvent: {},
      ReleaseTriggerBase: {},
      ReleaseTriggerType: {
        enumValues: {
          "undefined": 0,
          "artifactSource": 1,
          "schedule": 2,
          "sourceRepo": 3,
          "containerImage": 4,
          "package": 5,
          "pullRequest": 6
        }
      },
      ReleaseUpdatedEvent: {},
      ReleaseUpdateMetadata: {},
      RunOnServerDeployPhase: {},
      ScheduleDays: {
        enumValues: {
          "none": 0,
          "monday": 1,
          "tuesday": 2,
          "wednesday": 4,
          "thursday": 8,
          "friday": 16,
          "saturday": 32,
          "sunday": 64,
          "all": 127
        }
      },
      ScheduledReleaseTrigger: {},
      SenderType: {
        enumValues: {
          "serviceAccount": 1,
          "requestingUser": 2
        }
      },
      ServerDeploymentInput: {},
      SingleReleaseExpands: {
        enumValues: {
          "none": 0,
          "tasks": 1
        }
      },
      SourcePullRequestVersion: {},
      SourceRepoTrigger: {},
      SummaryMailSection: {},
      TaskStatus: {
        enumValues: {
          "unknown": 0,
          "pending": 1,
          "inProgress": 2,
          "success": 3,
          "failure": 4,
          "canceled": 5,
          "skipped": 6,
          "succeeded": 7,
          "failed": 8,
          "partiallySucceeded": 9
        }
      },
      VariableGroup: {},
      VariableGroupActionFilter: {
        enumValues: {
          "none": 0,
          "manage": 2,
          "use": 16
        }
      },
      YamlFileSource: {},
      YamlFileSourceTypes: {
        enumValues: {
          "none": 0,
          "tfsGit": 1
        }
      },
      YamlPipelineProcess: {}
    };
    exports2.TypeInfo.AgentArtifactDefinition.fields = {
      artifactType: {
        enumType: exports2.TypeInfo.AgentArtifactType
      }
    };
    exports2.TypeInfo.AgentBasedDeployPhase.fields = {
      deploymentInput: {
        typeInfo: exports2.TypeInfo.AgentDeploymentInput
      },
      phaseType: {
        enumType: exports2.TypeInfo.DeployPhaseTypes
      }
    };
    exports2.TypeInfo.AgentDeploymentInput.fields = {
      parallelExecution: {
        typeInfo: exports2.TypeInfo.ExecutionInput
      }
    };
    exports2.TypeInfo.ApprovalOptions.fields = {
      executionOrder: {
        enumType: exports2.TypeInfo.ApprovalExecutionOrder
      }
    };
    exports2.TypeInfo.ArtifactContributionDefinition.fields = {
      inputDescriptors: {
        isArray: true,
        typeInfo: FormInputInterfaces.TypeInfo.InputDescriptor
      }
    };
    exports2.TypeInfo.ArtifactMetadata.fields = {
      instanceReference: {
        typeInfo: exports2.TypeInfo.BuildVersion
      }
    };
    exports2.TypeInfo.ArtifactSourceTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.ArtifactTypeDefinition.fields = {
      inputDescriptors: {
        isArray: true,
        typeInfo: FormInputInterfaces.TypeInfo.InputDescriptor
      }
    };
    exports2.TypeInfo.ArtifactVersion.fields = {
      defaultVersion: {
        typeInfo: exports2.TypeInfo.BuildVersion
      },
      versions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BuildVersion
      }
    };
    exports2.TypeInfo.ArtifactVersionQueryResult.fields = {
      artifactVersions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ArtifactVersion
      }
    };
    exports2.TypeInfo.AutoTriggerIssue.fields = {
      issueSource: {
        enumType: exports2.TypeInfo.IssueSource
      },
      releaseTriggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.AzureKeyVaultVariableGroupProviderData.fields = {
      lastRefreshedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.AzureKeyVaultVariableValue.fields = {
      expires: {
        isDate: true
      }
    };
    exports2.TypeInfo.BuildVersion.fields = {
      sourcePullRequestVersion: {
        typeInfo: exports2.TypeInfo.SourcePullRequestVersion
      }
    };
    exports2.TypeInfo.Change.fields = {
      timestamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.CodeRepositoryReference.fields = {
      systemType: {
        enumType: exports2.TypeInfo.PullRequestSystemType
      }
    };
    exports2.TypeInfo.Condition.fields = {
      conditionType: {
        enumType: exports2.TypeInfo.ConditionType
      }
    };
    exports2.TypeInfo.ContainerImageTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.ContinuousDeploymentTriggerIssue.fields = {
      issueSource: {
        enumType: exports2.TypeInfo.IssueSource
      },
      releaseTriggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.Deployment.fields = {
      completedOn: {
        isDate: true
      },
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Condition
      },
      deploymentStatus: {
        enumType: exports2.TypeInfo.DeploymentStatus
      },
      lastModifiedOn: {
        isDate: true
      },
      operationStatus: {
        enumType: exports2.TypeInfo.DeploymentOperationStatus
      },
      postDeployApprovals: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      preDeployApprovals: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      queuedOn: {
        isDate: true
      },
      reason: {
        enumType: exports2.TypeInfo.DeploymentReason
      },
      release: {
        typeInfo: exports2.TypeInfo.ReleaseReference
      },
      scheduledDeploymentTime: {
        isDate: true
      },
      startedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.DeploymentApprovalCompletedEvent.fields = {
      approval: {
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      release: {
        typeInfo: exports2.TypeInfo.Release
      }
    };
    exports2.TypeInfo.DeploymentApprovalPendingEvent.fields = {
      approval: {
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      approvalOptions: {
        typeInfo: exports2.TypeInfo.ApprovalOptions
      },
      completedApprovals: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      deployment: {
        typeInfo: exports2.TypeInfo.Deployment
      },
      pendingApprovals: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      release: {
        typeInfo: exports2.TypeInfo.Release
      }
    };
    exports2.TypeInfo.DeploymentAttempt.fields = {
      job: {
        typeInfo: exports2.TypeInfo.ReleaseTask
      },
      lastModifiedOn: {
        isDate: true
      },
      operationStatus: {
        enumType: exports2.TypeInfo.DeploymentOperationStatus
      },
      postDeploymentGates: {
        typeInfo: exports2.TypeInfo.ReleaseGates
      },
      preDeploymentGates: {
        typeInfo: exports2.TypeInfo.ReleaseGates
      },
      queuedOn: {
        isDate: true
      },
      reason: {
        enumType: exports2.TypeInfo.DeploymentReason
      },
      releaseDeployPhases: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseDeployPhase
      },
      status: {
        enumType: exports2.TypeInfo.DeploymentStatus
      },
      tasks: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseTask
      }
    };
    exports2.TypeInfo.DeploymentAuthorizationInfo.fields = {
      authorizationHeaderFor: {
        enumType: exports2.TypeInfo.AuthorizationHeaderFor
      }
    };
    exports2.TypeInfo.DeploymentCompletedEvent.fields = {
      deployment: {
        typeInfo: exports2.TypeInfo.Deployment
      },
      environment: {
        typeInfo: exports2.TypeInfo.ReleaseEnvironment
      }
    };
    exports2.TypeInfo.DeploymentJob.fields = {
      job: {
        typeInfo: exports2.TypeInfo.ReleaseTask
      },
      tasks: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseTask
      }
    };
    exports2.TypeInfo.DeploymentManualInterventionPendingEvent.fields = {
      approval: {
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      deployment: {
        typeInfo: exports2.TypeInfo.Deployment
      },
      manualIntervention: {
        typeInfo: exports2.TypeInfo.ManualIntervention
      },
      release: {
        typeInfo: exports2.TypeInfo.Release
      }
    };
    exports2.TypeInfo.DeploymentQueryParameters.fields = {
      deploymentStatus: {
        enumType: exports2.TypeInfo.DeploymentStatus
      },
      expands: {
        enumType: exports2.TypeInfo.DeploymentExpands
      },
      maxModifiedTime: {
        isDate: true
      },
      minModifiedTime: {
        isDate: true
      },
      operationStatus: {
        enumType: exports2.TypeInfo.DeploymentOperationStatus
      },
      queryOrder: {
        enumType: exports2.TypeInfo.ReleaseQueryOrder
      },
      queryType: {
        enumType: exports2.TypeInfo.DeploymentsQueryType
      }
    };
    exports2.TypeInfo.DeploymentStartedEvent.fields = {
      environment: {
        typeInfo: exports2.TypeInfo.ReleaseEnvironment
      },
      release: {
        typeInfo: exports2.TypeInfo.Release
      }
    };
    exports2.TypeInfo.DeployPhase.fields = {
      phaseType: {
        enumType: exports2.TypeInfo.DeployPhaseTypes
      }
    };
    exports2.TypeInfo.EnvironmentTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.EnvironmentTriggerType
      }
    };
    exports2.TypeInfo.ExecutionInput.fields = {
      parallelExecutionType: {
        enumType: exports2.TypeInfo.ParallelExecutionTypes
      }
    };
    exports2.TypeInfo.Folder.fields = {
      createdOn: {
        isDate: true
      },
      lastChangedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.GatesDeployPhase.fields = {
      phaseType: {
        enumType: exports2.TypeInfo.DeployPhaseTypes
      }
    };
    exports2.TypeInfo.IgnoredGate.fields = {
      lastModifiedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.MachineGroupBasedDeployPhase.fields = {
      phaseType: {
        enumType: exports2.TypeInfo.DeployPhaseTypes
      }
    };
    exports2.TypeInfo.MailMessage.fields = {
      replyBy: {
        isDate: true
      },
      sections: {
        isArray: true,
        enumType: exports2.TypeInfo.MailSectionType
      },
      senderType: {
        enumType: exports2.TypeInfo.SenderType
      }
    };
    exports2.TypeInfo.ManualIntervention.fields = {
      createdOn: {
        isDate: true
      },
      modifiedOn: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.ManualInterventionStatus
      }
    };
    exports2.TypeInfo.ManualInterventionUpdateMetadata.fields = {
      status: {
        enumType: exports2.TypeInfo.ManualInterventionStatus
      }
    };
    exports2.TypeInfo.MultiConfigInput.fields = {
      parallelExecutionType: {
        enumType: exports2.TypeInfo.ParallelExecutionTypes
      }
    };
    exports2.TypeInfo.MultiMachineInput.fields = {
      parallelExecutionType: {
        enumType: exports2.TypeInfo.ParallelExecutionTypes
      }
    };
    exports2.TypeInfo.PackageTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.ParallelExecutionInputBase.fields = {
      parallelExecutionType: {
        enumType: exports2.TypeInfo.ParallelExecutionTypes
      }
    };
    exports2.TypeInfo.PipelineProcess.fields = {
      type: {
        enumType: exports2.TypeInfo.PipelineProcessTypes
      }
    };
    exports2.TypeInfo.PropertySelector.fields = {
      selectorType: {
        enumType: exports2.TypeInfo.PropertySelectorType
      }
    };
    exports2.TypeInfo.PullRequestConfiguration.fields = {
      codeRepositoryReference: {
        typeInfo: exports2.TypeInfo.CodeRepositoryReference
      }
    };
    exports2.TypeInfo.PullRequestTrigger.fields = {
      pullRequestConfiguration: {
        typeInfo: exports2.TypeInfo.PullRequestConfiguration
      },
      triggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.Release.fields = {
      createdOn: {
        isDate: true
      },
      environments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseEnvironment
      },
      modifiedOn: {
        isDate: true
      },
      reason: {
        enumType: exports2.TypeInfo.ReleaseReason
      },
      status: {
        enumType: exports2.TypeInfo.ReleaseStatus
      },
      variableGroups: {
        isArray: true,
        typeInfo: exports2.TypeInfo.VariableGroup
      }
    };
    exports2.TypeInfo.ReleaseAbandonedEvent.fields = {
      release: {
        typeInfo: exports2.TypeInfo.Release
      }
    };
    exports2.TypeInfo.ReleaseApproval.fields = {
      approvalType: {
        enumType: exports2.TypeInfo.ApprovalType
      },
      createdOn: {
        isDate: true
      },
      history: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApprovalHistory
      },
      modifiedOn: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.ApprovalStatus
      }
    };
    exports2.TypeInfo.ReleaseApprovalHistory.fields = {
      createdOn: {
        isDate: true
      },
      modifiedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReleaseApprovalPendingEvent.fields = {
      approval: {
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      approvalOptions: {
        typeInfo: exports2.TypeInfo.ApprovalOptions
      },
      completedApprovals: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      deployment: {
        typeInfo: exports2.TypeInfo.Deployment
      },
      environments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseEnvironment
      },
      pendingApprovals: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApproval
      }
    };
    exports2.TypeInfo.ReleaseCondition.fields = {
      conditionType: {
        enumType: exports2.TypeInfo.ConditionType
      }
    };
    exports2.TypeInfo.ReleaseCreatedEvent.fields = {
      release: {
        typeInfo: exports2.TypeInfo.Release
      }
    };
    exports2.TypeInfo.ReleaseDefinition.fields = {
      createdOn: {
        isDate: true
      },
      environments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseDefinitionEnvironment
      },
      lastRelease: {
        typeInfo: exports2.TypeInfo.ReleaseReference
      },
      modifiedOn: {
        isDate: true
      },
      pipelineProcess: {
        typeInfo: exports2.TypeInfo.PipelineProcess
      },
      source: {
        enumType: exports2.TypeInfo.ReleaseDefinitionSource
      },
      triggers: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseTriggerBase
      }
    };
    exports2.TypeInfo.ReleaseDefinitionApprovals.fields = {
      approvalOptions: {
        typeInfo: exports2.TypeInfo.ApprovalOptions
      }
    };
    exports2.TypeInfo.ReleaseDefinitionEnvironment.fields = {
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Condition
      },
      deployPhases: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeployPhase
      },
      environmentTriggers: {
        isArray: true,
        typeInfo: exports2.TypeInfo.EnvironmentTrigger
      },
      postDeployApprovals: {
        typeInfo: exports2.TypeInfo.ReleaseDefinitionApprovals
      },
      preDeployApprovals: {
        typeInfo: exports2.TypeInfo.ReleaseDefinitionApprovals
      },
      schedules: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseSchedule
      }
    };
    exports2.TypeInfo.ReleaseDefinitionEnvironmentTemplate.fields = {
      environment: {
        typeInfo: exports2.TypeInfo.ReleaseDefinitionEnvironment
      }
    };
    exports2.TypeInfo.ReleaseDefinitionRevision.fields = {
      changedDate: {
        isDate: true
      },
      changeType: {
        enumType: exports2.TypeInfo.AuditAction
      }
    };
    exports2.TypeInfo.ReleaseDefinitionSummary.fields = {
      releases: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Release
      }
    };
    exports2.TypeInfo.ReleaseDeployPhase.fields = {
      deploymentJobs: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentJob
      },
      manualInterventions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ManualIntervention
      },
      phaseType: {
        enumType: exports2.TypeInfo.DeployPhaseTypes
      },
      startedOn: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.DeployPhaseStatus
      }
    };
    exports2.TypeInfo.ReleaseEnvironment.fields = {
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseCondition
      },
      createdOn: {
        isDate: true
      },
      deployPhasesSnapshot: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeployPhase
      },
      deploySteps: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentAttempt
      },
      modifiedOn: {
        isDate: true
      },
      nextScheduledUtcTime: {
        isDate: true
      },
      postApprovalsSnapshot: {
        typeInfo: exports2.TypeInfo.ReleaseDefinitionApprovals
      },
      postDeployApprovals: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      preApprovalsSnapshot: {
        typeInfo: exports2.TypeInfo.ReleaseDefinitionApprovals
      },
      preDeployApprovals: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseApproval
      },
      scheduledDeploymentTime: {
        isDate: true
      },
      schedules: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseSchedule
      },
      status: {
        enumType: exports2.TypeInfo.EnvironmentStatus
      },
      variableGroups: {
        isArray: true,
        typeInfo: exports2.TypeInfo.VariableGroup
      }
    };
    exports2.TypeInfo.ReleaseEnvironmentCompletedEvent.fields = {
      environment: {
        typeInfo: exports2.TypeInfo.ReleaseEnvironment
      },
      reason: {
        enumType: exports2.TypeInfo.DeploymentReason
      }
    };
    exports2.TypeInfo.ReleaseEnvironmentStatusUpdatedEvent.fields = {
      environmentStatus: {
        enumType: exports2.TypeInfo.EnvironmentStatus
      },
      latestDeploymentOperationStatus: {
        enumType: exports2.TypeInfo.DeploymentOperationStatus
      },
      latestDeploymentStatus: {
        enumType: exports2.TypeInfo.DeploymentStatus
      }
    };
    exports2.TypeInfo.ReleaseEnvironmentUpdateMetadata.fields = {
      scheduledDeploymentTime: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.EnvironmentStatus
      }
    };
    exports2.TypeInfo.ReleaseGates.fields = {
      deploymentJobs: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentJob
      },
      ignoredGates: {
        isArray: true,
        typeInfo: exports2.TypeInfo.IgnoredGate
      },
      lastModifiedOn: {
        isDate: true
      },
      stabilizationCompletedOn: {
        isDate: true
      },
      startedOn: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.GateStatus
      },
      succeedingSince: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReleaseGatesPhase.fields = {
      deploymentJobs: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentJob
      },
      ignoredGates: {
        isArray: true,
        typeInfo: exports2.TypeInfo.IgnoredGate
      },
      manualInterventions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ManualIntervention
      },
      phaseType: {
        enumType: exports2.TypeInfo.DeployPhaseTypes
      },
      stabilizationCompletedOn: {
        isDate: true
      },
      startedOn: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.DeployPhaseStatus
      },
      succeedingSince: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReleaseNotCreatedEvent.fields = {
      releaseReason: {
        enumType: exports2.TypeInfo.ReleaseReason
      }
    };
    exports2.TypeInfo.ReleaseReference.fields = {
      createdOn: {
        isDate: true
      },
      reason: {
        enumType: exports2.TypeInfo.ReleaseReason
      }
    };
    exports2.TypeInfo.ReleaseRevision.fields = {
      changedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReleaseSchedule.fields = {
      daysToRelease: {
        enumType: exports2.TypeInfo.ScheduleDays
      }
    };
    exports2.TypeInfo.ReleaseStartMetadata.fields = {
      artifacts: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ArtifactMetadata
      },
      reason: {
        enumType: exports2.TypeInfo.ReleaseReason
      }
    };
    exports2.TypeInfo.ReleaseTask.fields = {
      dateEnded: {
        isDate: true
      },
      dateStarted: {
        isDate: true
      },
      finishTime: {
        isDate: true
      },
      startTime: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.TaskStatus
      }
    };
    exports2.TypeInfo.ReleaseTaskAttachment.fields = {
      createdOn: {
        isDate: true
      },
      modifiedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.ReleaseTasksUpdatedEvent.fields = {
      job: {
        typeInfo: exports2.TypeInfo.ReleaseTask
      },
      tasks: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ReleaseTask
      }
    };
    exports2.TypeInfo.ReleaseTriggerBase.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.ReleaseUpdatedEvent.fields = {
      release: {
        typeInfo: exports2.TypeInfo.Release
      }
    };
    exports2.TypeInfo.ReleaseUpdateMetadata.fields = {
      status: {
        enumType: exports2.TypeInfo.ReleaseStatus
      }
    };
    exports2.TypeInfo.RunOnServerDeployPhase.fields = {
      deploymentInput: {
        typeInfo: exports2.TypeInfo.ServerDeploymentInput
      },
      phaseType: {
        enumType: exports2.TypeInfo.DeployPhaseTypes
      }
    };
    exports2.TypeInfo.ScheduledReleaseTrigger.fields = {
      schedule: {
        typeInfo: exports2.TypeInfo.ReleaseSchedule
      },
      triggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.ServerDeploymentInput.fields = {
      parallelExecution: {
        typeInfo: exports2.TypeInfo.ExecutionInput
      }
    };
    exports2.TypeInfo.SourcePullRequestVersion.fields = {
      pullRequestMergedAt: {
        isDate: true
      }
    };
    exports2.TypeInfo.SourceRepoTrigger.fields = {
      triggerType: {
        enumType: exports2.TypeInfo.ReleaseTriggerType
      }
    };
    exports2.TypeInfo.SummaryMailSection.fields = {
      sectionType: {
        enumType: exports2.TypeInfo.MailSectionType
      }
    };
    exports2.TypeInfo.VariableGroup.fields = {
      createdOn: {
        isDate: true
      },
      modifiedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.YamlFileSource.fields = {
      type: {
        enumType: exports2.TypeInfo.YamlFileSourceTypes
      }
    };
    exports2.TypeInfo.YamlPipelineProcess.fields = {
      fileSource: {
        typeInfo: exports2.TypeInfo.YamlFileSource
      },
      type: {
        enumType: exports2.TypeInfo.PipelineProcessTypes
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/ReleaseApi.js
var require_ReleaseApi = __commonJS({
  "../node_modules/azure-devops-node-api/ReleaseApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.ReleaseApi = void 0;
    var basem = require_ClientApiBases();
    var ReleaseInterfaces = require_ReleaseInterfaces();
    var ReleaseApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Release-api", options);
      }
      /**
       * Returns the artifact details that automation agent requires
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       */
      getAgentArtifactDefinitions(project, releaseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "f2571c27-bf50-4938-b396-32d109ddef26", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.AgentArtifactDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of approvals
       *
       * @param {string} project - Project ID or project name
       * @param {string} assignedToFilter - Approvals assigned to this user.
       * @param {ReleaseInterfaces.ApprovalStatus} statusFilter - Approvals with this status. Default is 'pending'.
       * @param {number[]} releaseIdsFilter - Approvals for release id(s) mentioned in the filter. Multiple releases can be mentioned by separating them with ',' e.g. releaseIdsFilter=1,2,3,4.
       * @param {ReleaseInterfaces.ApprovalType} typeFilter - Approval with this type.
       * @param {number} top - Number of approvals to get. Default is 50.
       * @param {number} continuationToken - Gets the approvals after the continuation token provided.
       * @param {ReleaseInterfaces.ReleaseQueryOrder} queryOrder - Gets the results in the defined order of created approvals. Default is 'descending'.
       * @param {boolean} includeMyGroupApprovals - 'true' to include my group approvals. Default is 'false'.
       */
      getApprovals(project, assignedToFilter, statusFilter, releaseIdsFilter, typeFilter, top, continuationToken, queryOrder, includeMyGroupApprovals) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              assignedToFilter,
              statusFilter,
              releaseIdsFilter: releaseIdsFilter && releaseIdsFilter.join(","),
              typeFilter,
              top,
              continuationToken,
              queryOrder,
              includeMyGroupApprovals
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Release", "b47c6458-e73b-47cb-a770-4df1e8813a91", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseApproval, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get approval history.
       *
       * @param {string} project - Project ID or project name
       * @param {number} approvalStepId - Id of the approval.
       */
      getApprovalHistory(project, approvalStepId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              approvalStepId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Release", "250c7158-852e-4130-a00f-a0cce9b72d05", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseApproval, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get an approval.
       *
       * @param {string} project - Project ID or project name
       * @param {number} approvalId - Id of the approval.
       * @param {boolean} includeHistory - 'true' to include history of the approval. Default is 'false'.
       */
      getApproval(project, approvalId, includeHistory) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              approvalId
            };
            let queryValues = {
              includeHistory
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Release", "9328e074-59fb-465a-89d9-b09c82ee5109", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseApproval, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update status of an approval
       *
       * @param {ReleaseInterfaces.ReleaseApproval} approval - ReleaseApproval object having status, approver and comments.
       * @param {string} project - Project ID or project name
       * @param {number} approvalId - Id of the approval.
       */
      updateReleaseApproval(approval, project, approvalId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              approvalId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Release", "9328e074-59fb-465a-89d9-b09c82ee5109", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, approval, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseApproval, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {ReleaseInterfaces.ReleaseApproval[]} approvals
       * @param {string} project - Project ID or project name
       */
      updateReleaseApprovals(approvals, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Release", "c957584a-82aa-4131-8222-6d47f78bfa7a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, approvals, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseApproval, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a task attachment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of the release environment.
       * @param {number} attemptId - Attempt number of deployment.
       * @param {string} timelineId - Timeline Id of the task.
       * @param {string} recordId - Record Id of attachment.
       * @param {string} type - Type of the attachment.
       * @param {string} name - Name of the attachment.
       */
      getTaskAttachmentContent(project, releaseId, environmentId, attemptId, timelineId, recordId, type, name) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              attemptId,
              timelineId,
              recordId,
              type,
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "c4071f6d-3697-46ca-858e-8b10ff09e52f", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a release task attachment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of the release environment.
       * @param {number} attemptId - Attempt number of deployment.
       * @param {string} planId - Plan Id of the deploy phase.
       * @param {string} timelineId - Timeline Id of the task.
       * @param {string} recordId - Record Id of attachment.
       * @param {string} type - Type of the attachment.
       * @param {string} name - Name of the attachment.
       */
      getReleaseTaskAttachmentContent(project, releaseId, environmentId, attemptId, planId, timelineId, recordId, type, name) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              attemptId,
              planId,
              timelineId,
              recordId,
              type,
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "60b86efb-7b8c-4853-8f9f-aa142b77b479", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the task attachments.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of the release environment.
       * @param {number} attemptId - Attempt number of deployment.
       * @param {string} timelineId - Timeline Id of the task.
       * @param {string} type - Type of the attachment.
       */
      getTaskAttachments(project, releaseId, environmentId, attemptId, timelineId, type) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              attemptId,
              timelineId,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "214111ee-2415-4df2-8ed2-74417f7d61f9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseTaskAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the release task attachments.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of the release environment.
       * @param {number} attemptId - Attempt number of deployment.
       * @param {string} planId - Plan Id of the deploy phase.
       * @param {string} type - Type of the attachment.
       */
      getReleaseTaskAttachments(project, releaseId, environmentId, attemptId, planId, type) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              attemptId,
              planId,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "a4d06688-0dfa-4895-82a5-f43ec9452306", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseTaskAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} artifactType
       * @param {string} sourceId
       * @param {string} artifactVersionId
       * @param {string} project - Project ID or project name
       */
      getAutoTriggerIssues(artifactType, sourceId, artifactVersionId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (artifactType == null) {
            throw new TypeError("artifactType can not be null or undefined");
          }
          if (sourceId == null) {
            throw new TypeError("sourceId can not be null or undefined");
          }
          if (artifactVersionId == null) {
            throw new TypeError("artifactVersionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              artifactType,
              sourceId,
              artifactVersionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "c1a68497-69da-40fb-9423-cab19cfeeca9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.AutoTriggerIssue, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a badge that indicates the status of the most recent deployment for an environment.
       *
       * @param {string} projectId - The ID of the Project.
       * @param {number} releaseDefinitionId - The ID of the Release Definition.
       * @param {number} environmentId - The ID of the Environment.
       * @param {string} branchName - The name of the branch.
       */
      getDeploymentBadge(projectId, releaseDefinitionId, environmentId, branchName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              projectId,
              releaseDefinitionId,
              environmentId,
              branchName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "1a60a35d-b8c9-45fb-bf67-da0829711147", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} baseReleaseId
       * @param {number} top
       * @param {string} artifactAlias
       */
      getReleaseChanges(project, releaseId, baseReleaseId, top, artifactAlias) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            let queryValues = {
              baseReleaseId,
              "$top": top,
              artifactAlias
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "8dcf9fe9-ca37-4113-8ee1-37928e98407c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Change, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} taskGroupId
       * @param {string[]} propertyFilters
       */
      getDefinitionEnvironments(project, taskGroupId, propertyFilters) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              taskGroupId,
              propertyFilters: propertyFilters && propertyFilters.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "12b5d21a-f54c-430e-a8c1-7515d196890e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a release definition
       *
       * @param {ReleaseInterfaces.ReleaseDefinition} releaseDefinition - release definition object to create.
       * @param {string} project - Project ID or project name
       */
      createReleaseDefinition(releaseDefinition, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "d8f96f24-8ea7-4cb6-baab-2df8fc515665", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, releaseDefinition, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a release definition.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - Id of the release definition.
       * @param {string} comment - Comment for deleting a release definition.
       * @param {boolean} forceDelete - 'true' to automatically cancel any in-progress release deployments and proceed with release definition deletion . Default is 'false'.
       */
      deleteReleaseDefinition(project, definitionId, comment, forceDelete) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              comment,
              forceDelete
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "d8f96f24-8ea7-4cb6-baab-2df8fc515665", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a release definition.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - Id of the release definition.
       * @param {string[]} propertyFilters - A comma-delimited list of extended properties to be retrieved. If set, the returned Release Definition will contain values for the specified property Ids (if they exist). If not set, properties will not be included.
       */
      getReleaseDefinition(project, definitionId, propertyFilters) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              propertyFilters: propertyFilters && propertyFilters.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "d8f96f24-8ea7-4cb6-baab-2df8fc515665", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get release definition of a given revision.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - Id of the release definition.
       * @param {number} revision - Revision number of the release definition.
       */
      getReleaseDefinitionRevision(project, definitionId, revision) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (revision == null) {
            throw new TypeError("revision can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            let queryValues = {
              revision
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "d8f96f24-8ea7-4cb6-baab-2df8fc515665", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of release definitions.
       *
       * @param {string} project - Project ID or project name
       * @param {string} searchText - Get release definitions with names containing searchText.
       * @param {ReleaseInterfaces.ReleaseDefinitionExpands} expand - The properties that should be expanded in the list of Release definitions.
       * @param {string} artifactType - Release definitions with given artifactType will be returned. Values can be Build, Jenkins, GitHub, Nuget, Team Build (external), ExternalTFSBuild, Git, TFVC, ExternalTfsXamlBuild.
       * @param {string} artifactSourceId - Release definitions with given artifactSourceId will be returned. e.g. For build it would be {projectGuid}:{BuildDefinitionId}, for Jenkins it would be {JenkinsConnectionId}:{JenkinsDefinitionId}, for TfsOnPrem it would be {TfsOnPremConnectionId}:{ProjectName}:{TfsOnPremDefinitionId}. For third-party artifacts e.g. TeamCity, BitBucket you may refer 'uniqueSourceIdentifier' inside vss-extension.json at https://github.com/Microsoft/vsts-rm-extensions/blob/master/Extensions.
       * @param {number} top - Number of release definitions to get.
       * @param {string} continuationToken - Gets the release definitions after the continuation token provided.
       * @param {ReleaseInterfaces.ReleaseDefinitionQueryOrder} queryOrder - Gets the results in the defined order. Default is 'IdAscending'.
       * @param {string} path - Gets the release definitions under the specified path.
       * @param {boolean} isExactNameMatch - 'true'to gets the release definitions with exact match as specified in searchText. Default is 'false'.
       * @param {string[]} tagFilter - A comma-delimited list of tags. Only release definitions with these tags will be returned.
       * @param {string[]} propertyFilters - A comma-delimited list of extended properties to be retrieved. If set, the returned Release Definitions will contain values for the specified property Ids (if they exist). If not set, properties will not be included. Note that this will not filter out any Release Definition from results irrespective of whether it has property set or not.
       * @param {string[]} definitionIdFilter - A comma-delimited list of release definitions to retrieve.
       * @param {boolean} isDeleted - 'true' to get release definitions that has been deleted. Default is 'false'
       * @param {boolean} searchTextContainsFolderName - 'true' to get the release definitions under the folder with name as specified in searchText. Default is 'false'.
       */
      getReleaseDefinitions(project, searchText, expand, artifactType, artifactSourceId, top, continuationToken, queryOrder, path2, isExactNameMatch, tagFilter, propertyFilters, definitionIdFilter, isDeleted, searchTextContainsFolderName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              searchText,
              "$expand": expand,
              artifactType,
              artifactSourceId,
              "$top": top,
              continuationToken,
              queryOrder,
              path: path2,
              isExactNameMatch,
              tagFilter: tagFilter && tagFilter.join(","),
              propertyFilters: propertyFilters && propertyFilters.join(","),
              definitionIdFilter: definitionIdFilter && definitionIdFilter.join(","),
              isDeleted,
              searchTextContainsFolderName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "d8f96f24-8ea7-4cb6-baab-2df8fc515665", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Undelete a release definition.
       *
       * @param {ReleaseInterfaces.ReleaseDefinitionUndeleteParameter} releaseDefinitionUndeleteParameter - Object for undelete release definition.
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - Id of the release definition to be undeleted
       */
      undeleteReleaseDefinition(releaseDefinitionUndeleteParameter, project, definitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "d8f96f24-8ea7-4cb6-baab-2df8fc515665", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, releaseDefinitionUndeleteParameter, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a release definition.
       *
       * @param {ReleaseInterfaces.ReleaseDefinition} releaseDefinition - Release definition object to update.
       * @param {string} project - Project ID or project name
       */
      updateReleaseDefinition(releaseDefinition, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "d8f96f24-8ea7-4cb6-baab-2df8fc515665", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, releaseDefinition, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of deployments
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - List the deployments for a given definition id.
       * @param {number} definitionEnvironmentId - List the deployments for a given definition environment id.
       * @param {string} createdBy - List the deployments for which deployments are created as identity specified.
       * @param {Date} minModifiedTime - List the deployments with LastModified time >= minModifiedTime.
       * @param {Date} maxModifiedTime - List the deployments with LastModified time <= maxModifiedTime.
       * @param {ReleaseInterfaces.DeploymentStatus} deploymentStatus - List the deployments with given deployment status. Defult is 'All'.
       * @param {ReleaseInterfaces.DeploymentOperationStatus} operationStatus - List the deployments with given operation status. Default is 'All'.
       * @param {boolean} latestAttemptsOnly - 'true' to include deployments with latest attempt only. Default is 'false'.
       * @param {ReleaseInterfaces.ReleaseQueryOrder} queryOrder - List the deployments with given query order. Default is 'Descending'.
       * @param {number} top - List the deployments with given top. Default top is '50' and Max top is '100'.
       * @param {number} continuationToken - List the deployments with deployment id >= continuationToken.
       * @param {string} createdFor - List the deployments for which deployments are requested as identity specified.
       * @param {Date} minStartedTime - List the deployments with StartedOn time >= minStartedTime.
       * @param {Date} maxStartedTime - List the deployments with StartedOn time <= maxStartedTime.
       * @param {string} sourceBranch - List the deployments that are deployed from given branch name.
       */
      getDeployments(project, definitionId, definitionEnvironmentId, createdBy, minModifiedTime, maxModifiedTime, deploymentStatus, operationStatus, latestAttemptsOnly, queryOrder, top, continuationToken, createdFor, minStartedTime, maxStartedTime, sourceBranch) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              definitionId,
              definitionEnvironmentId,
              createdBy,
              minModifiedTime,
              maxModifiedTime,
              deploymentStatus,
              operationStatus,
              latestAttemptsOnly,
              queryOrder,
              "$top": top,
              continuationToken,
              createdFor,
              minStartedTime,
              maxStartedTime,
              sourceBranch
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "b005ef73-cddc-448e-9ba2-5193bf36b19f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Deployment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {ReleaseInterfaces.DeploymentQueryParameters} queryParameters
       * @param {string} project - Project ID or project name
       */
      getDeploymentsForMultipleEnvironments(queryParameters, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "b005ef73-cddc-448e-9ba2-5193bf36b19f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, queryParameters, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Deployment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a release environment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of the release environment.
       * @param {ReleaseInterfaces.ReleaseEnvironmentExpands} expand - A property that should be expanded in the environment.
       */
      getReleaseEnvironment(project, releaseId, environmentId, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "Release", "a7e426b1-03dc-48af-9dfe-c98bac612dcb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseEnvironment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the status of a release environment
       *
       * @param {ReleaseInterfaces.ReleaseEnvironmentUpdateMetadata} environmentUpdateData - Environment update meta data.
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of release environment.
       */
      updateReleaseEnvironment(environmentUpdateData, project, releaseId, environmentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.7", "Release", "a7e426b1-03dc-48af-9dfe-c98bac612dcb", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, environmentUpdateData, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseEnvironment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a definition environment template
       *
       * @param {ReleaseInterfaces.ReleaseDefinitionEnvironmentTemplate} template - Definition environment template to create
       * @param {string} project - Project ID or project name
       */
      createDefinitionEnvironmentTemplate(template2, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "6b03b696-824e-4479-8eb2-6644a51aba89", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, template2, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinitionEnvironmentTemplate, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a definition environment template
       *
       * @param {string} project - Project ID or project name
       * @param {string} templateId - Id of the definition environment template
       */
      deleteDefinitionEnvironmentTemplate(project, templateId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (templateId == null) {
            throw new TypeError("templateId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "6b03b696-824e-4479-8eb2-6644a51aba89", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a definition environment template
       *
       * @param {string} project - Project ID or project name
       * @param {string} templateId - Id of the definition environment template
       */
      getDefinitionEnvironmentTemplate(project, templateId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (templateId == null) {
            throw new TypeError("templateId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "6b03b696-824e-4479-8eb2-6644a51aba89", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinitionEnvironmentTemplate, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of definition environment templates
       *
       * @param {string} project - Project ID or project name
       * @param {boolean} isDeleted - 'true' to get definition environment templates that have been deleted. Default is 'false'
       */
      listDefinitionEnvironmentTemplates(project, isDeleted) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              isDeleted
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "6b03b696-824e-4479-8eb2-6644a51aba89", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinitionEnvironmentTemplate, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Undelete a release definition environment template.
       *
       * @param {string} project - Project ID or project name
       * @param {string} templateId - Id of the definition environment template to be undeleted
       */
      undeleteReleaseDefinitionEnvironmentTemplate(project, templateId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (templateId == null) {
            throw new TypeError("templateId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "6b03b696-824e-4479-8eb2-6644a51aba89", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, null, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinitionEnvironmentTemplate, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {ReleaseInterfaces.FavoriteItem[]} favoriteItems
       * @param {string} project - Project ID or project name
       * @param {string} scope
       * @param {string} identityId
       */
      createFavorites(favoriteItems, project, scope, identityId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              scope
            };
            let queryValues = {
              identityId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "938f7222-9acb-48fe-b8a3-4eda04597171", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, favoriteItems, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} scope
       * @param {string} identityId
       * @param {string} favoriteItemIds
       */
      deleteFavorites(project, scope, identityId, favoriteItemIds) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              scope
            };
            let queryValues = {
              identityId,
              favoriteItemIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "938f7222-9acb-48fe-b8a3-4eda04597171", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} scope
       * @param {string} identityId
       */
      getFavorites(project, scope, identityId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              scope
            };
            let queryValues = {
              identityId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "938f7222-9acb-48fe-b8a3-4eda04597171", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} flightName
       */
      getFlightAssignments(flightName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              flightName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "409d301f-3046-46f3-beb9-4357fbce0a8c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new folder.
       *
       * @param {ReleaseInterfaces.Folder} folder - folder.
       * @param {string} project - Project ID or project name
       * @param {string} path - Path of the folder.
       */
      createFolder(folder, project, path2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              path: path2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "f7ddf76d-ce0c-4d68-94ff-becaec5d9dea", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, folder, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Folder, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a definition folder for given folder name and path and all it's existing definitions.
       *
       * @param {string} project - Project ID or project name
       * @param {string} path - Path of the folder to delete.
       */
      deleteFolder(project, path2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              path: path2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "f7ddf76d-ce0c-4d68-94ff-becaec5d9dea", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets folders.
       *
       * @param {string} project - Project ID or project name
       * @param {string} path - Path of the folder.
       * @param {ReleaseInterfaces.FolderPathQueryOrder} queryOrder - Gets the results in the defined order. Default is 'None'.
       */
      getFolders(project, path2, queryOrder) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              path: path2
            };
            let queryValues = {
              queryOrder
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "f7ddf76d-ce0c-4d68-94ff-becaec5d9dea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Folder, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates an existing folder at given existing path.
       *
       * @param {ReleaseInterfaces.Folder} folder - folder.
       * @param {string} project - Project ID or project name
       * @param {string} path - Path of the folder to update.
       */
      updateFolder(folder, project, path2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              path: path2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "f7ddf76d-ce0c-4d68-94ff-becaec5d9dea", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, folder, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Folder, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates the gate for a deployment.
       *
       * @param {ReleaseInterfaces.GateUpdateMetadata} gateUpdateMetadata - Metadata to patch the Release Gates.
       * @param {string} project - Project ID or project name
       * @param {number} gateStepId - Gate step Id.
       */
      updateGates(gateUpdateMetadata, project, gateStepId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              gateStepId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "2666a539-2001-4f80-bcc7-0379956749d4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, gateUpdateMetadata, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseGates, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       */
      getReleaseHistory(project, releaseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "23f461c8-629a-4144-a076-3054fa5f268a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseRevision, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {FormInputInterfaces.InputValuesQuery} query
       * @param {string} project - Project ID or project name
       */
      getInputValues(query, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "71dd499b-317d-45ea-9134-140ea1932b5e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, query, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} sourceId
       */
      getIssues(project, buildId, sourceId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            let queryValues = {
              sourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "cd42261a-f5c6-41c8-9259-f078989b9f25", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.AutoTriggerIssue, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets gate logs
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of release environment.
       * @param {number} gateId - Id of the gate.
       * @param {number} taskId - ReleaseTask Id for the log.
       */
      getGateLog(project, releaseId, environmentId, gateId, taskId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              gateId,
              taskId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "dec7ca5a-7f7f-4797-8bf1-8efc0dc93b28", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get logs for a release Id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       */
      getLogs(project, releaseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "c37fbab5-214b-48e4-a55b-cb6b4f6e4038", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets logs
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of release environment.
       * @param {number} taskId - ReleaseTask Id for the log.
       * @param {number} attemptId - Id of the attempt.
       */
      getLog(project, releaseId, environmentId, taskId, attemptId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              taskId
            };
            let queryValues = {
              attemptId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "e71ba1ed-c0a4-4a28-a61f-2dd5f68cf3fd", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the task log of a release as a plain text file.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of release environment.
       * @param {number} attemptId
       * @param {string} timelineId
       * @param {number} taskId - ReleaseTask Id for the log.
       * @param {number} startLine - Starting line number for logs
       * @param {number} endLine - Ending line number for logs
       */
      getTaskLog2(project, releaseId, environmentId, attemptId, timelineId, taskId, startLine, endLine) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              attemptId,
              timelineId,
              taskId
            };
            let queryValues = {
              startLine,
              endLine
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "2577e6c3-6999-4400-bc69-fe1d837755fe", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the task log of a release as a plain text file.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} environmentId - Id of release environment.
       * @param {number} releaseDeployPhaseId - Release deploy phase Id.
       * @param {number} taskId - ReleaseTask Id for the log.
       * @param {number} startLine - Starting line number for logs
       * @param {number} endLine - Ending line number for logs
       */
      getTaskLog(project, releaseId, environmentId, releaseDeployPhaseId, taskId, startLine, endLine) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              releaseDeployPhaseId,
              taskId
            };
            let queryValues = {
              startLine,
              endLine
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "17c91af7-09fd-4256-bff1-c24ee4f73bc0", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get manual intervention for a given release and manual intervention id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} manualInterventionId - Id of the manual intervention.
       */
      getManualIntervention(project, releaseId, manualInterventionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              manualInterventionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "616c46e4-f370-4456-adaa-fbaf79c7b79e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ManualIntervention, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * List all manual interventions for a given release.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       */
      getManualInterventions(project, releaseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "616c46e4-f370-4456-adaa-fbaf79c7b79e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ManualIntervention, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update manual intervention.
       *
       * @param {ReleaseInterfaces.ManualInterventionUpdateMetadata} manualInterventionUpdateMetadata - Meta data to update manual intervention.
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} manualInterventionId - Id of the manual intervention.
       */
      updateManualIntervention(manualInterventionUpdateMetadata, project, releaseId, manualInterventionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              manualInterventionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "616c46e4-f370-4456-adaa-fbaf79c7b79e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, manualInterventionUpdateMetadata, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ManualIntervention, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {Date} minMetricsTime
       */
      getMetrics(project, minMetricsTime) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              minMetricsTime
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "cd1502bb-3c73-4e11-80a6-d11308dceae5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets Org pipeline release settings
       *
       */
      getOrgPipelineReleaseSettings() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "d156c759-ca4e-492b-90d4-db03971796ea", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates Org pipeline release settings
       *
       * @param {ReleaseInterfaces.OrgPipelineReleaseSettingsUpdateParameters} newSettings
       */
      updateOrgPipelineReleaseSettings(newSettings) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "d156c759-ca4e-492b-90d4-db03971796ea", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, newSettings, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets pipeline release settings
       *
       * @param {string} project - Project ID or project name
       */
      getPipelineReleaseSettings(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "e816b9f4-f9fe-46ba-bdcc-a9af6abf3144", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates pipeline release settings
       *
       * @param {ReleaseInterfaces.ProjectPipelineReleaseSettingsUpdateParameters} newSettings
       * @param {string} project - Project ID or project name
       */
      updatePipelineReleaseSettings(newSettings, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "e816b9f4-f9fe-46ba-bdcc-a9af6abf3144", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, newSettings, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} artifactType
       * @param {string} artifactSourceId
       */
      getReleaseProjects(artifactType, artifactSourceId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (artifactType == null) {
            throw new TypeError("artifactType can not be null or undefined");
          }
          if (artifactSourceId == null) {
            throw new TypeError("artifactSourceId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              artifactType,
              artifactSourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "917ace4a-79d1-45a7-987c-7be4db4268fa", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of releases
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - Releases from this release definition Id.
       * @param {number} definitionEnvironmentId
       * @param {string} searchText - Releases with names containing searchText.
       * @param {string} createdBy - Releases created by this user.
       * @param {ReleaseInterfaces.ReleaseStatus} statusFilter - Releases that have this status.
       * @param {number} environmentStatusFilter
       * @param {Date} minCreatedTime - Releases that were created after this time.
       * @param {Date} maxCreatedTime - Releases that were created before this time.
       * @param {ReleaseInterfaces.ReleaseQueryOrder} queryOrder - Gets the results in the defined order of created date for releases. Default is descending.
       * @param {number} top - Number of releases to get. Default is 50.
       * @param {number} continuationToken - Gets the releases after the continuation token provided.
       * @param {ReleaseInterfaces.ReleaseExpands} expand - The property that should be expanded in the list of releases.
       * @param {string} artifactTypeId - Releases with given artifactTypeId will be returned. Values can be Build, Jenkins, GitHub, Nuget, Team Build (external), ExternalTFSBuild, Git, TFVC, ExternalTfsXamlBuild.
       * @param {string} sourceId - Unique identifier of the artifact used. e.g. For build it would be {projectGuid}:{BuildDefinitionId}, for Jenkins it would be {JenkinsConnectionId}:{JenkinsDefinitionId}, for TfsOnPrem it would be {TfsOnPremConnectionId}:{ProjectName}:{TfsOnPremDefinitionId}. For third-party artifacts e.g. TeamCity, BitBucket you may refer 'uniqueSourceIdentifier' inside vss-extension.json https://github.com/Microsoft/vsts-rm-extensions/blob/master/Extensions.
       * @param {string} artifactVersionId - Releases with given artifactVersionId will be returned. E.g. in case of Build artifactType, it is buildId.
       * @param {string} sourceBranchFilter - Releases with given sourceBranchFilter will be returned.
       * @param {boolean} isDeleted - Gets the soft deleted releases, if true.
       * @param {string[]} tagFilter - A comma-delimited list of tags. Only releases with these tags will be returned.
       * @param {string[]} propertyFilters - A comma-delimited list of extended properties to be retrieved. If set, the returned Releases will contain values for the specified property Ids (if they exist). If not set, properties will not be included. Note that this will not filter out any Release from results irrespective of whether it has property set or not.
       * @param {number[]} releaseIdFilter - A comma-delimited list of releases Ids. Only releases with these Ids will be returned.
       * @param {string} path - Releases under this folder path will be returned
       */
      getReleases(project, definitionId, definitionEnvironmentId, searchText, createdBy, statusFilter, environmentStatusFilter, minCreatedTime, maxCreatedTime, queryOrder, top, continuationToken, expand, artifactTypeId, sourceId, artifactVersionId, sourceBranchFilter, isDeleted, tagFilter, propertyFilters, releaseIdFilter, path2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              definitionId,
              definitionEnvironmentId,
              searchText,
              createdBy,
              statusFilter,
              environmentStatusFilter,
              minCreatedTime,
              maxCreatedTime,
              queryOrder,
              "$top": top,
              continuationToken,
              "$expand": expand,
              artifactTypeId,
              sourceId,
              artifactVersionId,
              sourceBranchFilter,
              isDeleted,
              tagFilter: tagFilter && tagFilter.join(","),
              propertyFilters: propertyFilters && propertyFilters.join(","),
              releaseIdFilter: releaseIdFilter && releaseIdFilter.join(","),
              path: path2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.8", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Release, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a release.
       *
       * @param {ReleaseInterfaces.ReleaseStartMetadata} releaseStartMetadata - Metadata to create a release.
       * @param {string} project - Project ID or project name
       */
      createRelease(releaseStartMetadata, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.8", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, releaseStartMetadata, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Release, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Soft delete a release
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {string} comment - Comment for deleting a release.
       */
      deleteRelease(project, releaseId, comment) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            let queryValues = {
              comment
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.8", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a Release
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {ReleaseInterfaces.ApprovalFilters} approvalFilters - A filter which would allow fetching approval steps selectively based on whether it is automated, or manual. This would also decide whether we should fetch pre and post approval snapshots. Assumes All by default
       * @param {string[]} propertyFilters - A comma-delimited list of extended properties to be retrieved. If set, the returned Release will contain values for the specified property Ids (if they exist). If not set, properties will not be included.
       * @param {ReleaseInterfaces.SingleReleaseExpands} expand - A property that should be expanded in the release.
       * @param {number} topGateRecords - Number of release gate records to get. Default is 5.
       */
      getRelease(project, releaseId, approvalFilters, propertyFilters, expand, topGateRecords) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            let queryValues = {
              approvalFilters,
              propertyFilters: propertyFilters && propertyFilters.join(","),
              "$expand": expand,
              "$topGateRecords": topGateRecords
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.8", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Release, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get release summary of a given definition Id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - Id of the definition to get release summary.
       * @param {number} releaseCount - Count of releases to be included in summary.
       * @param {boolean} includeArtifact - Include artifact details.Default is 'false'.
       * @param {number[]} definitionEnvironmentIdsFilter
       */
      getReleaseDefinitionSummary(project, definitionId, releaseCount, includeArtifact, definitionEnvironmentIdsFilter) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (definitionId == null) {
            throw new TypeError("definitionId can not be null or undefined");
          }
          if (releaseCount == null) {
            throw new TypeError("releaseCount can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              definitionId,
              releaseCount,
              includeArtifact,
              definitionEnvironmentIdsFilter: definitionEnvironmentIdsFilter && definitionEnvironmentIdsFilter.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.8", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinitionSummary, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get release for a given revision number.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release.
       * @param {number} definitionSnapshotRevision - Definition snapshot revision number.
       */
      getReleaseRevision(project, releaseId, definitionSnapshotRevision) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (definitionSnapshotRevision == null) {
            throw new TypeError("definitionSnapshotRevision can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            let queryValues = {
              definitionSnapshotRevision
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.8", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Undelete a soft deleted release.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of release to be undeleted.
       * @param {string} comment - Any comment for undeleting.
       */
      undeleteRelease(project, releaseId, comment) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (comment == null) {
            throw new TypeError("comment can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            let queryValues = {
              comment
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.8", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a complete release object.
       *
       * @param {ReleaseInterfaces.Release} release - Release object for update.
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release to update.
       */
      updateRelease(release, project, releaseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.8", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, release, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Release, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update few properties of a release.
       *
       * @param {ReleaseInterfaces.ReleaseUpdateMetadata} releaseUpdateMetadata - Properties of release to update.
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Id of the release to update.
       */
      updateReleaseResource(releaseUpdateMetadata, project, releaseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.8", "Release", "a166fde7-27ad-408e-ba75-703c2cc9d500", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, releaseUpdateMetadata, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.Release, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the release settings
       *
       * @param {string} project - Project ID or project name
       */
      getReleaseSettings(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "c63c3718-7cfd-41e0-b89b-81c1ca143437", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates the release settings
       *
       * @param {ReleaseInterfaces.ReleaseSettings} releaseSettings
       * @param {string} project - Project ID or project name
       */
      updateReleaseSettings(releaseSettings, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "c63c3718-7cfd-41e0-b89b-81c1ca143437", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, releaseSettings, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get release definition for a given definitionId and revision
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - Id of the definition.
       * @param {number} revision - Id of the revision.
       */
      getDefinitionRevision(project, definitionId, revision) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId,
              revision
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "258b82e0-9d41-43f3-86d6-fef14ddd44bc", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get revision history for a release definition
       *
       * @param {string} project - Project ID or project name
       * @param {number} definitionId - Id of the definition.
       */
      getReleaseDefinitionHistory(project, definitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "Release", "258b82e0-9d41-43f3-86d6-fef14ddd44bc", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseDefinitionRevision, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       */
      getSummaryMailSections(project, releaseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "224e92b2-8d13-4c14-b120-13d877c516f8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.SummaryMailSection, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {ReleaseInterfaces.MailMessage} mailMessage
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       */
      sendSummaryMail(mailMessage, project, releaseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "224e92b2-8d13-4c14-b120-13d877c516f8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, mailMessage, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} definitionId
       */
      getSourceBranches(project, definitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "0e5def23-78b3-461f-8198-1558f25041c8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a tag to a definition
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseDefinitionId
       * @param {string} tag
       */
      addDefinitionTag(project, releaseDefinitionId, tag) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseDefinitionId,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "3d21b4c8-c32e-45b2-a7cb-770a369012f4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, null, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds multiple tags to a definition
       *
       * @param {string[]} tags
       * @param {string} project - Project ID or project name
       * @param {number} releaseDefinitionId
       */
      addDefinitionTags(tags, project, releaseDefinitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseDefinitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "3d21b4c8-c32e-45b2-a7cb-770a369012f4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, tags, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a tag from a definition
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseDefinitionId
       * @param {string} tag
       */
      deleteDefinitionTag(project, releaseDefinitionId, tag) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseDefinitionId,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "3d21b4c8-c32e-45b2-a7cb-770a369012f4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the tags for a definition
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseDefinitionId
       */
      getDefinitionTags(project, releaseDefinitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseDefinitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "3d21b4c8-c32e-45b2-a7cb-770a369012f4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a tag to a releaseId
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {string} tag
       */
      addReleaseTag(project, releaseId, tag) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "c5b602b6-d1b3-4363-8a51-94384f78068f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, null, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds tag to a release
       *
       * @param {string[]} tags
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       */
      addReleaseTags(tags, project, releaseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "c5b602b6-d1b3-4363-8a51-94384f78068f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, tags, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a tag from a release
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {string} tag
       */
      deleteReleaseTag(project, releaseId, tag) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              tag
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "c5b602b6-d1b3-4363-8a51-94384f78068f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the tags for a release
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       */
      getReleaseTags(project, releaseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "c5b602b6-d1b3-4363-8a51-94384f78068f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       */
      getTags(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "86cee25a-68ba-4ba3-9171-8ad6ffc6df93", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} environmentId
       * @param {number} releaseDeployPhaseId
       */
      getTasksForTaskGroup(project, releaseId, environmentId, releaseDeployPhaseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              releaseDeployPhaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "4259191d-4b0a-4409-9fb3-09f22ab9bc47", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseTask, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} environmentId
       * @param {number} attemptId
       * @param {string} timelineId
       */
      getTasks2(project, releaseId, environmentId, attemptId, timelineId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId,
              attemptId,
              timelineId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "4259291d-4b0a-4409-9fb3-04f22ab9bc47", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseTask, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} environmentId
       * @param {number} attemptId
       */
      getTasks(project, releaseId, environmentId, attemptId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId,
              environmentId
            };
            let queryValues = {
              attemptId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Release", "36b276e0-3c70-4320-a63c-1a2e1466a0d1", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ReleaseTask, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       */
      getArtifactTypeDefinitions(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "8efc2a3c-1fc8-4f6d-9822-75e98cecb48f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ArtifactTypeDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseDefinitionId
       */
      getArtifactVersions(project, releaseDefinitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (releaseDefinitionId == null) {
            throw new TypeError("releaseDefinitionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseDefinitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "30fc787e-a9e0-4a07-9fbc-3e903aa051d2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ArtifactVersionQueryResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {ReleaseInterfaces.Artifact[]} artifacts
       * @param {string} project - Project ID or project name
       */
      getArtifactVersionsForSources(artifacts, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "30fc787e-a9e0-4a07-9fbc-3e903aa051d2", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, artifacts, options);
              let ret = this.formatResponse(res.result, ReleaseInterfaces.TypeInfo.ArtifactVersionQueryResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} baseReleaseId
       * @param {number} top
       * @param {string} artifactAlias
       */
      getReleaseWorkItemsRefs(project, releaseId, baseReleaseId, top, artifactAlias) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              releaseId
            };
            let queryValues = {
              baseReleaseId,
              "$top": top,
              artifactAlias
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Release", "4f165cc0-875c-4768-b148-f12f78769fab", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.ReleaseApi = ReleaseApi;
    ReleaseApi.RESOURCE_AREA_ID = "efc2f575-36ef-48e9-b672-0c6fb4a48ac5";
  }
});

// ../node_modules/azure-devops-node-api/interfaces/SecurityRolesInterfaces.js
var require_SecurityRolesInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/SecurityRolesInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.RoleAccess = void 0;
    var RoleAccess;
    (function(RoleAccess2) {
      RoleAccess2[RoleAccess2["Assigned"] = 1] = "Assigned";
      RoleAccess2[RoleAccess2["Inherited"] = 2] = "Inherited";
    })(RoleAccess = exports2.RoleAccess || (exports2.RoleAccess = {}));
    exports2.TypeInfo = {
      RoleAccess: {
        enumValues: {
          "assigned": 1,
          "inherited": 2
        }
      },
      RoleAssignment: {}
    };
    exports2.TypeInfo.RoleAssignment.fields = {
      access: {
        enumType: exports2.TypeInfo.RoleAccess
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/SecurityRolesApi.js
var require_SecurityRolesApi = __commonJS({
  "../node_modules/azure-devops-node-api/SecurityRolesApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.SecurityRolesApi = void 0;
    var basem = require_ClientApiBases();
    var SecurityRolesInterfaces = require_SecurityRolesInterfaces();
    var SecurityRolesApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-SecurityRoles-api", options);
      }
      /**
       * @param {string} scopeId
       * @param {string} resourceId
       */
      getRoleAssignments(scopeId, resourceId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeId,
              resourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "securityroles", "9461c234-c84c-4ed2-b918-2f0f92ad0a35", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, SecurityRolesInterfaces.TypeInfo.RoleAssignment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeId
       * @param {string} resourceId
       * @param {string} identityId
       */
      removeRoleAssignment(scopeId, resourceId, identityId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeId,
              resourceId,
              identityId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "securityroles", "9461c234-c84c-4ed2-b918-2f0f92ad0a35", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string[]} identityIds
       * @param {string} scopeId
       * @param {string} resourceId
       */
      removeRoleAssignments(identityIds, scopeId, resourceId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeId,
              resourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "securityroles", "9461c234-c84c-4ed2-b918-2f0f92ad0a35", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, identityIds, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {SecurityRolesInterfaces.UserRoleAssignmentRef} roleAssignment
       * @param {string} scopeId
       * @param {string} resourceId
       * @param {string} identityId
       */
      setRoleAssignment(roleAssignment, scopeId, resourceId, identityId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeId,
              resourceId,
              identityId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "securityroles", "9461c234-c84c-4ed2-b918-2f0f92ad0a35", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, roleAssignment, options);
              let ret = this.formatResponse(res.result, SecurityRolesInterfaces.TypeInfo.RoleAssignment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {SecurityRolesInterfaces.UserRoleAssignmentRef[]} roleAssignments
       * @param {string} scopeId
       * @param {string} resourceId
       */
      setRoleAssignments(roleAssignments, scopeId, resourceId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeId,
              resourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "securityroles", "9461c234-c84c-4ed2-b918-2f0f92ad0a35", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, roleAssignments, options);
              let ret = this.formatResponse(res.result, SecurityRolesInterfaces.TypeInfo.RoleAssignment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeId
       */
      getRoleDefinitions(scopeId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("3.2-preview.1", "securityroles", "f4cc9a86-453c-48d2-b44d-d3bd5c105f4f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.SecurityRolesApi = SecurityRolesApi;
  }
});

// ../node_modules/azure-devops-node-api/interfaces/TaskAgentInterfaces.js
var require_TaskAgentInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/TaskAgentInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.VariableGroupQueryOrder = exports2.VariableGroupActionFilter = exports2.TimelineRecordState = exports2.TaskResult = exports2.TaskOrchestrationPlanState = exports2.TaskOrchestrationItemType = exports2.TaskGroupQueryOrder = exports2.TaskGroupExpands = exports2.TaskDefinitionStatus = exports2.TaskCommandMode = exports2.TaskAgentUpdateReasonType = exports2.TaskAgentStatusFilter = exports2.TaskAgentStatus = exports2.TaskAgentRequestUpdateOptions = exports2.TaskAgentQueueActionFilter = exports2.TaskAgentPoolType = exports2.TaskAgentPoolOptions = exports2.TaskAgentPoolMaintenanceScheduleDays = exports2.TaskAgentPoolMaintenanceJobStatus = exports2.TaskAgentPoolMaintenanceJobResult = exports2.TaskAgentPoolActionFilter = exports2.TaskAgentJobStepType = exports2.TaskAgentJobResultFilter = exports2.SecureFileActionFilter = exports2.ResourceLockStatus = exports2.PlanGroupStatusFilter = exports2.PlanGroupStatus = exports2.OrchestrationType = exports2.OperationType = exports2.OperatingSystemType = exports2.MaskType = exports2.MachineGroupActionFilter = exports2.LogLevel = exports2.IssueType = exports2.ExclusiveLockType = exports2.EnvironmentResourceType = exports2.EnvironmentExpands = exports2.EnvironmentActionFilter = exports2.ElasticPoolState = exports2.ElasticNodeState = exports2.ElasticComputeState = exports2.ElasticAgentState = exports2.DeploymentTargetExpands = exports2.DeploymentPoolSummaryExpands = exports2.DeploymentMachineExpands = exports2.DeploymentGroupExpands = exports2.DeploymentGroupActionFilter = exports2.DemandSourceType = exports2.AuditAction = exports2.AadLoginPromptOption = void 0;
    var FormInputInterfaces = require_FormInputInterfaces();
    var AadLoginPromptOption;
    (function(AadLoginPromptOption2) {
      AadLoginPromptOption2[AadLoginPromptOption2["NoOption"] = 0] = "NoOption";
      AadLoginPromptOption2[AadLoginPromptOption2["Login"] = 1] = "Login";
      AadLoginPromptOption2[AadLoginPromptOption2["SelectAccount"] = 2] = "SelectAccount";
      AadLoginPromptOption2[AadLoginPromptOption2["FreshLogin"] = 3] = "FreshLogin";
      AadLoginPromptOption2[AadLoginPromptOption2["FreshLoginWithMfa"] = 4] = "FreshLoginWithMfa";
    })(AadLoginPromptOption = exports2.AadLoginPromptOption || (exports2.AadLoginPromptOption = {}));
    var AuditAction;
    (function(AuditAction2) {
      AuditAction2[AuditAction2["Add"] = 1] = "Add";
      AuditAction2[AuditAction2["Update"] = 2] = "Update";
      AuditAction2[AuditAction2["Delete"] = 3] = "Delete";
      AuditAction2[AuditAction2["Undelete"] = 4] = "Undelete";
    })(AuditAction = exports2.AuditAction || (exports2.AuditAction = {}));
    var DemandSourceType;
    (function(DemandSourceType2) {
      DemandSourceType2[DemandSourceType2["Task"] = 0] = "Task";
      DemandSourceType2[DemandSourceType2["Feature"] = 1] = "Feature";
    })(DemandSourceType = exports2.DemandSourceType || (exports2.DemandSourceType = {}));
    var DeploymentGroupActionFilter;
    (function(DeploymentGroupActionFilter2) {
      DeploymentGroupActionFilter2[DeploymentGroupActionFilter2["None"] = 0] = "None";
      DeploymentGroupActionFilter2[DeploymentGroupActionFilter2["Manage"] = 2] = "Manage";
      DeploymentGroupActionFilter2[DeploymentGroupActionFilter2["Use"] = 16] = "Use";
    })(DeploymentGroupActionFilter = exports2.DeploymentGroupActionFilter || (exports2.DeploymentGroupActionFilter = {}));
    var DeploymentGroupExpands;
    (function(DeploymentGroupExpands2) {
      DeploymentGroupExpands2[DeploymentGroupExpands2["None"] = 0] = "None";
      DeploymentGroupExpands2[DeploymentGroupExpands2["Machines"] = 2] = "Machines";
      DeploymentGroupExpands2[DeploymentGroupExpands2["Tags"] = 4] = "Tags";
    })(DeploymentGroupExpands = exports2.DeploymentGroupExpands || (exports2.DeploymentGroupExpands = {}));
    var DeploymentMachineExpands;
    (function(DeploymentMachineExpands2) {
      DeploymentMachineExpands2[DeploymentMachineExpands2["None"] = 0] = "None";
      DeploymentMachineExpands2[DeploymentMachineExpands2["Capabilities"] = 2] = "Capabilities";
      DeploymentMachineExpands2[DeploymentMachineExpands2["AssignedRequest"] = 4] = "AssignedRequest";
    })(DeploymentMachineExpands = exports2.DeploymentMachineExpands || (exports2.DeploymentMachineExpands = {}));
    var DeploymentPoolSummaryExpands;
    (function(DeploymentPoolSummaryExpands2) {
      DeploymentPoolSummaryExpands2[DeploymentPoolSummaryExpands2["None"] = 0] = "None";
      DeploymentPoolSummaryExpands2[DeploymentPoolSummaryExpands2["DeploymentGroups"] = 2] = "DeploymentGroups";
      DeploymentPoolSummaryExpands2[DeploymentPoolSummaryExpands2["Resource"] = 4] = "Resource";
    })(DeploymentPoolSummaryExpands = exports2.DeploymentPoolSummaryExpands || (exports2.DeploymentPoolSummaryExpands = {}));
    var DeploymentTargetExpands;
    (function(DeploymentTargetExpands2) {
      DeploymentTargetExpands2[DeploymentTargetExpands2["None"] = 0] = "None";
      DeploymentTargetExpands2[DeploymentTargetExpands2["Capabilities"] = 2] = "Capabilities";
      DeploymentTargetExpands2[DeploymentTargetExpands2["AssignedRequest"] = 4] = "AssignedRequest";
      DeploymentTargetExpands2[DeploymentTargetExpands2["LastCompletedRequest"] = 8] = "LastCompletedRequest";
    })(DeploymentTargetExpands = exports2.DeploymentTargetExpands || (exports2.DeploymentTargetExpands = {}));
    var ElasticAgentState;
    (function(ElasticAgentState2) {
      ElasticAgentState2[ElasticAgentState2["None"] = 0] = "None";
      ElasticAgentState2[ElasticAgentState2["Enabled"] = 1] = "Enabled";
      ElasticAgentState2[ElasticAgentState2["Online"] = 2] = "Online";
      ElasticAgentState2[ElasticAgentState2["Assigned"] = 4] = "Assigned";
    })(ElasticAgentState = exports2.ElasticAgentState || (exports2.ElasticAgentState = {}));
    var ElasticComputeState;
    (function(ElasticComputeState2) {
      ElasticComputeState2[ElasticComputeState2["None"] = 0] = "None";
      ElasticComputeState2[ElasticComputeState2["Healthy"] = 1] = "Healthy";
      ElasticComputeState2[ElasticComputeState2["Creating"] = 2] = "Creating";
      ElasticComputeState2[ElasticComputeState2["Deleting"] = 3] = "Deleting";
      ElasticComputeState2[ElasticComputeState2["Failed"] = 4] = "Failed";
      ElasticComputeState2[ElasticComputeState2["Stopped"] = 5] = "Stopped";
      ElasticComputeState2[ElasticComputeState2["Reimaging"] = 6] = "Reimaging";
      ElasticComputeState2[ElasticComputeState2["UnhealthyVm"] = 7] = "UnhealthyVm";
      ElasticComputeState2[ElasticComputeState2["UnhealthyVmssVm"] = 8] = "UnhealthyVmssVm";
    })(ElasticComputeState = exports2.ElasticComputeState || (exports2.ElasticComputeState = {}));
    var ElasticNodeState;
    (function(ElasticNodeState2) {
      ElasticNodeState2[ElasticNodeState2["None"] = 0] = "None";
      ElasticNodeState2[ElasticNodeState2["New"] = 1] = "New";
      ElasticNodeState2[ElasticNodeState2["CreatingCompute"] = 2] = "CreatingCompute";
      ElasticNodeState2[ElasticNodeState2["StartingAgent"] = 3] = "StartingAgent";
      ElasticNodeState2[ElasticNodeState2["Idle"] = 4] = "Idle";
      ElasticNodeState2[ElasticNodeState2["Assigned"] = 5] = "Assigned";
      ElasticNodeState2[ElasticNodeState2["Offline"] = 6] = "Offline";
      ElasticNodeState2[ElasticNodeState2["PendingReimage"] = 7] = "PendingReimage";
      ElasticNodeState2[ElasticNodeState2["PendingDelete"] = 8] = "PendingDelete";
      ElasticNodeState2[ElasticNodeState2["Saved"] = 9] = "Saved";
      ElasticNodeState2[ElasticNodeState2["DeletingCompute"] = 10] = "DeletingCompute";
      ElasticNodeState2[ElasticNodeState2["Deleted"] = 11] = "Deleted";
      ElasticNodeState2[ElasticNodeState2["Lost"] = 12] = "Lost";
      ElasticNodeState2[ElasticNodeState2["ReimagingCompute"] = 13] = "ReimagingCompute";
      ElasticNodeState2[ElasticNodeState2["RestartingAgent"] = 14] = "RestartingAgent";
      ElasticNodeState2[ElasticNodeState2["FailedToStartPendingDelete"] = 15] = "FailedToStartPendingDelete";
      ElasticNodeState2[ElasticNodeState2["FailedToRestartPendingDelete"] = 16] = "FailedToRestartPendingDelete";
      ElasticNodeState2[ElasticNodeState2["FailedVMPendingDelete"] = 17] = "FailedVMPendingDelete";
      ElasticNodeState2[ElasticNodeState2["AssignedPendingDelete"] = 18] = "AssignedPendingDelete";
      ElasticNodeState2[ElasticNodeState2["RetryDelete"] = 19] = "RetryDelete";
      ElasticNodeState2[ElasticNodeState2["UnhealthyVm"] = 20] = "UnhealthyVm";
      ElasticNodeState2[ElasticNodeState2["UnhealthyVmPendingDelete"] = 21] = "UnhealthyVmPendingDelete";
    })(ElasticNodeState = exports2.ElasticNodeState || (exports2.ElasticNodeState = {}));
    var ElasticPoolState;
    (function(ElasticPoolState2) {
      ElasticPoolState2[ElasticPoolState2["Online"] = 0] = "Online";
      ElasticPoolState2[ElasticPoolState2["Offline"] = 1] = "Offline";
      ElasticPoolState2[ElasticPoolState2["Unhealthy"] = 2] = "Unhealthy";
      ElasticPoolState2[ElasticPoolState2["New"] = 3] = "New";
    })(ElasticPoolState = exports2.ElasticPoolState || (exports2.ElasticPoolState = {}));
    var EnvironmentActionFilter;
    (function(EnvironmentActionFilter2) {
      EnvironmentActionFilter2[EnvironmentActionFilter2["None"] = 0] = "None";
      EnvironmentActionFilter2[EnvironmentActionFilter2["Manage"] = 2] = "Manage";
      EnvironmentActionFilter2[EnvironmentActionFilter2["Use"] = 16] = "Use";
    })(EnvironmentActionFilter = exports2.EnvironmentActionFilter || (exports2.EnvironmentActionFilter = {}));
    var EnvironmentExpands;
    (function(EnvironmentExpands2) {
      EnvironmentExpands2[EnvironmentExpands2["None"] = 0] = "None";
      EnvironmentExpands2[EnvironmentExpands2["ResourceReferences"] = 1] = "ResourceReferences";
    })(EnvironmentExpands = exports2.EnvironmentExpands || (exports2.EnvironmentExpands = {}));
    var EnvironmentResourceType;
    (function(EnvironmentResourceType2) {
      EnvironmentResourceType2[EnvironmentResourceType2["Undefined"] = 0] = "Undefined";
      EnvironmentResourceType2[EnvironmentResourceType2["Generic"] = 1] = "Generic";
      EnvironmentResourceType2[EnvironmentResourceType2["VirtualMachine"] = 2] = "VirtualMachine";
      EnvironmentResourceType2[EnvironmentResourceType2["Kubernetes"] = 4] = "Kubernetes";
    })(EnvironmentResourceType = exports2.EnvironmentResourceType || (exports2.EnvironmentResourceType = {}));
    var ExclusiveLockType;
    (function(ExclusiveLockType2) {
      ExclusiveLockType2[ExclusiveLockType2["RunLatest"] = 0] = "RunLatest";
      ExclusiveLockType2[ExclusiveLockType2["Sequential"] = 1] = "Sequential";
      ExclusiveLockType2[ExclusiveLockType2["BranchRunLatest"] = 2] = "BranchRunLatest";
      ExclusiveLockType2[ExclusiveLockType2["Parallel"] = 3] = "Parallel";
    })(ExclusiveLockType = exports2.ExclusiveLockType || (exports2.ExclusiveLockType = {}));
    var IssueType;
    (function(IssueType2) {
      IssueType2[IssueType2["Error"] = 1] = "Error";
      IssueType2[IssueType2["Warning"] = 2] = "Warning";
    })(IssueType = exports2.IssueType || (exports2.IssueType = {}));
    var LogLevel;
    (function(LogLevel2) {
      LogLevel2[LogLevel2["Error"] = 0] = "Error";
      LogLevel2[LogLevel2["Warning"] = 1] = "Warning";
      LogLevel2[LogLevel2["Info"] = 2] = "Info";
    })(LogLevel = exports2.LogLevel || (exports2.LogLevel = {}));
    var MachineGroupActionFilter;
    (function(MachineGroupActionFilter2) {
      MachineGroupActionFilter2[MachineGroupActionFilter2["None"] = 0] = "None";
      MachineGroupActionFilter2[MachineGroupActionFilter2["Manage"] = 2] = "Manage";
      MachineGroupActionFilter2[MachineGroupActionFilter2["Use"] = 16] = "Use";
    })(MachineGroupActionFilter = exports2.MachineGroupActionFilter || (exports2.MachineGroupActionFilter = {}));
    var MaskType;
    (function(MaskType2) {
      MaskType2[MaskType2["Variable"] = 1] = "Variable";
      MaskType2[MaskType2["Regex"] = 2] = "Regex";
    })(MaskType = exports2.MaskType || (exports2.MaskType = {}));
    var OperatingSystemType;
    (function(OperatingSystemType2) {
      OperatingSystemType2[OperatingSystemType2["Windows"] = 0] = "Windows";
      OperatingSystemType2[OperatingSystemType2["Linux"] = 1] = "Linux";
    })(OperatingSystemType = exports2.OperatingSystemType || (exports2.OperatingSystemType = {}));
    var OperationType;
    (function(OperationType2) {
      OperationType2[OperationType2["ConfigurationJob"] = 0] = "ConfigurationJob";
      OperationType2[OperationType2["SizingJob"] = 1] = "SizingJob";
      OperationType2[OperationType2["IncreaseCapacity"] = 2] = "IncreaseCapacity";
      OperationType2[OperationType2["Reimage"] = 3] = "Reimage";
      OperationType2[OperationType2["DeleteVMs"] = 4] = "DeleteVMs";
    })(OperationType = exports2.OperationType || (exports2.OperationType = {}));
    var OrchestrationType;
    (function(OrchestrationType2) {
      OrchestrationType2[OrchestrationType2["Uniform"] = 0] = "Uniform";
      OrchestrationType2[OrchestrationType2["Flexible"] = 1] = "Flexible";
    })(OrchestrationType = exports2.OrchestrationType || (exports2.OrchestrationType = {}));
    var PlanGroupStatus;
    (function(PlanGroupStatus2) {
      PlanGroupStatus2[PlanGroupStatus2["Running"] = 1] = "Running";
      PlanGroupStatus2[PlanGroupStatus2["Queued"] = 2] = "Queued";
      PlanGroupStatus2[PlanGroupStatus2["All"] = 3] = "All";
    })(PlanGroupStatus = exports2.PlanGroupStatus || (exports2.PlanGroupStatus = {}));
    var PlanGroupStatusFilter;
    (function(PlanGroupStatusFilter2) {
      PlanGroupStatusFilter2[PlanGroupStatusFilter2["Running"] = 1] = "Running";
      PlanGroupStatusFilter2[PlanGroupStatusFilter2["Queued"] = 2] = "Queued";
      PlanGroupStatusFilter2[PlanGroupStatusFilter2["All"] = 3] = "All";
    })(PlanGroupStatusFilter = exports2.PlanGroupStatusFilter || (exports2.PlanGroupStatusFilter = {}));
    var ResourceLockStatus;
    (function(ResourceLockStatus2) {
      ResourceLockStatus2[ResourceLockStatus2["Queued"] = 0] = "Queued";
      ResourceLockStatus2[ResourceLockStatus2["InUse"] = 1] = "InUse";
      ResourceLockStatus2[ResourceLockStatus2["Finished"] = 2] = "Finished";
      ResourceLockStatus2[ResourceLockStatus2["TimedOut"] = 3] = "TimedOut";
      ResourceLockStatus2[ResourceLockStatus2["Canceled"] = 4] = "Canceled";
      ResourceLockStatus2[ResourceLockStatus2["Abandoned"] = 5] = "Abandoned";
      ResourceLockStatus2[ResourceLockStatus2["WaitingOnChecks"] = 6] = "WaitingOnChecks";
    })(ResourceLockStatus = exports2.ResourceLockStatus || (exports2.ResourceLockStatus = {}));
    var SecureFileActionFilter;
    (function(SecureFileActionFilter2) {
      SecureFileActionFilter2[SecureFileActionFilter2["None"] = 0] = "None";
      SecureFileActionFilter2[SecureFileActionFilter2["Manage"] = 2] = "Manage";
      SecureFileActionFilter2[SecureFileActionFilter2["Use"] = 16] = "Use";
    })(SecureFileActionFilter = exports2.SecureFileActionFilter || (exports2.SecureFileActionFilter = {}));
    var TaskAgentJobResultFilter;
    (function(TaskAgentJobResultFilter2) {
      TaskAgentJobResultFilter2[TaskAgentJobResultFilter2["Failed"] = 1] = "Failed";
      TaskAgentJobResultFilter2[TaskAgentJobResultFilter2["Passed"] = 2] = "Passed";
      TaskAgentJobResultFilter2[TaskAgentJobResultFilter2["NeverDeployed"] = 4] = "NeverDeployed";
      TaskAgentJobResultFilter2[TaskAgentJobResultFilter2["All"] = 7] = "All";
    })(TaskAgentJobResultFilter = exports2.TaskAgentJobResultFilter || (exports2.TaskAgentJobResultFilter = {}));
    var TaskAgentJobStepType;
    (function(TaskAgentJobStepType2) {
      TaskAgentJobStepType2[TaskAgentJobStepType2["Task"] = 1] = "Task";
      TaskAgentJobStepType2[TaskAgentJobStepType2["Action"] = 2] = "Action";
    })(TaskAgentJobStepType = exports2.TaskAgentJobStepType || (exports2.TaskAgentJobStepType = {}));
    var TaskAgentPoolActionFilter;
    (function(TaskAgentPoolActionFilter2) {
      TaskAgentPoolActionFilter2[TaskAgentPoolActionFilter2["None"] = 0] = "None";
      TaskAgentPoolActionFilter2[TaskAgentPoolActionFilter2["Manage"] = 2] = "Manage";
      TaskAgentPoolActionFilter2[TaskAgentPoolActionFilter2["Use"] = 16] = "Use";
    })(TaskAgentPoolActionFilter = exports2.TaskAgentPoolActionFilter || (exports2.TaskAgentPoolActionFilter = {}));
    var TaskAgentPoolMaintenanceJobResult;
    (function(TaskAgentPoolMaintenanceJobResult2) {
      TaskAgentPoolMaintenanceJobResult2[TaskAgentPoolMaintenanceJobResult2["Succeeded"] = 1] = "Succeeded";
      TaskAgentPoolMaintenanceJobResult2[TaskAgentPoolMaintenanceJobResult2["Failed"] = 2] = "Failed";
      TaskAgentPoolMaintenanceJobResult2[TaskAgentPoolMaintenanceJobResult2["Canceled"] = 4] = "Canceled";
    })(TaskAgentPoolMaintenanceJobResult = exports2.TaskAgentPoolMaintenanceJobResult || (exports2.TaskAgentPoolMaintenanceJobResult = {}));
    var TaskAgentPoolMaintenanceJobStatus;
    (function(TaskAgentPoolMaintenanceJobStatus2) {
      TaskAgentPoolMaintenanceJobStatus2[TaskAgentPoolMaintenanceJobStatus2["InProgress"] = 1] = "InProgress";
      TaskAgentPoolMaintenanceJobStatus2[TaskAgentPoolMaintenanceJobStatus2["Completed"] = 2] = "Completed";
      TaskAgentPoolMaintenanceJobStatus2[TaskAgentPoolMaintenanceJobStatus2["Cancelling"] = 4] = "Cancelling";
      TaskAgentPoolMaintenanceJobStatus2[TaskAgentPoolMaintenanceJobStatus2["Queued"] = 8] = "Queued";
    })(TaskAgentPoolMaintenanceJobStatus = exports2.TaskAgentPoolMaintenanceJobStatus || (exports2.TaskAgentPoolMaintenanceJobStatus = {}));
    var TaskAgentPoolMaintenanceScheduleDays;
    (function(TaskAgentPoolMaintenanceScheduleDays2) {
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["None"] = 0] = "None";
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["Monday"] = 1] = "Monday";
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["Tuesday"] = 2] = "Tuesday";
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["Wednesday"] = 4] = "Wednesday";
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["Thursday"] = 8] = "Thursday";
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["Friday"] = 16] = "Friday";
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["Saturday"] = 32] = "Saturday";
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["Sunday"] = 64] = "Sunday";
      TaskAgentPoolMaintenanceScheduleDays2[TaskAgentPoolMaintenanceScheduleDays2["All"] = 127] = "All";
    })(TaskAgentPoolMaintenanceScheduleDays = exports2.TaskAgentPoolMaintenanceScheduleDays || (exports2.TaskAgentPoolMaintenanceScheduleDays = {}));
    var TaskAgentPoolOptions;
    (function(TaskAgentPoolOptions2) {
      TaskAgentPoolOptions2[TaskAgentPoolOptions2["None"] = 0] = "None";
      TaskAgentPoolOptions2[TaskAgentPoolOptions2["ElasticPool"] = 1] = "ElasticPool";
      TaskAgentPoolOptions2[TaskAgentPoolOptions2["SingleUseAgents"] = 2] = "SingleUseAgents";
      TaskAgentPoolOptions2[TaskAgentPoolOptions2["PreserveAgentOnJobFailure"] = 4] = "PreserveAgentOnJobFailure";
    })(TaskAgentPoolOptions = exports2.TaskAgentPoolOptions || (exports2.TaskAgentPoolOptions = {}));
    var TaskAgentPoolType;
    (function(TaskAgentPoolType2) {
      TaskAgentPoolType2[TaskAgentPoolType2["Automation"] = 1] = "Automation";
      TaskAgentPoolType2[TaskAgentPoolType2["Deployment"] = 2] = "Deployment";
    })(TaskAgentPoolType = exports2.TaskAgentPoolType || (exports2.TaskAgentPoolType = {}));
    var TaskAgentQueueActionFilter;
    (function(TaskAgentQueueActionFilter2) {
      TaskAgentQueueActionFilter2[TaskAgentQueueActionFilter2["None"] = 0] = "None";
      TaskAgentQueueActionFilter2[TaskAgentQueueActionFilter2["Manage"] = 2] = "Manage";
      TaskAgentQueueActionFilter2[TaskAgentQueueActionFilter2["Use"] = 16] = "Use";
    })(TaskAgentQueueActionFilter = exports2.TaskAgentQueueActionFilter || (exports2.TaskAgentQueueActionFilter = {}));
    var TaskAgentRequestUpdateOptions;
    (function(TaskAgentRequestUpdateOptions2) {
      TaskAgentRequestUpdateOptions2[TaskAgentRequestUpdateOptions2["None"] = 0] = "None";
      TaskAgentRequestUpdateOptions2[TaskAgentRequestUpdateOptions2["BumpRequestToTop"] = 1] = "BumpRequestToTop";
    })(TaskAgentRequestUpdateOptions = exports2.TaskAgentRequestUpdateOptions || (exports2.TaskAgentRequestUpdateOptions = {}));
    var TaskAgentStatus;
    (function(TaskAgentStatus2) {
      TaskAgentStatus2[TaskAgentStatus2["Offline"] = 1] = "Offline";
      TaskAgentStatus2[TaskAgentStatus2["Online"] = 2] = "Online";
    })(TaskAgentStatus = exports2.TaskAgentStatus || (exports2.TaskAgentStatus = {}));
    var TaskAgentStatusFilter;
    (function(TaskAgentStatusFilter2) {
      TaskAgentStatusFilter2[TaskAgentStatusFilter2["Offline"] = 1] = "Offline";
      TaskAgentStatusFilter2[TaskAgentStatusFilter2["Online"] = 2] = "Online";
      TaskAgentStatusFilter2[TaskAgentStatusFilter2["All"] = 3] = "All";
    })(TaskAgentStatusFilter = exports2.TaskAgentStatusFilter || (exports2.TaskAgentStatusFilter = {}));
    var TaskAgentUpdateReasonType;
    (function(TaskAgentUpdateReasonType2) {
      TaskAgentUpdateReasonType2[TaskAgentUpdateReasonType2["Manual"] = 1] = "Manual";
      TaskAgentUpdateReasonType2[TaskAgentUpdateReasonType2["MinAgentVersionRequired"] = 2] = "MinAgentVersionRequired";
      TaskAgentUpdateReasonType2[TaskAgentUpdateReasonType2["Downgrade"] = 3] = "Downgrade";
    })(TaskAgentUpdateReasonType = exports2.TaskAgentUpdateReasonType || (exports2.TaskAgentUpdateReasonType = {}));
    var TaskCommandMode;
    (function(TaskCommandMode2) {
      TaskCommandMode2[TaskCommandMode2["Any"] = 0] = "Any";
      TaskCommandMode2[TaskCommandMode2["Restricted"] = 1] = "Restricted";
    })(TaskCommandMode = exports2.TaskCommandMode || (exports2.TaskCommandMode = {}));
    var TaskDefinitionStatus;
    (function(TaskDefinitionStatus2) {
      TaskDefinitionStatus2[TaskDefinitionStatus2["Preinstalled"] = 1] = "Preinstalled";
      TaskDefinitionStatus2[TaskDefinitionStatus2["ReceivedInstallOrUpdate"] = 2] = "ReceivedInstallOrUpdate";
      TaskDefinitionStatus2[TaskDefinitionStatus2["Installed"] = 3] = "Installed";
      TaskDefinitionStatus2[TaskDefinitionStatus2["ReceivedUninstall"] = 4] = "ReceivedUninstall";
      TaskDefinitionStatus2[TaskDefinitionStatus2["Uninstalled"] = 5] = "Uninstalled";
      TaskDefinitionStatus2[TaskDefinitionStatus2["RequestedUpdate"] = 6] = "RequestedUpdate";
      TaskDefinitionStatus2[TaskDefinitionStatus2["Updated"] = 7] = "Updated";
      TaskDefinitionStatus2[TaskDefinitionStatus2["AlreadyUpToDate"] = 8] = "AlreadyUpToDate";
      TaskDefinitionStatus2[TaskDefinitionStatus2["InlineUpdateReceived"] = 9] = "InlineUpdateReceived";
    })(TaskDefinitionStatus = exports2.TaskDefinitionStatus || (exports2.TaskDefinitionStatus = {}));
    var TaskGroupExpands;
    (function(TaskGroupExpands2) {
      TaskGroupExpands2[TaskGroupExpands2["None"] = 0] = "None";
      TaskGroupExpands2[TaskGroupExpands2["Tasks"] = 2] = "Tasks";
    })(TaskGroupExpands = exports2.TaskGroupExpands || (exports2.TaskGroupExpands = {}));
    var TaskGroupQueryOrder;
    (function(TaskGroupQueryOrder2) {
      TaskGroupQueryOrder2[TaskGroupQueryOrder2["CreatedOnAscending"] = 0] = "CreatedOnAscending";
      TaskGroupQueryOrder2[TaskGroupQueryOrder2["CreatedOnDescending"] = 1] = "CreatedOnDescending";
    })(TaskGroupQueryOrder = exports2.TaskGroupQueryOrder || (exports2.TaskGroupQueryOrder = {}));
    var TaskOrchestrationItemType;
    (function(TaskOrchestrationItemType2) {
      TaskOrchestrationItemType2[TaskOrchestrationItemType2["Container"] = 0] = "Container";
      TaskOrchestrationItemType2[TaskOrchestrationItemType2["Job"] = 1] = "Job";
    })(TaskOrchestrationItemType = exports2.TaskOrchestrationItemType || (exports2.TaskOrchestrationItemType = {}));
    var TaskOrchestrationPlanState;
    (function(TaskOrchestrationPlanState2) {
      TaskOrchestrationPlanState2[TaskOrchestrationPlanState2["InProgress"] = 1] = "InProgress";
      TaskOrchestrationPlanState2[TaskOrchestrationPlanState2["Queued"] = 2] = "Queued";
      TaskOrchestrationPlanState2[TaskOrchestrationPlanState2["Completed"] = 4] = "Completed";
      TaskOrchestrationPlanState2[TaskOrchestrationPlanState2["Throttled"] = 8] = "Throttled";
    })(TaskOrchestrationPlanState = exports2.TaskOrchestrationPlanState || (exports2.TaskOrchestrationPlanState = {}));
    var TaskResult;
    (function(TaskResult2) {
      TaskResult2[TaskResult2["Succeeded"] = 0] = "Succeeded";
      TaskResult2[TaskResult2["SucceededWithIssues"] = 1] = "SucceededWithIssues";
      TaskResult2[TaskResult2["Failed"] = 2] = "Failed";
      TaskResult2[TaskResult2["Canceled"] = 3] = "Canceled";
      TaskResult2[TaskResult2["Skipped"] = 4] = "Skipped";
      TaskResult2[TaskResult2["Abandoned"] = 5] = "Abandoned";
    })(TaskResult = exports2.TaskResult || (exports2.TaskResult = {}));
    var TimelineRecordState;
    (function(TimelineRecordState2) {
      TimelineRecordState2[TimelineRecordState2["Pending"] = 0] = "Pending";
      TimelineRecordState2[TimelineRecordState2["InProgress"] = 1] = "InProgress";
      TimelineRecordState2[TimelineRecordState2["Completed"] = 2] = "Completed";
    })(TimelineRecordState = exports2.TimelineRecordState || (exports2.TimelineRecordState = {}));
    var VariableGroupActionFilter;
    (function(VariableGroupActionFilter2) {
      VariableGroupActionFilter2[VariableGroupActionFilter2["None"] = 0] = "None";
      VariableGroupActionFilter2[VariableGroupActionFilter2["Manage"] = 2] = "Manage";
      VariableGroupActionFilter2[VariableGroupActionFilter2["Use"] = 16] = "Use";
    })(VariableGroupActionFilter = exports2.VariableGroupActionFilter || (exports2.VariableGroupActionFilter = {}));
    var VariableGroupQueryOrder;
    (function(VariableGroupQueryOrder2) {
      VariableGroupQueryOrder2[VariableGroupQueryOrder2["IdAscending"] = 0] = "IdAscending";
      VariableGroupQueryOrder2[VariableGroupQueryOrder2["IdDescending"] = 1] = "IdDescending";
    })(VariableGroupQueryOrder = exports2.VariableGroupQueryOrder || (exports2.VariableGroupQueryOrder = {}));
    exports2.TypeInfo = {
      AadLoginPromptOption: {
        enumValues: {
          "noOption": 0,
          "login": 1,
          "selectAccount": 2,
          "freshLogin": 3,
          "freshLoginWithMfa": 4
        }
      },
      AgentChangeEvent: {},
      AgentJobRequestMessage: {},
      AgentPoolEvent: {},
      AgentQueueEvent: {},
      AgentQueuesEvent: {},
      AuditAction: {
        enumValues: {
          "add": 1,
          "update": 2,
          "delete": 3,
          "undelete": 4
        }
      },
      AzureKeyVaultVariableGroupProviderData: {},
      AzureKeyVaultVariableValue: {},
      DemandMinimumVersion: {},
      DemandSource: {},
      DemandSourceType: {
        enumValues: {
          "task": 0,
          "feature": 1
        }
      },
      DeploymentGroup: {},
      DeploymentGroupActionFilter: {
        enumValues: {
          "none": 0,
          "manage": 2,
          "use": 16
        }
      },
      DeploymentGroupExpands: {
        enumValues: {
          "none": 0,
          "machines": 2,
          "tags": 4
        }
      },
      DeploymentGroupMetrics: {},
      DeploymentGroupReference: {},
      DeploymentMachine: {},
      DeploymentMachineChangedData: {},
      DeploymentMachineExpands: {
        enumValues: {
          "none": 0,
          "capabilities": 2,
          "assignedRequest": 4
        }
      },
      DeploymentMachineGroup: {},
      DeploymentMachineGroupReference: {},
      DeploymentMachinesChangeEvent: {},
      DeploymentPoolSummary: {},
      DeploymentPoolSummaryExpands: {
        enumValues: {
          "none": 0,
          "deploymentGroups": 2,
          "resource": 4
        }
      },
      DeploymentTargetExpands: {
        enumValues: {
          "none": 0,
          "capabilities": 2,
          "assignedRequest": 4,
          "lastCompletedRequest": 8
        }
      },
      ElasticAgentState: {
        enumValues: {
          "none": 0,
          "enabled": 1,
          "online": 2,
          "assigned": 4
        }
      },
      ElasticComputeState: {
        enumValues: {
          "none": 0,
          "healthy": 1,
          "creating": 2,
          "deleting": 3,
          "failed": 4,
          "stopped": 5,
          "reimaging": 6,
          "unhealthyVm": 7,
          "unhealthyVmssVm": 8
        }
      },
      ElasticNode: {},
      ElasticNodeSettings: {},
      ElasticNodeState: {
        enumValues: {
          "none": 0,
          "new": 1,
          "creatingCompute": 2,
          "startingAgent": 3,
          "idle": 4,
          "assigned": 5,
          "offline": 6,
          "pendingReimage": 7,
          "pendingDelete": 8,
          "saved": 9,
          "deletingCompute": 10,
          "deleted": 11,
          "lost": 12,
          "reimagingCompute": 13,
          "restartingAgent": 14,
          "failedToStartPendingDelete": 15,
          "failedToRestartPendingDelete": 16,
          "failedVMPendingDelete": 17,
          "assignedPendingDelete": 18,
          "retryDelete": 19,
          "unhealthyVm": 20,
          "unhealthyVmPendingDelete": 21
        }
      },
      ElasticPool: {},
      ElasticPoolCreationResult: {},
      ElasticPoolLog: {},
      ElasticPoolSettings: {},
      ElasticPoolState: {
        enumValues: {
          "online": 0,
          "offline": 1,
          "unhealthy": 2,
          "new": 3
        }
      },
      EnvironmentActionFilter: {
        enumValues: {
          "none": 0,
          "manage": 2,
          "use": 16
        }
      },
      EnvironmentDeploymentExecutionRecord: {},
      EnvironmentExpands: {
        enumValues: {
          "none": 0,
          "resourceReferences": 1
        }
      },
      EnvironmentInstance: {},
      EnvironmentResource: {},
      EnvironmentResourceDeploymentExecutionRecord: {},
      EnvironmentResourceReference: {},
      EnvironmentResourceType: {
        enumValues: {
          "undefined": 0,
          "generic": 1,
          "virtualMachine": 2,
          "kubernetes": 4
        }
      },
      ExclusiveLockType: {
        enumValues: {
          "runLatest": 0,
          "sequential": 1,
          "branchRunLatest": 2,
          "parallel": 3
        }
      },
      Issue: {},
      IssueType: {
        enumValues: {
          "error": 1,
          "warning": 2
        }
      },
      JobAssignedEvent: {},
      JobCompletedEvent: {},
      JobEnvironment: {},
      JobRequestMessage: {},
      KubernetesResource: {},
      LogLevel: {
        enumValues: {
          "error": 0,
          "warning": 1,
          "info": 2
        }
      },
      MachineGroupActionFilter: {
        enumValues: {
          "none": 0,
          "manage": 2,
          "use": 16
        }
      },
      MaskHint: {},
      MaskType: {
        enumValues: {
          "variable": 1,
          "regex": 2
        }
      },
      OperatingSystemType: {
        enumValues: {
          "windows": 0,
          "linux": 1
        }
      },
      OperationType: {
        enumValues: {
          "configurationJob": 0,
          "sizingJob": 1,
          "increaseCapacity": 2,
          "reimage": 3,
          "deleteVMs": 4
        }
      },
      OrchestrationType: {
        enumValues: {
          "uniform": 0,
          "flexible": 1
        }
      },
      PackageMetadata: {},
      PlanEnvironment: {},
      PlanGroupStatus: {
        enumValues: {
          "running": 1,
          "queued": 2,
          "all": 3
        }
      },
      PlanGroupStatusFilter: {
        enumValues: {
          "running": 1,
          "queued": 2,
          "all": 3
        }
      },
      ResourceLockRequest: {},
      ResourceLockStatus: {
        enumValues: {
          "queued": 0,
          "inUse": 1,
          "finished": 2,
          "timedOut": 3,
          "canceled": 4,
          "abandoned": 5,
          "waitingOnChecks": 6
        }
      },
      ResourceUsage: {},
      SecureFile: {},
      SecureFileActionFilter: {
        enumValues: {
          "none": 0,
          "manage": 2,
          "use": 16
        }
      },
      SecureFileEvent: {},
      ServerTaskRequestMessage: {},
      ServiceEndpointAuthenticationScheme: {},
      ServiceEndpointExecutionData: {},
      ServiceEndpointExecutionRecord: {},
      ServiceEndpointExecutionRecordsInput: {},
      ServiceEndpointRequestResult: {},
      ServiceEndpointType: {},
      TaskAgent: {},
      TaskAgentCloudRequest: {},
      TaskAgentCloudType: {},
      TaskAgentDowngrade: {},
      TaskAgentJob: {},
      TaskAgentJobRequest: {},
      TaskAgentJobResultFilter: {
        enumValues: {
          "failed": 1,
          "passed": 2,
          "neverDeployed": 4,
          "all": 7
        }
      },
      TaskAgentJobStep: {},
      TaskAgentJobStepType: {
        enumValues: {
          "task": 1,
          "action": 2
        }
      },
      TaskAgentManualUpdate: {},
      TaskAgentMinAgentVersionRequiredUpdate: {},
      TaskAgentPool: {},
      TaskAgentPoolActionFilter: {
        enumValues: {
          "none": 0,
          "manage": 2,
          "use": 16
        }
      },
      TaskAgentPoolMaintenanceDefinition: {},
      TaskAgentPoolMaintenanceJob: {},
      TaskAgentPoolMaintenanceJobResult: {
        enumValues: {
          "succeeded": 1,
          "failed": 2,
          "canceled": 4
        }
      },
      TaskAgentPoolMaintenanceJobStatus: {
        enumValues: {
          "inProgress": 1,
          "completed": 2,
          "cancelling": 4,
          "queued": 8
        }
      },
      TaskAgentPoolMaintenanceJobTargetAgent: {},
      TaskAgentPoolMaintenanceSchedule: {},
      TaskAgentPoolMaintenanceScheduleDays: {
        enumValues: {
          "none": 0,
          "monday": 1,
          "tuesday": 2,
          "wednesday": 4,
          "thursday": 8,
          "friday": 16,
          "saturday": 32,
          "sunday": 64,
          "all": 127
        }
      },
      TaskAgentPoolOptions: {
        enumValues: {
          "none": 0,
          "elasticPool": 1,
          "singleUseAgents": 2,
          "preserveAgentOnJobFailure": 4
        }
      },
      TaskAgentPoolReference: {},
      TaskAgentPoolStatus: {},
      TaskAgentPoolSummary: {},
      TaskAgentPoolType: {
        enumValues: {
          "automation": 1,
          "deployment": 2
        }
      },
      TaskAgentQueue: {},
      TaskAgentQueueActionFilter: {
        enumValues: {
          "none": 0,
          "manage": 2,
          "use": 16
        }
      },
      TaskAgentReference: {},
      TaskAgentRequestUpdateOptions: {
        enumValues: {
          "none": 0,
          "bumpRequestToTop": 1
        }
      },
      TaskAgentSession: {},
      TaskAgentStatus: {
        enumValues: {
          "offline": 1,
          "online": 2
        }
      },
      TaskAgentStatusFilter: {
        enumValues: {
          "offline": 1,
          "online": 2,
          "all": 3
        }
      },
      TaskAgentUpdate: {},
      TaskAgentUpdateReason: {},
      TaskAgentUpdateReasonType: {
        enumValues: {
          "manual": 1,
          "minAgentVersionRequired": 2,
          "downgrade": 3
        }
      },
      TaskAttachment: {},
      TaskCommandMode: {
        enumValues: {
          "any": 0,
          "restricted": 1
        }
      },
      TaskCommandRestrictions: {},
      TaskCompletedEvent: {},
      TaskDefinition: {},
      TaskDefinitionStatus: {
        enumValues: {
          "preinstalled": 1,
          "receivedInstallOrUpdate": 2,
          "installed": 3,
          "receivedUninstall": 4,
          "uninstalled": 5,
          "requestedUpdate": 6,
          "updated": 7,
          "alreadyUpToDate": 8,
          "inlineUpdateReceived": 9
        }
      },
      TaskGroup: {},
      TaskGroupExpands: {
        enumValues: {
          "none": 0,
          "tasks": 2
        }
      },
      TaskGroupQueryOrder: {
        enumValues: {
          "createdOnAscending": 0,
          "createdOnDescending": 1
        }
      },
      TaskGroupRevision: {},
      TaskLog: {},
      TaskOrchestrationContainer: {},
      TaskOrchestrationItem: {},
      TaskOrchestrationItemType: {
        enumValues: {
          "container": 0,
          "job": 1
        }
      },
      TaskOrchestrationJob: {},
      TaskOrchestrationPlan: {},
      TaskOrchestrationPlanGroup: {},
      TaskOrchestrationPlanGroupsQueueMetrics: {},
      TaskOrchestrationPlanState: {
        enumValues: {
          "inProgress": 1,
          "queued": 2,
          "completed": 4,
          "throttled": 8
        }
      },
      TaskOrchestrationQueuedPlan: {},
      TaskOrchestrationQueuedPlanGroup: {},
      TaskRestrictions: {},
      TaskResult: {
        enumValues: {
          "succeeded": 0,
          "succeededWithIssues": 1,
          "failed": 2,
          "canceled": 3,
          "skipped": 4,
          "abandoned": 5
        }
      },
      Timeline: {},
      TimelineRecord: {},
      TimelineRecordReference: {},
      TimelineRecordState: {
        enumValues: {
          "pending": 0,
          "inProgress": 1,
          "completed": 2
        }
      },
      VariableGroup: {},
      VariableGroupActionFilter: {
        enumValues: {
          "none": 0,
          "manage": 2,
          "use": 16
        }
      },
      VariableGroupQueryOrder: {
        enumValues: {
          "idAscending": 0,
          "idDescending": 1
        }
      },
      VirtualMachine: {},
      VirtualMachineGroup: {},
      VirtualMachineResource: {},
      VirtualMachineResourceCreateParameters: {}
    };
    exports2.TypeInfo.AgentChangeEvent.fields = {
      agent: {
        typeInfo: exports2.TypeInfo.TaskAgent
      },
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      },
      timeStamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.AgentJobRequestMessage.fields = {
      environment: {
        typeInfo: exports2.TypeInfo.JobEnvironment
      },
      lockedUntil: {
        isDate: true
      }
    };
    exports2.TypeInfo.AgentPoolEvent.fields = {
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPool
      }
    };
    exports2.TypeInfo.AgentQueueEvent.fields = {
      queue: {
        typeInfo: exports2.TypeInfo.TaskAgentQueue
      }
    };
    exports2.TypeInfo.AgentQueuesEvent.fields = {
      queues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskAgentQueue
      }
    };
    exports2.TypeInfo.AzureKeyVaultVariableGroupProviderData.fields = {
      lastRefreshedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.AzureKeyVaultVariableValue.fields = {
      expires: {
        isDate: true
      }
    };
    exports2.TypeInfo.DemandMinimumVersion.fields = {
      source: {
        typeInfo: exports2.TypeInfo.DemandSource
      }
    };
    exports2.TypeInfo.DemandSource.fields = {
      sourceType: {
        enumType: exports2.TypeInfo.DemandSourceType
      }
    };
    exports2.TypeInfo.DeploymentGroup.fields = {
      machines: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentMachine
      },
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      }
    };
    exports2.TypeInfo.DeploymentGroupMetrics.fields = {
      deploymentGroup: {
        typeInfo: exports2.TypeInfo.DeploymentGroupReference
      }
    };
    exports2.TypeInfo.DeploymentGroupReference.fields = {
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      }
    };
    exports2.TypeInfo.DeploymentMachine.fields = {
      agent: {
        typeInfo: exports2.TypeInfo.TaskAgent
      }
    };
    exports2.TypeInfo.DeploymentMachineChangedData.fields = {
      agent: {
        typeInfo: exports2.TypeInfo.TaskAgent
      }
    };
    exports2.TypeInfo.DeploymentMachineGroup.fields = {
      machines: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentMachine
      },
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      }
    };
    exports2.TypeInfo.DeploymentMachineGroupReference.fields = {
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      }
    };
    exports2.TypeInfo.DeploymentMachinesChangeEvent.fields = {
      machineGroupReference: {
        typeInfo: exports2.TypeInfo.DeploymentGroupReference
      },
      machines: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentMachineChangedData
      }
    };
    exports2.TypeInfo.DeploymentPoolSummary.fields = {
      deploymentGroups: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentGroupReference
      },
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      },
      resource: {
        typeInfo: exports2.TypeInfo.EnvironmentResourceReference
      }
    };
    exports2.TypeInfo.ElasticNode.fields = {
      agentState: {
        enumType: exports2.TypeInfo.ElasticAgentState
      },
      computeState: {
        enumType: exports2.TypeInfo.ElasticComputeState
      },
      desiredState: {
        enumType: exports2.TypeInfo.ElasticNodeState
      },
      state: {
        enumType: exports2.TypeInfo.ElasticNodeState
      },
      stateChangedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.ElasticNodeSettings.fields = {
      state: {
        enumType: exports2.TypeInfo.ElasticNodeState
      }
    };
    exports2.TypeInfo.ElasticPool.fields = {
      offlineSince: {
        isDate: true
      },
      orchestrationType: {
        enumType: exports2.TypeInfo.OrchestrationType
      },
      osType: {
        enumType: exports2.TypeInfo.OperatingSystemType
      },
      state: {
        enumType: exports2.TypeInfo.ElasticPoolState
      }
    };
    exports2.TypeInfo.ElasticPoolCreationResult.fields = {
      agentPool: {
        typeInfo: exports2.TypeInfo.TaskAgentPool
      },
      agentQueue: {
        typeInfo: exports2.TypeInfo.TaskAgentQueue
      },
      elasticPool: {
        typeInfo: exports2.TypeInfo.ElasticPool
      }
    };
    exports2.TypeInfo.ElasticPoolLog.fields = {
      level: {
        enumType: exports2.TypeInfo.LogLevel
      },
      operation: {
        enumType: exports2.TypeInfo.OperationType
      },
      timestamp: {
        isDate: true
      }
    };
    exports2.TypeInfo.ElasticPoolSettings.fields = {
      orchestrationType: {
        enumType: exports2.TypeInfo.OrchestrationType
      },
      osType: {
        enumType: exports2.TypeInfo.OperatingSystemType
      }
    };
    exports2.TypeInfo.EnvironmentDeploymentExecutionRecord.fields = {
      finishTime: {
        isDate: true
      },
      queueTime: {
        isDate: true
      },
      result: {
        enumType: exports2.TypeInfo.TaskResult
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.EnvironmentInstance.fields = {
      createdOn: {
        isDate: true
      },
      lastModifiedOn: {
        isDate: true
      },
      resources: {
        isArray: true,
        typeInfo: exports2.TypeInfo.EnvironmentResourceReference
      }
    };
    exports2.TypeInfo.EnvironmentResource.fields = {
      createdOn: {
        isDate: true
      },
      lastModifiedOn: {
        isDate: true
      },
      type: {
        enumType: exports2.TypeInfo.EnvironmentResourceType
      }
    };
    exports2.TypeInfo.EnvironmentResourceDeploymentExecutionRecord.fields = {
      finishTime: {
        isDate: true
      },
      result: {
        enumType: exports2.TypeInfo.TaskResult
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.EnvironmentResourceReference.fields = {
      type: {
        enumType: exports2.TypeInfo.EnvironmentResourceType
      }
    };
    exports2.TypeInfo.Issue.fields = {
      type: {
        enumType: exports2.TypeInfo.IssueType
      }
    };
    exports2.TypeInfo.JobAssignedEvent.fields = {
      request: {
        typeInfo: exports2.TypeInfo.TaskAgentJobRequest
      }
    };
    exports2.TypeInfo.JobCompletedEvent.fields = {
      result: {
        enumType: exports2.TypeInfo.TaskResult
      }
    };
    exports2.TypeInfo.JobEnvironment.fields = {
      mask: {
        isArray: true,
        typeInfo: exports2.TypeInfo.MaskHint
      },
      secureFiles: {
        isArray: true,
        typeInfo: exports2.TypeInfo.SecureFile
      }
    };
    exports2.TypeInfo.JobRequestMessage.fields = {
      environment: {
        typeInfo: exports2.TypeInfo.JobEnvironment
      }
    };
    exports2.TypeInfo.KubernetesResource.fields = {
      createdOn: {
        isDate: true
      },
      lastModifiedOn: {
        isDate: true
      },
      type: {
        enumType: exports2.TypeInfo.EnvironmentResourceType
      }
    };
    exports2.TypeInfo.MaskHint.fields = {
      type: {
        enumType: exports2.TypeInfo.MaskType
      }
    };
    exports2.TypeInfo.PackageMetadata.fields = {
      createdOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.PlanEnvironment.fields = {
      mask: {
        isArray: true,
        typeInfo: exports2.TypeInfo.MaskHint
      }
    };
    exports2.TypeInfo.ResourceLockRequest.fields = {
      assignTime: {
        isDate: true
      },
      finishTime: {
        isDate: true
      },
      lockType: {
        enumType: exports2.TypeInfo.ExclusiveLockType
      },
      queueTime: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.ResourceLockStatus
      }
    };
    exports2.TypeInfo.ResourceUsage.fields = {
      runningRequests: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskAgentJobRequest
      }
    };
    exports2.TypeInfo.SecureFile.fields = {
      createdOn: {
        isDate: true
      },
      modifiedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.SecureFileEvent.fields = {
      secureFiles: {
        isArray: true,
        typeInfo: exports2.TypeInfo.SecureFile
      }
    };
    exports2.TypeInfo.ServerTaskRequestMessage.fields = {
      environment: {
        typeInfo: exports2.TypeInfo.JobEnvironment
      },
      taskDefinition: {
        typeInfo: exports2.TypeInfo.TaskDefinition
      }
    };
    exports2.TypeInfo.ServiceEndpointAuthenticationScheme.fields = {
      inputDescriptors: {
        isArray: true,
        typeInfo: FormInputInterfaces.TypeInfo.InputDescriptor
      }
    };
    exports2.TypeInfo.ServiceEndpointExecutionData.fields = {
      finishTime: {
        isDate: true
      },
      result: {
        enumType: exports2.TypeInfo.TaskResult
      },
      startTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.ServiceEndpointExecutionRecord.fields = {
      data: {
        typeInfo: exports2.TypeInfo.ServiceEndpointExecutionData
      }
    };
    exports2.TypeInfo.ServiceEndpointExecutionRecordsInput.fields = {
      data: {
        typeInfo: exports2.TypeInfo.ServiceEndpointExecutionData
      }
    };
    exports2.TypeInfo.ServiceEndpointRequestResult.fields = {};
    exports2.TypeInfo.ServiceEndpointType.fields = {
      authenticationSchemes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.ServiceEndpointAuthenticationScheme
      },
      inputDescriptors: {
        isArray: true,
        typeInfo: FormInputInterfaces.TypeInfo.InputDescriptor
      }
    };
    exports2.TypeInfo.TaskAgent.fields = {
      assignedAgentCloudRequest: {
        typeInfo: exports2.TypeInfo.TaskAgentCloudRequest
      },
      assignedRequest: {
        typeInfo: exports2.TypeInfo.TaskAgentJobRequest
      },
      createdOn: {
        isDate: true
      },
      lastCompletedRequest: {
        typeInfo: exports2.TypeInfo.TaskAgentJobRequest
      },
      pendingUpdate: {
        typeInfo: exports2.TypeInfo.TaskAgentUpdate
      },
      status: {
        enumType: exports2.TypeInfo.TaskAgentStatus
      },
      statusChangedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.TaskAgentCloudRequest.fields = {
      agent: {
        typeInfo: exports2.TypeInfo.TaskAgentReference
      },
      agentConnectedTime: {
        isDate: true
      },
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      },
      provisionedTime: {
        isDate: true
      },
      provisionRequestTime: {
        isDate: true
      },
      releaseRequestTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.TaskAgentCloudType.fields = {
      inputDescriptors: {
        isArray: true,
        typeInfo: FormInputInterfaces.TypeInfo.InputDescriptor
      }
    };
    exports2.TypeInfo.TaskAgentDowngrade.fields = {
      code: {
        enumType: exports2.TypeInfo.TaskAgentUpdateReasonType
      }
    };
    exports2.TypeInfo.TaskAgentJob.fields = {
      steps: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskAgentJobStep
      }
    };
    exports2.TypeInfo.TaskAgentJobRequest.fields = {
      assignTime: {
        isDate: true
      },
      finishTime: {
        isDate: true
      },
      lockedUntil: {
        isDate: true
      },
      matchedAgents: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskAgentReference
      },
      queueTime: {
        isDate: true
      },
      receiveTime: {
        isDate: true
      },
      reservedAgent: {
        typeInfo: exports2.TypeInfo.TaskAgentReference
      },
      result: {
        enumType: exports2.TypeInfo.TaskResult
      }
    };
    exports2.TypeInfo.TaskAgentJobStep.fields = {
      type: {
        enumType: exports2.TypeInfo.TaskAgentJobStepType
      }
    };
    exports2.TypeInfo.TaskAgentManualUpdate.fields = {
      code: {
        enumType: exports2.TypeInfo.TaskAgentUpdateReasonType
      }
    };
    exports2.TypeInfo.TaskAgentMinAgentVersionRequiredUpdate.fields = {
      code: {
        enumType: exports2.TypeInfo.TaskAgentUpdateReasonType
      }
    };
    exports2.TypeInfo.TaskAgentPool.fields = {
      createdOn: {
        isDate: true
      },
      options: {
        enumType: exports2.TypeInfo.TaskAgentPoolOptions
      },
      poolType: {
        enumType: exports2.TypeInfo.TaskAgentPoolType
      }
    };
    exports2.TypeInfo.TaskAgentPoolMaintenanceDefinition.fields = {
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      },
      scheduleSetting: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolMaintenanceSchedule
      }
    };
    exports2.TypeInfo.TaskAgentPoolMaintenanceJob.fields = {
      finishTime: {
        isDate: true
      },
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      },
      queueTime: {
        isDate: true
      },
      result: {
        enumType: exports2.TypeInfo.TaskAgentPoolMaintenanceJobResult
      },
      startTime: {
        isDate: true
      },
      status: {
        enumType: exports2.TypeInfo.TaskAgentPoolMaintenanceJobStatus
      },
      targetAgents: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskAgentPoolMaintenanceJobTargetAgent
      }
    };
    exports2.TypeInfo.TaskAgentPoolMaintenanceJobTargetAgent.fields = {
      agent: {
        typeInfo: exports2.TypeInfo.TaskAgentReference
      },
      result: {
        enumType: exports2.TypeInfo.TaskAgentPoolMaintenanceJobResult
      },
      status: {
        enumType: exports2.TypeInfo.TaskAgentPoolMaintenanceJobStatus
      }
    };
    exports2.TypeInfo.TaskAgentPoolMaintenanceSchedule.fields = {
      daysToBuild: {
        enumType: exports2.TypeInfo.TaskAgentPoolMaintenanceScheduleDays
      }
    };
    exports2.TypeInfo.TaskAgentPoolReference.fields = {
      options: {
        enumType: exports2.TypeInfo.TaskAgentPoolOptions
      },
      poolType: {
        enumType: exports2.TypeInfo.TaskAgentPoolType
      }
    };
    exports2.TypeInfo.TaskAgentPoolStatus.fields = {
      options: {
        enumType: exports2.TypeInfo.TaskAgentPoolOptions
      },
      poolType: {
        enumType: exports2.TypeInfo.TaskAgentPoolType
      }
    };
    exports2.TypeInfo.TaskAgentPoolSummary.fields = {
      deploymentGroups: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DeploymentGroupReference
      },
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      },
      queues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskAgentQueue
      }
    };
    exports2.TypeInfo.TaskAgentQueue.fields = {
      pool: {
        typeInfo: exports2.TypeInfo.TaskAgentPoolReference
      }
    };
    exports2.TypeInfo.TaskAgentReference.fields = {
      status: {
        enumType: exports2.TypeInfo.TaskAgentStatus
      }
    };
    exports2.TypeInfo.TaskAgentSession.fields = {
      agent: {
        typeInfo: exports2.TypeInfo.TaskAgentReference
      }
    };
    exports2.TypeInfo.TaskAgentUpdate.fields = {
      reason: {
        typeInfo: exports2.TypeInfo.TaskAgentUpdateReason
      },
      requestTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.TaskAgentUpdateReason.fields = {
      code: {
        enumType: exports2.TypeInfo.TaskAgentUpdateReasonType
      }
    };
    exports2.TypeInfo.TaskAttachment.fields = {
      createdOn: {
        isDate: true
      },
      lastChangedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.TaskCommandRestrictions.fields = {
      mode: {
        enumType: exports2.TypeInfo.TaskCommandMode
      }
    };
    exports2.TypeInfo.TaskCompletedEvent.fields = {
      result: {
        enumType: exports2.TypeInfo.TaskResult
      }
    };
    exports2.TypeInfo.TaskDefinition.fields = {
      restrictions: {
        typeInfo: exports2.TypeInfo.TaskRestrictions
      }
    };
    exports2.TypeInfo.TaskGroup.fields = {
      createdOn: {
        isDate: true
      },
      modifiedOn: {
        isDate: true
      },
      restrictions: {
        typeInfo: exports2.TypeInfo.TaskRestrictions
      }
    };
    exports2.TypeInfo.TaskGroupRevision.fields = {
      changedDate: {
        isDate: true
      },
      changeType: {
        enumType: exports2.TypeInfo.AuditAction
      }
    };
    exports2.TypeInfo.TaskLog.fields = {
      createdOn: {
        isDate: true
      },
      lastChangedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.TaskOrchestrationContainer.fields = {
      children: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskOrchestrationItem
      },
      itemType: {
        enumType: exports2.TypeInfo.TaskOrchestrationItemType
      },
      rollback: {
        typeInfo: exports2.TypeInfo.TaskOrchestrationContainer
      }
    };
    exports2.TypeInfo.TaskOrchestrationItem.fields = {
      itemType: {
        enumType: exports2.TypeInfo.TaskOrchestrationItemType
      }
    };
    exports2.TypeInfo.TaskOrchestrationJob.fields = {
      itemType: {
        enumType: exports2.TypeInfo.TaskOrchestrationItemType
      }
    };
    exports2.TypeInfo.TaskOrchestrationPlan.fields = {
      environment: {
        typeInfo: exports2.TypeInfo.PlanEnvironment
      },
      finishTime: {
        isDate: true
      },
      implementation: {
        typeInfo: exports2.TypeInfo.TaskOrchestrationContainer
      },
      result: {
        enumType: exports2.TypeInfo.TaskResult
      },
      startTime: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.TaskOrchestrationPlanState
      }
    };
    exports2.TypeInfo.TaskOrchestrationPlanGroup.fields = {
      runningRequests: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskAgentJobRequest
      }
    };
    exports2.TypeInfo.TaskOrchestrationPlanGroupsQueueMetrics.fields = {
      status: {
        enumType: exports2.TypeInfo.PlanGroupStatus
      }
    };
    exports2.TypeInfo.TaskOrchestrationQueuedPlan.fields = {
      assignTime: {
        isDate: true
      },
      queueTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.TaskOrchestrationQueuedPlanGroup.fields = {
      plans: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TaskOrchestrationQueuedPlan
      }
    };
    exports2.TypeInfo.TaskRestrictions.fields = {
      commands: {
        typeInfo: exports2.TypeInfo.TaskCommandRestrictions
      }
    };
    exports2.TypeInfo.Timeline.fields = {
      lastChangedOn: {
        isDate: true
      },
      records: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TimelineRecord
      }
    };
    exports2.TypeInfo.TimelineRecord.fields = {
      finishTime: {
        isDate: true
      },
      issues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Issue
      },
      lastModified: {
        isDate: true
      },
      result: {
        enumType: exports2.TypeInfo.TaskResult
      },
      startTime: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.TimelineRecordState
      }
    };
    exports2.TypeInfo.TimelineRecordReference.fields = {
      state: {
        enumType: exports2.TypeInfo.TimelineRecordState
      }
    };
    exports2.TypeInfo.VariableGroup.fields = {
      createdOn: {
        isDate: true
      },
      modifiedOn: {
        isDate: true
      }
    };
    exports2.TypeInfo.VirtualMachine.fields = {
      agent: {
        typeInfo: exports2.TypeInfo.TaskAgent
      }
    };
    exports2.TypeInfo.VirtualMachineGroup.fields = {
      createdOn: {
        isDate: true
      },
      lastModifiedOn: {
        isDate: true
      },
      type: {
        enumType: exports2.TypeInfo.EnvironmentResourceType
      }
    };
    exports2.TypeInfo.VirtualMachineResource.fields = {
      agent: {
        typeInfo: exports2.TypeInfo.TaskAgent
      },
      createdOn: {
        isDate: true
      },
      lastModifiedOn: {
        isDate: true
      },
      type: {
        enumType: exports2.TypeInfo.EnvironmentResourceType
      }
    };
    exports2.TypeInfo.VirtualMachineResourceCreateParameters.fields = {
      virtualMachineResource: {
        typeInfo: exports2.TypeInfo.VirtualMachineResource
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/TaskAgentApiBase.js
var require_TaskAgentApiBase = __commonJS({
  "../node_modules/azure-devops-node-api/TaskAgentApiBase.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TaskAgentApiBase = void 0;
    var basem = require_ClientApiBases();
    var TaskAgentInterfaces = require_TaskAgentInterfaces();
    var TaskAgentApiBase = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-TaskAgent-api", options);
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentCloud} agentCloud
       */
      addAgentCloud(agentCloud) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "bfa72b3d-0fc6-43fb-932b-a7f6559f93b9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, agentCloud, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} agentCloudId
       */
      deleteAgentCloud(agentCloudId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              agentCloudId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "bfa72b3d-0fc6-43fb-932b-a7f6559f93b9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} agentCloudId
       */
      getAgentCloud(agentCloudId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              agentCloudId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "bfa72b3d-0fc6-43fb-932b-a7f6559f93b9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       */
      getAgentClouds() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "bfa72b3d-0fc6-43fb-932b-a7f6559f93b9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentCloud} updatedCloud
       * @param {number} agentCloudId
       */
      updateAgentCloud(updatedCloud, agentCloudId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              agentCloudId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "bfa72b3d-0fc6-43fb-932b-a7f6559f93b9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updatedCloud, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get agent cloud types.
       *
       */
      getAgentCloudTypes() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "5932e193-f376-469d-9c3e-e5588ce12cb5", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentCloudType, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} queueId
       * @param {number} top
       * @param {string} continuationToken
       */
      getAgentRequestsForQueue(project, queueId, top, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (top == null) {
            throw new TypeError("top can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              queueId
            };
            let queryValues = {
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "f5f81ffb-f396-498d-85b1-5ada145e648a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentJobRequest} request
       * @param {string} project - Project ID or project name
       * @param {number} queueId
       */
      queueAgentRequest(request, project, queueId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              queueId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "f5f81ffb-f396-498d-85b1-5ada145e648a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, request, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds an agent to a pool.  You probably don't want to call this endpoint directly. Instead, [configure an agent](https://docs.microsoft.com/azure/devops/pipelines/agents/agents) using the agent download package.
       *
       * @param {TaskAgentInterfaces.TaskAgent} agent - Details about the agent being added
       * @param {number} poolId - The agent pool in which to add the agent
       */
      addAgent(agent, poolId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "e298ef32-5878-4cab-993c-043836571f42", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, agent, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgent, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete an agent.  You probably don't want to call this endpoint directly. Instead, [use the agent configuration script](https://docs.microsoft.com/azure/devops/pipelines/agents/agents) to remove an agent from your organization.
       *
       * @param {number} poolId - The pool ID to remove the agent from
       * @param {number} agentId - The agent ID to remove
       */
      deleteAgent(poolId, agentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              agentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "e298ef32-5878-4cab-993c-043836571f42", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get information about an agent.
       *
       * @param {number} poolId - The agent pool containing the agent
       * @param {number} agentId - The agent ID to get information about
       * @param {boolean} includeCapabilities - Whether to include the agent's capabilities in the response
       * @param {boolean} includeAssignedRequest - Whether to include details about the agent's current work
       * @param {boolean} includeLastCompletedRequest - Whether to include details about the agents' most recent completed work
       * @param {string[]} propertyFilters - Filter which custom properties will be returned
       */
      getAgent(poolId, agentId, includeCapabilities, includeAssignedRequest, includeLastCompletedRequest, propertyFilters) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              agentId
            };
            let queryValues = {
              includeCapabilities,
              includeAssignedRequest,
              includeLastCompletedRequest,
              propertyFilters: propertyFilters && propertyFilters.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "e298ef32-5878-4cab-993c-043836571f42", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgent, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of agents.
       *
       * @param {number} poolId - The agent pool containing the agents
       * @param {string} agentName - Filter on agent name
       * @param {boolean} includeCapabilities - Whether to include the agents' capabilities in the response
       * @param {boolean} includeAssignedRequest - Whether to include details about the agents' current work
       * @param {boolean} includeLastCompletedRequest - Whether to include details about the agents' most recent completed work
       * @param {string[]} propertyFilters - Filter which custom properties will be returned
       * @param {string[]} demands - Filter by demands the agents can satisfy
       */
      getAgents(poolId, agentName, includeCapabilities, includeAssignedRequest, includeLastCompletedRequest, propertyFilters, demands) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              agentName,
              includeCapabilities,
              includeAssignedRequest,
              includeLastCompletedRequest,
              propertyFilters: propertyFilters && propertyFilters.join(","),
              demands: demands && demands.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "e298ef32-5878-4cab-993c-043836571f42", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgent, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Replace an agent.  You probably don't want to call this endpoint directly. Instead, [use the agent configuration script](https://docs.microsoft.com/azure/devops/pipelines/agents/agents) to remove and reconfigure an agent from your organization.
       *
       * @param {TaskAgentInterfaces.TaskAgent} agent - Updated details about the replacing agent
       * @param {number} poolId - The agent pool to use
       * @param {number} agentId - The agent to replace
       */
      replaceAgent(agent, poolId, agentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              agentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "e298ef32-5878-4cab-993c-043836571f42", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, agent, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgent, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update agent details.
       *
       * @param {TaskAgentInterfaces.TaskAgent} agent - Updated details about the agent
       * @param {number} poolId - The agent pool to use
       * @param {number} agentId - The agent to update
       */
      updateAgent(agent, poolId, agentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              agentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "e298ef32-5878-4cab-993c-043836571f42", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, agent, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgent, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns list of azure subscriptions
       *
       */
      getAzureManagementGroups() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "39fe3bf2-7ee0-4198-a469-4a29929afa9c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns list of azure subscriptions
       *
       */
      getAzureSubscriptions() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "bcd6189c-0303-471f-a8e1-acb22b74d700", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * GET a PAT token for managing (configuring, removing, tagging) deployment targets in a deployment group.
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group in which deployment targets are managed.
       */
      generateDeploymentGroupAccessToken(project, deploymentGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "3d197ba2-c3e9-4253-882f-0ee2440f8174", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a deployment group.
       *
       * @param {TaskAgentInterfaces.DeploymentGroupCreateParameter} deploymentGroup - Deployment group to create.
       * @param {string} project - Project ID or project name
       */
      addDeploymentGroup(deploymentGroup, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "083c4d89-ab35-45af-aa11-7cf66895c53e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, deploymentGroup, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a deployment group.
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group to be deleted.
       */
      deleteDeploymentGroup(project, deploymentGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "083c4d89-ab35-45af-aa11-7cf66895c53e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a deployment group by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group.
       * @param {TaskAgentInterfaces.DeploymentGroupActionFilter} actionFilter - Get the deployment group only if this action can be performed on it.
       * @param {TaskAgentInterfaces.DeploymentGroupExpands} expand - Include these additional details in the returned object.
       */
      getDeploymentGroup(project, deploymentGroupId, actionFilter, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            let queryValues = {
              actionFilter,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "083c4d89-ab35-45af-aa11-7cf66895c53e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of deployment groups by name or IDs.
       *
       * @param {string} project - Project ID or project name
       * @param {string} name - Name of the deployment group.
       * @param {TaskAgentInterfaces.DeploymentGroupActionFilter} actionFilter - Get only deployment groups on which this action can be performed.
       * @param {TaskAgentInterfaces.DeploymentGroupExpands} expand - Include these additional details in the returned objects.
       * @param {string} continuationToken - Get deployment groups with names greater than this continuationToken lexicographically.
       * @param {number} top - Maximum number of deployment groups to return. Default is **1000**.
       * @param {number[]} ids - Comma separated list of IDs of the deployment groups.
       */
      getDeploymentGroups(project, name, actionFilter, expand, continuationToken, top, ids) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              name,
              actionFilter,
              "$expand": expand,
              continuationToken,
              "$top": top,
              ids: ids && ids.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "083c4d89-ab35-45af-aa11-7cf66895c53e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a deployment group.
       *
       * @param {TaskAgentInterfaces.DeploymentGroupUpdateParameter} deploymentGroup - Deployment group to update.
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group.
       */
      updateDeploymentGroup(deploymentGroup, project, deploymentGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "083c4d89-ab35-45af-aa11-7cf66895c53e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, deploymentGroup, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of deployment group metrics.
       *
       * @param {string} project - Project ID or project name
       * @param {string} deploymentGroupName - Name of the deployment group.
       * @param {string} continuationToken - Get metrics for deployment groups with names greater than this continuationToken lexicographically.
       * @param {number} top - Maximum number of deployment group metrics to return. Default is **50**.
       */
      getDeploymentGroupsMetrics(project, deploymentGroupName, continuationToken, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              deploymentGroupName,
              continuationToken,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "281c6308-427a-49e1-b83a-dac0f4862189", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentGroupMetrics, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       * @param {number} machineId
       * @param {number} completedRequestCount
       */
      getAgentRequestsForDeploymentMachine(project, deploymentGroupId, machineId, completedRequestCount) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (machineId == null) {
            throw new TypeError("machineId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            let queryValues = {
              machineId,
              completedRequestCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "a3540e5b-f0dc-4668-963b-b752459be545", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       * @param {number[]} machineIds
       * @param {number} completedRequestCount
       */
      getAgentRequestsForDeploymentMachines(project, deploymentGroupId, machineIds, completedRequestCount) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            let queryValues = {
              machineIds: machineIds && machineIds.join(","),
              completedRequestCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "a3540e5b-f0dc-4668-963b-b752459be545", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       */
      refreshDeploymentMachines(project, deploymentGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "91006ac4-0f68-4d82-a2bc-540676bd73ce", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * GET a PAT token for managing (configuring, removing, tagging) deployment agents in a deployment pool.
       *
       * @param {number} poolId - ID of the deployment pool in which deployment agents are managed.
       */
      generateDeploymentPoolAccessToken(poolId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "e077ee4a-399b-420b-841f-c43fbc058e0b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of deployment pool summaries.
       *
       * @param {string} poolName - Name of the deployment pool.
       * @param {TaskAgentInterfaces.DeploymentPoolSummaryExpands} expands - Include these additional details in the returned objects.
       * @param {number[]} poolIds - List of deployment pool ids.
       */
      getDeploymentPoolsSummary(poolName, expands, poolIds) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              poolName,
              expands,
              poolIds: poolIds && poolIds.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6525d6c6-258f-40e0-a1a9-8a24a3957625", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentPoolSummary, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get agent requests for a deployment target.
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group to which the target belongs.
       * @param {number} targetId - ID of the deployment target.
       * @param {number} completedRequestCount - Maximum number of completed requests to return. Default is **50**
       */
      getAgentRequestsForDeploymentTarget(project, deploymentGroupId, targetId, completedRequestCount) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (targetId == null) {
            throw new TypeError("targetId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            let queryValues = {
              targetId,
              completedRequestCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2fac0be3-8c8f-4473-ab93-c1389b08a2c9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get agent requests for a list deployment targets.
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group to which the targets belong.
       * @param {number[]} targetIds - Comma separated list of IDs of the deployment targets.
       * @param {number} ownerId - Id of owner of agent job request.
       * @param {Date} completedOn - Datetime to return request after this time.
       * @param {number} completedRequestCount - Maximum number of completed requests to return for each target. Default is **50**
       */
      getAgentRequestsForDeploymentTargets(project, deploymentGroupId, targetIds, ownerId, completedOn, completedRequestCount) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            let queryValues = {
              targetIds: targetIds && targetIds.join(","),
              ownerId,
              completedOn,
              completedRequestCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2fac0be3-8c8f-4473-ab93-c1389b08a2c9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Upgrade the deployment targets in a deployment group.
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group.
       */
      refreshDeploymentTargets(project, deploymentGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "1c1a817f-f23d-41c6-bf8d-14b638f64152", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Proxy for a GET request defined by an 'endpoint'. The request is authorized using a service connection. The response is filtered using an XPath/Json based selector.
       *
       * @param {TaskAgentInterfaces.TaskDefinitionEndpoint} endpoint - Describes the URL to fetch.
       */
      queryEndpoint(endpoint) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "f223b809-8c33-4b7d-b53f-07232569b5d6", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, endpoint, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get environment deployment execution history
       *
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       * @param {string} continuationToken
       * @param {number} top
       */
      getEnvironmentDeploymentExecutionRecords(project, environmentId, continuationToken, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId
            };
            let queryValues = {
              continuationToken,
              top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "51bb5d21-4305-4ea6-9dbb-b7488af73334", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.EnvironmentDeploymentExecutionRecord, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create an environment.
       *
       * @param {TaskAgentInterfaces.EnvironmentCreateParameter} environmentCreateParameter - Environment to create.
       * @param {string} project - Project ID or project name
       */
      addEnvironment(environmentCreateParameter, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "8572b1fc-2482-47fa-8f74-7e3ed53ee54b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, environmentCreateParameter, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.EnvironmentInstance, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete the specified environment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} environmentId - ID of the environment.
       */
      deleteEnvironment(project, environmentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "8572b1fc-2482-47fa-8f74-7e3ed53ee54b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get an environment by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} environmentId - ID of the environment.
       * @param {TaskAgentInterfaces.EnvironmentExpands} expands - Include these additional details in the returned objects.
       */
      getEnvironmentById(project, environmentId, expands) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId
            };
            let queryValues = {
              expands
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "8572b1fc-2482-47fa-8f74-7e3ed53ee54b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.EnvironmentInstance, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all environments.
       *
       * @param {string} project - Project ID or project name
       * @param {string} name
       * @param {string} continuationToken
       * @param {number} top
       */
      getEnvironments(project, name, continuationToken, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              name,
              continuationToken,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "8572b1fc-2482-47fa-8f74-7e3ed53ee54b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.EnvironmentInstance, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the specified environment.
       *
       * @param {TaskAgentInterfaces.EnvironmentUpdateParameter} environmentUpdateParameter - Environment data to update.
       * @param {string} project - Project ID or project name
       * @param {number} environmentId - ID of the environment.
       */
      updateEnvironment(environmentUpdateParameter, project, environmentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "8572b1fc-2482-47fa-8f74-7e3ed53ee54b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, environmentUpdateParameter, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.EnvironmentInstance, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} hubName
       * @param {boolean} includeEnterpriseUsersCount
       * @param {boolean} includeHostedAgentMinutesCount
       */
      getTaskHubLicenseDetails(hubName, includeEnterpriseUsersCount, includeHostedAgentMinutesCount) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              hubName
            };
            let queryValues = {
              includeEnterpriseUsersCount,
              includeHostedAgentMinutesCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "distributedtask", "f9f0f436-b8a1-4475-9041-1ccdbf8f0128", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskHubLicenseDetails} taskHubLicenseDetails
       * @param {string} hubName
       */
      updateTaskHubLicenseDetails(taskHubLicenseDetails, hubName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              hubName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "distributedtask", "f9f0f436-b8a1-4475-9041-1ccdbf8f0128", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, taskHubLicenseDetails, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.InputValidationRequest} inputValidationRequest
       */
      validateInputs(inputValidationRequest) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "58475b1e-adaf-4155-9bc1-e04bf1fff4c2", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, inputValidationRequest, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} requestId
       * @param {string} lockToken
       * @param {TaskAgentInterfaces.TaskResult} result
       * @param {boolean} agentShuttingDown
       */
      deleteAgentRequest(poolId, requestId, lockToken, result2, agentShuttingDown) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (lockToken == null) {
            throw new TypeError("lockToken can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              requestId
            };
            let queryValues = {
              lockToken,
              result: result2,
              agentShuttingDown
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "fc825784-c92a-4299-9221-998a02d1b54f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} requestId
       * @param {boolean} includeStatus
       */
      getAgentRequest(poolId, requestId, includeStatus) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              requestId
            };
            let queryValues = {
              includeStatus
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "fc825784-c92a-4299-9221-998a02d1b54f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} top
       * @param {string} continuationToken
       */
      getAgentRequests(poolId, top, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (top == null) {
            throw new TypeError("top can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "fc825784-c92a-4299-9221-998a02d1b54f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} agentId
       * @param {number} completedRequestCount
       */
      getAgentRequestsForAgent(poolId, agentId, completedRequestCount) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (agentId == null) {
            throw new TypeError("agentId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              agentId,
              completedRequestCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "fc825784-c92a-4299-9221-998a02d1b54f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number[]} agentIds
       * @param {number} completedRequestCount
       */
      getAgentRequestsForAgents(poolId, agentIds, completedRequestCount) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              agentIds: agentIds && agentIds.join(","),
              completedRequestCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "fc825784-c92a-4299-9221-998a02d1b54f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {string} planId
       * @param {string} jobId
       */
      getAgentRequestsForPlan(poolId, planId, jobId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (planId == null) {
            throw new TypeError("planId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              planId,
              jobId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "fc825784-c92a-4299-9221-998a02d1b54f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentJobRequest} request
       * @param {number} poolId
       */
      queueAgentRequestByPool(request, poolId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "fc825784-c92a-4299-9221-998a02d1b54f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, request, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentJobRequest} request
       * @param {number} poolId
       * @param {number} requestId
       * @param {string} lockToken
       * @param {TaskAgentInterfaces.TaskAgentRequestUpdateOptions} updateOptions
       */
      updateAgentRequest(request, poolId, requestId, lockToken, updateOptions) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (lockToken == null) {
            throw new TypeError("lockToken can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              requestId
            };
            let queryValues = {
              lockToken,
              updateOptions
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "fc825784-c92a-4299-9221-998a02d1b54f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, request, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJobRequest, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.KubernetesResourceCreateParameters} createParameters
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       */
      addKubernetesResource(createParameters, project, environmentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "73fba52f-15ab-42b3-a538-ce67a9223a04", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, createParameters, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.KubernetesResource, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       * @param {number} resourceId
       */
      deleteKubernetesResource(project, environmentId, resourceId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId,
              resourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "73fba52f-15ab-42b3-a538-ce67a9223a04", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       * @param {number} resourceId
       */
      getKubernetesResource(project, environmentId, resourceId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId,
              resourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "73fba52f-15ab-42b3-a538-ce67a9223a04", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.KubernetesResource, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} machineGroupId
       */
      generateDeploymentMachineGroupAccessToken(project, machineGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              machineGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "f8c7c0de-ac0d-469b-9cb1-c21f72d67693", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.DeploymentMachineGroup} machineGroup
       * @param {string} project - Project ID or project name
       */
      addDeploymentMachineGroup(machineGroup, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "d4adf50f-80c6-4ac8-9ca1-6e4e544286e9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, machineGroup, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachineGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} machineGroupId
       */
      deleteDeploymentMachineGroup(project, machineGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              machineGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "d4adf50f-80c6-4ac8-9ca1-6e4e544286e9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} machineGroupId
       * @param {TaskAgentInterfaces.MachineGroupActionFilter} actionFilter
       */
      getDeploymentMachineGroup(project, machineGroupId, actionFilter) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              machineGroupId
            };
            let queryValues = {
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "d4adf50f-80c6-4ac8-9ca1-6e4e544286e9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachineGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} machineGroupName
       * @param {TaskAgentInterfaces.MachineGroupActionFilter} actionFilter
       */
      getDeploymentMachineGroups(project, machineGroupName, actionFilter) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              machineGroupName,
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "d4adf50f-80c6-4ac8-9ca1-6e4e544286e9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachineGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.DeploymentMachineGroup} machineGroup
       * @param {string} project - Project ID or project name
       * @param {number} machineGroupId
       */
      updateDeploymentMachineGroup(machineGroup, project, machineGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              machineGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "d4adf50f-80c6-4ac8-9ca1-6e4e544286e9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, machineGroup, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachineGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} machineGroupId
       * @param {string[]} tagFilters
       */
      getDeploymentMachineGroupMachines(project, machineGroupId, tagFilters) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              machineGroupId
            };
            let queryValues = {
              tagFilters: tagFilters && tagFilters.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "966c3874-c347-4b18-a90c-d509116717fd", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.DeploymentMachine[]} deploymentMachines
       * @param {string} project - Project ID or project name
       * @param {number} machineGroupId
       */
      updateDeploymentMachineGroupMachines(deploymentMachines, project, machineGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              machineGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "966c3874-c347-4b18-a90c-d509116717fd", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, deploymentMachines, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.DeploymentMachine} machine
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       */
      addDeploymentMachine(machine, project, deploymentGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6f6d406f-cfe6-409c-9327-7009928077e7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, machine, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       * @param {number} machineId
       */
      deleteDeploymentMachine(project, deploymentGroupId, machineId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId,
              machineId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6f6d406f-cfe6-409c-9327-7009928077e7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       * @param {number} machineId
       * @param {TaskAgentInterfaces.DeploymentMachineExpands} expand
       */
      getDeploymentMachine(project, deploymentGroupId, machineId, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId,
              machineId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6f6d406f-cfe6-409c-9327-7009928077e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       * @param {string[]} tags
       * @param {string} name
       * @param {TaskAgentInterfaces.DeploymentMachineExpands} expand
       */
      getDeploymentMachines(project, deploymentGroupId, tags, name, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            let queryValues = {
              tags: tags && tags.join(","),
              name,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6f6d406f-cfe6-409c-9327-7009928077e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.DeploymentMachine} machine
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       * @param {number} machineId
       */
      replaceDeploymentMachine(machine, project, deploymentGroupId, machineId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId,
              machineId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6f6d406f-cfe6-409c-9327-7009928077e7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, machine, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.DeploymentMachine} machine
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       * @param {number} machineId
       */
      updateDeploymentMachine(machine, project, deploymentGroupId, machineId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId,
              machineId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6f6d406f-cfe6-409c-9327-7009928077e7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, machine, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.DeploymentMachine[]} machines
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId
       */
      updateDeploymentMachines(machines, project, deploymentGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6f6d406f-cfe6-409c-9327-7009928077e7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, machines, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentPoolMaintenanceDefinition} definition
       * @param {number} poolId
       */
      createAgentPoolMaintenanceDefinition(definition, poolId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "80572e16-58f0-4419-ac07-d19fde32195c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, definition, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPoolMaintenanceDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} definitionId
       */
      deleteAgentPoolMaintenanceDefinition(poolId, definitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "80572e16-58f0-4419-ac07-d19fde32195c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} definitionId
       */
      getAgentPoolMaintenanceDefinition(poolId, definitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "80572e16-58f0-4419-ac07-d19fde32195c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPoolMaintenanceDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       */
      getAgentPoolMaintenanceDefinitions(poolId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "80572e16-58f0-4419-ac07-d19fde32195c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPoolMaintenanceDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentPoolMaintenanceDefinition} definition
       * @param {number} poolId
       * @param {number} definitionId
       */
      updateAgentPoolMaintenanceDefinition(definition, poolId, definitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "80572e16-58f0-4419-ac07-d19fde32195c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, definition, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPoolMaintenanceDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} jobId
       */
      deleteAgentPoolMaintenanceJob(poolId, jobId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              jobId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "15e7ab6e-abce-4601-a6d8-e111fe148f46", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} jobId
       */
      getAgentPoolMaintenanceJob(poolId, jobId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              jobId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "15e7ab6e-abce-4601-a6d8-e111fe148f46", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPoolMaintenanceJob, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} jobId
       */
      getAgentPoolMaintenanceJobLogs(poolId, jobId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              jobId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "15e7ab6e-abce-4601-a6d8-e111fe148f46", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} definitionId
       */
      getAgentPoolMaintenanceJobs(poolId, definitionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              definitionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "15e7ab6e-abce-4601-a6d8-e111fe148f46", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPoolMaintenanceJob, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentPoolMaintenanceJob} job
       * @param {number} poolId
       */
      queueAgentPoolMaintenanceJob(job, poolId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "15e7ab6e-abce-4601-a6d8-e111fe148f46", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, job, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPoolMaintenanceJob, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentPoolMaintenanceJob} job
       * @param {number} poolId
       * @param {number} jobId
       */
      updateAgentPoolMaintenanceJob(job, poolId, jobId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              jobId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "15e7ab6e-abce-4601-a6d8-e111fe148f46", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, job, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPoolMaintenanceJob, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} messageId
       * @param {string} sessionId
       */
      deleteMessage(poolId, messageId, sessionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (sessionId == null) {
            throw new TypeError("sessionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              messageId
            };
            let queryValues = {
              sessionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "c3a054f6-7a8a-49c0-944e-3a8e5d7adfd7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {string} sessionId
       * @param {number} lastMessageId
       */
      getMessage(poolId, sessionId, lastMessageId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (sessionId == null) {
            throw new TypeError("sessionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              sessionId,
              lastMessageId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "c3a054f6-7a8a-49c0-944e-3a8e5d7adfd7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} agentId
       */
      refreshAgent(poolId, agentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (agentId == null) {
            throw new TypeError("agentId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              agentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "c3a054f6-7a8a-49c0-944e-3a8e5d7adfd7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       */
      refreshAgents(poolId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "c3a054f6-7a8a-49c0-944e-3a8e5d7adfd7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentMessage} message
       * @param {number} poolId
       * @param {number} requestId
       */
      sendMessage(message, poolId, requestId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (requestId == null) {
            throw new TypeError("requestId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              requestId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "c3a054f6-7a8a-49c0-944e-3a8e5d7adfd7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, message, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} packageType
       * @param {string} platform
       * @param {string} version
       */
      getPackage(packageType, platform, version2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              packageType,
              platform,
              version: version2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "8ffcd551-079c-493a-9c02-54346299d144", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.PackageMetadata, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} packageType
       * @param {string} platform
       * @param {number} top
       */
      getPackages(packageType, platform, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              packageType,
              platform
            };
            let queryValues = {
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "8ffcd551-079c-493a-9c02-54346299d144", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.PackageMetadata, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       */
      getAgentPoolMetadata(poolId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "0d62f887-9f53-48b9-9161-4c35d5735b0f", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {any} agentPoolMetadata
       * @param {number} poolId
       */
      setAgentPoolMetadata(customHeaders, agentPoolMetadata, poolId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "0d62f887-9f53-48b9-9161-4c35d5735b0f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.replace(url, agentPoolMetadata, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Checks if current identity has passed permissions on a pool.
       *
       * @param {number} poolId - Id of the pool to check
       * @param {number} permissions - Permissions to check. Multiple permissions might be merged into single value using bitwise OR operator (e.g. AgentPoolPermissions.Manage | AgentPoolPermissions.View)
       */
      hasPoolPermissions(poolId, permissions) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              permissions
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "162778f3-4b48-48f3-9d58-436fb9c407bc", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create an agent pool.
       *
       * @param {TaskAgentInterfaces.TaskAgentPool} pool - Details about the new agent pool
       */
      addAgentPool(pool) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "a8c47e17-4d56-4a56-92bb-de7ea7dc65be", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, pool, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPool, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete an agent pool.
       *
       * @param {number} poolId - ID of the agent pool to delete
       */
      deleteAgentPool(poolId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "a8c47e17-4d56-4a56-92bb-de7ea7dc65be", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get information about an agent pool.
       *
       * @param {number} poolId - An agent pool ID
       * @param {string[]} properties - Agent pool properties (comma-separated)
       * @param {TaskAgentInterfaces.TaskAgentPoolActionFilter} actionFilter - Filter by whether the calling user has use or manage permissions
       */
      getAgentPool(poolId, properties, actionFilter) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            let queryValues = {
              properties: properties && properties.join(","),
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "a8c47e17-4d56-4a56-92bb-de7ea7dc65be", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPool, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of agent pools.
       *
       * @param {string} poolName - Filter by name
       * @param {string[]} properties - Filter by agent pool properties (comma-separated)
       * @param {TaskAgentInterfaces.TaskAgentPoolType} poolType - Filter by pool type
       * @param {TaskAgentInterfaces.TaskAgentPoolActionFilter} actionFilter - Filter by whether the calling user has use or manage permissions
       */
      getAgentPools(poolName, properties, poolType, actionFilter) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              poolName,
              properties: properties && properties.join(","),
              poolType,
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "a8c47e17-4d56-4a56-92bb-de7ea7dc65be", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPool, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of agent pools.
       *
       * @param {number[]} poolIds - pool Ids to fetch
       * @param {TaskAgentInterfaces.TaskAgentPoolActionFilter} actionFilter - Filter by whether the calling user has use or manage permissions
       */
      getAgentPoolsByIds(poolIds, actionFilter) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (poolIds == null) {
            throw new TypeError("poolIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              poolIds: poolIds && poolIds.join(","),
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "a8c47e17-4d56-4a56-92bb-de7ea7dc65be", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPool, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update properties on an agent pool
       *
       * @param {TaskAgentInterfaces.TaskAgentPool} pool - Updated agent pool details
       * @param {number} poolId - The agent pool to update
       */
      updateAgentPool(pool, poolId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "a8c47e17-4d56-4a56-92bb-de7ea7dc65be", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, pool, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentPool, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a new agent queue to connect a project to an agent pool.
       *
       * @param {TaskAgentInterfaces.TaskAgentQueue} queue - Details about the queue to create
       * @param {string} project - Project ID or project name
       * @param {boolean} authorizePipelines - Automatically authorize this queue when using YAML
       */
      addAgentQueue(queue, project, authorizePipelines) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              authorizePipelines
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "900fa995-c559-4923-aae7-f8424fe4fbea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, queue, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentQueue, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a new team project.
       *
       * @param {string} project - Project ID or project name
       */
      createTeamProject(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "900fa995-c559-4923-aae7-f8424fe4fbea", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes an agent queue from a project.
       *
       * @param {number} queueId - The agent queue to remove
       * @param {string} project - Project ID or project name
       */
      deleteAgentQueue(queueId, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              queueId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "900fa995-c559-4923-aae7-f8424fe4fbea", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get information about an agent queue.
       *
       * @param {number} queueId - The agent queue to get information about
       * @param {string} project - Project ID or project name
       * @param {TaskAgentInterfaces.TaskAgentQueueActionFilter} actionFilter - Filter by whether the calling user has use or manage permissions
       */
      getAgentQueue(queueId, project, actionFilter) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              queueId
            };
            let queryValues = {
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "900fa995-c559-4923-aae7-f8424fe4fbea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentQueue, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of agent queues.
       *
       * @param {string} project - Project ID or project name
       * @param {string} queueName - Filter on the agent queue name
       * @param {TaskAgentInterfaces.TaskAgentQueueActionFilter} actionFilter - Filter by whether the calling user has use or manage permissions
       */
      getAgentQueues(project, queueName, actionFilter) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              queueName,
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "900fa995-c559-4923-aae7-f8424fe4fbea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentQueue, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of agent queues by their IDs
       *
       * @param {number[]} queueIds - A comma-separated list of agent queue IDs to retrieve
       * @param {string} project - Project ID or project name
       * @param {TaskAgentInterfaces.TaskAgentQueueActionFilter} actionFilter - Filter by whether the calling user has use or manage permissions
       */
      getAgentQueuesByIds(queueIds, project, actionFilter) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (queueIds == null) {
            throw new TypeError("queueIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              queueIds: queueIds && queueIds.join(","),
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "900fa995-c559-4923-aae7-f8424fe4fbea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentQueue, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of agent queues by their names
       *
       * @param {string[]} queueNames - A comma-separated list of agent names to retrieve
       * @param {string} project - Project ID or project name
       * @param {TaskAgentInterfaces.TaskAgentQueueActionFilter} actionFilter - Filter by whether the calling user has use or manage permissions
       */
      getAgentQueuesByNames(queueNames, project, actionFilter) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (queueNames == null) {
            throw new TypeError("queueNames can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              queueNames: queueNames && queueNames.join(","),
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "900fa995-c559-4923-aae7-f8424fe4fbea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentQueue, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of agent queues by pool ids
       *
       * @param {number[]} poolIds - A comma-separated list of pool ids to get the corresponding queues for
       * @param {string} project - Project ID or project name
       * @param {TaskAgentInterfaces.TaskAgentQueueActionFilter} actionFilter - Filter by whether the calling user has use or manage permissions
       */
      getAgentQueuesForPools(poolIds, project, actionFilter) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (poolIds == null) {
            throw new TypeError("poolIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              poolIds: poolIds && poolIds.join(","),
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "900fa995-c559-4923-aae7-f8424fe4fbea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentQueue, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} agentCloudId
       */
      getAgentCloudRequests(agentCloudId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              agentCloudId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "20189bd7-5134-49c2-b8e9-f9e856eea2b2", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentCloudRequest, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       */
      getResourceLimits() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "1f1f0557-c445-42a6-b4a0-0df605a3a0f8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} parallelismTag
       * @param {boolean} poolIsHosted
       * @param {boolean} includeRunningRequests
       */
      getResourceUsage(parallelismTag, poolIsHosted, includeRunningRequests) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              parallelismTag,
              poolIsHosted,
              includeRunningRequests
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "eae1d376-a8b1-4475-9041-1dfdbe8f0143", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.ResourceUsage, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} taskGroupId
       */
      getTaskGroupHistory(project, taskGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              taskGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "100cc92a-b255-47fa-9ab3-e44a2985a3ac", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskGroupRevision, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a secure file
       *
       * @param {string} project - Project ID or project name
       * @param {string} secureFileId - The unique secure file Id
       */
      deleteSecureFile(project, secureFileId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              secureFileId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Download a secure file by Id
       *
       * @param {string} project - Project ID or project name
       * @param {string} secureFileId - The unique secure file Id
       * @param {string} ticket - A valid download ticket
       * @param {boolean} download - If download is true, the file is sent as attachement in the response body. If download is false, the response body contains the file stream.
       */
      downloadSecureFile(project, secureFileId, ticket, download) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (ticket == null) {
            throw new TypeError("ticket can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              secureFileId
            };
            let queryValues = {
              ticket,
              download
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a secure file
       *
       * @param {string} project - Project ID or project name
       * @param {string} secureFileId - The unique secure file Id
       * @param {boolean} includeDownloadTicket - If includeDownloadTicket is true and the caller has permissions, a download ticket is included in the response.
       * @param {TaskAgentInterfaces.SecureFileActionFilter} actionFilter
       */
      getSecureFile(project, secureFileId, includeDownloadTicket, actionFilter) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              secureFileId
            };
            let queryValues = {
              includeDownloadTicket,
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.SecureFile, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get secure files
       *
       * @param {string} project - Project ID or project name
       * @param {string} namePattern - Name of the secure file to match. Can include wildcards to match multiple files.
       * @param {boolean} includeDownloadTickets - If includeDownloadTickets is true and the caller has permissions, a download ticket for each secure file is included in the response.
       * @param {TaskAgentInterfaces.SecureFileActionFilter} actionFilter - Filter by secure file permissions for View, Manage or Use action. Defaults to View.
       */
      getSecureFiles(project, namePattern, includeDownloadTickets, actionFilter) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              namePattern,
              includeDownloadTickets,
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.SecureFile, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get secure files
       *
       * @param {string} project - Project ID or project name
       * @param {string[]} secureFileIds - A list of secure file Ids
       * @param {boolean} includeDownloadTickets - If includeDownloadTickets is true and the caller has permissions, a download ticket for each secure file is included in the response.
       * @param {TaskAgentInterfaces.SecureFileActionFilter} actionFilter
       */
      getSecureFilesByIds(project, secureFileIds, includeDownloadTickets, actionFilter) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (secureFileIds == null) {
            throw new TypeError("secureFileIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              secureFileIds: secureFileIds && secureFileIds.join(","),
              includeDownloadTickets,
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.SecureFile, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get secure files
       *
       * @param {string} project - Project ID or project name
       * @param {string[]} secureFileNames - A list of secure file Ids
       * @param {boolean} includeDownloadTickets - If includeDownloadTickets is true and the caller has permissions, a download ticket for each secure file is included in the response.
       * @param {TaskAgentInterfaces.SecureFileActionFilter} actionFilter
       */
      getSecureFilesByNames(project, secureFileNames, includeDownloadTickets, actionFilter) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (secureFileNames == null) {
            throw new TypeError("secureFileNames can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              secureFileNames: secureFileNames && secureFileNames.join(","),
              includeDownloadTickets,
              actionFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.SecureFile, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Query secure files using a name pattern and a condition on file properties.
       *
       * @param {string} condition - The main condition syntax is described [here](https://go.microsoft.com/fwlink/?linkid=842996). Use the *property('property-name')* function to access the value of the specified property of a secure file. It returns null if the property is not set. E.g. ``` and( eq( property('devices'), '2' ), in( property('provisioning profile type'), 'ad hoc', 'development' ) ) ```
       * @param {string} project - Project ID or project name
       * @param {string} namePattern - Name of the secure file to match. Can include wildcards to match multiple files.
       */
      querySecureFilesByProperties(condition, project, namePattern) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              namePattern
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, condition, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.SecureFile, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the name or properties of an existing secure file
       *
       * @param {TaskAgentInterfaces.SecureFile} secureFile - The secure file with updated name and/or properties
       * @param {string} project - Project ID or project name
       * @param {string} secureFileId - The unique secure file Id
       */
      updateSecureFile(secureFile, project, secureFileId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              secureFileId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, secureFile, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.SecureFile, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update properties and/or names of a set of secure files. Files are identified by their IDs. Properties provided override the existing one entirely, i.e. do not merge.
       *
       * @param {TaskAgentInterfaces.SecureFile[]} secureFiles - A list of secure file objects. Only three field must be populated Id, Name, and Properties. The rest of fields in the object are ignored.
       * @param {string} project - Project ID or project name
       */
      updateSecureFiles(secureFiles, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, secureFiles, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.SecureFile, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Upload a secure file, include the file stream in the request body
       *
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} project - Project ID or project name
       * @param {string} name - Name of the file to upload
       * @param {boolean} authorizePipelines - If authorizePipelines is true, then the secure file is authorized for use by all pipelines in the project.
       */
      uploadSecureFile(customHeaders, contentStream, project, name, authorizePipelines) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (name == null) {
            throw new TypeError("name can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              name,
              authorizePipelines
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "adcfd8bc-b184-43ba-bd84-7c8c6a2ff421", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.SecureFile, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskAgentSession} session
       * @param {number} poolId
       */
      createAgentSession(session, poolId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "134e239e-2df3-4794-a6f6-24f1f19ec8dc", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, session, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentSession, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {string} sessionId
       */
      deleteAgentSession(poolId, sessionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              sessionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "134e239e-2df3-4794-a6f6-24f1f19ec8dc", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Register a deployment target to a deployment group. Generally this is called by agent configuration tool.
       *
       * @param {TaskAgentInterfaces.DeploymentMachine} machine - Deployment target to register.
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group to which the deployment target is registered.
       */
      addDeploymentTarget(machine, project, deploymentGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2f0aa599-c121-4256-a5fd-ba370e0ae7b6", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, machine, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a deployment target in a deployment group. This deletes the agent from associated deployment pool too.
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group in which deployment target is deleted.
       * @param {number} targetId - ID of the deployment target to delete.
       */
      deleteDeploymentTarget(project, deploymentGroupId, targetId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId,
              targetId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2f0aa599-c121-4256-a5fd-ba370e0ae7b6", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a deployment target by its ID in a deployment group
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group to which deployment target belongs.
       * @param {number} targetId - ID of the deployment target to return.
       * @param {TaskAgentInterfaces.DeploymentTargetExpands} expand - Include these additional details in the returned objects.
       */
      getDeploymentTarget(project, deploymentGroupId, targetId, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId,
              targetId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2f0aa599-c121-4256-a5fd-ba370e0ae7b6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of deployment targets in a deployment group.
       *
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group.
       * @param {string[]} tags - Get only the deployment targets that contain all these comma separted list of tags.
       * @param {string} name - Name pattern of the deployment targets to return.
       * @param {boolean} partialNameMatch - When set to true, treats **name** as pattern. Else treats it as absolute match. Default is **false**.
       * @param {TaskAgentInterfaces.DeploymentTargetExpands} expand - Include these additional details in the returned objects.
       * @param {TaskAgentInterfaces.TaskAgentStatusFilter} agentStatus - Get only deployment targets that have this status.
       * @param {TaskAgentInterfaces.TaskAgentJobResultFilter} agentJobResult - Get only deployment targets that have this last job result.
       * @param {string} continuationToken - Get deployment targets with names greater than this continuationToken lexicographically.
       * @param {number} top - Maximum number of deployment targets to return. Default is **1000**.
       * @param {boolean} enabled - Get only deployment targets that are enabled or disabled. Default is 'null' which returns all the targets.
       * @param {string[]} propertyFilters
       */
      getDeploymentTargets(project, deploymentGroupId, tags, name, partialNameMatch, expand, agentStatus, agentJobResult, continuationToken, top, enabled, propertyFilters) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            let queryValues = {
              tags: tags && tags.join(","),
              name,
              partialNameMatch,
              "$expand": expand,
              agentStatus,
              agentJobResult,
              continuationToken,
              "$top": top,
              enabled,
              propertyFilters: propertyFilters && propertyFilters.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2f0aa599-c121-4256-a5fd-ba370e0ae7b6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Replace a deployment target in a deployment group. Generally this is called by agent configuration tool.
       *
       * @param {TaskAgentInterfaces.DeploymentMachine} machine - New deployment target.
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group in which deployment target is replaced.
       * @param {number} targetId - ID of the deployment target to replace.
       */
      replaceDeploymentTarget(machine, project, deploymentGroupId, targetId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId,
              targetId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2f0aa599-c121-4256-a5fd-ba370e0ae7b6", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, machine, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a deployment target and its agent properties in a deployment group. Generally this is called by agent configuration tool.
       *
       * @param {TaskAgentInterfaces.DeploymentMachine} machine - Deployment target to update.
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group in which deployment target is updated.
       * @param {number} targetId - ID of the deployment target to update.
       */
      updateDeploymentTarget(machine, project, deploymentGroupId, targetId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId,
              targetId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2f0aa599-c121-4256-a5fd-ba370e0ae7b6", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, machine, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update tags of a list of deployment targets in a deployment group.
       *
       * @param {TaskAgentInterfaces.DeploymentTargetUpdateParameter[]} machines - Deployment targets with tags to udpdate.
       * @param {string} project - Project ID or project name
       * @param {number} deploymentGroupId - ID of the deployment group in which deployment targets are updated.
       */
      updateDeploymentTargets(machines, project, deploymentGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              deploymentGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "2f0aa599-c121-4256-a5fd-ba370e0ae7b6", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, machines, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.DeploymentMachine, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a task group.
       *
       * @param {TaskAgentInterfaces.TaskGroupCreateParameter} taskGroup - Task group object to create.
       * @param {string} project - Project ID or project name
       */
      addTaskGroup(taskGroup, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, taskGroup, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a task group.
       *
       * @param {string} project - Project ID or project name
       * @param {string} taskGroupId - Id of the task group to be deleted.
       * @param {string} comment - Comments to delete.
       */
      deleteTaskGroup(project, taskGroupId, comment) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              taskGroupId
            };
            let queryValues = {
              comment
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get task group.
       *
       * @param {string} project - Project ID or project name
       * @param {string} taskGroupId - Id of the task group.
       * @param {string} versionSpec - version specification of the task group. examples: 1, 1.0.
       * @param {TaskAgentInterfaces.TaskGroupExpands} expand - The properties that should be expanded. example $expand=Tasks will expand nested task groups.
       */
      getTaskGroup(project, taskGroupId, versionSpec, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (versionSpec == null) {
            throw new TypeError("versionSpec can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              taskGroupId
            };
            let queryValues = {
              versionSpec,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} taskGroupId
       * @param {number} revision
       */
      getTaskGroupRevision(project, taskGroupId, revision) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (revision == null) {
            throw new TypeError("revision can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              taskGroupId
            };
            let queryValues = {
              revision
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * List task groups.
       *
       * @param {string} project - Project ID or project name
       * @param {string} taskGroupId - Id of the task group.
       * @param {boolean} expanded - 'true' to recursively expand task groups. Default is 'false'.
       * @param {string} taskIdFilter - Guid of the taskId to filter.
       * @param {boolean} deleted - 'true'to include deleted task groups. Default is 'false'.
       * @param {number} top - Number of task groups to get.
       * @param {Date} continuationToken - Gets the task groups after the continuation token provided.
       * @param {TaskAgentInterfaces.TaskGroupQueryOrder} queryOrder - Gets the results in the defined order. Default is 'CreatedOnDescending'.
       */
      getTaskGroups(project, taskGroupId, expanded, taskIdFilter, deleted, top, continuationToken, queryOrder) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              taskGroupId
            };
            let queryValues = {
              expanded,
              taskIdFilter,
              deleted,
              "$top": top,
              continuationToken,
              queryOrder
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.PublishTaskGroupMetadata} taskGroupMetadata
       * @param {string} project - Project ID or project name
       * @param {string} parentTaskGroupId
       */
      publishTaskGroup(taskGroupMetadata, project, parentTaskGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (parentTaskGroupId == null) {
            throw new TypeError("parentTaskGroupId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              parentTaskGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, taskGroupMetadata, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskGroup} taskGroup
       * @param {string} project - Project ID or project name
       */
      undeleteTaskGroup(taskGroup, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, taskGroup, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a task group.
       *
       * @param {TaskAgentInterfaces.TaskGroupUpdateParameter} taskGroup - Task group to update.
       * @param {string} project - Project ID or project name
       * @param {string} taskGroupId - Id of the task group to update.
       */
      updateTaskGroup(taskGroup, project, taskGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              taskGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, taskGroup, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.TaskGroupUpdatePropertiesBase} taskGroupUpdateProperties
       * @param {string} project - Project ID or project name
       * @param {string} taskGroupId
       * @param {boolean} disablePriorVersions
       */
      updateTaskGroupProperties(taskGroupUpdateProperties, project, taskGroupId, disablePriorVersions) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              taskGroupId
            };
            let queryValues = {
              disablePriorVersions
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "6c08ffbf-dbf1-4f9a-94e5-a1cbd47005e7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, taskGroupUpdateProperties, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} taskId
       */
      deleteTaskDefinition(taskId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              taskId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} taskId
       * @param {string} versionString
       * @param {string[]} visibility
       * @param {boolean} scopeLocal
       */
      getTaskContentZip(taskId, versionString, visibility, scopeLocal) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              taskId,
              versionString
            };
            let queryValues = {
              visibility,
              scopeLocal
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} taskId
       * @param {string} versionString
       * @param {string[]} visibility
       * @param {boolean} scopeLocal
       */
      getTaskDefinition(taskId, versionString, visibility, scopeLocal) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              taskId,
              versionString
            };
            let queryValues = {
              visibility,
              scopeLocal
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskDefinition, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} taskId
       * @param {string[]} visibility
       * @param {boolean} scopeLocal
       * @param {boolean} allVersions
       */
      getTaskDefinitions(taskId, visibility, scopeLocal, allVersions) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              taskId
            };
            let queryValues = {
              visibility,
              scopeLocal,
              allVersions
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {number} poolId
       * @param {number} agentId
       * @param {string} currentState
       */
      updateAgentUpdateState(poolId, agentId, currentState) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (currentState == null) {
            throw new TypeError("currentState can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              agentId
            };
            let queryValues = {
              currentState
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "8cc1b02b-ae49-4516-b5ad-4f9b29967c30", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgent, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {{ [key: string] : string; }} userCapabilities
       * @param {number} poolId
       * @param {number} agentId
       */
      updateAgentUserCapabilities(userCapabilities, poolId, agentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              poolId,
              agentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "30ba3ada-fedf-4da8-bbb5-dacf2f82e176", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, userCapabilities, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgent, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add a variable group.
       *
       * @param {TaskAgentInterfaces.VariableGroupParameters} variableGroupParameters
       */
      addVariableGroup(variableGroupParameters) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "ef5b7057-ffc3-4c77-bbad-c10b4a4abcc7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, variableGroupParameters, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VariableGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a variable group
       *
       * @param {number} groupId - Id of the variable group.
       * @param {string[]} projectIds
       */
      deleteVariableGroup(groupId, projectIds) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (projectIds == null) {
            throw new TypeError("projectIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              groupId
            };
            let queryValues = {
              projectIds: projectIds && projectIds.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "ef5b7057-ffc3-4c77-bbad-c10b4a4abcc7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add a variable group.
       *
       * @param {TaskAgentInterfaces.VariableGroupProjectReference[]} variableGroupProjectReferences
       * @param {number} variableGroupId
       */
      shareVariableGroup(variableGroupProjectReferences, variableGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (variableGroupId == null) {
            throw new TypeError("variableGroupId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              variableGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "ef5b7057-ffc3-4c77-bbad-c10b4a4abcc7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, variableGroupProjectReferences, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a variable group.
       *
       * @param {TaskAgentInterfaces.VariableGroupParameters} variableGroupParameters
       * @param {number} groupId - Id of the variable group to update.
       */
      updateVariableGroup(variableGroupParameters, groupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              groupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "ef5b7057-ffc3-4c77-bbad-c10b4a4abcc7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, variableGroupParameters, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VariableGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a variable group.
       *
       * @param {string} project - Project ID or project name
       * @param {number} groupId - Id of the variable group.
       */
      getVariableGroup(project, groupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              groupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "f5b09dd5-9d54-45a1-8b5a-1c8287d634cc", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VariableGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get variable groups.
       *
       * @param {string} project - Project ID or project name
       * @param {string} groupName - Name of variable group.
       * @param {TaskAgentInterfaces.VariableGroupActionFilter} actionFilter - Action filter for the variable group. It specifies the action which can be performed on the variable groups.
       * @param {number} top - Number of variable groups to get.
       * @param {number} continuationToken - Gets the variable groups after the continuation token provided.
       * @param {TaskAgentInterfaces.VariableGroupQueryOrder} queryOrder - Gets the results in the defined order. Default is 'IdDescending'.
       */
      getVariableGroups(project, groupName, actionFilter, top, continuationToken, queryOrder) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              groupName,
              actionFilter,
              "$top": top,
              continuationToken,
              queryOrder
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "f5b09dd5-9d54-45a1-8b5a-1c8287d634cc", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VariableGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get variable groups by ids.
       *
       * @param {string} project - Project ID or project name
       * @param {number[]} groupIds - Comma separated list of Ids of variable groups.
       * @param {boolean} loadSecrets
       */
      getVariableGroupsById(project, groupIds, loadSecrets) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (groupIds == null) {
            throw new TypeError("groupIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              groupIds: groupIds && groupIds.join(","),
              loadSecrets
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "f5b09dd5-9d54-45a1-8b5a-1c8287d634cc", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VariableGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.VirtualMachineGroupCreateParameters} createParameters
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       */
      addVirtualMachineGroup(createParameters, project, environmentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "9e597901-4af7-4cc3-8d92-47d54db8ebfb", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, createParameters, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VirtualMachineGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       * @param {number} resourceId
       */
      deleteVirtualMachineGroup(project, environmentId, resourceId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId,
              resourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "9e597901-4af7-4cc3-8d92-47d54db8ebfb", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       * @param {number} resourceId
       */
      getVirtualMachineGroup(project, environmentId, resourceId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId,
              resourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "9e597901-4af7-4cc3-8d92-47d54db8ebfb", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VirtualMachineGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.VirtualMachineGroup} resource
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       */
      updateVirtualMachineGroup(resource, project, environmentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "9e597901-4af7-4cc3-8d92-47d54db8ebfb", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, resource, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VirtualMachineGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       * @param {number} resourceId
       * @param {string} continuationToken
       * @param {string} name
       * @param {boolean} partialNameMatch
       * @param {string[]} tags
       * @param {number} top
       */
      getVirtualMachines(project, environmentId, resourceId, continuationToken, name, partialNameMatch, tags, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId,
              resourceId
            };
            let queryValues = {
              continuationToken,
              name,
              partialNameMatch,
              tags: tags && tags.join(","),
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "48700676-2ba5-4282-8ec8-083280d169c7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VirtualMachine, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.VirtualMachine[]} machines
       * @param {string} project - Project ID or project name
       * @param {number} environmentId
       * @param {number} resourceId
       */
      updateVirtualMachines(machines, project, environmentId, resourceId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              environmentId,
              resourceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "48700676-2ba5-4282-8ec8-083280d169c7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, machines, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.VirtualMachine, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} tenantId
       * @param {string} redirectUri
       * @param {TaskAgentInterfaces.AadLoginPromptOption} promptOption
       * @param {string} completeCallbackPayload
       * @param {boolean} completeCallbackByAuthCode
       */
      createAadOAuthRequest(tenantId, redirectUri, promptOption, completeCallbackPayload, completeCallbackByAuthCode) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (tenantId == null) {
            throw new TypeError("tenantId can not be null or undefined");
          }
          if (redirectUri == null) {
            throw new TypeError("redirectUri can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              tenantId,
              redirectUri,
              promptOption,
              completeCallbackPayload,
              completeCallbackByAuthCode
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "9c63205e-3a0f-42a0-ad88-095200f13607", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       */
      getVstsAadTenantId() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "9c63205e-3a0f-42a0-ad88-095200f13607", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * GET the Yaml schema used for Yaml file validation.
       *
       * @param {boolean} validateTaskNames - Whether the schema should validate that tasks are actually installed (useful for offline tools where you don't want validation).
       */
      getYamlSchema(validateTaskNames) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              validateTaskNames
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "1f9990b9-1dba-441f-9c2e-6485888c42b6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.TaskAgentApiBase = TaskAgentApiBase;
    TaskAgentApiBase.RESOURCE_AREA_ID = "a85b8835-c1a1-4aac-ae97-1c3d0ba72dbd";
  }
});

// ../node_modules/azure-devops-node-api/TaskAgentApi.js
var require_TaskAgentApi = __commonJS({
  "../node_modules/azure-devops-node-api/TaskAgentApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TaskAgentApi = void 0;
    var taskagentbasem = require_TaskAgentApiBase();
    var url = require("url");
    var TaskAgentApi = class _TaskAgentApi extends taskagentbasem.TaskAgentApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, options);
        this._handlers = handlers;
        this._options = options;
      }
      /**
       * @param {string} taskId
       * @param onResult callback function
       */
      deleteTaskDefinition(taskId) {
        let promise = this.vsoClient.beginGetLocation("distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd").then((location) => {
          if (location) {
            return super.deleteTaskDefinition(taskId);
          } else {
            var fallbackClient = this._getFallbackClient(this.baseUrl);
            if (!fallbackClient) {
              throw new Error("Failed to find api location for area: distributedtask id: 60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd");
            } else {
              return fallbackClient.deleteTaskDefinition(taskId);
            }
          }
        });
        return promise;
      }
      /**
       * @param {string} taskId
       * @param {string} versionString
       * @param {string[]} visibility
       * @param {boolean} scopeLocal
       * @param onResult callback function with the resulting ArrayBuffer
       */
      getTaskContentZip(taskId, versionString, visibility, scopeLocal) {
        let promise = this.vsoClient.beginGetLocation("distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd").then((location) => {
          if (location) {
            return super.getTaskContentZip(taskId, versionString, visibility, scopeLocal);
          } else {
            var fallbackClient = this._getFallbackClient(this.baseUrl);
            if (!fallbackClient) {
              throw new Error("Failed to find api location for area: distributedtask id: 60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd");
            } else {
              return fallbackClient.getTaskContentZip(taskId, versionString, visibility, scopeLocal);
            }
          }
        });
        return promise;
      }
      /**
       * @param {string} taskId
       * @param {string} versionString
       * @param {string[]} visibility
       * @param {boolean} scopeLocal
       * @param onResult callback function with the resulting TaskAgentInterfaces.TaskDefinition
       */
      getTaskDefinition(taskId, versionString, visibility, scopeLocal) {
        let promise = this.vsoClient.beginGetLocation("distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd").then((location) => {
          if (location) {
            return super.getTaskDefinition(taskId, versionString, visibility, scopeLocal);
          } else {
            var fallbackClient = this._getFallbackClient(this.baseUrl);
            if (!fallbackClient) {
              throw new Error("Failed to find api location for area: distributedtask id: 60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd");
            } else {
              return fallbackClient.getTaskDefinition(taskId, versionString, visibility, scopeLocal);
            }
          }
        });
        return promise;
      }
      /**
       * @param {string} taskId
       * @param {string[]} visibility
       * @param {boolean} scopeLocal
       * @param onResult callback function with the resulting TaskAgentInterfaces.TaskDefinition[]
       */
      getTaskDefinitions(taskId, visibility, scopeLocal) {
        let promise = this.vsoClient.beginGetLocation("distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd").then((location) => {
          if (location) {
            return super.getTaskDefinitions(taskId, visibility, scopeLocal);
          } else {
            var fallbackClient = this._getFallbackClient(this.baseUrl);
            if (!fallbackClient) {
              throw new Error("Failed to find api location for area: distributedtask id: 60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd");
            } else {
              return fallbackClient.getTaskDefinitions(taskId, visibility, scopeLocal);
            }
          }
        });
        return promise;
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream
       * @param {string} taskId
       * @param {boolean} overwrite
       * @param onResult callback function
       */
      uploadTaskDefinition(customHeaders, contentStream, taskId, overwrite) {
        return __awaiter2(this, void 0, void 0, function* () {
          let routeValues = {
            taskId
          };
          let queryValues = {
            overwrite
          };
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("3.0-preview.1", "distributedtask", "60aac929-f0cd-4bc8-9ce4-6b30e8f1b1bd", routeValues, queryValues);
              let url2 = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url2, contentStream, options);
              resolve(res.result);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      _getFallbackClient(baseUrl) {
        if (!this._fallbackClient) {
          var accountUrl = this._getAccountUrl(baseUrl);
          if (accountUrl) {
            this._fallbackClient = new _TaskAgentApi(accountUrl, this._handlers, this._options);
          }
        }
        return this._fallbackClient;
      }
      _getAccountUrl(collectionUrl) {
        var purl = url.parse(collectionUrl);
        if (!purl.protocol || !purl.host) {
          return null;
        }
        var accountUrl = purl.protocol + "//" + purl.host;
        var splitPath = purl.path.split("/").slice(1);
        if (splitPath.length === 0 || splitPath.length === 1 && splitPath[0] === "") {
          return null;
        }
        if (splitPath[0] === "tfs" && (splitPath.length === 2 || splitPath.length === 3 && splitPath[2].length === 0)) {
          accountUrl += "/tfs";
        } else if (splitPath.length === 2 && splitPath[0] === "") {
          return accountUrl;
        } else if (splitPath.length > 1) {
          return null;
        }
        return accountUrl;
      }
    };
    exports2.TaskAgentApi = TaskAgentApi;
  }
});

// ../node_modules/azure-devops-node-api/TaskApi.js
var require_TaskApi = __commonJS({
  "../node_modules/azure-devops-node-api/TaskApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TaskApi = void 0;
    var basem = require_ClientApiBases();
    var TaskAgentInterfaces = require_TaskAgentInterfaces();
    var TaskApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Task-api", options);
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} type
       */
      getPlanAttachments(scopeIdentifier, hubName, planId, type) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "eb55e5d6-2f30-4295-b5ed-38da50b1fc52", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       * @param {string} recordId
       * @param {string} type
       * @param {string} name
       */
      createAttachment(customHeaders, contentStream, scopeIdentifier, hubName, planId, timelineId, recordId, type, name) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId,
              recordId,
              type,
              name
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("PUT", url, contentStream, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAttachment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       * @param {string} recordId
       * @param {string} type
       * @param {string} name
       * @param {string} artifactHash
       * @param {number} length
       */
      createAttachmentFromArtifact(scopeIdentifier, hubName, planId, timelineId, recordId, type, name, artifactHash, length) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (artifactHash == null) {
            throw new TypeError("artifactHash can not be null or undefined");
          }
          if (length == null) {
            throw new TypeError("length can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId,
              recordId,
              type,
              name
            };
            let queryValues = {
              artifactHash,
              length
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAttachment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       * @param {string} recordId
       * @param {string} type
       * @param {string} name
       */
      getAttachment(scopeIdentifier, hubName, planId, timelineId, recordId, type, name) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId,
              recordId,
              type,
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAttachment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       * @param {string} recordId
       * @param {string} type
       * @param {string} name
       */
      getAttachmentContent(scopeIdentifier, hubName, planId, timelineId, recordId, type, name) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId,
              recordId,
              type,
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       * @param {string} recordId
       * @param {string} type
       */
      getAttachments(scopeIdentifier, hubName, planId, timelineId, recordId, type) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId,
              recordId,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "7898f959-9cdf-4096-b29e-7f293031629e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Append content to timeline record feed.
       *
       * @param {TaskAgentInterfaces.TimelineRecordFeedLinesWrapper} lines - Content to be appended to the timeline record feed.
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId - ID of the plan.
       * @param {string} timelineId - ID of the task's timeline.
       * @param {string} recordId - ID of the timeline record.
       */
      appendTimelineRecordFeed(lines, scopeIdentifier, hubName, planId, timelineId, recordId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId,
              recordId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "858983e4-19bd-4c5e-864c-507b59b58b12", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, lines, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       * @param {string} recordId
       * @param {string} stepId
       * @param {number} endLine
       * @param {number} takeCount
       * @param {string} continuationToken
       */
      getLines(scopeIdentifier, hubName, planId, timelineId, recordId, stepId, endLine, takeCount, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (stepId == null) {
            throw new TypeError("stepId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId,
              recordId
            };
            let queryValues = {
              stepId,
              endLine,
              takeCount,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "858983e4-19bd-4c5e-864c-507b59b58b12", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} orchestrationId
       */
      getJobInstance(scopeIdentifier, hubName, orchestrationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              orchestrationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "0a1efd25-abda-43bd-9629-6c7bdd2e0d60", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskAgentJob, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Append a log to a task's log. The log should be sent in the body of the request as a TaskLog object stream.
       *
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId - The ID of the plan.
       * @param {number} logId - The ID of the log.
       */
      appendLogContent(customHeaders, contentStream, scopeIdentifier, hubName, planId, logId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              logId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskLog, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {number} logId
       * @param {string} serializedBlobId
       * @param {number} lineCount
       */
      associateLog(scopeIdentifier, hubName, planId, logId, serializedBlobId, lineCount) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (serializedBlobId == null) {
            throw new TypeError("serializedBlobId can not be null or undefined");
          }
          if (lineCount == null) {
            throw new TypeError("lineCount can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              logId
            };
            let queryValues = {
              serializedBlobId,
              lineCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskLog, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a log and connect it to a pipeline run's execution plan.
       *
       * @param {TaskAgentInterfaces.TaskLog} log - An object that contains information about log's path.
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId - The ID of the plan.
       */
      createLog(log, scopeIdentifier, hubName, planId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, log, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskLog, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {number} logId
       * @param {number} startLine
       * @param {number} endLine
       */
      getLog(scopeIdentifier, hubName, planId, logId, startLine, endLine) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              logId
            };
            let queryValues = {
              startLine,
              endLine
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       */
      getLogs(scopeIdentifier, hubName, planId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "46f5667d-263a-4684-91b1-dff7fdcf64e2", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskLog, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       */
      getPlanGroupsQueueMetrics(scopeIdentifier, hubName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "038fd4d5-cda7-44ca-92c0-935843fee1a7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskOrchestrationPlanGroupsQueueMetrics, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {{ [key: string] : string; }} claims
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} jobId
       * @param {string} serviceConnectionId
       */
      createOidcToken(claims, scopeIdentifier, hubName, planId, jobId, serviceConnectionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              jobId
            };
            let queryValues = {
              serviceConnectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "69a319f4-28c1-4bfd-93e6-ea0ff5c6f1a2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, claims, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {TaskAgentInterfaces.PlanGroupStatus} statusFilter
       * @param {number} count
       */
      getQueuedPlanGroups(scopeIdentifier, hubName, statusFilter, count) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName
            };
            let queryValues = {
              statusFilter,
              count
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "0dd73091-3e36-4f43-b443-1b76dd426d84", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskOrchestrationQueuedPlanGroup, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planGroup
       */
      getQueuedPlanGroup(scopeIdentifier, hubName, planGroup) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planGroup
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "65fd0708-bc1e-447b-a731-0587c5464e5b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskOrchestrationQueuedPlanGroup, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       */
      getPlan(scopeIdentifier, hubName, planId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "distributedtask", "5cecd946-d704-471e-a45f-3b4064fcfaba", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TaskOrchestrationPlan, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       * @param {number} changeId
       */
      getRecords(scopeIdentifier, hubName, planId, timelineId, changeId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId
            };
            let queryValues = {
              changeId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "8893bc5b-35b2-4be7-83cb-99e683551db4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TimelineRecord, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update timeline records if they already exist, otherwise create new ones for the same timeline.
       *
       * @param {VSSInterfaces.VssJsonCollectionWrapperV<TaskAgentInterfaces.TimelineRecord[]>} records - The array of timeline records to be updated.
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId - The ID of the plan.
       * @param {string} timelineId - The ID of the timeline.
       */
      updateRecords(records, scopeIdentifier, hubName, planId, timelineId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "8893bc5b-35b2-4be7-83cb-99e683551db4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, records, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.TimelineRecord, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TaskAgentInterfaces.Timeline} timeline
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       */
      createTimeline(timeline, scopeIdentifier, hubName, planId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "83597576-cc2c-453c-bea6-2882ae6a1653", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, timeline, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.Timeline, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       */
      deleteTimeline(scopeIdentifier, hubName, planId, timelineId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "83597576-cc2c-453c-bea6-2882ae6a1653", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       * @param {string} timelineId
       * @param {number} changeId
       * @param {boolean} includeRecords
       */
      getTimeline(scopeIdentifier, hubName, planId, timelineId, changeId, includeRecords) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId,
              timelineId
            };
            let queryValues = {
              changeId,
              includeRecords
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "83597576-cc2c-453c-bea6-2882ae6a1653", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.Timeline, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} scopeIdentifier - The project GUID to scope the request
       * @param {string} hubName - The name of the server hub. Common examples: "build", "rm", "checks"
       * @param {string} planId
       */
      getTimelines(scopeIdentifier, hubName, planId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              scopeIdentifier,
              hubName,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "distributedtask", "83597576-cc2c-453c-bea6-2882ae6a1653", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TaskAgentInterfaces.TypeInfo.Timeline, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.TaskApi = TaskApi;
  }
});

// ../node_modules/azure-devops-node-api/TestApi.js
var require_TestApi = __commonJS({
  "../node_modules/azure-devops-node-api/TestApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TestApi = void 0;
    var basem = require_ClientApiBases();
    var TestInterfaces = require_TestInterfaces();
    var TestApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Test-api", options);
      }
      /**
       * Attach a file to test step result
       *
       * @param {TestInterfaces.TestAttachmentRequestModel} attachmentRequestModel - Attachment details TestAttachmentRequestModel
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test result that contains the iteration
       * @param {number} iterationId - ID of the test result iteration.
       * @param {string} actionPath - Hex value of test result action path.
       */
      createTestIterationResultAttachment(attachmentRequestModel, project, runId, testCaseResultId, iterationId, actionPath) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (iterationId == null) {
            throw new TypeError("iterationId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            let queryValues = {
              iterationId,
              actionPath
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Attach a file to a test result.
       *
       * @param {TestInterfaces.TestAttachmentRequestModel} attachmentRequestModel - Attachment details TestAttachmentRequestModel
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test result against which attachment has to be uploaded.
       */
      createTestResultAttachment(attachmentRequestModel, project, runId, testCaseResultId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Attach a file to a test result
       *
       * @param {TestInterfaces.TestAttachmentRequestModel} attachmentRequestModel - Attachment Request Model.
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test results that contains sub result.
       * @param {number} testSubResultId - ID of the test sub results against which attachment has to be uploaded.
       */
      createTestSubResultAttachment(attachmentRequestModel, project, runId, testCaseResultId, testSubResultId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            let queryValues = {
              testSubResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Download a test result attachment by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the testCaseResultId.
       * @param {number} testCaseResultId - ID of the test result whose attachment has to be downloaded.
       * @param {number} attachmentId - ID of the test result attachment to be downloaded.
       */
      getTestResultAttachmentContent(project, runId, testCaseResultId, attachmentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of test result attachments reference.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test result.
       */
      getTestResultAttachments(project, runId, testCaseResultId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Download a test result attachment by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the testCaseResultId.
       * @param {number} testCaseResultId - ID of the test result whose attachment has to be downloaded.
       * @param {number} attachmentId - ID of the test result attachment to be downloaded.
       */
      getTestResultAttachmentZip(project, runId, testCaseResultId, attachmentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Download a test sub result attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test results that contains sub result.
       * @param {number} attachmentId - ID of the test result attachment to be downloaded
       * @param {number} testSubResultId - ID of the test sub result whose attachment has to be downloaded
       */
      getTestSubResultAttachmentContent(project, runId, testCaseResultId, attachmentId, testSubResultId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            let queryValues = {
              testSubResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of test sub result attachments
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test results that contains sub result.
       * @param {number} testSubResultId - ID of the test sub result whose attachment has to be downloaded
       */
      getTestSubResultAttachments(project, runId, testCaseResultId, testSubResultId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            let queryValues = {
              testSubResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Download a test sub result attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test results that contains sub result.
       * @param {number} attachmentId - ID of the test result attachment to be downloaded
       * @param {number} testSubResultId - ID of the test sub result whose attachment has to be downloaded
       */
      getTestSubResultAttachmentZip(project, runId, testCaseResultId, attachmentId, testSubResultId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            let queryValues = {
              testSubResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "2bffebe9-2f0f-4639-9af8-56129e9fed2d", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Attach a file to a test run.
       *
       * @param {TestInterfaces.TestAttachmentRequestModel} attachmentRequestModel - Attachment details TestAttachmentRequestModel
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run against which attachment has to be uploaded.
       */
      createTestRunAttachment(attachmentRequestModel, project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "4f004af4-a507-489c-9b13-cb62060beb11", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Download a test run attachment by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run whose attachment has to be downloaded.
       * @param {number} attachmentId - ID of the test run attachment to be downloaded.
       */
      getTestRunAttachmentContent(project, runId, attachmentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "4f004af4-a507-489c-9b13-cb62060beb11", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of test run attachments reference.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run.
       */
      getTestRunAttachments(project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "4f004af4-a507-489c-9b13-cb62060beb11", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Download a test run attachment by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run whose attachment has to be downloaded.
       * @param {number} attachmentId - ID of the test run attachment to be downloaded.
       */
      getTestRunAttachmentZip(project, runId, attachmentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "4f004af4-a507-489c-9b13-cb62060beb11", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       */
      getBugsLinkedToTestResult(project, runId, testCaseResultId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "6de20ca2-67de-4faf-97fa-38c5d585eb00", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get code coverage data for a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - ID of the build for which code coverage data needs to be fetched.
       * @param {number} flags - Value of flags determine the level of code coverage details to be fetched. Flags are additive. Expected Values are 1 for Modules, 2 for Functions, 4 for BlockData.
       */
      getBuildCodeCoverage(project, buildId, flags) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          if (flags == null) {
            throw new TypeError("flags can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              flags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "77560e8a-4e8c-4d59-894e-a5f264c24444", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.BuildCoverage, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Code Coverage Summary for Build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - ID of the build for which code coverage data needs to be fetched.
       * @param {number} deltaBuildId - Delta Build id (optional)
       */
      getCodeCoverageSummary(project, buildId, deltaBuildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              deltaBuildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "77560e8a-4e8c-4d59-894e-a5f264c24444", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.CodeCoverageSummary, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * http://(tfsserver):8080/tfs/DefaultCollection/_apis/test/CodeCoverage?buildId=10 Request: Json of code coverage summary
       *
       * @param {TestInterfaces.CodeCoverageData} coverageData
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       */
      updateCodeCoverageSummary(coverageData, project, buildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "77560e8a-4e8c-4d59-894e-a5f264c24444", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, coverageData, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get code coverage data for a test run
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run for which code coverage data needs to be fetched.
       * @param {number} flags - Value of flags determine the level of code coverage details to be fetched. Flags are additive. Expected Values are 1 for Modules, 2 for Functions, 4 for BlockData.
       */
      getTestRunCodeCoverage(project, runId, flags) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (flags == null) {
            throw new TypeError("flags can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              flags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "9629116f-3b89-4ed8-b358-d4694efda160", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.CustomTestFieldDefinition[]} newFields
       * @param {string} project - Project ID or project name
       */
      addCustomFields(newFields, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "8ce1923b-f4c7-4e22-b93b-f6284e525ec2", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, newFields, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.CustomTestFieldDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {TestInterfaces.CustomTestFieldScope} scopeFilter
       */
      queryCustomFields(project, scopeFilter) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (scopeFilter == null) {
            throw new TypeError("scopeFilter can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              scopeFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "8ce1923b-f4c7-4e22-b93b-f6284e525ec2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.CustomTestFieldDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.ResultsFilter} filter
       * @param {string} project - Project ID or project name
       */
      queryTestResultHistory(filter2, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "234616f5-429c-4e7b-9192-affd76731dfd", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestResultHistory, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get iteration for a result
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test result that contains the iterations.
       * @param {number} iterationId - Id of the test results Iteration.
       * @param {boolean} includeActionResults - Include result details for each action performed in the test iteration. ActionResults refer to outcome (pass/fail) of test steps that are executed as part of a running a manual test. Including the ActionResults flag gets the outcome of test steps in the actionResults section and test parameters in the parameters section for each test iteration.
       */
      getTestIteration(project, runId, testCaseResultId, iterationId, includeActionResults) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              iterationId
            };
            let queryValues = {
              includeActionResults
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "73eb9074-3446-4c44-8296-2f811950ff8d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestIterationDetailsModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get iterations for a result
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the test run that contains the result.
       * @param {number} testCaseResultId - ID of the test result that contains the iterations.
       * @param {boolean} includeActionResults - Include result details for each action performed in the test iteration. ActionResults refer to outcome (pass/fail) of test steps that are executed as part of a running a manual test. Including the ActionResults flag gets the outcome of test steps in the actionResults section and test parameters in the parameters section for each test iteration.
       */
      getTestIterations(project, runId, testCaseResultId, includeActionResults) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            let queryValues = {
              includeActionResults
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "73eb9074-3446-4c44-8296-2f811950ff8d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestIterationDetailsModel, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.LinkedWorkItemsQuery} workItemQuery
       * @param {string} project - Project ID or project name
       */
      getLinkedWorkItemsByQuery(workItemQuery, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "a4dcb25b-9878-49ea-abfd-e440bd9b1dcd", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, workItemQuery, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test run message logs
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the run to get.
       */
      getTestRunLogs(project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "a1e55200-637e-42e9-a7c0-7e5bfdedb1b3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestMessageLogDetails, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a test point.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan.
       * @param {number} suiteId - ID of the suite that contains the point.
       * @param {number} pointIds - ID of the test point to get.
       * @param {string} witFields - Comma-separated list of work item field names.
       */
      getPoint(project, planId, suiteId, pointIds, witFields) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId,
              pointIds
            };
            let queryValues = {
              witFields
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "3bcfd5c8-be62-488e-b1da-b8289ce9299c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestPoint, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of test points.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan.
       * @param {number} suiteId - ID of the suite that contains the points.
       * @param {string} witFields - Comma-separated list of work item field names.
       * @param {string} configurationId - Get test points for specific configuration.
       * @param {string} testCaseId - Get test points for a specific test case, valid when configurationId is not set.
       * @param {string} testPointIds - Get test points for comma-separated list of test point IDs, valid only when configurationId and testCaseId are not set.
       * @param {boolean} includePointDetails - Include all properties for the test point.
       * @param {number} skip - Number of test points to skip..
       * @param {number} top - Number of test points to return.
       */
      getPoints(project, planId, suiteId, witFields, configurationId, testCaseId, testPointIds, includePointDetails, skip, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            let queryValues = {
              witFields,
              configurationId,
              testCaseId,
              testPointIds,
              includePointDetails,
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "3bcfd5c8-be62-488e-b1da-b8289ce9299c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestPoint, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update test points.
       *
       * @param {TestInterfaces.PointUpdateModel} pointUpdateModel - Data to update.
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan.
       * @param {number} suiteId - ID of the suite that contains the points.
       * @param {string} pointIds - ID of the test point to get. Use a comma-separated list of IDs to update multiple test points.
       */
      updateTestPoints(pointUpdateModel, project, planId, suiteId, pointIds) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId,
              pointIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "3bcfd5c8-be62-488e-b1da-b8289ce9299c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, pointUpdateModel, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestPoint, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test points using query.
       *
       * @param {TestInterfaces.TestPointsQuery} query - TestPointsQuery to get test points.
       * @param {string} project - Project ID or project name
       * @param {number} skip - Number of test points to skip..
       * @param {number} top - Number of test points to return.
       */
      getPointsByQuery(query, project, skip, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "b4264fd0-a5d1-43e2-82a5-b9c46b7da9ce", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, query, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestPointsQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} publishContext
       * @param {string} groupBy
       * @param {string} filter
       * @param {string} orderby
       * @param {boolean} shouldIncludeResults
       * @param {boolean} queryRunSummaryForInProgress
       */
      getTestResultDetailsForBuild(project, buildId, publishContext, groupBy, filter2, orderby, shouldIncludeResults, queryRunSummaryForInProgress) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              publishContext,
              groupBy,
              "$filter": filter2,
              "$orderby": orderby,
              shouldIncludeResults,
              queryRunSummaryForInProgress
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "efb387b0-10d5-42e7-be40-95e06ee9430f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestResultsDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} releaseEnvId
       * @param {string} publishContext
       * @param {string} groupBy
       * @param {string} filter
       * @param {string} orderby
       * @param {boolean} shouldIncludeResults
       * @param {boolean} queryRunSummaryForInProgress
       */
      getTestResultDetailsForRelease(project, releaseId, releaseEnvId, publishContext, groupBy, filter2, orderby, shouldIncludeResults, queryRunSummaryForInProgress) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          if (releaseEnvId == null) {
            throw new TypeError("releaseEnvId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              releaseEnvId,
              publishContext,
              groupBy,
              "$filter": filter2,
              "$orderby": orderby,
              shouldIncludeResults,
              queryRunSummaryForInProgress
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "b834ec7e-35bb-450f-a3c8-802e70ca40dd", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestResultsDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.TestResultDocument} document
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      publishTestResultDocument(document, project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "370ca04b-8eec-4ca8-8ba3-d24dca228791", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, document, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} publishContext
       * @param {string[]} fields
       * @param {string} continuationToken
       */
      getResultGroupsByBuild(project, buildId, publishContext, fields, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          if (publishContext == null) {
            throw new TypeError("publishContext can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              publishContext,
              fields: fields && fields.join(","),
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "d279d052-c55a-4204-b913-42f733b52958", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {string} publishContext
       * @param {number} releaseEnvId
       * @param {string[]} fields
       * @param {string} continuationToken
       */
      getResultGroupsByRelease(project, releaseId, publishContext, releaseEnvId, fields, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          if (publishContext == null) {
            throw new TypeError("publishContext can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              publishContext,
              releaseEnvId,
              fields: fields && fields.join(","),
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "ef5ce5d4-a4e5-47ee-804c-354518f8d03f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of test Result meta data details for corresponding testcasereferenceId
       *
       * @param {string[]} testReferenceIds - TestCaseReference Ids of the test Result to be queried, comma separated list of valid ids (limit no. of ids 200).
       * @param {string} project - Project ID or project name
       */
      queryTestResultsMetaData(testReferenceIds, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "afa7830e-67a7-4336-8090-2b448ca80295", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testReferenceIds, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test result retention settings
       *
       * @param {string} project - Project ID or project name
       */
      getResultRetentionSettings(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "a3206d9e-fa8d-42d3-88cb-f75c51e69cde", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.ResultRetentionSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update test result retention settings
       *
       * @param {TestInterfaces.ResultRetentionSettings} retentionSettings - Test result retention settings details to be updated
       * @param {string} project - Project ID or project name
       */
      updateResultRetentionSettings(retentionSettings, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "a3206d9e-fa8d-42d3-88cb-f75c51e69cde", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, retentionSettings, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.ResultRetentionSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add test results to a test run.
       *
       * @param {TestInterfaces.TestCaseResult[]} results - List of test results to add.
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test run ID into which test results to add.
       */
      addTestResultsToTestRun(results, project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.6", "Test", "4637d869-3a76-4468-8057-0bb02aa385cf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, results, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a test result for a test run.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test run ID of a test result to fetch.
       * @param {number} testCaseResultId - Test result ID.
       * @param {TestInterfaces.ResultDetails} detailsToInclude - Details to include with test results. Default is None. Other values are Iterations, WorkItems and SubResults.
       */
      getTestResultById(project, runId, testCaseResultId, detailsToInclude) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            let queryValues = {
              detailsToInclude
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.6", "Test", "4637d869-3a76-4468-8057-0bb02aa385cf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestCaseResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test results for a test run.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test run ID of test results to fetch.
       * @param {TestInterfaces.ResultDetails} detailsToInclude - Details to include with test results. Default is None. Other values are Iterations and WorkItems.
       * @param {number} skip - Number of test results to skip from beginning.
       * @param {number} top - Number of test results to return. Maximum is 1000 when detailsToInclude is None and 200 otherwise.
       * @param {TestInterfaces.TestOutcome[]} outcomes - Comma separated list of test outcomes to filter test results.
       */
      getTestResults(project, runId, detailsToInclude, skip, top, outcomes) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              detailsToInclude,
              "$skip": skip,
              "$top": top,
              outcomes: outcomes && outcomes.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.6", "Test", "4637d869-3a76-4468-8057-0bb02aa385cf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update test results in a test run.
       *
       * @param {TestInterfaces.TestCaseResult[]} results - List of test results to update.
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test run ID whose test results to update.
       */
      updateTestResults(results, project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.6", "Test", "4637d869-3a76-4468-8057-0bb02aa385cf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, results, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * This API will return results by Ids with fields specified/trend for particular automated test method. We are still improving this API and have not finalized proper signature and contract.
       *
       * @param {TestInterfaces.TestResultsQuery} query
       * @param {string} project - Project ID or project name
       */
      getTestResultsByQuery(query, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.6", "Test", "6711da49-8e6f-4d35-9f73-cef7a3c81a5b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, query, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestResultsQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} publishContext
       * @param {TestInterfaces.TestOutcome[]} outcomes
       * @param {number} top
       * @param {string} continuationToken
       */
      getTestResultsByBuild(project, buildId, publishContext, outcomes, top, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              publishContext,
              outcomes: outcomes && outcomes.join(","),
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "3c191b88-615b-4be2-b7d9-5ff9141e91d4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} releaseEnvid
       * @param {string} publishContext
       * @param {TestInterfaces.TestOutcome[]} outcomes
       * @param {number} top
       * @param {string} continuationToken
       */
      getTestResultsByRelease(project, releaseId, releaseEnvid, publishContext, outcomes, top, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              releaseEnvid,
              publishContext,
              outcomes: outcomes && outcomes.join(","),
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "ce01820b-83f3-4c15-a583-697a43292c4e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} publishContext
       * @param {boolean} includeFailureDetails
       * @param {TestInterfaces.BuildReference} buildToCompare
       */
      queryTestResultsReportForBuild(project, buildId, publishContext, includeFailureDetails, buildToCompare) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              publishContext,
              includeFailureDetails,
              buildToCompare
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "000ef77b-fea2-498d-a10d-ad1a037f559f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestResultSummary, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} releaseEnvId
       * @param {string} publishContext
       * @param {boolean} includeFailureDetails
       * @param {TestInterfaces.ReleaseReference} releaseToCompare
       */
      queryTestResultsReportForRelease(project, releaseId, releaseEnvId, publishContext, includeFailureDetails, releaseToCompare) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          if (releaseEnvId == null) {
            throw new TypeError("releaseEnvId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              releaseEnvId,
              publishContext,
              includeFailureDetails,
              releaseToCompare
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "85765790-ac68-494e-b268-af36c3929744", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestResultSummary, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.ReleaseReference[]} releases
       * @param {string} project - Project ID or project name
       */
      queryTestResultsSummaryForReleases(releases, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "85765790-ac68-494e-b268-af36c3929744", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, releases, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestResultSummary, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.TestResultsContext} resultsContext
       * @param {string} project - Project ID or project name
       * @param {number[]} workItemIds
       */
      queryTestSummaryByRequirement(resultsContext, project, workItemIds) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              workItemIds: workItemIds && workItemIds.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "cd08294e-308d-4460-a46e-4cfdefba0b4b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, resultsContext, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestSummaryForWorkItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.TestResultTrendFilter} filter
       * @param {string} project - Project ID or project name
       */
      queryResultTrendForBuild(filter2, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "fbc82a85-0786-4442-88bb-eb0fda6b01b0", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.AggregatedDataForResultTrend, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.TestResultTrendFilter} filter
       * @param {string} project - Project ID or project name
       */
      queryResultTrendForRelease(filter2, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "dd178e93-d8dd-4887-9635-d6b9560b7b6e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.AggregatedDataForResultTrend, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test run statistics , used when we want to get summary of a run by outcome.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the run to get.
       */
      getTestRunStatistics(project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "0a42c424-d764-4a16-a2d5-5c85f87d0ae8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestRunStatistic, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create new test run.
       *
       * @param {TestInterfaces.RunCreateModel} testRun - Run details RunCreateModel
       * @param {string} project - Project ID or project name
       */
      createTestRun(testRun, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "cadb3810-d47d-4a3c-a234-fe5f3be50138", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testRun, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestRun, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a test run by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the run to delete.
       */
      deleteTestRun(project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "cadb3810-d47d-4a3c-a234-fe5f3be50138", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a test run by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the run to get.
       * @param {boolean} includeDetails - Default value is true. It includes details like run statistics, release, build, test environment, post process state, and more.
       */
      getTestRunById(project, runId, includeDetails) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              includeDetails
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "cadb3810-d47d-4a3c-a234-fe5f3be50138", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestRun, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of test runs.
       *
       * @param {string} project - Project ID or project name
       * @param {string} buildUri - URI of the build that the runs used.
       * @param {string} owner - Team foundation ID of the owner of the runs.
       * @param {string} tmiRunId
       * @param {number} planId - ID of the test plan that the runs are a part of.
       * @param {boolean} includeRunDetails - If true, include all the properties of the runs.
       * @param {boolean} automated - If true, only returns automated runs.
       * @param {number} skip - Number of test runs to skip.
       * @param {number} top - Number of test runs to return.
       */
      getTestRuns(project, buildUri, owner, tmiRunId, planId, includeRunDetails, automated, skip, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildUri,
              owner,
              tmiRunId,
              planId,
              includeRunDetails,
              automated,
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "cadb3810-d47d-4a3c-a234-fe5f3be50138", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestRun, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Query Test Runs based on filters. Mandatory fields are minLastUpdatedDate and maxLastUpdatedDate.
       *
       * @param {string} project - Project ID or project name
       * @param {Date} minLastUpdatedDate - Minimum Last Modified Date of run to be queried (Mandatory).
       * @param {Date} maxLastUpdatedDate - Maximum Last Modified Date of run to be queried (Mandatory, difference between min and max date can be atmost 7 days).
       * @param {TestInterfaces.TestRunState} state - Current state of the Runs to be queried.
       * @param {number[]} planIds - Plan Ids of the Runs to be queried, comma separated list of valid ids (limit no. of ids 10).
       * @param {boolean} isAutomated - Automation type of the Runs to be queried.
       * @param {TestInterfaces.TestRunPublishContext} publishContext - PublishContext of the Runs to be queried.
       * @param {number[]} buildIds - Build Ids of the Runs to be queried, comma separated list of valid ids (limit no. of ids 10).
       * @param {number[]} buildDefIds - Build Definition Ids of the Runs to be queried, comma separated list of valid ids (limit no. of ids 10).
       * @param {string} branchName - Source Branch name of the Runs to be queried.
       * @param {number[]} releaseIds - Release Ids of the Runs to be queried, comma separated list of valid ids (limit no. of ids 10).
       * @param {number[]} releaseDefIds - Release Definition Ids of the Runs to be queried, comma separated list of valid ids (limit no. of ids 10).
       * @param {number[]} releaseEnvIds - Release Environment Ids of the Runs to be queried, comma separated list of valid ids (limit no. of ids 10).
       * @param {number[]} releaseEnvDefIds - Release Environment Definition Ids of the Runs to be queried, comma separated list of valid ids (limit no. of ids 10).
       * @param {string} runTitle - Run Title of the Runs to be queried.
       * @param {number} top - Number of runs to be queried. Limit is 100
       * @param {string} continuationToken - continuationToken received from previous batch or null for first batch. It is not supposed to be created (or altered, if received from last batch) by user.
       */
      queryTestRuns(project, minLastUpdatedDate, maxLastUpdatedDate, state, planIds, isAutomated, publishContext, buildIds, buildDefIds, branchName, releaseIds, releaseDefIds, releaseEnvIds, releaseEnvDefIds, runTitle, top, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (minLastUpdatedDate == null) {
            throw new TypeError("minLastUpdatedDate can not be null or undefined");
          }
          if (maxLastUpdatedDate == null) {
            throw new TypeError("maxLastUpdatedDate can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              minLastUpdatedDate,
              maxLastUpdatedDate,
              state,
              planIds: planIds && planIds.join(","),
              isAutomated,
              publishContext,
              buildIds: buildIds && buildIds.join(","),
              buildDefIds: buildDefIds && buildDefIds.join(","),
              branchName,
              releaseIds: releaseIds && releaseIds.join(","),
              releaseDefIds: releaseDefIds && releaseDefIds.join(","),
              releaseEnvIds: releaseEnvIds && releaseEnvIds.join(","),
              releaseEnvDefIds: releaseEnvDefIds && releaseEnvDefIds.join(","),
              runTitle,
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "cadb3810-d47d-4a3c-a234-fe5f3be50138", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestRun, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update test run by its ID.
       *
       * @param {TestInterfaces.RunUpdateModel} runUpdateModel - Run details RunUpdateModel
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the run to update.
       */
      updateTestRun(runUpdateModel, project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "cadb3810-d47d-4a3c-a234-fe5f3be50138", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, runUpdateModel, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestRun, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a test session
       *
       * @param {TestInterfaces.TestSession} testSession - Test session details for creation
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      createTestSession(testSession, teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "1500b4b4-6c69-4ca6-9b18-35e9e97fe2ac", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testSession, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestSession, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of test sessions
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {number} period - Period in days from now, for which test sessions are fetched.
       * @param {boolean} allSessions - If false, returns test sessions for current user. Otherwise, it returns test sessions for all users
       * @param {boolean} includeAllProperties - If true, it returns all properties of the test sessions. Otherwise, it returns the skinny version.
       * @param {TestInterfaces.TestSessionSource} source - Source of the test session.
       * @param {boolean} includeOnlyCompletedSessions - If true, it returns test sessions in completed state. Otherwise, it returns test sessions for all states
       */
      getTestSessions(teamContext, period, allSessions, includeAllProperties, source, includeOnlyCompletedSessions) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            let queryValues = {
              period,
              allSessions,
              includeAllProperties,
              source,
              includeOnlyCompletedSessions
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "1500b4b4-6c69-4ca6-9b18-35e9e97fe2ac", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestSession, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a test session
       *
       * @param {TestInterfaces.TestSession} testSession - Test session details for update
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      updateTestSession(testSession, teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "1500b4b4-6c69-4ca6-9b18-35e9e97fe2ac", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testSession, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestSession, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} sharedParameterId
       */
      deleteSharedParameter(project, sharedParameterId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              sharedParameterId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "8300eeca-0f8c-4eff-a089-d2dda409c41f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} sharedStepId
       */
      deleteSharedStep(project, sharedStepId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              sharedStepId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "fabb3cc9-e3f8-40b7-8b62-24cc4b73fccf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add test cases to suite.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suite.
       * @param {number} suiteId - ID of the test suite to which the test cases must be added.
       * @param {string} testCaseIds - IDs of the test cases to add to the suite. Ids are specified in comma separated format.
       */
      addTestCasesToSuite(project, planId, suiteId, testCaseIds) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              action: "TestCases",
              project,
              planId,
              suiteId,
              testCaseIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "a4a1ec1c-b03f-41ca-8857-704594ecf58e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a specific test case in a test suite with test case id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suites.
       * @param {number} suiteId - ID of the suite that contains the test case.
       * @param {number} testCaseIds - ID of the test case to get.
       */
      getTestCaseById(project, planId, suiteId, testCaseIds) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              action: "TestCases",
              project,
              planId,
              suiteId,
              testCaseIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "a4a1ec1c-b03f-41ca-8857-704594ecf58e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all test cases in a suite.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suites.
       * @param {number} suiteId - ID of the suite to get.
       */
      getTestCases(project, planId, suiteId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              action: "TestCases",
              project,
              planId,
              suiteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "a4a1ec1c-b03f-41ca-8857-704594ecf58e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * The test points associated with the test cases are removed from the test suite. The test case work item is not deleted from the system. See test cases resource to delete a test case permanently.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suite.
       * @param {number} suiteId - ID of the suite to get.
       * @param {string} testCaseIds - IDs of the test cases to remove from the suite.
       */
      removeTestCasesFromSuiteUrl(project, planId, suiteId, testCaseIds) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              action: "TestCases",
              project,
              planId,
              suiteId,
              testCaseIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "a4a1ec1c-b03f-41ca-8857-704594ecf58e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates the properties of the test case association in a suite.
       *
       * @param {TestInterfaces.SuiteTestCaseUpdateModel} suiteTestCaseUpdateModel - Model for updation of the properties of test case suite association.
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suite.
       * @param {number} suiteId - ID of the test suite to which the test cases must be added.
       * @param {string} testCaseIds - IDs of the test cases to add to the suite. Ids are specified in comma separated format.
       */
      updateSuiteTestCases(suiteTestCaseUpdateModel, project, planId, suiteId, testCaseIds) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              action: "TestCases",
              project,
              planId,
              suiteId,
              testCaseIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "Test", "a4a1ec1c-b03f-41ca-8857-704594ecf58e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, suiteTestCaseUpdateModel, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a test case.
       *
       * @param {string} project - Project ID or project name
       * @param {number} testCaseId - Id of test case to delete.
       */
      deleteTestCase(project, testCaseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testCaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "4d472e0f-e32c-4ef8-adf4-a4078772889c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get history of a test method using TestHistoryQuery
       *
       * @param {TestInterfaces.TestHistoryQuery} filter - TestHistoryQuery to get history
       * @param {string} project - Project ID or project name
       */
      queryTestHistory(filter2, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "Test", "929fd86c-3e38-4d8c-b4b6-90df256e5971", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.TestHistoryQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.TestSettings} testSettings
       * @param {string} project - Project ID or project name
       */
      createTestSettings(testSettings, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "8133ce14-962f-42af-a5f9-6aa9defcb9c8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testSettings, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} testSettingsId
       */
      deleteTestSettings(project, testSettingsId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testSettingsId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "8133ce14-962f-42af-a5f9-6aa9defcb9c8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} testSettingsId
       */
      getTestSettingsById(project, testSettingsId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testSettingsId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "8133ce14-962f-42af-a5f9-6aa9defcb9c8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestInterfaces.WorkItemToTestLinks} workItemToTestLinks
       * @param {string} project - Project ID or project name
       */
      addWorkItemToTestLinks(workItemToTestLinks, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "371b1655-ce05-412e-a113-64cc77bb78d2", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, workItemToTestLinks, options);
              let ret = this.formatResponse(res.result, TestInterfaces.TypeInfo.WorkItemToTestLinks, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} testName
       * @param {number} workItemId
       */
      deleteTestMethodToWorkItemLink(project, testName, workItemId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testName == null) {
            throw new TypeError("testName can not be null or undefined");
          }
          if (workItemId == null) {
            throw new TypeError("workItemId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              testName,
              workItemId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "7b0bdee3-a354-47f9-a42c-89018d7808d5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} testName
       */
      queryTestMethodLinkedWorkItems(project, testName) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testName == null) {
            throw new TypeError("testName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              testName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "7b0bdee3-a354-47f9-a42c-89018d7808d5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} workItemCategory
       * @param {string} automatedTestName
       * @param {number} testCaseId
       * @param {Date} maxCompleteDate
       * @param {number} days
       * @param {number} workItemCount
       */
      queryTestResultWorkItems(project, workItemCategory, automatedTestName, testCaseId, maxCompleteDate, days, workItemCount) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (workItemCategory == null) {
            throw new TypeError("workItemCategory can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              workItemCategory,
              automatedTestName,
              testCaseId,
              maxCompleteDate,
              days,
              "$workItemCount": workItemCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "Test", "926ff5dc-137f-45f0-bd51-9412fa9810ce", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.TestApi = TestApi;
    TestApi.RESOURCE_AREA_ID = "c2aa639c-3ccc-4740-b3b6-ce2a1e1d984e";
  }
});

// ../node_modules/azure-devops-node-api/interfaces/TestPlanInterfaces.js
var require_TestPlanInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/TestPlanInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.UserFriendlyTestOutcome = exports2.TestSuiteType = exports2.TestPlansLibraryWorkItemFilterMode = exports2.TestPlansLibraryQuery = exports2.TestEntityTypes = exports2.SuiteExpand = exports2.SuiteEntryTypes = exports2.ResultState = exports2.PointState = exports2.Outcome = exports2.LibraryTestCasesDataReturnCode = exports2.LastResolutionState = exports2.FailureType = exports2.ExcludeFlags = void 0;
    var TFS_TestManagement_Contracts = require_TestInterfaces();
    var TfsCoreInterfaces = require_CoreInterfaces();
    var ExcludeFlags;
    (function(ExcludeFlags2) {
      ExcludeFlags2[ExcludeFlags2["None"] = 0] = "None";
      ExcludeFlags2[ExcludeFlags2["PointAssignments"] = 1] = "PointAssignments";
      ExcludeFlags2[ExcludeFlags2["ExtraInformation"] = 2] = "ExtraInformation";
    })(ExcludeFlags = exports2.ExcludeFlags || (exports2.ExcludeFlags = {}));
    var FailureType;
    (function(FailureType2) {
      FailureType2[FailureType2["None"] = 0] = "None";
      FailureType2[FailureType2["Regression"] = 1] = "Regression";
      FailureType2[FailureType2["New_Issue"] = 2] = "New_Issue";
      FailureType2[FailureType2["Known_Issue"] = 3] = "Known_Issue";
      FailureType2[FailureType2["Unknown"] = 4] = "Unknown";
      FailureType2[FailureType2["Null_Value"] = 5] = "Null_Value";
      FailureType2[FailureType2["MaxValue"] = 5] = "MaxValue";
    })(FailureType = exports2.FailureType || (exports2.FailureType = {}));
    var LastResolutionState;
    (function(LastResolutionState2) {
      LastResolutionState2[LastResolutionState2["None"] = 0] = "None";
      LastResolutionState2[LastResolutionState2["NeedsInvestigation"] = 1] = "NeedsInvestigation";
      LastResolutionState2[LastResolutionState2["TestIssue"] = 2] = "TestIssue";
      LastResolutionState2[LastResolutionState2["ProductIssue"] = 3] = "ProductIssue";
      LastResolutionState2[LastResolutionState2["ConfigurationIssue"] = 4] = "ConfigurationIssue";
      LastResolutionState2[LastResolutionState2["NullValue"] = 5] = "NullValue";
      LastResolutionState2[LastResolutionState2["MaxValue"] = 5] = "MaxValue";
    })(LastResolutionState = exports2.LastResolutionState || (exports2.LastResolutionState = {}));
    var LibraryTestCasesDataReturnCode;
    (function(LibraryTestCasesDataReturnCode2) {
      LibraryTestCasesDataReturnCode2[LibraryTestCasesDataReturnCode2["Success"] = 0] = "Success";
      LibraryTestCasesDataReturnCode2[LibraryTestCasesDataReturnCode2["Error"] = 1] = "Error";
    })(LibraryTestCasesDataReturnCode = exports2.LibraryTestCasesDataReturnCode || (exports2.LibraryTestCasesDataReturnCode = {}));
    var Outcome;
    (function(Outcome2) {
      Outcome2[Outcome2["Unspecified"] = 0] = "Unspecified";
      Outcome2[Outcome2["None"] = 1] = "None";
      Outcome2[Outcome2["Passed"] = 2] = "Passed";
      Outcome2[Outcome2["Failed"] = 3] = "Failed";
      Outcome2[Outcome2["Inconclusive"] = 4] = "Inconclusive";
      Outcome2[Outcome2["Timeout"] = 5] = "Timeout";
      Outcome2[Outcome2["Aborted"] = 6] = "Aborted";
      Outcome2[Outcome2["Blocked"] = 7] = "Blocked";
      Outcome2[Outcome2["NotExecuted"] = 8] = "NotExecuted";
      Outcome2[Outcome2["Warning"] = 9] = "Warning";
      Outcome2[Outcome2["Error"] = 10] = "Error";
      Outcome2[Outcome2["NotApplicable"] = 11] = "NotApplicable";
      Outcome2[Outcome2["Paused"] = 12] = "Paused";
      Outcome2[Outcome2["InProgress"] = 13] = "InProgress";
      Outcome2[Outcome2["NotImpacted"] = 14] = "NotImpacted";
      Outcome2[Outcome2["MaxValue"] = 14] = "MaxValue";
    })(Outcome = exports2.Outcome || (exports2.Outcome = {}));
    var PointState;
    (function(PointState2) {
      PointState2[PointState2["None"] = 0] = "None";
      PointState2[PointState2["Ready"] = 1] = "Ready";
      PointState2[PointState2["Completed"] = 2] = "Completed";
      PointState2[PointState2["NotReady"] = 3] = "NotReady";
      PointState2[PointState2["InProgress"] = 4] = "InProgress";
      PointState2[PointState2["MaxValue"] = 4] = "MaxValue";
    })(PointState = exports2.PointState || (exports2.PointState = {}));
    var ResultState;
    (function(ResultState2) {
      ResultState2[ResultState2["Unspecified"] = 0] = "Unspecified";
      ResultState2[ResultState2["Pending"] = 1] = "Pending";
      ResultState2[ResultState2["Queued"] = 2] = "Queued";
      ResultState2[ResultState2["InProgress"] = 3] = "InProgress";
      ResultState2[ResultState2["Paused"] = 4] = "Paused";
      ResultState2[ResultState2["Completed"] = 5] = "Completed";
      ResultState2[ResultState2["MaxValue"] = 5] = "MaxValue";
    })(ResultState = exports2.ResultState || (exports2.ResultState = {}));
    var SuiteEntryTypes;
    (function(SuiteEntryTypes2) {
      SuiteEntryTypes2[SuiteEntryTypes2["TestCase"] = 0] = "TestCase";
      SuiteEntryTypes2[SuiteEntryTypes2["Suite"] = 1] = "Suite";
    })(SuiteEntryTypes = exports2.SuiteEntryTypes || (exports2.SuiteEntryTypes = {}));
    var SuiteExpand;
    (function(SuiteExpand2) {
      SuiteExpand2[SuiteExpand2["None"] = 0] = "None";
      SuiteExpand2[SuiteExpand2["Children"] = 1] = "Children";
      SuiteExpand2[SuiteExpand2["DefaultTesters"] = 2] = "DefaultTesters";
    })(SuiteExpand = exports2.SuiteExpand || (exports2.SuiteExpand = {}));
    var TestEntityTypes;
    (function(TestEntityTypes2) {
      TestEntityTypes2[TestEntityTypes2["TestCase"] = 0] = "TestCase";
      TestEntityTypes2[TestEntityTypes2["TestPoint"] = 1] = "TestPoint";
    })(TestEntityTypes = exports2.TestEntityTypes || (exports2.TestEntityTypes = {}));
    var TestPlansLibraryQuery;
    (function(TestPlansLibraryQuery2) {
      TestPlansLibraryQuery2[TestPlansLibraryQuery2["None"] = 0] = "None";
      TestPlansLibraryQuery2[TestPlansLibraryQuery2["AllTestCases"] = 1] = "AllTestCases";
      TestPlansLibraryQuery2[TestPlansLibraryQuery2["TestCasesWithActiveBugs"] = 2] = "TestCasesWithActiveBugs";
      TestPlansLibraryQuery2[TestPlansLibraryQuery2["TestCasesNotLinkedToRequirements"] = 3] = "TestCasesNotLinkedToRequirements";
      TestPlansLibraryQuery2[TestPlansLibraryQuery2["TestCasesLinkedToRequirements"] = 4] = "TestCasesLinkedToRequirements";
      TestPlansLibraryQuery2[TestPlansLibraryQuery2["AllSharedSteps"] = 11] = "AllSharedSteps";
      TestPlansLibraryQuery2[TestPlansLibraryQuery2["SharedStepsNotLinkedToRequirement"] = 12] = "SharedStepsNotLinkedToRequirement";
    })(TestPlansLibraryQuery = exports2.TestPlansLibraryQuery || (exports2.TestPlansLibraryQuery = {}));
    var TestPlansLibraryWorkItemFilterMode;
    (function(TestPlansLibraryWorkItemFilterMode2) {
      TestPlansLibraryWorkItemFilterMode2[TestPlansLibraryWorkItemFilterMode2["Or"] = 0] = "Or";
      TestPlansLibraryWorkItemFilterMode2[TestPlansLibraryWorkItemFilterMode2["And"] = 1] = "And";
    })(TestPlansLibraryWorkItemFilterMode = exports2.TestPlansLibraryWorkItemFilterMode || (exports2.TestPlansLibraryWorkItemFilterMode = {}));
    var TestSuiteType;
    (function(TestSuiteType2) {
      TestSuiteType2[TestSuiteType2["None"] = 0] = "None";
      TestSuiteType2[TestSuiteType2["DynamicTestSuite"] = 1] = "DynamicTestSuite";
      TestSuiteType2[TestSuiteType2["StaticTestSuite"] = 2] = "StaticTestSuite";
      TestSuiteType2[TestSuiteType2["RequirementTestSuite"] = 3] = "RequirementTestSuite";
    })(TestSuiteType = exports2.TestSuiteType || (exports2.TestSuiteType = {}));
    var UserFriendlyTestOutcome;
    (function(UserFriendlyTestOutcome2) {
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["InProgress"] = 0] = "InProgress";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Blocked"] = 1] = "Blocked";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Failed"] = 2] = "Failed";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Passed"] = 3] = "Passed";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Ready"] = 4] = "Ready";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["NotApplicable"] = 5] = "NotApplicable";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Paused"] = 6] = "Paused";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Timeout"] = 7] = "Timeout";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Warning"] = 8] = "Warning";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Error"] = 9] = "Error";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["NotExecuted"] = 10] = "NotExecuted";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Inconclusive"] = 11] = "Inconclusive";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Aborted"] = 12] = "Aborted";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["None"] = 13] = "None";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["NotImpacted"] = 14] = "NotImpacted";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["Unspecified"] = 15] = "Unspecified";
      UserFriendlyTestOutcome2[UserFriendlyTestOutcome2["MaxValue"] = 15] = "MaxValue";
    })(UserFriendlyTestOutcome = exports2.UserFriendlyTestOutcome || (exports2.UserFriendlyTestOutcome = {}));
    exports2.TypeInfo = {
      CloneOperationCommonResponse: {},
      CloneTestCaseOperationInformation: {},
      CloneTestPlanOperationInformation: {},
      CloneTestPlanParams: {},
      CloneTestSuiteOperationInformation: {},
      DestinationTestPlanCloneParams: {},
      ExcludeFlags: {
        enumValues: {
          "none": 0,
          "pointAssignments": 1,
          "extraInformation": 2
        }
      },
      FailureType: {
        enumValues: {
          "none": 0,
          "regression": 1,
          "new_Issue": 2,
          "known_Issue": 3,
          "unknown": 4,
          "null_Value": 5,
          "maxValue": 5
        }
      },
      LastResolutionState: {
        enumValues: {
          "none": 0,
          "needsInvestigation": 1,
          "testIssue": 2,
          "productIssue": 3,
          "configurationIssue": 4,
          "nullValue": 5,
          "maxValue": 5
        }
      },
      LibraryTestCasesDataReturnCode: {
        enumValues: {
          "success": 0,
          "error": 1
        }
      },
      LibraryWorkItemsData: {},
      LibraryWorkItemsDataProviderRequest: {},
      Outcome: {
        enumValues: {
          "unspecified": 0,
          "none": 1,
          "passed": 2,
          "failed": 3,
          "inconclusive": 4,
          "timeout": 5,
          "aborted": 6,
          "blocked": 7,
          "notExecuted": 8,
          "warning": 9,
          "error": 10,
          "notApplicable": 11,
          "paused": 12,
          "inProgress": 13,
          "notImpacted": 14,
          "maxValue": 14
        }
      },
      PointState: {
        enumValues: {
          "none": 0,
          "ready": 1,
          "completed": 2,
          "notReady": 3,
          "inProgress": 4,
          "maxValue": 4
        }
      },
      Results: {},
      ResultState: {
        enumValues: {
          "unspecified": 0,
          "pending": 1,
          "queued": 2,
          "inProgress": 3,
          "paused": 4,
          "completed": 5,
          "maxValue": 5
        }
      },
      SourceTestplanResponse: {},
      SourceTestSuiteResponse: {},
      SuiteEntry: {},
      SuiteEntryTypes: {
        enumValues: {
          "testCase": 0,
          "suite": 1
        }
      },
      SuiteEntryUpdateParams: {},
      SuiteExpand: {
        enumValues: {
          "none": 0,
          "children": 1,
          "defaultTesters": 2
        }
      },
      TestCase: {},
      TestCaseAssociatedResult: {},
      TestCaseResultsData: {},
      TestConfiguration: {},
      TestConfigurationCreateUpdateParameters: {},
      TestEntityTypes: {
        enumValues: {
          "testCase": 0,
          "testPoint": 1
        }
      },
      TestPlan: {},
      TestPlanCreateParams: {},
      TestPlanDetailedReference: {},
      TestPlansHubRefreshData: {},
      TestPlansLibraryQuery: {
        enumValues: {
          "none": 0,
          "allTestCases": 1,
          "testCasesWithActiveBugs": 2,
          "testCasesNotLinkedToRequirements": 3,
          "testCasesLinkedToRequirements": 4,
          "allSharedSteps": 11,
          "sharedStepsNotLinkedToRequirement": 12
        }
      },
      TestPlansLibraryWorkItemFilter: {},
      TestPlansLibraryWorkItemFilterMode: {
        enumValues: {
          "or": 0,
          "and": 1
        }
      },
      TestPlanUpdateParams: {},
      TestPoint: {},
      TestPointResults: {},
      TestPointUpdateParams: {},
      TestSuite: {},
      TestSuiteCreateParams: {},
      TestSuiteReferenceWithProject: {},
      TestSuiteType: {
        enumValues: {
          "none": 0,
          "dynamicTestSuite": 1,
          "staticTestSuite": 2,
          "requirementTestSuite": 3
        }
      },
      TestVariable: {},
      UserFriendlyTestOutcome: {
        enumValues: {
          "inProgress": 0,
          "blocked": 1,
          "failed": 2,
          "passed": 3,
          "ready": 4,
          "notApplicable": 5,
          "paused": 6,
          "timeout": 7,
          "warning": 8,
          "error": 9,
          "notExecuted": 10,
          "inconclusive": 11,
          "aborted": 12,
          "none": 13,
          "notImpacted": 14,
          "unspecified": 15,
          "maxValue": 15
        }
      }
    };
    exports2.TypeInfo.CloneOperationCommonResponse.fields = {
      completionDate: {
        isDate: true
      },
      creationDate: {
        isDate: true
      },
      state: {
        enumType: TFS_TestManagement_Contracts.TypeInfo.CloneOperationState
      }
    };
    exports2.TypeInfo.CloneTestCaseOperationInformation.fields = {
      cloneOperationResponse: {
        typeInfo: exports2.TypeInfo.CloneOperationCommonResponse
      },
      destinationTestSuite: {
        typeInfo: exports2.TypeInfo.TestSuiteReferenceWithProject
      },
      sourceTestSuite: {
        typeInfo: exports2.TypeInfo.SourceTestSuiteResponse
      }
    };
    exports2.TypeInfo.CloneTestPlanOperationInformation.fields = {
      cloneOperationResponse: {
        typeInfo: exports2.TypeInfo.CloneOperationCommonResponse
      },
      destinationTestPlan: {
        typeInfo: exports2.TypeInfo.TestPlan
      },
      sourceTestPlan: {
        typeInfo: exports2.TypeInfo.SourceTestplanResponse
      }
    };
    exports2.TypeInfo.CloneTestPlanParams.fields = {
      destinationTestPlan: {
        typeInfo: exports2.TypeInfo.DestinationTestPlanCloneParams
      }
    };
    exports2.TypeInfo.CloneTestSuiteOperationInformation.fields = {
      clonedTestSuite: {
        typeInfo: exports2.TypeInfo.TestSuiteReferenceWithProject
      },
      cloneOperationResponse: {
        typeInfo: exports2.TypeInfo.CloneOperationCommonResponse
      },
      destinationTestSuite: {
        typeInfo: exports2.TypeInfo.TestSuiteReferenceWithProject
      },
      sourceTestSuite: {
        typeInfo: exports2.TypeInfo.TestSuiteReferenceWithProject
      }
    };
    exports2.TypeInfo.DestinationTestPlanCloneParams.fields = {
      endDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.LibraryWorkItemsData.fields = {
      returnCode: {
        enumType: exports2.TypeInfo.LibraryTestCasesDataReturnCode
      }
    };
    exports2.TypeInfo.LibraryWorkItemsDataProviderRequest.fields = {
      filterValues: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestPlansLibraryWorkItemFilter
      },
      libraryQueryType: {
        enumType: exports2.TypeInfo.TestPlansLibraryQuery
      }
    };
    exports2.TypeInfo.Results.fields = {
      outcome: {
        enumType: exports2.TypeInfo.Outcome
      }
    };
    exports2.TypeInfo.SourceTestplanResponse.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.SourceTestSuiteResponse.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.SuiteEntry.fields = {
      suiteEntryType: {
        enumType: exports2.TypeInfo.SuiteEntryTypes
      }
    };
    exports2.TypeInfo.SuiteEntryUpdateParams.fields = {
      suiteEntryType: {
        enumType: exports2.TypeInfo.SuiteEntryTypes
      }
    };
    exports2.TypeInfo.TestCase.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.TestCaseAssociatedResult.fields = {
      completedDate: {
        isDate: true
      },
      outcome: {
        enumType: exports2.TypeInfo.UserFriendlyTestOutcome
      }
    };
    exports2.TypeInfo.TestCaseResultsData.fields = {
      results: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestCaseAssociatedResult
      }
    };
    exports2.TypeInfo.TestConfiguration.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      state: {
        enumType: TFS_TestManagement_Contracts.TypeInfo.TestConfigurationState
      }
    };
    exports2.TypeInfo.TestConfigurationCreateUpdateParameters.fields = {
      state: {
        enumType: TFS_TestManagement_Contracts.TypeInfo.TestConfigurationState
      }
    };
    exports2.TypeInfo.TestPlan.fields = {
      endDate: {
        isDate: true
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      startDate: {
        isDate: true
      },
      updatedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestPlanCreateParams.fields = {
      endDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestPlanDetailedReference.fields = {
      endDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestPlansHubRefreshData.fields = {
      testCases: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestCase
      },
      testPlan: {
        typeInfo: exports2.TypeInfo.TestPlanDetailedReference
      },
      testPoints: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestPoint
      },
      testSuites: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestSuite
      }
    };
    exports2.TypeInfo.TestPlansLibraryWorkItemFilter.fields = {
      filterMode: {
        enumType: exports2.TypeInfo.TestPlansLibraryWorkItemFilterMode
      }
    };
    exports2.TypeInfo.TestPlanUpdateParams.fields = {
      endDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TestPoint.fields = {
      lastResetToActive: {
        isDate: true
      },
      lastUpdatedDate: {
        isDate: true
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      results: {
        typeInfo: exports2.TypeInfo.TestPointResults
      }
    };
    exports2.TypeInfo.TestPointResults.fields = {
      failureType: {
        enumType: exports2.TypeInfo.FailureType
      },
      lastResolutionState: {
        enumType: exports2.TypeInfo.LastResolutionState
      },
      lastResultDetails: {
        typeInfo: TFS_TestManagement_Contracts.TypeInfo.LastResultDetails
      },
      lastResultState: {
        enumType: exports2.TypeInfo.ResultState
      },
      outcome: {
        enumType: exports2.TypeInfo.Outcome
      },
      state: {
        enumType: exports2.TypeInfo.PointState
      }
    };
    exports2.TypeInfo.TestPointUpdateParams.fields = {
      results: {
        typeInfo: exports2.TypeInfo.Results
      }
    };
    exports2.TypeInfo.TestSuite.fields = {
      children: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TestSuite
      },
      lastPopulatedDate: {
        isDate: true
      },
      lastUpdatedDate: {
        isDate: true
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      },
      suiteType: {
        enumType: exports2.TypeInfo.TestSuiteType
      }
    };
    exports2.TypeInfo.TestSuiteCreateParams.fields = {
      suiteType: {
        enumType: exports2.TypeInfo.TestSuiteType
      }
    };
    exports2.TypeInfo.TestSuiteReferenceWithProject.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.TestVariable.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/TestPlanApi.js
var require_TestPlanApi = __commonJS({
  "../node_modules/azure-devops-node-api/TestPlanApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TestPlanApi = void 0;
    var basem = require_ClientApiBases();
    var TestPlanInterfaces = require_TestPlanInterfaces();
    var TestPlanApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-TestPlan-api", options);
      }
      /**
       * Create a test configuration.
       *
       * @param {TestPlanInterfaces.TestConfigurationCreateUpdateParameters} testConfigurationCreateUpdateParameters - TestConfigurationCreateUpdateParameters
       * @param {string} project - Project ID or project name
       */
      createTestConfiguration(testConfigurationCreateUpdateParameters, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "8369318e-38fa-4e84-9043-4b2a75d2c256", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testConfigurationCreateUpdateParameters, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a test configuration by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} testConfiguartionId - ID of the test configuration to delete.
       */
      deleteTestConfguration(project, testConfiguartionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testConfiguartionId == null) {
            throw new TypeError("testConfiguartionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              testConfiguartionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "8369318e-38fa-4e84-9043-4b2a75d2c256", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a test configuration
       *
       * @param {string} project - Project ID or project name
       * @param {number} testConfigurationId - ID of the test configuration to get.
       */
      getTestConfigurationById(project, testConfigurationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testConfigurationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "8369318e-38fa-4e84-9043-4b2a75d2c256", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of test configurations.
       *
       * @param {string} project - Project ID or project name
       * @param {string} continuationToken - If the list of configurations returned is not complete, a continuation token to query next batch of configurations is included in the response header as "x-ms-continuationtoken". Omit this parameter to get the first batch of test configurations.
       */
      getTestConfigurations(project, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "8369318e-38fa-4e84-9043-4b2a75d2c256", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestConfiguration, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a test configuration by its ID.
       *
       * @param {TestPlanInterfaces.TestConfigurationCreateUpdateParameters} testConfigurationCreateUpdateParameters - TestConfigurationCreateUpdateParameters
       * @param {string} project - Project ID or project name
       * @param {number} testConfiguartionId - ID of the test configuration to update.
       */
      updateTestConfiguration(testConfigurationCreateUpdateParameters, project, testConfiguartionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testConfiguartionId == null) {
            throw new TypeError("testConfiguartionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              testConfiguartionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "8369318e-38fa-4e84-9043-4b2a75d2c256", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testConfigurationCreateUpdateParameters, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} planId
       * @param {string} states
       * @param {TestPlanInterfaces.UserFriendlyTestOutcome} outcome
       * @param {string} configurations
       * @param {string} testers
       * @param {string} assignedTo
       * @param {TestPlanInterfaces.TestEntityTypes} entity
       */
      getTestEntityCountByPlanId(project, planId, states, outcome, configurations, testers, assignedTo, entity) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId
            };
            let queryValues = {
              states,
              outcome,
              configurations,
              testers,
              assignedTo,
              entity
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "300578da-7b40-4c1e-9542-7aed6029e504", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a test plan.
       *
       * @param {TestPlanInterfaces.TestPlanCreateParams} testPlanCreateParams - A testPlanCreateParams object.TestPlanCreateParams
       * @param {string} project - Project ID or project name
       */
      createTestPlan(testPlanCreateParams, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "0e292477-a0c2-47f3-a9b6-34f153d627f4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testPlanCreateParams, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestPlan, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a test plan.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan to be deleted.
       */
      deleteTestPlan(project, planId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "0e292477-a0c2-47f3-a9b6-34f153d627f4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a test plan by Id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan to get.
       */
      getTestPlanById(project, planId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "0e292477-a0c2-47f3-a9b6-34f153d627f4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestPlan, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of test plans
       *
       * @param {string} project - Project ID or project name
       * @param {string} owner - Filter for test plan by owner ID or name
       * @param {string} continuationToken - If the list of plans returned is not complete, a continuation token to query next batch of plans is included in the response header as "x-ms-continuationtoken". Omit this parameter to get the first batch of test plans.
       * @param {boolean} includePlanDetails - Get all properties of the test plan
       * @param {boolean} filterActivePlans - Get just the active plans
       */
      getTestPlans(project, owner, continuationToken, includePlanDetails, filterActivePlans) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              owner,
              continuationToken,
              includePlanDetails,
              filterActivePlans
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "0e292477-a0c2-47f3-a9b6-34f153d627f4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestPlan, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a test plan.
       *
       * @param {TestPlanInterfaces.TestPlanUpdateParams} testPlanUpdateParams - A testPlanUpdateParams object.TestPlanUpdateParams
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan to be updated.
       */
      updateTestPlan(testPlanUpdateParams, project, planId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "0e292477-a0c2-47f3-a9b6-34f153d627f4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testPlanUpdateParams, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestPlan, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of test suite entries in the test suite.
       *
       * @param {string} project - Project ID or project name
       * @param {number} suiteId - Id of the parent suite.
       * @param {TestPlanInterfaces.SuiteEntryTypes} suiteEntryType
       */
      getSuiteEntries(project, suiteId, suiteEntryType) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              suiteId
            };
            let queryValues = {
              suiteEntryType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "d6733edf-72f1-4252-925b-c560dfe9b75a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.SuiteEntry, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Reorder test suite entries in the test suite.
       *
       * @param {TestPlanInterfaces.SuiteEntryUpdateParams[]} suiteEntries - List of SuiteEntry to reorder.
       * @param {string} project - Project ID or project name
       * @param {number} suiteId - Id of the parent test suite.
       */
      reorderSuiteEntries(suiteEntries, project, suiteId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              suiteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "d6733edf-72f1-4252-925b-c560dfe9b75a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, suiteEntries, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.SuiteEntry, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create bulk requirement based test suites.
       *
       * @param {TestPlanInterfaces.TestSuiteCreateParams[]} testSuiteCreateParams - Parameters for suite creation
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan where requirement based suites need to be created.
       * @param {number} parentSuiteId - ID of the parent suite under which requirement based suites will be created
       */
      createBulkTestSuites(testSuiteCreateParams, project, planId, parentSuiteId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              parentSuiteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "1e58fbe6-1761-43ce-97f6-5492ec9d438e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testSuiteCreateParams, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestSuite, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create test suite.
       *
       * @param {TestPlanInterfaces.TestSuiteCreateParams} testSuiteCreateParams - Parameters for suite creation
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suites.
       */
      createTestSuite(testSuiteCreateParams, project, planId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "1046d5d3-ab61-4ca7-a65a-36118a978256", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testSuiteCreateParams, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestSuite, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete test suite.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suite.
       * @param {number} suiteId - ID of the test suite to delete.
       */
      deleteTestSuite(project, planId, suiteId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "1046d5d3-ab61-4ca7-a65a-36118a978256", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test suite by suite id.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suites.
       * @param {number} suiteId - ID of the suite to get.
       * @param {TestPlanInterfaces.SuiteExpand} expand - Include the children suites and testers details
       */
      getTestSuiteById(project, planId, suiteId, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            let queryValues = {
              expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "1046d5d3-ab61-4ca7-a65a-36118a978256", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestSuite, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test suites for plan.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan for which suites are requested.
       * @param {TestPlanInterfaces.SuiteExpand} expand - Include the children suites and testers details.
       * @param {string} continuationToken - If the list of suites returned is not complete, a continuation token to query next batch of suites is included in the response header as "x-ms-continuationtoken". Omit this parameter to get the first batch of test suites.
       * @param {boolean} asTreeView - If the suites returned should be in a tree structure.
       */
      getTestSuitesForPlan(project, planId, expand, continuationToken, asTreeView) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId
            };
            let queryValues = {
              expand,
              continuationToken,
              asTreeView
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "1046d5d3-ab61-4ca7-a65a-36118a978256", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestSuite, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update test suite.
       *
       * @param {TestPlanInterfaces.TestSuiteUpdateParams} testSuiteUpdateParams - Parameters for suite updation
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan that contains the suites.
       * @param {number} suiteId - ID of the parent suite.
       */
      updateTestSuite(testSuiteUpdateParams, project, planId, suiteId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "1046d5d3-ab61-4ca7-a65a-36118a978256", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testSuiteUpdateParams, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestSuite, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Find the list of all test suites in which a given test case is present. This is helpful if you need to find out which test suites are using a test case, when you need to make changes to a test case.
       *
       * @param {number} testCaseId - ID of the test case for which suites need to be fetched.
       */
      getSuitesByTestCaseId(testCaseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testCaseId == null) {
            throw new TypeError("testCaseId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              testCaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "a4080e84-f17b-4fad-84f1-7960b6525bf2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestSuite, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add test cases to a suite with specified configurations
       *
       * @param {TestPlanInterfaces.SuiteTestCaseCreateUpdateParameters[]} suiteTestCaseCreateUpdateParameters - SuiteTestCaseCreateUpdateParameters object.
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan to which test cases are to be added.
       * @param {number} suiteId - ID of the test suite to which test cases are to be added.
       */
      addTestCasesToSuite(suiteTestCaseCreateUpdateParameters, project, planId, suiteId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "testplan", "a9bd61ac-45cf-4d13-9441-43dcd01edf8d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, suiteTestCaseCreateUpdateParameters, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestCase, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a particular Test Case from a Suite.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan for which test cases are requested.
       * @param {number} suiteId - ID of the test suite for which test cases are requested.
       * @param {string} testCaseId - Test Case Id to be fetched.
       * @param {string} witFields - Get the list of witFields.
       * @param {boolean} returnIdentityRef - If set to true, returns all identity fields, like AssignedTo, ActivatedBy etc., as IdentityRef objects. If set to false, these fields are returned as unique names in string format. This is false by default.
       */
      getTestCase(project, planId, suiteId, testCaseId, witFields, returnIdentityRef) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId,
              testCaseId
            };
            let queryValues = {
              witFields,
              returnIdentityRef
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "testplan", "a9bd61ac-45cf-4d13-9441-43dcd01edf8d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestCase, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Test Case List return those test cases which have all the configuration Ids as mentioned in the optional parameter. If configuration Ids is null, it return all the test cases
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan for which test cases are requested.
       * @param {number} suiteId - ID of the test suite for which test cases are requested.
       * @param {string} testIds - Test Case Ids to be fetched.
       * @param {string} configurationIds - Fetch Test Cases which contains all the configuration Ids specified.
       * @param {string} witFields - Get the list of witFields.
       * @param {string} continuationToken - If the list of test cases returned is not complete, a continuation token to query next batch of test cases is included in the response header as "x-ms-continuationtoken". Omit this parameter to get the first batch of test cases.
       * @param {boolean} returnIdentityRef - If set to true, returns all identity fields, like AssignedTo, ActivatedBy etc., as IdentityRef objects. If set to false, these fields are returned as unique names in string format. This is false by default.
       * @param {boolean} expand - If set to false, will get a smaller payload containing only basic details about the suite test case object
       * @param {TestPlanInterfaces.ExcludeFlags} excludeFlags - Flag to exclude various values from payload. For example to remove point assignments pass exclude = 1. To remove extra information (links, test plan , test suite) pass exclude = 2. To remove both extra information and point assignments pass exclude = 3 (1 + 2).
       * @param {boolean} isRecursive
       */
      getTestCaseList(project, planId, suiteId, testIds, configurationIds, witFields, continuationToken, returnIdentityRef, expand, excludeFlags, isRecursive) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            let queryValues = {
              testIds,
              configurationIds,
              witFields,
              continuationToken,
              returnIdentityRef,
              expand,
              excludeFlags,
              isRecursive
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "testplan", "a9bd61ac-45cf-4d13-9441-43dcd01edf8d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestCase, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes test cases from a suite based on the list of test case Ids provided.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan from which test cases are to be removed.
       * @param {number} suiteId - ID of the test suite from which test cases are to be removed.
       * @param {string} testCaseIds - Test Case Ids to be removed.
       */
      removeTestCasesFromSuite(project, planId, suiteId, testCaseIds) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testCaseIds == null) {
            throw new TypeError("testCaseIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            let queryValues = {
              testCaseIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "testplan", "a9bd61ac-45cf-4d13-9441-43dcd01edf8d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes test cases from a suite based on the list of test case Ids provided. This API can be used to remove a larger number of test cases.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan from which test cases are to be removed.
       * @param {number} suiteId - ID of the test suite from which test cases are to be removed.
       * @param {string} testIds - Comma separated string of Test Case Ids to be removed.
       */
      removeTestCasesListFromSuite(project, planId, suiteId, testIds) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testIds == null) {
            throw new TypeError("testIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            let queryValues = {
              testIds
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "testplan", "a9bd61ac-45cf-4d13-9441-43dcd01edf8d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the configurations for test cases
       *
       * @param {TestPlanInterfaces.SuiteTestCaseCreateUpdateParameters[]} suiteTestCaseCreateUpdateParameters - A SuiteTestCaseCreateUpdateParameters object.
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan to which test cases are to be updated.
       * @param {number} suiteId - ID of the test suite to which test cases are to be updated.
       */
      updateSuiteTestCases(suiteTestCaseCreateUpdateParameters, project, planId, suiteId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "testplan", "a9bd61ac-45cf-4d13-9441-43dcd01edf8d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, suiteTestCaseCreateUpdateParameters, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestCase, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TestPlanInterfaces.CloneTestCaseParams} cloneRequestBody
       * @param {string} project - Project ID or project name
       */
      cloneTestCase(cloneRequestBody, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "529b2b8d-82f4-4893-b1e4-1e74ea534673", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, cloneRequestBody, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.CloneTestCaseOperationInformation, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get clone information.
       *
       * @param {string} project - Project ID or project name
       * @param {number} cloneOperationId - Operation ID returned when we queue a clone operation
       */
      getTestCaseCloneInformation(project, cloneOperationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              cloneOperationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "529b2b8d-82f4-4893-b1e4-1e74ea534673", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.CloneTestCaseOperationInformation, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Exports a set of test cases from a suite to a file. Currently supported  formats: xlsx
       *
       * @param {TestPlanInterfaces.ExportTestCaseParams} exportTestCaseRequestBody - A ExportTestCaseParams object.ExportTestCaseParams
       * @param {string} project - Project ID or project name
       */
      exportTestCases(exportTestCaseRequestBody, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "3b9d1c87-6b1a-4e7d-9e7d-1a8e543112bb", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a test case.
       *
       * @param {string} project - Project ID or project name
       * @param {number} testCaseId - Id of test case to be deleted.
       */
      deleteTestCase(project, testCaseId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testCaseId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "29006fb5-816b-4ff7-a329-599943569229", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Clone test plan
       *
       * @param {TestPlanInterfaces.CloneTestPlanParams} cloneRequestBody - Plan Clone Request Body detail TestPlanCloneRequest
       * @param {string} project - Project ID or project name
       * @param {boolean} deepClone - Clones all the associated test cases as well
       */
      cloneTestPlan(cloneRequestBody, project, deepClone) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              deepClone
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "e65df662-d8a3-46c7-ae1c-14e2d4df57e1", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, cloneRequestBody, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.CloneTestPlanOperationInformation, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get clone information.
       *
       * @param {string} project - Project ID or project name
       * @param {number} cloneOperationId - Operation ID returned when we queue a clone operation
       */
      getCloneInformation(project, cloneOperationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              cloneOperationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "e65df662-d8a3-46c7-ae1c-14e2d4df57e1", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.CloneTestPlanOperationInformation, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a particular Test Point from a suite.
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan for which test points are requested.
       * @param {number} suiteId - ID of the test suite for which test points are requested.
       * @param {string} pointId - ID of test point to be fetched.
       * @param {boolean} returnIdentityRef - If set to true, returns the AssignedTo field in TestCaseReference as IdentityRef object.
       * @param {boolean} includePointDetails - If set to false, will get a smaller payload containing only basic details about the test point object
       */
      getPoints(project, planId, suiteId, pointId, returnIdentityRef, includePointDetails) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (pointId == null) {
            throw new TypeError("pointId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            let queryValues = {
              pointId,
              returnIdentityRef,
              includePointDetails
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "52df686e-bae4-4334-b0ee-b6cf4e6f6b73", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestPoint, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the points inside a suite based on some filters
       *
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan for which test points are requested.
       * @param {number} suiteId - ID of the test suite for which test points are requested
       * @param {string} testPointIds - ID of test points to fetch.
       * @param {string} testCaseId - Get Test Points for specific test case Ids.
       * @param {string} continuationToken - If the list of test point returned is not complete, a continuation token to query next batch of test points is included in the response header as "x-ms-continuationtoken". Omit this parameter to get the first batch of test points.
       * @param {boolean} returnIdentityRef - If set to true, returns the AssignedTo field in TestCaseReference as IdentityRef object.
       * @param {boolean} includePointDetails - If set to false, will get a smaller payload containing only basic details about the test point object
       * @param {boolean} isRecursive - If set to true, will also fetch test points belonging to child suites recursively.
       */
      getPointsList(project, planId, suiteId, testPointIds, testCaseId, continuationToken, returnIdentityRef, includePointDetails, isRecursive) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            let queryValues = {
              testPointIds,
              testCaseId,
              continuationToken,
              returnIdentityRef,
              includePointDetails,
              isRecursive
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "52df686e-bae4-4334-b0ee-b6cf4e6f6b73", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestPoint, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update Test Points. This is used to Reset test point to active, update the outcome of a test point or update the tester of a test point
       *
       * @param {TestPlanInterfaces.TestPointUpdateParams[]} testPointUpdateParams - A TestPointUpdateParams Object.
       * @param {string} project - Project ID or project name
       * @param {number} planId - ID of the test plan for which test points are requested.
       * @param {number} suiteId - ID of the test suite for which test points are requested.
       * @param {boolean} includePointDetails - If set to false, will get a smaller payload containing only basic details about the test point object
       * @param {boolean} returnIdentityRef - If set to true, returns the AssignedTo field in TestCaseReference as IdentityRef object.
       */
      updateTestPoints(testPointUpdateParams, project, planId, suiteId, includePointDetails, returnIdentityRef) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              planId,
              suiteId
            };
            let queryValues = {
              includePointDetails,
              returnIdentityRef
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "52df686e-bae4-4334-b0ee-b6cf4e6f6b73", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testPointUpdateParams, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestPoint, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Clone test suite
       *
       * @param {TestPlanInterfaces.CloneTestSuiteParams} cloneRequestBody - Suite Clone Request Body detail TestSuiteCloneRequest
       * @param {string} project - Project ID or project name
       * @param {boolean} deepClone - Clones all the associated test cases as well
       */
      cloneTestSuite(cloneRequestBody, project, deepClone) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              deepClone
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "181d4c97-0e98-4ee2-ad6a-4cada675e555", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, cloneRequestBody, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.CloneTestSuiteOperationInformation, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get clone information.
       *
       * @param {string} project - Project ID or project name
       * @param {number} cloneOperationId - Operation ID returned when we queue a clone operation
       */
      getSuiteCloneInformation(project, cloneOperationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              cloneOperationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testplan", "181d4c97-0e98-4ee2-ad6a-4cada675e555", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.CloneTestSuiteOperationInformation, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a test variable.
       *
       * @param {TestPlanInterfaces.TestVariableCreateUpdateParameters} testVariableCreateUpdateParameters - TestVariableCreateUpdateParameters
       * @param {string} project - Project ID or project name
       */
      createTestVariable(testVariableCreateUpdateParameters, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "2c61fac6-ac4e-45a5-8c38-1c2b8fd8ea6c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testVariableCreateUpdateParameters, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestVariable, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a test variable by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} testVariableId - ID of the test variable to delete.
       */
      deleteTestVariable(project, testVariableId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testVariableId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "2c61fac6-ac4e-45a5-8c38-1c2b8fd8ea6c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a test variable by its ID.
       *
       * @param {string} project - Project ID or project name
       * @param {number} testVariableId - ID of the test variable to get.
       */
      getTestVariableById(project, testVariableId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testVariableId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "2c61fac6-ac4e-45a5-8c38-1c2b8fd8ea6c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestVariable, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of test variables.
       *
       * @param {string} project - Project ID or project name
       * @param {string} continuationToken - If the list of variables returned is not complete, a continuation token to query next batch of variables is included in the response header as "x-ms-continuationtoken". Omit this parameter to get the first batch of test variables.
       */
      getTestVariables(project, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "2c61fac6-ac4e-45a5-8c38-1c2b8fd8ea6c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestVariable, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a test variable by its ID.
       *
       * @param {TestPlanInterfaces.TestVariableCreateUpdateParameters} testVariableCreateUpdateParameters - TestVariableCreateUpdateParameters
       * @param {string} project - Project ID or project name
       * @param {number} testVariableId - ID of the test variable to update.
       */
      updateTestVariable(testVariableCreateUpdateParameters, project, testVariableId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testVariableId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testplan", "2c61fac6-ac4e-45a5-8c38-1c2b8fd8ea6c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testVariableCreateUpdateParameters, options);
              let ret = this.formatResponse(res.result, TestPlanInterfaces.TypeInfo.TestVariable, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.TestPlanApi = TestPlanApi;
  }
});

// ../node_modules/azure-devops-node-api/TestResultsApi.js
var require_TestResultsApi = __commonJS({
  "../node_modules/azure-devops-node-api/TestResultsApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TestResultsApi = void 0;
    var basem = require_ClientApiBases();
    var Contracts = require_TestInterfaces();
    var TestResultsApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-testResults-api", options);
      }
      /**
       * @param {Contracts.TestAttachmentRequestModel} attachmentRequestModel
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} iterationId
       * @param {string} actionPath
       */
      createTestIterationResultAttachment(attachmentRequestModel, project, runId, testCaseResultId, iterationId, actionPath) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (iterationId == null) {
            throw new TypeError("iterationId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            let queryValues = {
              iterationId,
              actionPath
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestAttachmentRequestModel} attachmentRequestModel
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       */
      createTestResultAttachment(attachmentRequestModel, project, runId, testCaseResultId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestAttachmentRequestModel} attachmentRequestModel
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} testSubResultId
       */
      createTestSubResultAttachment(attachmentRequestModel, project, runId, testCaseResultId, testSubResultId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            let queryValues = {
              testSubResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} attachmentId
       */
      deleteTestResultAttachment(project, runId, testCaseResultId, attachmentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a test iteration attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} attachmentId
       * @param {number} iterationId
       */
      getTestIterationAttachmentContent(project, runId, testCaseResultId, attachmentId, iterationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (iterationId == null) {
            throw new TypeError("iterationId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            let queryValues = {
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a test iteration attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} attachmentId
       * @param {number} iterationId
       */
      getTestIterationAttachmentZip(project, runId, testCaseResultId, attachmentId, iterationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (iterationId == null) {
            throw new TypeError("iterationId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            let queryValues = {
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a test result attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} attachmentId
       */
      getTestResultAttachmentContent(project, runId, testCaseResultId, attachmentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       */
      getTestResultAttachments(project, runId, testCaseResultId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a test result attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} attachmentId
       */
      getTestResultAttachmentZip(project, runId, testCaseResultId, attachmentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a test sub result attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} attachmentId
       * @param {number} testSubResultId
       */
      getTestSubResultAttachmentContent(project, runId, testCaseResultId, attachmentId, testSubResultId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            let queryValues = {
              testSubResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns attachment references for test sub result.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} testSubResultId
       */
      getTestSubResultAttachments(project, runId, testCaseResultId, testSubResultId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            let queryValues = {
              testSubResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a test sub result attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       * @param {number} attachmentId
       * @param {number} testSubResultId
       */
      getTestSubResultAttachmentZip(project, runId, testCaseResultId, attachmentId, testSubResultId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId,
              attachmentId
            };
            let queryValues = {
              testSubResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "2a632e97-e014-4275-978f-8e5c4906d4b3", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestAttachmentRequestModel} attachmentRequestModel
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      createTestRunAttachment(attachmentRequestModel, project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "b5731898-8206-477a-a51d-3fdf116fc6bf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} attachmentId
       */
      deleteTestRunAttachment(project, runId, attachmentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "b5731898-8206-477a-a51d-3fdf116fc6bf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a test run attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} attachmentId
       */
      getTestRunAttachmentContent(project, runId, attachmentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "b5731898-8206-477a-a51d-3fdf116fc6bf", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      getTestRunAttachments(project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "b5731898-8206-477a-a51d-3fdf116fc6bf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a test run attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} attachmentId
       */
      getTestRunAttachmentZip(project, runId, attachmentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "b5731898-8206-477a-a51d-3fdf116fc6bf", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       */
      getBugsLinkedToTestResult(project, runId, testCaseResultId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "d8dbf98f-eb34-4f8d-8365-47972af34f29", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       */
      fetchSourceCodeCoverageReport(project, buildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "a459e10b-d703-4193-b3c1-60f2287918b3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.SourceViewBuildCoverage, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {number} flags
       */
      getBuildCodeCoverage(project, buildId, flags) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          if (flags == null) {
            throw new TypeError("flags can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              flags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "9b3e1ece-c6ab-4fbb-8167-8a32a0c92216", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.BuildCoverage, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * http://(tfsserver):8080/tfs/DefaultCollection/_apis/test/CodeCoverage?buildId=10&deltaBuildId=9 Request: build id and delta build id (optional)
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {number} deltaBuildId
       */
      getCodeCoverageSummary(project, buildId, deltaBuildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              deltaBuildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "9b3e1ece-c6ab-4fbb-8167-8a32a0c92216", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.CodeCoverageSummary, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * http://(tfsserver):8080/tfs/DefaultCollection/_apis/test/CodeCoverage?buildId=10 Request: Json of code coverage summary
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {Contracts.CodeCoverageData} coverageData
       */
      updateCodeCoverageSummary(project, buildId, coverageData) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "9b3e1ece-c6ab-4fbb-8167-8a32a0c92216", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, coverageData, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} flags
       */
      getTestRunCodeCoverage(project, runId, flags) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (flags == null) {
            throw new TypeError("flags can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              flags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "5641efbc-6f9b-401a-baeb-d3da22489e5e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.CustomTestFieldDefinition[]} newFields
       * @param {string} project - Project ID or project name
       */
      addCustomFields(newFields, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "b67d46d8-b70e-4dcc-a98c-7f74b52ba82f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, newFields, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.CustomTestFieldDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {Contracts.CustomTestFieldScope} scopeFilter
       */
      queryCustomFields(project, scopeFilter) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (scopeFilter == null) {
            throw new TypeError("scopeFilter can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              scopeFilter
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "b67d46d8-b70e-4dcc-a98c-7f74b52ba82f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.CustomTestFieldDefinition, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get file coverage for the specified file
       *
       * @param {Contracts.FileCoverageRequest} fileCoverageRequest - File details with pull request iteration context
       * @param {string} project - Project ID or project name
       */
      getFileLevelCodeCoverage(fileCoverageRequest, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "4a6d0c46-51ca-45aa-9163-249cee3289b7", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildDefinitionId
       * @param {Date} minBuildCreatedDate
       */
      getFlakyTestResultsByBuildDefinitionId(project, buildDefinitionId, minBuildCreatedDate) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildDefinitionId == null) {
            throw new TypeError("buildDefinitionId can not be null or undefined");
          }
          if (minBuildCreatedDate == null) {
            throw new TypeError("minBuildCreatedDate can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildDefinitionId,
              minBuildCreatedDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "8ed3cf63-7153-4722-a107-c49dae996143", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      getFlakyTestResultsByTestRun(project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "31cc4b31-416f-45cd-9b45-39534279e10c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.ResultsFilter} filter
       * @param {string} project - Project ID or project name
       */
      queryTestResultHistory(filter2, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "bdf7a97b-0395-4da8-9d5d-f957619327d1", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultHistory, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test run message logs
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the run to get.
       */
      getTestRunMessageLogs(project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "e9ab0c6a-1984-418b-87c0-ee4202318ba3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestMessageLogDetails, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get summary of test results.
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - Pipeline Id. This is same as build Id.
       * @param {string} stageName - Name of the stage. Maximum supported length for name is 256 character.
       * @param {string} phaseName - Name of the phase. Maximum supported length for name is 256 character.
       * @param {string} jobName - Matrixing in YAML generates copies of a job with different inputs in matrix. JobName is the name of those input. Maximum supported length for name is 256 character.
       * @param {Contracts.Metrics[]} metricNames
       * @param {boolean} groupByNode - Group summary for each node of the pipleine heirarchy
       */
      getTestPipelineMetrics(project, pipelineId, stageName, phaseName, jobName, metricNames, groupByNode) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (pipelineId == null) {
            throw new TypeError("pipelineId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              pipelineId,
              stageName,
              phaseName,
              jobName,
              metricNames: metricNames && metricNames.join(","),
              groupByNode
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "65f35817-86a1-4131-b38b-3ec2d4744e53", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.PipelineTestMetrics, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} publishContext
       * @param {string} groupBy
       * @param {string} filter
       * @param {string} orderby
       * @param {boolean} shouldIncludeResults
       * @param {boolean} queryRunSummaryForInProgress
       */
      getTestResultDetailsForBuild(project, buildId, publishContext, groupBy, filter2, orderby, shouldIncludeResults, queryRunSummaryForInProgress) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              publishContext,
              groupBy,
              "$filter": filter2,
              "$orderby": orderby,
              shouldIncludeResults,
              queryRunSummaryForInProgress
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "a518c749-4524-45b2-a7ef-1ac009b312cd", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultsDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} releaseEnvId
       * @param {string} publishContext
       * @param {string} groupBy
       * @param {string} filter
       * @param {string} orderby
       * @param {boolean} shouldIncludeResults
       * @param {boolean} queryRunSummaryForInProgress
       */
      getTestResultDetailsForRelease(project, releaseId, releaseEnvId, publishContext, groupBy, filter2, orderby, shouldIncludeResults, queryRunSummaryForInProgress) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          if (releaseEnvId == null) {
            throw new TypeError("releaseEnvId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              releaseEnvId,
              publishContext,
              groupBy,
              "$filter": filter2,
              "$orderby": orderby,
              shouldIncludeResults,
              queryRunSummaryForInProgress
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "19a8183a-69fb-47d7-bfbf-1b6b0d921294", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultsDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestResultDocument} document
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      publishTestResultDocument(document, project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "74838649-b038-42f1-a0e7-6deb3973bf14", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, document, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} publishContext
       * @param {string[]} fields
       * @param {string} continuationToken
       */
      getResultGroupsByBuild(project, buildId, publishContext, fields, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          if (publishContext == null) {
            throw new TypeError("publishContext can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              publishContext,
              fields: fields && fields.join(","),
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "e49244d1-c49f-49ad-a717-3bbaefe6a201", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {string} publishContext
       * @param {number} releaseEnvId
       * @param {string[]} fields
       * @param {string} continuationToken
       */
      getResultGroupsByRelease(project, releaseId, publishContext, releaseEnvId, fields, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          if (publishContext == null) {
            throw new TypeError("publishContext can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              publishContext,
              releaseEnvId,
              fields: fields && fields.join(","),
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "3c2b6bb0-0620-434a-a5c3-26aa0fcfda15", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of test Result meta data details for corresponding testcasereferenceId
       *
       * @param {string[]} testCaseReferenceIds - TestCaseReference Ids of the test Result to be queried, comma separated list of valid ids (limit no. of ids 200).
       * @param {string} project - Project ID or project name
       * @param {Contracts.ResultMetaDataDetails} detailsToInclude - Details to include with test results metadata. Default is None. Other values are FlakyIdentifiers.
       */
      queryTestResultsMetaData(testCaseReferenceIds, project, detailsToInclude) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              detailsToInclude
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "testresults", "b72ff4c0-4341-4213-ba27-f517cf341c95", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testCaseReferenceIds, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update properties of test result meta data
       *
       * @param {Contracts.TestResultMetaDataUpdateInput} testResultMetaDataUpdateInput - TestResultMetaData update input TestResultMetaDataUpdateInput
       * @param {string} project - Project ID or project name
       * @param {number} testCaseReferenceId - TestCaseReference Id of Test Result to be updated.
       */
      updateTestResultsMetaData(testResultMetaDataUpdateInput, project, testCaseReferenceId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              testCaseReferenceId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.4", "testresults", "b72ff4c0-4341-4213-ba27-f517cf341c95", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testResultMetaDataUpdateInput, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestResultsQuery} query
       * @param {string} project - Project ID or project name
       */
      getTestResultsByQuery(query, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "14033a2c-af25-4af1-9e39-8ef6900482e3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, query, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultsQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.QueryModel} queryModel
       * @param {string} project - Project ID or project name
       * @param {boolean} includeResultDetails
       * @param {boolean} includeIterationDetails
       * @param {number} skip
       * @param {number} top
       */
      getTestResultsByQueryWiql(queryModel, project, includeResultDetails, includeIterationDetails, skip, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              includeResultDetails,
              includeIterationDetails,
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "5ea78be3-2f5a-4110-8034-c27f24c62db1", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, queryModel, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestCaseResult[]} results
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      addTestResultsToTestRun(results, project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "02afa165-e79a-4d70-8f0c-2af0f35b4e07", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, results, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testResultId
       * @param {Contracts.ResultDetails} detailsToInclude
       */
      getTestResultById(project, runId, testResultId, detailsToInclude) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testResultId
            };
            let queryValues = {
              detailsToInclude
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "02afa165-e79a-4d70-8f0c-2af0f35b4e07", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {Contracts.ResultDetails} detailsToInclude
       * @param {number} skip
       * @param {number} top
       * @param {Contracts.TestOutcome[]} outcomes
       * @param {boolean} newTestsOnly
       */
      getTestResults(project, runId, detailsToInclude, skip, top, outcomes, newTestsOnly) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              detailsToInclude,
              "$skip": skip,
              "$top": top,
              outcomes: outcomes && outcomes.join(","),
              "$newTestsOnly": newTestsOnly
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "02afa165-e79a-4d70-8f0c-2af0f35b4e07", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestCaseResult[]} results
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      updateTestResults(results, project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "02afa165-e79a-4d70-8f0c-2af0f35b4e07", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, results, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} publishContext
       * @param {Contracts.TestOutcome[]} outcomes
       * @param {number} top
       * @param {string} continuationToken
       */
      getTestResultsByBuild(project, buildId, publishContext, outcomes, top, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              publishContext,
              outcomes: outcomes && outcomes.join(","),
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "f48cc885-dbc4-4efc-ab19-ae8c19d1e02a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of results.
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - Pipeline Id. This is same as build Id.
       * @param {string} stageName - Name of the stage. Maximum supported length for name is 256 character.
       * @param {string} phaseName - Name of the phase. Maximum supported length for name is 256 character.
       * @param {string} jobName - Matrixing in YAML generates copies of a job with different inputs in matrix. JobName is the name of those input. Maximum supported length for name is 256 character.
       * @param {Contracts.TestOutcome[]} outcomes - List of outcome of results
       * @param {number} top - Maximum number of results to return
       * @param {String} continuationToken - Header to pass the continuationToken
       */
      getTestResultsByPipeline(customHeaders, project, pipelineId, stageName, phaseName, jobName, outcomes, top, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (pipelineId == null) {
            throw new TypeError("pipelineId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              pipelineId,
              stageName,
              phaseName,
              jobName,
              outcomes: outcomes && outcomes.join(","),
              "$top": top
            };
            customHeaders = customHeaders || {};
            customHeaders["x-ms-continuationtoken"] = "continuationToken";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "80169dc2-30c3-4c25-84b2-dd67d7ff1f52", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} releaseEnvid
       * @param {string} publishContext
       * @param {Contracts.TestOutcome[]} outcomes
       * @param {number} top
       * @param {string} continuationToken
       */
      getTestResultsByRelease(project, releaseId, releaseEnvid, publishContext, outcomes, top, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              releaseEnvid,
              publishContext,
              outcomes: outcomes && outcomes.join(","),
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "3994b949-77e5-495d-8034-edf80d95b84e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the available groups details and for these groups get failed and aborted results.
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - Pipeline Id. This is same as build Id.
       * @param {string} stageName - Name of the stage. Maximum supported length for name is 256 character.
       * @param {string} phaseName - Name of the phase. Maximum supported length for name is 256 character.
       * @param {string} jobName - Matrixing in YAML generates copies of a job with different inputs in matrix. JobName is the name of those input. Maximum supported length for name is 256 character.
       * @param {boolean} shouldIncludeFailedAndAbortedResults - If true, it will return Ids of failed and aborted results for each test group
       * @param {boolean} queryGroupSummaryForInProgress - If true, it will calculate summary for InProgress runs as well.
       */
      testResultsGroupDetails(project, pipelineId, stageName, phaseName, jobName, shouldIncludeFailedAndAbortedResults, queryGroupSummaryForInProgress) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (pipelineId == null) {
            throw new TypeError("pipelineId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              pipelineId,
              stageName,
              phaseName,
              jobName,
              shouldIncludeFailedAndAbortedResults,
              queryGroupSummaryForInProgress
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "f903b850-06af-4b50-a344-d7bbfb19e93b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultsDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       * @param {string} publishContext
       * @param {boolean} includeFailureDetails
       * @param {Contracts.BuildReference} buildToCompare
       */
      queryTestResultsReportForBuild(project, buildId, publishContext, includeFailureDetails, buildToCompare) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              publishContext,
              includeFailureDetails,
              buildToCompare
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "e009fa95-95a5-4ad4-9681-590043ce2423", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultSummary, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get summary of test results.
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - Pipeline Id. This is same as build Id.
       * @param {string} stageName - Name of the stage. Maximum supported length for name is 256 character.
       * @param {string} phaseName - Name of the phase. Maximum supported length for name is 256 character.
       * @param {string} jobName - Matrixing in YAML generates copies of a job with different inputs in matrix. JobName is the name of those input. Maximum supported length for name is 256 character.
       * @param {boolean} includeFailureDetails - If true returns failure insights
       */
      queryTestResultsReportForPipeline(project, pipelineId, stageName, phaseName, jobName, includeFailureDetails) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (pipelineId == null) {
            throw new TypeError("pipelineId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              pipelineId,
              stageName,
              phaseName,
              jobName,
              includeFailureDetails
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "71f746a1-7d68-40fe-b705-9d821a73dff2", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultSummary, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} releaseId
       * @param {number} releaseEnvId
       * @param {string} publishContext
       * @param {boolean} includeFailureDetails
       * @param {Contracts.ReleaseReference} releaseToCompare
       */
      queryTestResultsReportForRelease(project, releaseId, releaseEnvId, publishContext, includeFailureDetails, releaseToCompare) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          if (releaseEnvId == null) {
            throw new TypeError("releaseEnvId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              releaseEnvId,
              publishContext,
              includeFailureDetails,
              releaseToCompare
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "f10f9577-2c04-45ab-8c99-b26567a7cd55", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultSummary, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.ReleaseReference[]} releases
       * @param {string} project - Project ID or project name
       */
      queryTestResultsSummaryForReleases(releases, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "f10f9577-2c04-45ab-8c99-b26567a7cd55", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, releases, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultSummary, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestResultsContext} resultsContext
       * @param {string} project - Project ID or project name
       * @param {number[]} workItemIds
       */
      queryTestSummaryByRequirement(resultsContext, project, workItemIds) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              workItemIds: workItemIds && workItemIds.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "3b7fd26f-c335-4e55-afc1-a588f5e2af3c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, resultsContext, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestSummaryForWorkItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestResultTrendFilter} filter
       * @param {string} project - Project ID or project name
       */
      queryResultTrendForBuild(filter2, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "0886a7ae-315a-4dba-9122-bcce93301f3a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.AggregatedDataForResultTrend, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestResultTrendFilter} filter
       * @param {string} project - Project ID or project name
       */
      queryResultTrendForRelease(filter2, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "107f23c3-359a-460a-a70c-63ee739f9f9a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.AggregatedDataForResultTrend, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.RunCreateModel} testRun
       * @param {string} project - Project ID or project name
       */
      createTestRun(testRun, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "364538f9-8062-4ce0-b024-75a0fb463f0d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testRun, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestRun, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      deleteTestRun(project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "364538f9-8062-4ce0-b024-75a0fb463f0d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {boolean} includeDetails
       * @param {boolean} includeTags
       */
      getTestRunById(project, runId, includeDetails, includeTags) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              includeDetails,
              includeTags
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "364538f9-8062-4ce0-b024-75a0fb463f0d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestRun, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} buildUri
       * @param {string} owner
       * @param {string} tmiRunId
       * @param {number} planId
       * @param {boolean} includeRunDetails
       * @param {boolean} automated
       * @param {number} skip
       * @param {number} top
       */
      getTestRuns(project, buildUri, owner, tmiRunId, planId, includeRunDetails, automated, skip, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildUri,
              owner,
              tmiRunId,
              planId,
              includeRunDetails,
              automated,
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "364538f9-8062-4ce0-b024-75a0fb463f0d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestRun, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Query Test Runs based on filters. Mandatory fields are minLastUpdatedDate and maxLastUpdatedDate.
       *
       * @param {string} project - Project ID or project name
       * @param {Date} minLastUpdatedDate - Minimum Last Modified Date of run to be queried (Mandatory).
       * @param {Date} maxLastUpdatedDate - Maximum Last Modified Date of run to be queried (Mandatory, difference between min and max date can be atmost 7 days).
       * @param {Contracts.TestRunState} state - Current state of the Runs to be queried.
       * @param {number[]} planIds - Plan Ids of the Runs to be queried, comma separated list of valid ids.
       * @param {boolean} isAutomated - Automation type of the Runs to be queried.
       * @param {Contracts.TestRunPublishContext} publishContext - PublishContext of the Runs to be queried.
       * @param {number[]} buildIds - Build Ids of the Runs to be queried, comma separated list of valid ids.
       * @param {number[]} buildDefIds - Build Definition Ids of the Runs to be queried, comma separated list of valid ids.
       * @param {string} branchName - Source Branch name of the Runs to be queried.
       * @param {number[]} releaseIds - Release Ids of the Runs to be queried, comma separated list of valid ids.
       * @param {number[]} releaseDefIds - Release Definition Ids of the Runs to be queried, comma separated list of valid ids.
       * @param {number[]} releaseEnvIds - Release Environment Ids of the Runs to be queried, comma separated list of valid ids.
       * @param {number[]} releaseEnvDefIds - Release Environment Definition Ids of the Runs to be queried, comma separated list of valid ids.
       * @param {string} runTitle - Run Title of the Runs to be queried.
       * @param {number} top - Number of runs to be queried. Limit is 100
       * @param {string} continuationToken - continuationToken received from previous batch or null for first batch. It is not supposed to be created (or altered, if received from last batch) by user.
       */
      queryTestRuns(project, minLastUpdatedDate, maxLastUpdatedDate, state, planIds, isAutomated, publishContext, buildIds, buildDefIds, branchName, releaseIds, releaseDefIds, releaseEnvIds, releaseEnvDefIds, runTitle, top, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (minLastUpdatedDate == null) {
            throw new TypeError("minLastUpdatedDate can not be null or undefined");
          }
          if (maxLastUpdatedDate == null) {
            throw new TypeError("maxLastUpdatedDate can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              minLastUpdatedDate,
              maxLastUpdatedDate,
              state,
              planIds: planIds && planIds.join(","),
              isAutomated,
              publishContext,
              buildIds: buildIds && buildIds.join(","),
              buildDefIds: buildDefIds && buildDefIds.join(","),
              branchName,
              releaseIds: releaseIds && releaseIds.join(","),
              releaseDefIds: releaseDefIds && releaseDefIds.join(","),
              releaseEnvIds: releaseEnvIds && releaseEnvIds.join(","),
              releaseEnvDefIds: releaseEnvDefIds && releaseEnvDefIds.join(","),
              runTitle,
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "364538f9-8062-4ce0-b024-75a0fb463f0d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestRun, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.RunUpdateModel} runUpdateModel
       * @param {string} project - Project ID or project name
       * @param {number} runId
       */
      updateTestRun(runUpdateModel, project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "364538f9-8062-4ce0-b024-75a0fb463f0d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, runUpdateModel, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestRun, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test run summary, used when we want to get summary of a run by outcome. Test run should be in completed state.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the run to get.
       */
      getTestRunSummaryByOutcome(project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "5c6a250c-53b7-4851-990c-42a7a00c8b39", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestRunStatistic, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get TestResultsSettings data
       *
       * @param {string} project - Project ID or project name
       * @param {Contracts.TestResultsSettingsType} settingsType
       */
      getTestResultsSettings(project, settingsType) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              settingsType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "testresults", "7319952e-e5a9-4e19-a006-84f3be8b7c68", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultsSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update project settings of test results
       *
       * @param {Contracts.TestResultsUpdateSettings} testResultsUpdateSettings
       * @param {string} project - Project ID or project name
       */
      updatePipelinesTestSettings(testResultsUpdateSettings, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "testresults", "7319952e-e5a9-4e19-a006-84f3be8b7c68", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testResultsUpdateSettings, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultsSettings, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the list of results whose failure matches with the provided one.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - id of test run
       * @param {number} testResultId - id of test result inside a test run
       * @param {number} testSubResultId - id of subresult inside a test result
       * @param {number} top - Maximum number of results to return
       * @param {String} continuationToken - Header to pass the continuationToken
       */
      getSimilarTestResults(customHeaders, project, runId, testResultId, testSubResultId, top, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testSubResultId == null) {
            throw new TypeError("testSubResultId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testResultId
            };
            let queryValues = {
              testSubResultId,
              "$top": top
            };
            customHeaders = customHeaders || {};
            customHeaders["x-ms-continuationtoken"] = "continuationToken";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "67d0a074-b255-4902-a639-e3e6de7a3de6", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get test run statistics , used when we want to get summary of a run by outcome.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - ID of the run to get.
       */
      getTestRunStatistics(project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "82b986e8-ca9e-4a89-b39e-f65c69bc104a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestRunStatistic, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * <p>Gets the coverage status for the last successful build of a definition, optionally scoped to a specific branch</p>
       *
       * @param {string} project - Project ID or project name
       * @param {string} definition - The ID or name of the definition.
       * @param {string} branchName - The branch name.
       * @param {string} label - The String to replace the default text on the left side of the badge.
       */
      getCoverageStatusBadge(project, definition, branchName, label) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              definition
            };
            let queryValues = {
              branchName,
              label
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "73b7c9d8-defb-4b60-b3d6-2162d60d6b13", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the tags in a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - Build ID
       */
      getTestTagsForBuild(project, buildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "52ee2057-4b54-41a6-a18c-ed4375a00f8d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the tags in a release.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Release ID
       * @param {number} releaseEnvId - Release environment ID
       */
      getTestTagsForRelease(project, releaseId, releaseEnvId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          if (releaseEnvId == null) {
            throw new TypeError("releaseEnvId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              releaseEnvId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "52ee2057-4b54-41a6-a18c-ed4375a00f8d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update tags of a run, Tags can be Added and Deleted
       *
       * @param {Contracts.TestTagsUpdateModel} testTagsUpdateModel - TestTagsUpdateModel
       * @param {string} project - Project ID or project name
       * @param {number} runId - RunId of the run
       */
      updateTestRunTags(testTagsUpdateModel, project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "a5e2f411-2b43-45f3-989c-05b71339f5b8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, testTagsUpdateModel, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the tags in a build.
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - Build ID
       */
      getTestTagSummaryForBuild(project, buildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "655a8f6b-fec7-4b46-b672-68b44141b498", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all the tags in a release.
       *
       * @param {string} project - Project ID or project name
       * @param {number} releaseId - Release ID
       * @param {number} releaseEnvId - Release environment ID
       */
      getTestTagSummaryForRelease(project, releaseId, releaseEnvId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (releaseId == null) {
            throw new TypeError("releaseId can not be null or undefined");
          }
          if (releaseEnvId == null) {
            throw new TypeError("releaseEnvId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              releaseId,
              releaseEnvId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "655a8f6b-fec7-4b46-b672-68b44141b498", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates an attachment in the LogStore for the specified buildId.
       *
       * @param {Contracts.TestAttachmentRequestModel} attachmentRequestModel - Contains attachment info like stream, filename, comment, attachmentType
       * @param {string} project - Project ID or project name
       * @param {number} buildId - BuildId
       */
      createBuildAttachmentInLogStore(attachmentRequestModel, project, buildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "6f747e16-18c2-435a-b4fb-fa05d6845fee", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates an attachment in the LogStore for the specified runId.
       *
       * @param {Contracts.TestAttachmentRequestModel} attachmentRequestModel - Contains attachment info like stream, filename, comment, attachmentType
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test RunId
       */
      createTestRunLogStoreAttachment(attachmentRequestModel, project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "1026d5de-4b0b-46ae-a31f-7c59b6af51ef", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, attachmentRequestModel, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes the attachment with the specified filename for the specified runId from the LogStore.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test RunId
       * @param {string} filename - Attachment FileName
       */
      deleteTestRunLogStoreAttachment(project, runId, filename) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (filename == null) {
            throw new TypeError("filename can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              filename
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "1026d5de-4b0b-46ae-a31f-7c59b6af51ef", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the attachment with the specified filename for the specified runId from the LogStore.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test RunId
       * @param {string} filename - Attachment FileName
       */
      getTestRunLogStoreAttachmentContent(project, runId, filename) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (filename == null) {
            throw new TypeError("filename can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              filename
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "1026d5de-4b0b-46ae-a31f-7c59b6af51ef", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of attachments for the specified runId from the LogStore.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test RunId
       */
      getTestRunLogStoreAttachments(project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "1026d5de-4b0b-46ae-a31f-7c59b6af51ef", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLogStoreAttachment, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the attachment with the specified filename for the specified runId from the LogStore.
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Test RunId
       * @param {string} filename - Attachment FileName
       */
      getTestRunLogStoreAttachmentZip(project, runId, filename) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (filename == null) {
            throw new TypeError("filename can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              filename
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "1026d5de-4b0b-46ae-a31f-7c59b6af51ef", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new test failure type
       *
       * @param {Contracts.TestResultFailureTypeRequestModel} testResultFailureType
       * @param {string} project - Project ID or project name
       */
      createFailureType(testResultFailureType, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "c4ac0486-830c-4a2a-9ef9-e8a1791a70fd", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testResultFailureType, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a test failure type with specified failureTypeId
       *
       * @param {string} project - Project ID or project name
       * @param {number} failureTypeId
       */
      deleteFailureType(project, failureTypeId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              failureTypeId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "c4ac0486-830c-4a2a-9ef9-e8a1791a70fd", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the list of test failure types.
       *
       * @param {string} project - Project ID or project name
       */
      getFailureTypes(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "c4ac0486-830c-4a2a-9ef9-e8a1791a70fd", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get history of a test method using TestHistoryQuery
       *
       * @param {Contracts.TestHistoryQuery} filter - TestHistoryQuery to get history
       * @param {string} project - Project ID or project name
       */
      queryTestHistory(filter2, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "2a41bd6a-8118-4403-b74e-5ba7492aed9d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestHistoryQuery, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of build attachments reference
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - Id of the build to get
       * @param {Contracts.TestLogType} type - type of the attachment to get
       * @param {string} directoryPath - directory path for which attachments are needed
       * @param {string} fileNamePrefix - file name prefix to filter the list of attachment
       * @param {boolean} fetchMetaData - Default is false, set if metadata is needed
       * @param {number} top - Number of test attachments reference to return
       * @param {String} continuationToken - Header to pass the continuationToken
       */
      getTestLogsForBuild(customHeaders, project, buildId, type, directoryPath, fileNamePrefix, fetchMetaData, top, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              type,
              directoryPath,
              fileNamePrefix,
              fetchMetaData,
              top
            };
            customHeaders = customHeaders || {};
            customHeaders["x-ms-continuationtoken"] = "continuationToken";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "dff8ce3a-e539-4817-a405-d968491a88f1", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLog, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of test result attachments reference
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Id of the test run that contains the result
       * @param {number} resultId - Id of the test result
       * @param {Contracts.TestLogType} type - type of attachments to get
       * @param {string} directoryPath - directory path of attachments to get
       * @param {string} fileNamePrefix - file name prefix to filter the list of attachment
       * @param {boolean} fetchMetaData - Default is false, set if metadata is needed
       * @param {number} top - Numbe of attachments reference to return
       * @param {String} continuationToken - Header to pass the continuationToken
       */
      getTestResultLogs(customHeaders, project, runId, resultId, type, directoryPath, fileNamePrefix, fetchMetaData, top, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              resultId
            };
            let queryValues = {
              type,
              directoryPath,
              fileNamePrefix,
              fetchMetaData,
              top
            };
            customHeaders = customHeaders || {};
            customHeaders["x-ms-continuationtoken"] = "continuationToken";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "714caaac-ae1e-4869-8323-9bc0f5120dbf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLog, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of test subresult attachments reference
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Id of the test run that contains the results
       * @param {number} resultId - Id of the test result that contains subresult
       * @param {number} subResultId - Id of the test subresult
       * @param {Contracts.TestLogType} type - type of the attachments to get
       * @param {string} directoryPath - directory path of the attachment to get
       * @param {string} fileNamePrefix - file name prefix to filter the list of attachments
       * @param {boolean} fetchMetaData - Default is false, set if metadata is needed
       * @param {number} top - Number of attachments reference to return
       * @param {String} continuationToken - Header to pass the continuationToken
       */
      getTestSubResultLogs(customHeaders, project, runId, resultId, subResultId, type, directoryPath, fileNamePrefix, fetchMetaData, top, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (subResultId == null) {
            throw new TypeError("subResultId can not be null or undefined");
          }
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              resultId
            };
            let queryValues = {
              subResultId,
              type,
              directoryPath,
              fileNamePrefix,
              fetchMetaData,
              top
            };
            customHeaders = customHeaders || {};
            customHeaders["x-ms-continuationtoken"] = "continuationToken";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "714caaac-ae1e-4869-8323-9bc0f5120dbf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLog, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of test run attachments reference
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Id of the test run
       * @param {Contracts.TestLogType} type - type of the attachments to get
       * @param {string} directoryPath - directory path for which attachments are needed
       * @param {string} fileNamePrefix - file name prefix to filter the list of attachment
       * @param {boolean} fetchMetaData - Default is false, set if metadata is needed
       * @param {number} top - Number of attachments reference to return
       * @param {String} continuationToken - Header to pass the continuationToken
       */
      getTestRunLogs(customHeaders, project, runId, type, directoryPath, fileNamePrefix, fetchMetaData, top, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              type,
              directoryPath,
              fileNamePrefix,
              fetchMetaData,
              top
            };
            customHeaders = customHeaders || {};
            customHeaders["x-ms-continuationtoken"] = "continuationToken";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "5b47b946-e875-4c9a-acdc-2a20996caebe", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLog, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get SAS Uri of a build attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} build - Id of the build to get
       * @param {Contracts.TestLogType} type - type of the file
       * @param {string} filePath - filePath for which sas uri is needed
       */
      getTestLogStoreEndpointDetailsForBuildLog(project, build, type, filePath) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (build == null) {
            throw new TypeError("build can not be null or undefined");
          }
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          if (filePath == null) {
            throw new TypeError("filePath can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              build,
              type,
              filePath
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "39b09be7-f0c9-4a83-a513-9ae31b45c56f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLogStoreEndpointDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create and Get sas uri of the build container
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId - Id of the build to get
       * @param {Contracts.TestLogStoreOperationType} testLogStoreOperationType - Type of operation to perform using sas uri
       */
      testLogStoreEndpointDetailsForBuild(project, buildId, testLogStoreOperationType) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          if (testLogStoreOperationType == null) {
            throw new TypeError("testLogStoreOperationType can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId,
              testLogStoreOperationType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "39b09be7-f0c9-4a83-a513-9ae31b45c56f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLogStoreEndpointDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get SAS Uri of a test results attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Id of the test run that contains result
       * @param {number} resultId - Id of the test result whose files need to be downloaded
       * @param {Contracts.TestLogType} type - type of the file
       * @param {string} filePath - filePath for which sas uri is needed
       */
      getTestLogStoreEndpointDetailsForResultLog(project, runId, resultId, type, filePath) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          if (filePath == null) {
            throw new TypeError("filePath can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              resultId
            };
            let queryValues = {
              type,
              filePath
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "da630b37-1236-45b5-945e-1d7bdb673850", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLogStoreEndpointDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get SAS Uri of a test subresults attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Id of the test run that contains result
       * @param {number} resultId - Id of the test result that contains subresult
       * @param {number} subResultId - Id of the test subresult whose file sas uri is needed
       * @param {Contracts.TestLogType} type - type of the file
       * @param {string} filePath - filePath for which sas uri is needed
       */
      getTestLogStoreEndpointDetailsForSubResultLog(project, runId, resultId, subResultId, type, filePath) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (subResultId == null) {
            throw new TypeError("subResultId can not be null or undefined");
          }
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          if (filePath == null) {
            throw new TypeError("filePath can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              resultId
            };
            let queryValues = {
              subResultId,
              type,
              filePath
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "da630b37-1236-45b5-945e-1d7bdb673850", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLogStoreEndpointDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create empty file for a result and Get Sas uri for the file
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Id of the test run that contains the result
       * @param {number} resultId - Id of the test results that contains sub result
       * @param {number} subResultId - Id of the test sub result whose file sas uri is needed
       * @param {string} filePath - file path inside the sub result for which sas uri is needed
       * @param {Contracts.TestLogType} type - Type of the file for download
       */
      testLogStoreEndpointDetailsForResult(project, runId, resultId, subResultId, filePath, type) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (subResultId == null) {
            throw new TypeError("subResultId can not be null or undefined");
          }
          if (filePath == null) {
            throw new TypeError("filePath can not be null or undefined");
          }
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              resultId
            };
            let queryValues = {
              subResultId,
              filePath,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "da630b37-1236-45b5-945e-1d7bdb673850", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLogStoreEndpointDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get SAS Uri of a test run attachment
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Id of the test run whose file has to be downloaded
       * @param {Contracts.TestLogType} type - type of the file
       * @param {string} filePath - filePath for which sas uri is needed
       */
      getTestLogStoreEndpointDetailsForRunLog(project, runId, type, filePath) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (type == null) {
            throw new TypeError("type can not be null or undefined");
          }
          if (filePath == null) {
            throw new TypeError("filePath can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              type,
              filePath
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "67eb3f92-6c97-4fd9-8b63-6cbdc7e526ea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLogStoreEndpointDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create empty file for a run and Get Sas uri for the file
       *
       * @param {string} project - Project ID or project name
       * @param {number} runId - Id of the run to get endpoint details
       * @param {Contracts.TestLogStoreOperationType} testLogStoreOperationType - Type of operation to perform using sas uri
       * @param {string} filePath - file path to create an empty file
       * @param {Contracts.TestLogType} type - Default is GeneralAttachment, type of empty file to be created
       */
      testLogStoreEndpointDetailsForRun(project, runId, testLogStoreOperationType, filePath, type) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testLogStoreOperationType == null) {
            throw new TypeError("testLogStoreOperationType can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              testLogStoreOperationType,
              filePath,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "67eb3f92-6c97-4fd9-8b63-6cbdc7e526ea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestLogStoreEndpointDetails, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves Test runs associated to a session
       *
       * @param {string} project - Project ID or project name
       * @param {number} sessionId - Id of TestResults session to obtain Test Runs for.
       */
      getTestRunsBySessionId(project, sessionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              sessionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "6efc2c12-d4bf-4e86-ae37-b502e57a84c7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates TestResultsSession object in TCM data store
       *
       * @param {Contracts.TestResultsSession} session - Received session object.
       * @param {string} project - Project ID or project name
       */
      createTestSession(session, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "531e61ce-580d-4962-8591-0b2942b6bf78", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, session, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves TestResultsSession metadata object in TCM data store
       *
       * @param {string} project - Project ID or project name
       * @param {number} buildId
       */
      getTestSession(project, buildId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (buildId == null) {
            throw new TypeError("buildId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              buildId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "531e61ce-580d-4962-8591-0b2942b6bf78", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestResultsSession, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves TestResultsSession Layout object in TCM data store
       *
       * @param {string} project - Project ID or project name
       * @param {string} sessionId
       */
      getTestSessionLayout(project, sessionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (sessionId == null) {
            throw new TypeError("sessionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              sessionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "531e61ce-580d-4962-8591-0b2942b6bf78", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates Environment object in TCM data store
       *
       * @param {Contracts.TestSessionEnvironment[]} environments - Received Environment object.
       * @param {string} project - Project ID or project name
       */
      createEnvironment(environments, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "f9c2e9e4-9c9a-4c1d-9a7d-2b4c8a6f0d5f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, environments, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates Notification object in TCM data store for a given session
       *
       * @param {Contracts.TestSessionNotification[]} notifications - Notification(s) to add for the specified sessionId
       * @param {string} project - Project ID or project name
       * @param {number} sessionId - ID of Session to add Notification
       */
      createNotification(notifications, project, sessionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              sessionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "ebff1c56-2188-4082-9d0e-1838a396f0c8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, notifications, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves TestResultsSession Notification objects in TCM data store
       *
       * @param {string} project - Project ID or project name
       * @param {number} sessionId - Id of TestResults session to obtain Notifications for.
       */
      getSessionNotifications(project, sessionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              sessionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "ebff1c56-2188-4082-9d0e-1838a396f0c8", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add Test Results to test run session
       *
       * @param {Contracts.TestCaseResult[]} results
       * @param {string} project - Project ID or project name
       * @param {number} runId - RunId of test run
       */
      addTestResultsToTestRunSession(results, project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "ee6d95bf-7506-4c47-8100-9fed82cdc2f7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, results, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {Contracts.ResultDetails} detailsToInclude
       * @param {number} skip
       * @param {number} top
       * @param {Contracts.TestOutcome[]} outcomes
       * @param {boolean} newTestsOnly
       */
      getTestSessionResults(project, runId, detailsToInclude, skip, top, outcomes, newTestsOnly) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            let queryValues = {
              detailsToInclude,
              "$skip": skip,
              "$top": top,
              outcomes: outcomes && outcomes.join(","),
              "$newTestsOnly": newTestsOnly
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "ee6d95bf-7506-4c47-8100-9fed82cdc2f7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.TestCaseResult, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates TestResultsMRX objects in TCM data store for existing test results
       *
       * @param {Contracts.TestCaseResult[]} results - Results object with only test results MRX properties and existing testResultId
       * @param {string} project - Project ID or project name
       * @param {number} runId - RunId of test run
       */
      updateTestResultsToTestRunSession(results, project, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "ee6d95bf-7506-4c47-8100-9fed82cdc2f7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, results, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.TestSettings} testSettings
       * @param {string} project - Project ID or project name
       */
      createTestSettings(testSettings, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "930bad47-f826-4099-9597-f44d0a9c735c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, testSettings, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} testSettingsId
       */
      deleteTestSettings(project, testSettingsId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testSettingsId == null) {
            throw new TypeError("testSettingsId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              testSettingsId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "930bad47-f826-4099-9597-f44d0a9c735c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} testSettingsId
       */
      getTestSettingsById(project, testSettingsId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testSettingsId == null) {
            throw new TypeError("testSettingsId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              testSettingsId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "testresults", "930bad47-f826-4099-9597-f44d0a9c735c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {Contracts.WorkItemToTestLinks} workItemToTestLinks
       * @param {string} project - Project ID or project name
       */
      addWorkItemToTestLinks(workItemToTestLinks, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "4e3abe63-ca46-4fe0-98b2-363f7ec7aa5f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, workItemToTestLinks, options);
              let ret = this.formatResponse(res.result, Contracts.TypeInfo.WorkItemToTestLinks, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} testName
       * @param {number} workItemId
       */
      deleteTestMethodToWorkItemLink(project, testName, workItemId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testName == null) {
            throw new TypeError("testName can not be null or undefined");
          }
          if (workItemId == null) {
            throw new TypeError("workItemId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              testName,
              workItemId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "cbd50bd7-f7ed-4e35-b127-4408ae6bfa2c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} testName
       */
      queryTestMethodLinkedWorkItems(project, testName) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (testName == null) {
            throw new TypeError("testName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              testName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "cbd50bd7-f7ed-4e35-b127-4408ae6bfa2c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} runId
       * @param {number} testCaseResultId
       */
      getTestResultWorkItemsById(project, runId, testCaseResultId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              runId,
              testCaseResultId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "3d032fd6-e7a0-468b-b105-75d206f99aad", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Query Test Result WorkItems based on filter
       *
       * @param {string} project - Project ID or project name
       * @param {string} workItemCategory - can take values Microsoft.BugCategory or all(for getting all workitems)
       * @param {string} automatedTestName
       * @param {number} testCaseId
       * @param {Date} maxCompleteDate
       * @param {number} days
       * @param {number} workItemCount
       */
      queryTestResultWorkItems(project, workItemCategory, automatedTestName, testCaseId, maxCompleteDate, days, workItemCount) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (workItemCategory == null) {
            throw new TypeError("workItemCategory can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              workItemCategory,
              automatedTestName,
              testCaseId,
              maxCompleteDate,
              days,
              "$workItemCount": workItemCount
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "testresults", "f7401a26-331b-44fe-a470-f7ed35138e4a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.TestResultsApi = TestResultsApi;
    TestResultsApi.RESOURCE_AREA_ID = "c83eaf52-edf3-4034-ae11-17d38f25404c";
  }
});

// ../node_modules/azure-devops-node-api/interfaces/TfvcInterfaces.js
var require_TfvcInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/TfvcInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.VersionControlRecursionType = exports2.VersionControlChangeType = exports2.TfvcVersionType = exports2.TfvcVersionOption = exports2.ItemContentType = void 0;
    var TfsCoreInterfaces = require_CoreInterfaces();
    var ItemContentType;
    (function(ItemContentType2) {
      ItemContentType2[ItemContentType2["RawText"] = 0] = "RawText";
      ItemContentType2[ItemContentType2["Base64Encoded"] = 1] = "Base64Encoded";
    })(ItemContentType = exports2.ItemContentType || (exports2.ItemContentType = {}));
    var TfvcVersionOption;
    (function(TfvcVersionOption2) {
      TfvcVersionOption2[TfvcVersionOption2["None"] = 0] = "None";
      TfvcVersionOption2[TfvcVersionOption2["Previous"] = 1] = "Previous";
      TfvcVersionOption2[TfvcVersionOption2["UseRename"] = 2] = "UseRename";
    })(TfvcVersionOption = exports2.TfvcVersionOption || (exports2.TfvcVersionOption = {}));
    var TfvcVersionType;
    (function(TfvcVersionType2) {
      TfvcVersionType2[TfvcVersionType2["None"] = 0] = "None";
      TfvcVersionType2[TfvcVersionType2["Changeset"] = 1] = "Changeset";
      TfvcVersionType2[TfvcVersionType2["Shelveset"] = 2] = "Shelveset";
      TfvcVersionType2[TfvcVersionType2["Change"] = 3] = "Change";
      TfvcVersionType2[TfvcVersionType2["Date"] = 4] = "Date";
      TfvcVersionType2[TfvcVersionType2["Latest"] = 5] = "Latest";
      TfvcVersionType2[TfvcVersionType2["Tip"] = 6] = "Tip";
      TfvcVersionType2[TfvcVersionType2["MergeSource"] = 7] = "MergeSource";
    })(TfvcVersionType = exports2.TfvcVersionType || (exports2.TfvcVersionType = {}));
    var VersionControlChangeType;
    (function(VersionControlChangeType2) {
      VersionControlChangeType2[VersionControlChangeType2["None"] = 0] = "None";
      VersionControlChangeType2[VersionControlChangeType2["Add"] = 1] = "Add";
      VersionControlChangeType2[VersionControlChangeType2["Edit"] = 2] = "Edit";
      VersionControlChangeType2[VersionControlChangeType2["Encoding"] = 4] = "Encoding";
      VersionControlChangeType2[VersionControlChangeType2["Rename"] = 8] = "Rename";
      VersionControlChangeType2[VersionControlChangeType2["Delete"] = 16] = "Delete";
      VersionControlChangeType2[VersionControlChangeType2["Undelete"] = 32] = "Undelete";
      VersionControlChangeType2[VersionControlChangeType2["Branch"] = 64] = "Branch";
      VersionControlChangeType2[VersionControlChangeType2["Merge"] = 128] = "Merge";
      VersionControlChangeType2[VersionControlChangeType2["Lock"] = 256] = "Lock";
      VersionControlChangeType2[VersionControlChangeType2["Rollback"] = 512] = "Rollback";
      VersionControlChangeType2[VersionControlChangeType2["SourceRename"] = 1024] = "SourceRename";
      VersionControlChangeType2[VersionControlChangeType2["TargetRename"] = 2048] = "TargetRename";
      VersionControlChangeType2[VersionControlChangeType2["Property"] = 4096] = "Property";
      VersionControlChangeType2[VersionControlChangeType2["All"] = 8191] = "All";
    })(VersionControlChangeType = exports2.VersionControlChangeType || (exports2.VersionControlChangeType = {}));
    var VersionControlRecursionType;
    (function(VersionControlRecursionType2) {
      VersionControlRecursionType2[VersionControlRecursionType2["None"] = 0] = "None";
      VersionControlRecursionType2[VersionControlRecursionType2["OneLevel"] = 1] = "OneLevel";
      VersionControlRecursionType2[VersionControlRecursionType2["OneLevelPlusNestedEmptyFolders"] = 4] = "OneLevelPlusNestedEmptyFolders";
      VersionControlRecursionType2[VersionControlRecursionType2["Full"] = 120] = "Full";
    })(VersionControlRecursionType = exports2.VersionControlRecursionType || (exports2.VersionControlRecursionType = {}));
    exports2.TypeInfo = {
      Change: {},
      GitRepository: {},
      GitRepositoryRef: {},
      ItemContent: {},
      ItemContentType: {
        enumValues: {
          "rawText": 0,
          "base64Encoded": 1
        }
      },
      TfvcBranch: {},
      TfvcBranchRef: {},
      TfvcChange: {},
      TfvcChangeset: {},
      TfvcChangesetRef: {},
      TfvcItem: {},
      TfvcItemDescriptor: {},
      TfvcItemRequestData: {},
      TfvcLabel: {},
      TfvcLabelRef: {},
      TfvcShelveset: {},
      TfvcShelvesetRef: {},
      TfvcVersionDescriptor: {},
      TfvcVersionOption: {
        enumValues: {
          "none": 0,
          "previous": 1,
          "useRename": 2
        }
      },
      TfvcVersionType: {
        enumValues: {
          "none": 0,
          "changeset": 1,
          "shelveset": 2,
          "change": 3,
          "date": 4,
          "latest": 5,
          "tip": 6,
          "mergeSource": 7
        }
      },
      VersionControlChangeType: {
        enumValues: {
          "none": 0,
          "add": 1,
          "edit": 2,
          "encoding": 4,
          "rename": 8,
          "delete": 16,
          "undelete": 32,
          "branch": 64,
          "merge": 128,
          "lock": 256,
          "rollback": 512,
          "sourceRename": 1024,
          "targetRename": 2048,
          "property": 4096,
          "all": 8191
        }
      },
      VersionControlProjectInfo: {},
      VersionControlRecursionType: {
        enumValues: {
          "none": 0,
          "oneLevel": 1,
          "oneLevelPlusNestedEmptyFolders": 4,
          "full": 120
        }
      }
    };
    exports2.TypeInfo.Change.fields = {
      changeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      },
      newContent: {
        typeInfo: exports2.TypeInfo.ItemContent
      }
    };
    exports2.TypeInfo.GitRepository.fields = {
      parentRepository: {
        typeInfo: exports2.TypeInfo.GitRepositoryRef
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.GitRepositoryRef.fields = {
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
    exports2.TypeInfo.ItemContent.fields = {
      contentType: {
        enumType: exports2.TypeInfo.ItemContentType
      }
    };
    exports2.TypeInfo.TfvcBranch.fields = {
      children: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcBranch
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcBranchRef.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcChange.fields = {
      changeType: {
        enumType: exports2.TypeInfo.VersionControlChangeType
      },
      newContent: {
        typeInfo: exports2.TypeInfo.ItemContent
      }
    };
    exports2.TypeInfo.TfvcChangeset.fields = {
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcChange
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcChangesetRef.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcItem.fields = {
      changeDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcItemDescriptor.fields = {
      recursionLevel: {
        enumType: exports2.TypeInfo.VersionControlRecursionType
      },
      versionOption: {
        enumType: exports2.TypeInfo.TfvcVersionOption
      },
      versionType: {
        enumType: exports2.TypeInfo.TfvcVersionType
      }
    };
    exports2.TypeInfo.TfvcItemRequestData.fields = {
      itemDescriptors: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcItemDescriptor
      }
    };
    exports2.TypeInfo.TfvcLabel.fields = {
      items: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcItem
      },
      modifiedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcLabelRef.fields = {
      modifiedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcShelveset.fields = {
      changes: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TfvcChange
      },
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcShelvesetRef.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.TfvcVersionDescriptor.fields = {
      versionOption: {
        enumType: exports2.TypeInfo.TfvcVersionOption
      },
      versionType: {
        enumType: exports2.TypeInfo.TfvcVersionType
      }
    };
    exports2.TypeInfo.VersionControlProjectInfo.fields = {
      defaultSourceControlType: {
        enumType: TfsCoreInterfaces.TypeInfo.SourceControlTypes
      },
      project: {
        typeInfo: TfsCoreInterfaces.TypeInfo.TeamProjectReference
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/TfvcApi.js
var require_TfvcApi = __commonJS({
  "../node_modules/azure-devops-node-api/TfvcApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TfvcApi = void 0;
    var basem = require_ClientApiBases();
    var TfvcInterfaces = require_TfvcInterfaces();
    var TfvcApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Tfvc-api", options);
      }
      /**
       * Get a single branch hierarchy at the given path with parents or children as specified.
       *
       * @param {string} path - Full path to the branch.  Default: $/ Examples: $/, $/MyProject, $/MyProject/SomeFolder.
       * @param {string} project - Project ID or project name
       * @param {boolean} includeParent - Return the parent branch, if there is one. Default: False
       * @param {boolean} includeChildren - Return child branches, if there are any. Default: False
       */
      getBranch(path2, project, includeParent, includeChildren) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (path2 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              path: path2,
              includeParent,
              includeChildren
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "bc1f417e-239d-42e7-85e1-76e80cb2d6eb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcBranch, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a collection of branch roots -- first-level children, branches with no parents.
       *
       * @param {string} project - Project ID or project name
       * @param {boolean} includeParent - Return the parent branch, if there is one. Default: False
       * @param {boolean} includeChildren - Return the child branches for each root branch. Default: False
       * @param {boolean} includeDeleted - Return deleted branches. Default: False
       * @param {boolean} includeLinks - Return links. Default: False
       */
      getBranches(project, includeParent, includeChildren, includeDeleted, includeLinks) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              includeParent,
              includeChildren,
              includeDeleted,
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "bc1f417e-239d-42e7-85e1-76e80cb2d6eb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcBranch, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get branch hierarchies below the specified scopePath
       *
       * @param {string} scopePath - Full path to the branch.  Default: $/ Examples: $/, $/MyProject, $/MyProject/SomeFolder.
       * @param {string} project - Project ID or project name
       * @param {boolean} includeDeleted - Return deleted branches. Default: False
       * @param {boolean} includeLinks - Return links. Default: False
       */
      getBranchRefs(scopePath, project, includeDeleted, includeLinks) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (scopePath == null) {
            throw new TypeError("scopePath can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              scopePath,
              includeDeleted,
              includeLinks
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "bc1f417e-239d-42e7-85e1-76e80cb2d6eb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcBranchRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve Tfvc changes for a given changeset.
       *
       * @param {number} id - ID of the changeset. Default: null
       * @param {number} skip - Number of results to skip. Default: null
       * @param {number} top - The maximum number of results to return. Default: null
       */
      getChangesetChanges(id, skip, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            let queryValues = {
              "$skip": skip,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "f32b86f2-15b9-4fe6-81b1-6f8938617ee5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcChange, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a new changeset.
       *
       * @param {TfvcInterfaces.TfvcChangeset} changeset
       * @param {string} project - Project ID or project name
       */
      createChangeset(changeset, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "tfvc", "0bc8f0a4-6bfb-42a9-ba84-139da7b99c49", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, changeset, options);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcChangesetRef, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve a Tfvc Changeset
       *
       * @param {number} id - Changeset Id to retrieve.
       * @param {string} project - Project ID or project name
       * @param {number} maxChangeCount - Number of changes to return (maximum 100 changes) Default: 0
       * @param {boolean} includeDetails - Include policy details and check-in notes in the response. Default: false
       * @param {boolean} includeWorkItems - Include workitems. Default: false
       * @param {number} maxCommentLength - Include details about associated work items in the response. Default: null
       * @param {boolean} includeSourceRename - Include renames.  Default: false
       * @param {number} skip - Number of results to skip. Default: null
       * @param {number} top - The maximum number of results to return. Default: null
       * @param {string} orderby - Results are sorted by ID in descending order by default. Use id asc to sort by ID in ascending order.
       * @param {TfvcInterfaces.TfvcChangesetSearchCriteria} searchCriteria - Following criteria available (.itemPath, .version, .versionType, .versionOption, .author, .fromId, .toId, .fromDate, .toDate) Default: null
       */
      getChangeset(id, project, maxChangeCount, includeDetails, includeWorkItems, maxCommentLength, includeSourceRename, skip, top, orderby, searchCriteria) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              maxChangeCount,
              includeDetails,
              includeWorkItems,
              maxCommentLength,
              includeSourceRename,
              "$skip": skip,
              "$top": top,
              "$orderby": orderby,
              searchCriteria
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "tfvc", "0bc8f0a4-6bfb-42a9-ba84-139da7b99c49", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcChangeset, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieve Tfvc Changesets
       *
       * @param {string} project - Project ID or project name
       * @param {number} maxCommentLength - Include details about associated work items in the response. Default: null
       * @param {number} skip - Number of results to skip. Default: null
       * @param {number} top - The maximum number of results to return. Default: null
       * @param {string} orderby - Results are sorted by ID in descending order by default. Use id asc to sort by ID in ascending order.
       * @param {TfvcInterfaces.TfvcChangesetSearchCriteria} searchCriteria - Following criteria available (.itemPath, .version, .versionType, .versionOption, .author, .fromId, .toId, .fromDate, .toDate) Default: null
       */
      getChangesets(project, maxCommentLength, skip, top, orderby, searchCriteria) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              maxCommentLength,
              "$skip": skip,
              "$top": top,
              "$orderby": orderby,
              searchCriteria
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "tfvc", "0bc8f0a4-6bfb-42a9-ba84-139da7b99c49", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcChangesetRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns changesets for a given list of changeset Ids.
       *
       * @param {TfvcInterfaces.TfvcChangesetsRequestData} changesetsRequestData - List of changeset IDs.
       */
      getBatchedChangesets(changesetsRequestData) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "b7e7c173-803c-4fea-9ec8-31ee35c5502a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, changesetsRequestData, options);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcChangesetRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves the work items associated with a particular changeset.
       *
       * @param {number} id - ID of the changeset.
       */
      getChangesetWorkItems(id) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "64ae0bea-1d71-47c9-a9e5-fe73f5ea0ff4", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Post for retrieving a set of items given a list of paths or a long path. Allows for specifying the recursionLevel and version descriptors for each path.
       *
       * @param {TfvcInterfaces.TfvcItemRequestData} itemRequestData
       * @param {string} project - Project ID or project name
       */
      getItemsBatch(itemRequestData, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "fe6f827b-5f64-480f-b8af-1eca3b80e833", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, itemRequestData, options);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Post for retrieving a set of items given a list of paths or a long path. Allows for specifying the recursionLevel and version descriptors for each path.
       *
       * @param {TfvcInterfaces.TfvcItemRequestData} itemRequestData
       * @param {string} project - Project ID or project name
       */
      getItemsBatchZip(itemRequestData, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "fe6f827b-5f64-480f-b8af-1eca3b80e833", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
       *
       * @param {string} path - Version control path of an individual item to return.
       * @param {string} project - Project ID or project name
       * @param {string} fileName - file name of item returned.
       * @param {boolean} download - If true, create a downloadable attachment.
       * @param {string} scopePath - Version control path of a folder to return multiple items.
       * @param {TfvcInterfaces.VersionControlRecursionType} recursionLevel - None (just the item), or OneLevel (contents of a folder).
       * @param {TfvcInterfaces.TfvcVersionDescriptor} versionDescriptor - Version descriptor.  Default is null.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       */
      getItem(path2, project, fileName, download, scopePath, recursionLevel, versionDescriptor, includeContent) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (path2 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              path: path2,
              fileName,
              download,
              scopePath,
              recursionLevel,
              versionDescriptor,
              includeContent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "ba9fc436-9a38-4578-89d6-e4f3241f5040", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcItem, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
       *
       * @param {string} path - Version control path of an individual item to return.
       * @param {string} project - Project ID or project name
       * @param {string} fileName - file name of item returned.
       * @param {boolean} download - If true, create a downloadable attachment.
       * @param {string} scopePath - Version control path of a folder to return multiple items.
       * @param {TfvcInterfaces.VersionControlRecursionType} recursionLevel - None (just the item), or OneLevel (contents of a folder).
       * @param {TfvcInterfaces.TfvcVersionDescriptor} versionDescriptor - Version descriptor.  Default is null.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       */
      getItemContent(path2, project, fileName, download, scopePath, recursionLevel, versionDescriptor, includeContent) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (path2 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              path: path2,
              fileName,
              download,
              scopePath,
              recursionLevel,
              versionDescriptor,
              includeContent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "ba9fc436-9a38-4578-89d6-e4f3241f5040", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of Tfvc items
       *
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - Version control path of a folder to return multiple items.
       * @param {TfvcInterfaces.VersionControlRecursionType} recursionLevel - None (just the item), or OneLevel (contents of a folder).
       * @param {boolean} includeLinks - True to include links.
       * @param {TfvcInterfaces.TfvcVersionDescriptor} versionDescriptor
       */
      getItems(project, scopePath, recursionLevel, includeLinks, versionDescriptor) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              scopePath,
              recursionLevel,
              includeLinks,
              versionDescriptor
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "ba9fc436-9a38-4578-89d6-e4f3241f5040", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
       *
       * @param {string} path - Version control path of an individual item to return.
       * @param {string} project - Project ID or project name
       * @param {string} fileName - file name of item returned.
       * @param {boolean} download - If true, create a downloadable attachment.
       * @param {string} scopePath - Version control path of a folder to return multiple items.
       * @param {TfvcInterfaces.VersionControlRecursionType} recursionLevel - None (just the item), or OneLevel (contents of a folder).
       * @param {TfvcInterfaces.TfvcVersionDescriptor} versionDescriptor - Version descriptor.  Default is null.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       */
      getItemText(path2, project, fileName, download, scopePath, recursionLevel, versionDescriptor, includeContent) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (path2 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              path: path2,
              fileName,
              download,
              scopePath,
              recursionLevel,
              versionDescriptor,
              includeContent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "ba9fc436-9a38-4578-89d6-e4f3241f5040", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Item Metadata and/or Content for a single item. The download parameter is to indicate whether the content should be available as a download or just sent as a stream in the response. Doesn't apply to zipped content which is always returned as a download.
       *
       * @param {string} path - Version control path of an individual item to return.
       * @param {string} project - Project ID or project name
       * @param {string} fileName - file name of item returned.
       * @param {boolean} download - If true, create a downloadable attachment.
       * @param {string} scopePath - Version control path of a folder to return multiple items.
       * @param {TfvcInterfaces.VersionControlRecursionType} recursionLevel - None (just the item), or OneLevel (contents of a folder).
       * @param {TfvcInterfaces.TfvcVersionDescriptor} versionDescriptor - Version descriptor.  Default is null.
       * @param {boolean} includeContent - Set to true to include item content when requesting json.  Default is false.
       */
      getItemZip(path2, project, fileName, download, scopePath, recursionLevel, versionDescriptor, includeContent) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (path2 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              path: path2,
              fileName,
              download,
              scopePath,
              recursionLevel,
              versionDescriptor,
              includeContent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "ba9fc436-9a38-4578-89d6-e4f3241f5040", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get items under a label.
       *
       * @param {string} labelId - Unique identifier of label
       * @param {number} top - Max number of items to return
       * @param {number} skip - Number of items to skip
       */
      getLabelItems(labelId, top, skip) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              labelId
            };
            let queryValues = {
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "06166e34-de17-4b60-8cd1-23182a346fda", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a single deep label.
       *
       * @param {string} labelId - Unique identifier of label
       * @param {TfvcInterfaces.TfvcLabelRequestData} requestData - maxItemCount
       * @param {string} project - Project ID or project name
       */
      getLabel(labelId, requestData, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (requestData == null) {
            throw new TypeError("requestData can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              labelId
            };
            let queryValues = {
              requestData
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "a5d9bd7f-b661-4d0e-b9be-d9c16affae54", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcLabel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a collection of shallow label references.
       *
       * @param {TfvcInterfaces.TfvcLabelRequestData} requestData - labelScope, name, owner, and itemLabelFilter
       * @param {string} project - Project ID or project name
       * @param {number} top - Max number of labels to return, defaults to 100 when undefined
       * @param {number} skip - Number of labels to skip
       */
      getLabels(requestData, project, top, skip) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (requestData == null) {
            throw new TypeError("requestData can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              requestData,
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "a5d9bd7f-b661-4d0e-b9be-d9c16affae54", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcLabelRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get changes included in a shelveset.
       *
       * @param {string} shelvesetId - Shelveset's unique ID
       * @param {number} top - Max number of changes to return
       * @param {number} skip - Number of changes to skip
       */
      getShelvesetChanges(shelvesetId, top, skip) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (shelvesetId == null) {
            throw new TypeError("shelvesetId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              shelvesetId,
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "dbaf075b-0445-4c34-9e5b-82292f856522", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcChange, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a single deep shelveset.
       *
       * @param {string} shelvesetId - Shelveset's unique ID
       * @param {TfvcInterfaces.TfvcShelvesetRequestData} requestData - includeDetails, includeWorkItems, maxChangeCount, and maxCommentLength
       */
      getShelveset(shelvesetId, requestData) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (shelvesetId == null) {
            throw new TypeError("shelvesetId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              shelvesetId,
              requestData
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "e36d44fb-e907-4b0a-b194-f83f1ed32ad3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcShelveset, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Return a collection of shallow shelveset references.
       *
       * @param {TfvcInterfaces.TfvcShelvesetRequestData} requestData - name, owner, and maxCommentLength
       * @param {number} top - Max number of shelvesets to return
       * @param {number} skip - Number of shelvesets to skip
       */
      getShelvesets(requestData, top, skip) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              requestData,
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "e36d44fb-e907-4b0a-b194-f83f1ed32ad3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, TfvcInterfaces.TypeInfo.TfvcShelvesetRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get work items associated with a shelveset.
       *
       * @param {string} shelvesetId - Shelveset's unique ID
       */
      getShelvesetWorkItems(shelvesetId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (shelvesetId == null) {
            throw new TypeError("shelvesetId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              shelvesetId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "a7a0c1c1-373e-425a-b031-a519474d743d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Provides File Count and Uncompressed Bytes for a Collection/Project at a particular scope for TFVC.
       *
       * @param {string} project - Project ID or project name
       * @param {string} scopePath - '$/' for collection, '$/project' for specific project
       */
      getTfvcStatistics(project, scopePath) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              scopePath
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "tfvc", "e15c74c0-3605-40e0-aed4-4cc61e549ed8", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.TfvcApi = TfvcApi;
    TfvcApi.RESOURCE_AREA_ID = "8aa40520-446d-40e6-89f6-9c9f9ce44c48";
  }
});

// ../node_modules/azure-devops-node-api/interfaces/CommentsInterfaces.js
var require_CommentsInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/CommentsInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.CommentState = exports2.CommentSortOrder = exports2.CommentReactionType = exports2.CommentMentionType = exports2.CommentFormat = exports2.CommentExpandOptions = void 0;
    var CommentExpandOptions;
    (function(CommentExpandOptions2) {
      CommentExpandOptions2[CommentExpandOptions2["None"] = 0] = "None";
      CommentExpandOptions2[CommentExpandOptions2["Reactions"] = 1] = "Reactions";
      CommentExpandOptions2[CommentExpandOptions2["RenderedText"] = 8] = "RenderedText";
      CommentExpandOptions2[CommentExpandOptions2["RenderedTextOnly"] = 16] = "RenderedTextOnly";
      CommentExpandOptions2[CommentExpandOptions2["Children"] = 32] = "Children";
      CommentExpandOptions2[CommentExpandOptions2["All"] = -17] = "All";
    })(CommentExpandOptions = exports2.CommentExpandOptions || (exports2.CommentExpandOptions = {}));
    var CommentFormat;
    (function(CommentFormat2) {
      CommentFormat2[CommentFormat2["Markdown"] = 0] = "Markdown";
      CommentFormat2[CommentFormat2["Html"] = 1] = "Html";
    })(CommentFormat = exports2.CommentFormat || (exports2.CommentFormat = {}));
    var CommentMentionType;
    (function(CommentMentionType2) {
      CommentMentionType2[CommentMentionType2["Person"] = 0] = "Person";
      CommentMentionType2[CommentMentionType2["WorkItem"] = 1] = "WorkItem";
      CommentMentionType2[CommentMentionType2["PullRequest"] = 2] = "PullRequest";
    })(CommentMentionType = exports2.CommentMentionType || (exports2.CommentMentionType = {}));
    var CommentReactionType;
    (function(CommentReactionType2) {
      CommentReactionType2[CommentReactionType2["Like"] = 0] = "Like";
      CommentReactionType2[CommentReactionType2["Dislike"] = 1] = "Dislike";
      CommentReactionType2[CommentReactionType2["Heart"] = 2] = "Heart";
      CommentReactionType2[CommentReactionType2["Hooray"] = 3] = "Hooray";
      CommentReactionType2[CommentReactionType2["Smile"] = 4] = "Smile";
      CommentReactionType2[CommentReactionType2["Confused"] = 5] = "Confused";
    })(CommentReactionType = exports2.CommentReactionType || (exports2.CommentReactionType = {}));
    var CommentSortOrder;
    (function(CommentSortOrder2) {
      CommentSortOrder2[CommentSortOrder2["Asc"] = 1] = "Asc";
      CommentSortOrder2[CommentSortOrder2["Desc"] = 2] = "Desc";
    })(CommentSortOrder = exports2.CommentSortOrder || (exports2.CommentSortOrder = {}));
    var CommentState;
    (function(CommentState2) {
      CommentState2[CommentState2["Active"] = 0] = "Active";
      CommentState2[CommentState2["Resolved"] = 1] = "Resolved";
      CommentState2[CommentState2["Closed"] = 2] = "Closed";
    })(CommentState = exports2.CommentState || (exports2.CommentState = {}));
    exports2.TypeInfo = {
      Comment: {},
      CommentAttachment: {},
      CommentExpandOptions: {
        enumValues: {
          "none": 0,
          "reactions": 1,
          "renderedText": 8,
          "renderedTextOnly": 16,
          "children": 32,
          "all": -17
        }
      },
      CommentFormat: {
        enumValues: {
          "markdown": 0,
          "html": 1
        }
      },
      CommentList: {},
      CommentMention: {},
      CommentMentionType: {
        enumValues: {
          "person": 0,
          "workItem": 1,
          "pullRequest": 2
        }
      },
      CommentReaction: {},
      CommentReactionType: {
        enumValues: {
          "like": 0,
          "dislike": 1,
          "heart": 2,
          "hooray": 3,
          "smile": 4,
          "confused": 5
        }
      },
      CommentSortOrder: {
        enumValues: {
          "asc": 1,
          "desc": 2
        }
      },
      CommentState: {
        enumValues: {
          "active": 0,
          "resolved": 1,
          "closed": 2
        }
      },
      CommentUpdateParameters: {},
      CommentVersion: {}
    };
    exports2.TypeInfo.Comment.fields = {
      createdDate: {
        isDate: true
      },
      mentions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.CommentMention
      },
      modifiedDate: {
        isDate: true
      },
      reactions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.CommentReaction
      },
      replies: {
        typeInfo: exports2.TypeInfo.CommentList
      },
      state: {
        enumType: exports2.TypeInfo.CommentState
      }
    };
    exports2.TypeInfo.CommentAttachment.fields = {
      createdDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.CommentList.fields = {
      comments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Comment
      }
    };
    exports2.TypeInfo.CommentMention.fields = {
      type: {
        enumType: exports2.TypeInfo.CommentMentionType
      }
    };
    exports2.TypeInfo.CommentReaction.fields = {
      type: {
        enumType: exports2.TypeInfo.CommentReactionType
      }
    };
    exports2.TypeInfo.CommentUpdateParameters.fields = {
      state: {
        enumType: exports2.TypeInfo.CommentState
      }
    };
    exports2.TypeInfo.CommentVersion.fields = {
      createdDate: {
        isDate: true
      },
      modifiedDate: {
        isDate: true
      },
      state: {
        enumType: exports2.TypeInfo.CommentState
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/interfaces/WikiInterfaces.js
var require_WikiInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/WikiInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.WikiType = void 0;
    var GitInterfaces = require_GitInterfaces();
    var WikiType;
    (function(WikiType2) {
      WikiType2[WikiType2["ProjectWiki"] = 0] = "ProjectWiki";
      WikiType2[WikiType2["CodeWiki"] = 1] = "CodeWiki";
    })(WikiType = exports2.WikiType || (exports2.WikiType = {}));
    exports2.TypeInfo = {
      Wiki: {},
      WikiCreateBaseParameters: {},
      WikiCreateParametersV2: {},
      WikiPageDetail: {},
      WikiPageStat: {},
      WikiPageViewStats: {},
      WikiType: {
        enumValues: {
          "projectWiki": 0,
          "codeWiki": 1
        }
      },
      WikiUpdateParameters: {},
      WikiV2: {}
    };
    exports2.TypeInfo.Wiki.fields = {
      repository: {
        typeInfo: GitInterfaces.TypeInfo.GitRepository
      }
    };
    exports2.TypeInfo.WikiCreateBaseParameters.fields = {
      type: {
        enumType: exports2.TypeInfo.WikiType
      }
    };
    exports2.TypeInfo.WikiCreateParametersV2.fields = {
      type: {
        enumType: exports2.TypeInfo.WikiType
      },
      version: {
        typeInfo: GitInterfaces.TypeInfo.GitVersionDescriptor
      }
    };
    exports2.TypeInfo.WikiPageDetail.fields = {
      viewStats: {
        isArray: true,
        typeInfo: exports2.TypeInfo.WikiPageStat
      }
    };
    exports2.TypeInfo.WikiPageStat.fields = {
      day: {
        isDate: true
      }
    };
    exports2.TypeInfo.WikiPageViewStats.fields = {
      lastViewedTime: {
        isDate: true
      }
    };
    exports2.TypeInfo.WikiUpdateParameters.fields = {
      versions: {
        isArray: true,
        typeInfo: GitInterfaces.TypeInfo.GitVersionDescriptor
      }
    };
    exports2.TypeInfo.WikiV2.fields = {
      type: {
        enumType: exports2.TypeInfo.WikiType
      },
      versions: {
        isArray: true,
        typeInfo: GitInterfaces.TypeInfo.GitVersionDescriptor
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/WikiApi.js
var require_WikiApi = __commonJS({
  "../node_modules/azure-devops-node-api/WikiApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WikiApi = void 0;
    var basem = require_ClientApiBases();
    var Comments_Contracts = require_CommentsInterfaces();
    var WikiInterfaces = require_WikiInterfaces();
    var WikiApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Wiki-api", options);
      }
      /**
       * Uploads an attachment on a comment on a wiki page.
       *
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {number} pageId - Wiki page ID.
       */
      createCommentAttachment(customHeaders, contentStream, project, wikiIdentifier, pageId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "5100d976-363d-42e7-a19d-4171ecb44782", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options);
              let ret = this.formatResponse(res.result, Comments_Contracts.TypeInfo.CommentAttachment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Downloads an attachment on a comment on a wiki page.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {number} pageId - Wiki page ID.
       * @param {string} attachmentId - Attachment ID.
       */
      getAttachmentContent(project, wikiIdentifier, pageId, attachmentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId,
              attachmentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "5100d976-363d-42e7-a19d-4171ecb44782", routeValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add a reaction on a wiki page comment.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name
       * @param {number} pageId - Wiki page ID
       * @param {number} commentId - ID of the associated comment
       * @param {Comments_Contracts.CommentReactionType} type - Type of the reaction being added
       */
      addCommentReaction(project, wikiIdentifier, pageId, commentId, type) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId,
              commentId,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "7a5bc693-aab7-4d48-8f34-36f373022063", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options);
              let ret = this.formatResponse(res.result, Comments_Contracts.TypeInfo.CommentReaction, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a reaction on a wiki page comment.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or name
       * @param {number} pageId - Wiki page ID
       * @param {number} commentId - ID of the associated comment
       * @param {Comments_Contracts.CommentReactionType} type - Type of the reaction being deleted
       */
      deleteCommentReaction(project, wikiIdentifier, pageId, commentId, type) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId,
              commentId,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "7a5bc693-aab7-4d48-8f34-36f373022063", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, Comments_Contracts.TypeInfo.CommentReaction, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of users who have reacted for the given wiki comment with a given reaction type. Supports paging, with a default page size of 100 users at a time.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {number} pageId - Wiki page ID.
       * @param {number} commentId - ID of the associated comment
       * @param {Comments_Contracts.CommentReactionType} type - Type of the reaction for which the engaged users are being requested
       * @param {number} top - Number of enagaged users to be returned in a given page. Optional, defaults to 100
       * @param {number} skip - Number of engaged users to be skipped to page the next set of engaged users, defaults to 0
       */
      getEngagedUsers(project, wikiIdentifier, pageId, commentId, type, top, skip) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId,
              commentId,
              type
            };
            let queryValues = {
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "598a5268-41a7-4162-b7dc-344131e4d1fa", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add a comment on a wiki page.
       *
       * @param {Comments_Contracts.CommentCreateParameters} request - Comment create request.
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {number} pageId - Wiki page ID.
       */
      addComment(request, project, wikiIdentifier, pageId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "9b394e93-7db5-46cb-9c26-09a36aa5c895", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, request, options);
              let ret = this.formatResponse(res.result, Comments_Contracts.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a comment on a wiki page.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or name.
       * @param {number} pageId - Wiki page ID.
       * @param {number} id - Comment ID.
       */
      deleteComment(project, wikiIdentifier, pageId, id) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "9b394e93-7db5-46cb-9c26-09a36aa5c895", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a comment associated with the Wiki Page.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {number} pageId - Wiki page ID.
       * @param {number} id - ID of the comment to return.
       * @param {boolean} excludeDeleted - Specify if the deleted comment should be skipped.
       * @param {Comments_Contracts.CommentExpandOptions} expand - Specifies the additional data retrieval options for comments.
       */
      getComment(project, wikiIdentifier, pageId, id, excludeDeleted, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId,
              id
            };
            let queryValues = {
              excludeDeleted,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "9b394e93-7db5-46cb-9c26-09a36aa5c895", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Comments_Contracts.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a pageable list of comments.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {number} pageId - Wiki page ID.
       * @param {number} top - Max number of comments to return.
       * @param {string} continuationToken - Used to query for the next page of comments.
       * @param {boolean} excludeDeleted - Specify if the deleted comments should be skipped.
       * @param {Comments_Contracts.CommentExpandOptions} expand - Specifies the additional data retrieval options for comments.
       * @param {Comments_Contracts.CommentSortOrder} order - Order in which the comments should be returned.
       * @param {number} parentId - CommentId of the parent comment.
       */
      listComments(project, wikiIdentifier, pageId, top, continuationToken, excludeDeleted, expand, order, parentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId
            };
            let queryValues = {
              "$top": top,
              continuationToken,
              excludeDeleted,
              "$expand": expand,
              order,
              parentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "9b394e93-7db5-46cb-9c26-09a36aa5c895", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, Comments_Contracts.TypeInfo.CommentList, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a comment on a wiki page.
       *
       * @param {Comments_Contracts.CommentUpdateParameters} comment - Comment update request.
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {number} pageId - Wiki page ID.
       * @param {number} id - Comment ID.
       */
      updateComment(comment, project, wikiIdentifier, pageId, id) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "9b394e93-7db5-46cb-9c26-09a36aa5c895", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, comment, options);
              let ret = this.formatResponse(res.result, Comments_Contracts.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets metadata or content of the wiki page for the provided path. Content negotiation is done based on the `Accept` header sent in the request.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {string} path - Wiki page path.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - Recursion level for subpages retrieval. Defaults to `None` (Optional).
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - GitVersionDescriptor for the page. Defaults to the default branch (Optional).
       * @param {boolean} includeContent - True to include the content of the page in the response for Json content type. Defaults to false (Optional)
       */
      getPageText(project, wikiIdentifier, path2, recursionLevel, versionDescriptor, includeContent) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier
            };
            let queryValues = {
              path: path2,
              recursionLevel,
              versionDescriptor,
              includeContent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "25d3fbc7-fe3d-46cb-b5a5-0b6f79caf27b", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets metadata or content of the wiki page for the provided path. Content negotiation is done based on the `Accept` header sent in the request.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {string} path - Wiki page path.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - Recursion level for subpages retrieval. Defaults to `None` (Optional).
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - GitVersionDescriptor for the page. Defaults to the default branch (Optional).
       * @param {boolean} includeContent - True to include the content of the page in the response for Json content type. Defaults to false (Optional)
       */
      getPageZip(project, wikiIdentifier, path2, recursionLevel, versionDescriptor, includeContent) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier
            };
            let queryValues = {
              path: path2,
              recursionLevel,
              versionDescriptor,
              includeContent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "25d3fbc7-fe3d-46cb-b5a5-0b6f79caf27b", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets metadata or content of the wiki page for the provided page id. Content negotiation is done based on the `Accept` header sent in the request.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name..
       * @param {number} id - Wiki page ID.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - Recursion level for subpages retrieval. Defaults to `None` (Optional).
       * @param {boolean} includeContent - True to include the content of the page in the response for Json content type. Defaults to false (Optional)
       */
      getPageByIdText(project, wikiIdentifier, id, recursionLevel, includeContent) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              id
            };
            let queryValues = {
              recursionLevel,
              includeContent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "ceddcf75-1068-452d-8b13-2d4d76e1f970", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("text/plain", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets metadata or content of the wiki page for the provided page id. Content negotiation is done based on the `Accept` header sent in the request.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name..
       * @param {number} id - Wiki page ID.
       * @param {GitInterfaces.VersionControlRecursionType} recursionLevel - Recursion level for subpages retrieval. Defaults to `None` (Optional).
       * @param {boolean} includeContent - True to include the content of the page in the response for Json content type. Defaults to false (Optional)
       */
      getPageByIdZip(project, wikiIdentifier, id, recursionLevel, includeContent) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              id
            };
            let queryValues = {
              recursionLevel,
              includeContent
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "ceddcf75-1068-452d-8b13-2d4d76e1f970", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns pageable list of Wiki Pages
       *
       * @param {WikiInterfaces.WikiPagesBatchRequest} pagesBatchRequest - Wiki batch page request.
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {GitInterfaces.GitVersionDescriptor} versionDescriptor - GitVersionDescriptor for the page. (Optional in case of ProjectWiki).
       */
      getPagesBatch(pagesBatchRequest, project, wikiIdentifier, versionDescriptor) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier
            };
            let queryValues = {
              versionDescriptor
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "71323c46-2592-4398-8771-ced73dd87207", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, pagesBatchRequest, options);
              let ret = this.formatResponse(res.result, WikiInterfaces.TypeInfo.WikiPageDetail, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns page detail corresponding to Page ID.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {number} pageId - Wiki page ID.
       * @param {number} pageViewsForDays - last N days from the current day for which page views is to be returned. It's inclusive of current day.
       */
      getPageData(project, wikiIdentifier, pageId, pageViewsForDays) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier,
              pageId
            };
            let queryValues = {
              pageViewsForDays
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "81c4e0fe-7663-4d62-ad46-6ab78459f274", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WikiInterfaces.TypeInfo.WikiPageDetail, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new page view stats resource or updates an existing page view stats resource.
       *
       * @param {string} project - Project ID or project name
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {GitInterfaces.GitVersionDescriptor} wikiVersion - Wiki version.
       * @param {string} path - Wiki page path.
       * @param {string} oldPath - Old page path. This is optional and required to rename path in existing page view stats.
       */
      createOrUpdatePageViewStats(project, wikiIdentifier, wikiVersion, path2, oldPath) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (wikiVersion == null) {
            throw new TypeError("wikiVersion can not be null or undefined");
          }
          if (path2 == null) {
            throw new TypeError("path can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier
            };
            let queryValues = {
              wikiVersion,
              path: path2,
              oldPath
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "wiki", "1087b746-5d15-41b9-bea6-14e325e7f880", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, null, options);
              let ret = this.formatResponse(res.result, WikiInterfaces.TypeInfo.WikiPageViewStats, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates the wiki resource.
       *
       * @param {WikiInterfaces.WikiCreateParametersV2} wikiCreateParams - Parameters for the wiki creation.
       * @param {string} project - Project ID or project name
       */
      createWiki(wikiCreateParams, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "wiki", "288d122c-dbd4-451d-aa5f-7dbbba070728", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, wikiCreateParams, options);
              let ret = this.formatResponse(res.result, WikiInterfaces.TypeInfo.WikiV2, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes the wiki corresponding to the wiki ID or wiki name provided.
       *
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {string} project - Project ID or project name
       */
      deleteWiki(wikiIdentifier, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "wiki", "288d122c-dbd4-451d-aa5f-7dbbba070728", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, WikiInterfaces.TypeInfo.WikiV2, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets all wikis in a project or collection.
       *
       * @param {string} project - Project ID or project name
       */
      getAllWikis(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "wiki", "288d122c-dbd4-451d-aa5f-7dbbba070728", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WikiInterfaces.TypeInfo.WikiV2, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the wiki corresponding to the wiki ID or wiki name provided.
       *
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {string} project - Project ID or project name
       */
      getWiki(wikiIdentifier, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "wiki", "288d122c-dbd4-451d-aa5f-7dbbba070728", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WikiInterfaces.TypeInfo.WikiV2, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates the wiki corresponding to the wiki ID or wiki name provided using the update parameters.
       *
       * @param {WikiInterfaces.WikiUpdateParameters} updateParameters - Update parameters.
       * @param {string} wikiIdentifier - Wiki ID or wiki name.
       * @param {string} project - Project ID or project name
       */
      updateWiki(updateParameters, wikiIdentifier, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              wikiIdentifier
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "wiki", "288d122c-dbd4-451d-aa5f-7dbbba070728", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateParameters, options);
              let ret = this.formatResponse(res.result, WikiInterfaces.TypeInfo.WikiV2, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.WikiApi = WikiApi;
    WikiApi.RESOURCE_AREA_ID = "bf7d82a0-8aa5-4613-94ef-6172a5ea01f3";
  }
});

// ../node_modules/azure-devops-node-api/interfaces/common/System.js
var require_System = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/common/System.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.DayOfWeek = void 0;
    var DayOfWeek;
    (function(DayOfWeek2) {
      DayOfWeek2[DayOfWeek2["Sunday"] = 0] = "Sunday";
      DayOfWeek2[DayOfWeek2["Monday"] = 1] = "Monday";
      DayOfWeek2[DayOfWeek2["Tuesday"] = 2] = "Tuesday";
      DayOfWeek2[DayOfWeek2["Wednesday"] = 3] = "Wednesday";
      DayOfWeek2[DayOfWeek2["Thursday"] = 4] = "Thursday";
      DayOfWeek2[DayOfWeek2["Friday"] = 5] = "Friday";
      DayOfWeek2[DayOfWeek2["Saturday"] = 6] = "Saturday";
    })(DayOfWeek = exports2.DayOfWeek || (exports2.DayOfWeek = {}));
    exports2.TypeInfo = {
      DayOfWeek: {
        enumValues: {
          "sunday": 0,
          "monday": 1,
          "tuesday": 2,
          "wednesday": 3,
          "thursday": 4,
          "friday": 5,
          "saturday": 6
        }
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/interfaces/WorkInterfaces.js
var require_WorkInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/WorkInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.TimelineTeamStatusCode = exports2.TimelineIterationStatusCode = exports2.TimelineCriteriaStatusCode = exports2.TimeFrame = exports2.PlanUserPermissions = exports2.PlanType = exports2.IdentityDisplayFormat = exports2.FieldType = exports2.BugsBehavior = exports2.BoardColumnType = exports2.BoardBadgeColumnOptions = exports2.BacklogType = void 0;
    var SystemInterfaces = require_System();
    var BacklogType;
    (function(BacklogType2) {
      BacklogType2[BacklogType2["Portfolio"] = 0] = "Portfolio";
      BacklogType2[BacklogType2["Requirement"] = 1] = "Requirement";
      BacklogType2[BacklogType2["Task"] = 2] = "Task";
    })(BacklogType = exports2.BacklogType || (exports2.BacklogType = {}));
    var BoardBadgeColumnOptions;
    (function(BoardBadgeColumnOptions2) {
      BoardBadgeColumnOptions2[BoardBadgeColumnOptions2["InProgressColumns"] = 0] = "InProgressColumns";
      BoardBadgeColumnOptions2[BoardBadgeColumnOptions2["AllColumns"] = 1] = "AllColumns";
      BoardBadgeColumnOptions2[BoardBadgeColumnOptions2["CustomColumns"] = 2] = "CustomColumns";
    })(BoardBadgeColumnOptions = exports2.BoardBadgeColumnOptions || (exports2.BoardBadgeColumnOptions = {}));
    var BoardColumnType;
    (function(BoardColumnType2) {
      BoardColumnType2[BoardColumnType2["Incoming"] = 0] = "Incoming";
      BoardColumnType2[BoardColumnType2["InProgress"] = 1] = "InProgress";
      BoardColumnType2[BoardColumnType2["Outgoing"] = 2] = "Outgoing";
    })(BoardColumnType = exports2.BoardColumnType || (exports2.BoardColumnType = {}));
    var BugsBehavior;
    (function(BugsBehavior2) {
      BugsBehavior2[BugsBehavior2["Off"] = 0] = "Off";
      BugsBehavior2[BugsBehavior2["AsRequirements"] = 1] = "AsRequirements";
      BugsBehavior2[BugsBehavior2["AsTasks"] = 2] = "AsTasks";
    })(BugsBehavior = exports2.BugsBehavior || (exports2.BugsBehavior = {}));
    var FieldType;
    (function(FieldType2) {
      FieldType2[FieldType2["String"] = 0] = "String";
      FieldType2[FieldType2["PlainText"] = 1] = "PlainText";
      FieldType2[FieldType2["Integer"] = 2] = "Integer";
      FieldType2[FieldType2["DateTime"] = 3] = "DateTime";
      FieldType2[FieldType2["TreePath"] = 4] = "TreePath";
      FieldType2[FieldType2["Boolean"] = 5] = "Boolean";
      FieldType2[FieldType2["Double"] = 6] = "Double";
    })(FieldType = exports2.FieldType || (exports2.FieldType = {}));
    var IdentityDisplayFormat;
    (function(IdentityDisplayFormat2) {
      IdentityDisplayFormat2[IdentityDisplayFormat2["AvatarOnly"] = 0] = "AvatarOnly";
      IdentityDisplayFormat2[IdentityDisplayFormat2["FullName"] = 1] = "FullName";
      IdentityDisplayFormat2[IdentityDisplayFormat2["AvatarAndFullName"] = 2] = "AvatarAndFullName";
    })(IdentityDisplayFormat = exports2.IdentityDisplayFormat || (exports2.IdentityDisplayFormat = {}));
    var PlanType;
    (function(PlanType2) {
      PlanType2[PlanType2["DeliveryTimelineView"] = 0] = "DeliveryTimelineView";
    })(PlanType = exports2.PlanType || (exports2.PlanType = {}));
    var PlanUserPermissions;
    (function(PlanUserPermissions2) {
      PlanUserPermissions2[PlanUserPermissions2["None"] = 0] = "None";
      PlanUserPermissions2[PlanUserPermissions2["View"] = 1] = "View";
      PlanUserPermissions2[PlanUserPermissions2["Edit"] = 2] = "Edit";
      PlanUserPermissions2[PlanUserPermissions2["Delete"] = 4] = "Delete";
      PlanUserPermissions2[PlanUserPermissions2["Manage"] = 8] = "Manage";
      PlanUserPermissions2[PlanUserPermissions2["AllPermissions"] = 15] = "AllPermissions";
    })(PlanUserPermissions = exports2.PlanUserPermissions || (exports2.PlanUserPermissions = {}));
    var TimeFrame;
    (function(TimeFrame2) {
      TimeFrame2[TimeFrame2["Past"] = 0] = "Past";
      TimeFrame2[TimeFrame2["Current"] = 1] = "Current";
      TimeFrame2[TimeFrame2["Future"] = 2] = "Future";
    })(TimeFrame = exports2.TimeFrame || (exports2.TimeFrame = {}));
    var TimelineCriteriaStatusCode;
    (function(TimelineCriteriaStatusCode2) {
      TimelineCriteriaStatusCode2[TimelineCriteriaStatusCode2["OK"] = 0] = "OK";
      TimelineCriteriaStatusCode2[TimelineCriteriaStatusCode2["InvalidFilterClause"] = 1] = "InvalidFilterClause";
      TimelineCriteriaStatusCode2[TimelineCriteriaStatusCode2["Unknown"] = 2] = "Unknown";
    })(TimelineCriteriaStatusCode = exports2.TimelineCriteriaStatusCode || (exports2.TimelineCriteriaStatusCode = {}));
    var TimelineIterationStatusCode;
    (function(TimelineIterationStatusCode2) {
      TimelineIterationStatusCode2[TimelineIterationStatusCode2["OK"] = 0] = "OK";
      TimelineIterationStatusCode2[TimelineIterationStatusCode2["IsOverlapping"] = 1] = "IsOverlapping";
    })(TimelineIterationStatusCode = exports2.TimelineIterationStatusCode || (exports2.TimelineIterationStatusCode = {}));
    var TimelineTeamStatusCode;
    (function(TimelineTeamStatusCode2) {
      TimelineTeamStatusCode2[TimelineTeamStatusCode2["OK"] = 0] = "OK";
      TimelineTeamStatusCode2[TimelineTeamStatusCode2["DoesntExistOrAccessDenied"] = 1] = "DoesntExistOrAccessDenied";
      TimelineTeamStatusCode2[TimelineTeamStatusCode2["MaxTeamsExceeded"] = 2] = "MaxTeamsExceeded";
      TimelineTeamStatusCode2[TimelineTeamStatusCode2["MaxTeamFieldsExceeded"] = 3] = "MaxTeamFieldsExceeded";
      TimelineTeamStatusCode2[TimelineTeamStatusCode2["BacklogInError"] = 4] = "BacklogInError";
      TimelineTeamStatusCode2[TimelineTeamStatusCode2["MissingTeamFieldValue"] = 5] = "MissingTeamFieldValue";
      TimelineTeamStatusCode2[TimelineTeamStatusCode2["NoIterationsExist"] = 6] = "NoIterationsExist";
    })(TimelineTeamStatusCode = exports2.TimelineTeamStatusCode || (exports2.TimelineTeamStatusCode = {}));
    exports2.TypeInfo = {
      BacklogConfiguration: {},
      BacklogLevelConfiguration: {},
      BacklogType: {
        enumValues: {
          "portfolio": 0,
          "requirement": 1,
          "task": 2
        }
      },
      Board: {},
      BoardBadgeColumnOptions: {
        enumValues: {
          "inProgressColumns": 0,
          "allColumns": 1,
          "customColumns": 2
        }
      },
      BoardColumn: {},
      BoardColumnType: {
        enumValues: {
          "incoming": 0,
          "inProgress": 1,
          "outgoing": 2
        }
      },
      BugsBehavior: {
        enumValues: {
          "off": 0,
          "asRequirements": 1,
          "asTasks": 2
        }
      },
      CapacityContractBase: {},
      CapacityPatch: {},
      CardFieldSettings: {},
      CardSettings: {},
      CreatePlan: {},
      DateRange: {},
      DeliveryViewData: {},
      DeliveryViewPropertyCollection: {},
      FieldInfo: {},
      FieldType: {
        enumValues: {
          "string": 0,
          "plainText": 1,
          "integer": 2,
          "dateTime": 3,
          "treePath": 4,
          "boolean": 5,
          "double": 6
        }
      },
      IdentityDisplayFormat: {
        enumValues: {
          "avatarOnly": 0,
          "fullName": 1,
          "avatarAndFullName": 2
        }
      },
      Marker: {},
      Plan: {},
      PlanMetadata: {},
      PlanType: {
        enumValues: {
          "deliveryTimelineView": 0
        }
      },
      PlanUserPermissions: {
        enumValues: {
          "none": 0,
          "view": 1,
          "edit": 2,
          "delete": 4,
          "manage": 8,
          "allPermissions": 15
        }
      },
      TeamCapacity: {},
      TeamIterationAttributes: {},
      TeamMemberCapacity: {},
      TeamMemberCapacityIdentityRef: {},
      TeamSetting: {},
      TeamSettingsDaysOff: {},
      TeamSettingsDaysOffPatch: {},
      TeamSettingsIteration: {},
      TeamSettingsPatch: {},
      TimeFrame: {
        enumValues: {
          "past": 0,
          "current": 1,
          "future": 2
        }
      },
      TimelineCriteriaStatus: {},
      TimelineCriteriaStatusCode: {
        enumValues: {
          "ok": 0,
          "invalidFilterClause": 1,
          "unknown": 2
        }
      },
      TimelineIterationStatus: {},
      TimelineIterationStatusCode: {
        enumValues: {
          "ok": 0,
          "isOverlapping": 1
        }
      },
      TimelineTeamData: {},
      TimelineTeamIteration: {},
      TimelineTeamStatus: {},
      TimelineTeamStatusCode: {
        enumValues: {
          "ok": 0,
          "doesntExistOrAccessDenied": 1,
          "maxTeamsExceeded": 2,
          "maxTeamFieldsExceeded": 3,
          "backlogInError": 4,
          "missingTeamFieldValue": 5,
          "noIterationsExist": 6
        }
      },
      UpdatePlan: {}
    };
    exports2.TypeInfo.BacklogConfiguration.fields = {
      bugsBehavior: {
        enumType: exports2.TypeInfo.BugsBehavior
      },
      portfolioBacklogs: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BacklogLevelConfiguration
      },
      requirementBacklog: {
        typeInfo: exports2.TypeInfo.BacklogLevelConfiguration
      },
      taskBacklog: {
        typeInfo: exports2.TypeInfo.BacklogLevelConfiguration
      }
    };
    exports2.TypeInfo.BacklogLevelConfiguration.fields = {
      type: {
        enumType: exports2.TypeInfo.BacklogType
      }
    };
    exports2.TypeInfo.Board.fields = {
      columns: {
        isArray: true,
        typeInfo: exports2.TypeInfo.BoardColumn
      }
    };
    exports2.TypeInfo.BoardColumn.fields = {
      columnType: {
        enumType: exports2.TypeInfo.BoardColumnType
      }
    };
    exports2.TypeInfo.CapacityContractBase.fields = {
      daysOff: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DateRange
      }
    };
    exports2.TypeInfo.CapacityPatch.fields = {
      daysOff: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DateRange
      }
    };
    exports2.TypeInfo.CardFieldSettings.fields = {
      additionalFields: {
        isArray: true,
        typeInfo: exports2.TypeInfo.FieldInfo
      },
      assignedToDisplayFormat: {
        enumType: exports2.TypeInfo.IdentityDisplayFormat
      },
      coreFields: {
        isArray: true,
        typeInfo: exports2.TypeInfo.FieldInfo
      }
    };
    exports2.TypeInfo.CardSettings.fields = {
      fields: {
        typeInfo: exports2.TypeInfo.CardFieldSettings
      }
    };
    exports2.TypeInfo.CreatePlan.fields = {
      type: {
        enumType: exports2.TypeInfo.PlanType
      }
    };
    exports2.TypeInfo.DateRange.fields = {
      end: {
        isDate: true
      },
      start: {
        isDate: true
      }
    };
    exports2.TypeInfo.DeliveryViewData.fields = {
      criteriaStatus: {
        typeInfo: exports2.TypeInfo.TimelineCriteriaStatus
      },
      endDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      },
      teams: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TimelineTeamData
      }
    };
    exports2.TypeInfo.DeliveryViewPropertyCollection.fields = {
      cardSettings: {
        typeInfo: exports2.TypeInfo.CardSettings
      },
      markers: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Marker
      }
    };
    exports2.TypeInfo.FieldInfo.fields = {
      fieldType: {
        enumType: exports2.TypeInfo.FieldType
      }
    };
    exports2.TypeInfo.Marker.fields = {
      date: {
        isDate: true
      }
    };
    exports2.TypeInfo.Plan.fields = {
      createdDate: {
        isDate: true
      },
      lastAccessed: {
        isDate: true
      },
      modifiedDate: {
        isDate: true
      },
      type: {
        enumType: exports2.TypeInfo.PlanType
      },
      userPermissions: {
        enumType: exports2.TypeInfo.PlanUserPermissions
      }
    };
    exports2.TypeInfo.PlanMetadata.fields = {
      modifiedDate: {
        isDate: true
      },
      userPermissions: {
        enumType: exports2.TypeInfo.PlanUserPermissions
      }
    };
    exports2.TypeInfo.TeamCapacity.fields = {
      teamMembers: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TeamMemberCapacityIdentityRef
      }
    };
    exports2.TypeInfo.TeamIterationAttributes.fields = {
      finishDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      },
      timeFrame: {
        enumType: exports2.TypeInfo.TimeFrame
      }
    };
    exports2.TypeInfo.TeamMemberCapacity.fields = {
      daysOff: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DateRange
      }
    };
    exports2.TypeInfo.TeamMemberCapacityIdentityRef.fields = {
      daysOff: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DateRange
      }
    };
    exports2.TypeInfo.TeamSetting.fields = {
      backlogIteration: {
        typeInfo: exports2.TypeInfo.TeamSettingsIteration
      },
      bugsBehavior: {
        enumType: exports2.TypeInfo.BugsBehavior
      },
      defaultIteration: {
        typeInfo: exports2.TypeInfo.TeamSettingsIteration
      },
      workingDays: {
        isArray: true,
        enumType: SystemInterfaces.TypeInfo.DayOfWeek
      }
    };
    exports2.TypeInfo.TeamSettingsDaysOff.fields = {
      daysOff: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DateRange
      }
    };
    exports2.TypeInfo.TeamSettingsDaysOffPatch.fields = {
      daysOff: {
        isArray: true,
        typeInfo: exports2.TypeInfo.DateRange
      }
    };
    exports2.TypeInfo.TeamSettingsIteration.fields = {
      attributes: {
        typeInfo: exports2.TypeInfo.TeamIterationAttributes
      }
    };
    exports2.TypeInfo.TeamSettingsPatch.fields = {
      bugsBehavior: {
        enumType: exports2.TypeInfo.BugsBehavior
      },
      workingDays: {
        isArray: true,
        enumType: SystemInterfaces.TypeInfo.DayOfWeek
      }
    };
    exports2.TypeInfo.TimelineCriteriaStatus.fields = {
      type: {
        enumType: exports2.TypeInfo.TimelineCriteriaStatusCode
      }
    };
    exports2.TypeInfo.TimelineIterationStatus.fields = {
      type: {
        enumType: exports2.TypeInfo.TimelineIterationStatusCode
      }
    };
    exports2.TypeInfo.TimelineTeamData.fields = {
      iterations: {
        isArray: true,
        typeInfo: exports2.TypeInfo.TimelineTeamIteration
      },
      status: {
        typeInfo: exports2.TypeInfo.TimelineTeamStatus
      }
    };
    exports2.TypeInfo.TimelineTeamIteration.fields = {
      finishDate: {
        isDate: true
      },
      startDate: {
        isDate: true
      },
      status: {
        typeInfo: exports2.TypeInfo.TimelineIterationStatus
      }
    };
    exports2.TypeInfo.TimelineTeamStatus.fields = {
      type: {
        enumType: exports2.TypeInfo.TimelineTeamStatusCode
      }
    };
    exports2.TypeInfo.UpdatePlan.fields = {
      type: {
        enumType: exports2.TypeInfo.PlanType
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/WorkApi.js
var require_WorkApi = __commonJS({
  "../node_modules/azure-devops-node-api/WorkApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkApi = void 0;
    var basem = require_ClientApiBases();
    var WorkInterfaces = require_WorkInterfaces();
    var WorkApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Work-api", options);
      }
      /**
       * Creates/updates an automation rules settings
       *
       * @param {WorkInterfaces.TeamAutomationRulesSettingsRequestModel} ruleRequestModel - Required parameters to create/update an automation rules settings
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      updateAutomationRule(ruleRequestModel, teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "work", "2882c15d-0cb3-43b5-8fb7-db62e09a79db", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, ruleRequestModel, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets backlog configuration for a team
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      getBacklogConfigurations(teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "7799f497-3cb5-4f16-ad4f-5cd06012db64", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.BacklogConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of work items within a backlog level
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} backlogId
       */
      getBacklogLevelWorkItems(teamContext, backlogId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              backlogId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "7c468d96-ab1d-4294-a360-92f07e9ccd98", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a backlog level
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} id - The id of the backlog level
       */
      getBacklog(teamContext, id) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "a93726f9-7867-4e38-b4f2-0bfafc2f6a94", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.BacklogLevelConfiguration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * List all backlog levels
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      getBacklogs(teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "a93726f9-7867-4e38-b4f2-0bfafc2f6a94", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.BacklogLevelConfiguration, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a badge that displays the status of columns on the board.
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} id - The id of the board.
       * @param {WorkInterfaces.BoardBadgeColumnOptions} columnOptions - Determines what columns to show.
       * @param {string[]} columns - If columnOptions is set to custom, specify the list of column names.
       */
      getBoardBadge(teamContext, id, columnOptions, columns) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              id
            };
            let queryValues = {
              columnOptions,
              columns: columns && columns.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0120b002-ab6c-4ca0-98cf-a8d7492f865c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a badge that displays the status of columns on the board.
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} id - The id of the board.
       * @param {WorkInterfaces.BoardBadgeColumnOptions} columnOptions - Determines what columns to show.
       * @param {string[]} columns - If columnOptions is set to custom, specify the list of column names.
       */
      getBoardBadgeData(teamContext, id, columnOptions, columns) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              id
            };
            let queryValues = {
              columnOptions,
              columns: columns && columns.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0120b002-ab6c-4ca0-98cf-a8d7492f865c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get available board columns in a project
       *
       * @param {string} project - Project ID or project name
       */
      getColumnSuggestedValues(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "eb7ec5a3-1ba3-4fd1-b834-49a5a387e57d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the list of parent field filter model for the given list of workitem ids
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} childBacklogContextCategoryRefName
       * @param {number[]} workitemIds
       */
      getBoardMappingParentItems(teamContext, childBacklogContextCategoryRefName, workitemIds) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (childBacklogContextCategoryRefName == null) {
            throw new TypeError("childBacklogContextCategoryRefName can not be null or undefined");
          }
          if (workitemIds == null) {
            throw new TypeError("workitemIds can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            let queryValues = {
              childBacklogContextCategoryRefName,
              workitemIds: workitemIds && workitemIds.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "186abea3-5c35-432f-9e28-7a15b4312a0e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get available board rows in a project
       *
       * @param {string} project - Project ID or project name
       */
      getRowSuggestedValues(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "bb494cc6-a0f5-4c6c-8dca-ea6912e79eb9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get board
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} id - identifier for board, either board's backlog level name (Eg:"Stories") or Id
       */
      getBoard(teamContext, id) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "23ad19fc-3b8e-4877-8462-b3f92bc06b40", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.Board, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get boards
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      getBoards(teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "23ad19fc-3b8e-4877-8462-b3f92bc06b40", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update board options
       *
       * @param {{ [key: string] : string; }} options - options to updated
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} id - identifier for board, either category plural name (Eg:"Stories") or guid
       */
      setBoardOptions(options, teamContext, id) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "23ad19fc-3b8e-4877-8462-b3f92bc06b40", routeValues);
              let url = verData.requestUrl;
              let options2 = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, options2, options2);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get board user settings for a board id
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board - Board ID or Name
       */
      getBoardUserSettings(teamContext, board) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "b30d9f58-1891-4b0a-b168-c46408f919b0", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update board user settings for the board id
       *
       * @param {{ [key: string] : string; }} boardUserSettings
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board
       */
      updateBoardUserSettings(boardUserSettings, teamContext, board) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "b30d9f58-1891-4b0a-b168-c46408f919b0", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, boardUserSettings, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a team's capacity including total capacity and days off
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId - ID of the iteration
       */
      getCapacitiesWithIdentityRefAndTotals(teamContext, iterationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "work", "74412d15-8c1a-4352-a48d-ef1ed5587d57", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamCapacity, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a team member's capacity
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId - ID of the iteration
       * @param {string} teamMemberId - ID of the team member
       */
      getCapacityWithIdentityRef(teamContext, iterationId, teamMemberId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId,
              teamMemberId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "work", "74412d15-8c1a-4352-a48d-ef1ed5587d57", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamMemberCapacityIdentityRef, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Replace a team's capacity
       *
       * @param {WorkInterfaces.TeamMemberCapacityIdentityRef[]} capacities - Team capacity to replace
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId - ID of the iteration
       */
      replaceCapacitiesWithIdentityRef(capacities, teamContext, iterationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "work", "74412d15-8c1a-4352-a48d-ef1ed5587d57", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, capacities, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamMemberCapacityIdentityRef, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a team member's capacity
       *
       * @param {WorkInterfaces.CapacityPatch} patch - Updated capacity
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId - ID of the iteration
       * @param {string} teamMemberId - ID of the team member
       */
      updateCapacityWithIdentityRef(patch, teamContext, iterationId, teamMemberId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId,
              teamMemberId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.3", "work", "74412d15-8c1a-4352-a48d-ef1ed5587d57", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, patch, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamMemberCapacityIdentityRef, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get board card Rule settings for the board id or board by name
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board
       */
      getBoardCardRuleSettings(teamContext, board) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "work", "b044a3d9-02ea-49c7-91a1-b730949cc896", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update board card Rule settings for the board id or board by name
       *
       * @param {WorkInterfaces.BoardCardRuleSettings} boardCardRuleSettings
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board
       */
      updateBoardCardRuleSettings(boardCardRuleSettings, teamContext, board) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "work", "b044a3d9-02ea-49c7-91a1-b730949cc896", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, boardCardRuleSettings, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update taskboard card Rule settings
       *
       * @param {WorkInterfaces.BoardCardRuleSettings} boardCardRuleSettings
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      updateTaskboardCardRuleSettings(boardCardRuleSettings, teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "work", "3f84a8d1-1aab-423e-a94b-6dcbdcca511f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, boardCardRuleSettings, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get board card settings for the board id or board by name
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board
       */
      getBoardCardSettings(teamContext, board) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "work", "07c3b467-bc60-4f05-8e34-599ce288fafc", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update board card settings for the board id or board by name
       *
       * @param {WorkInterfaces.BoardCardSettings} boardCardSettingsToSave
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board
       */
      updateBoardCardSettings(boardCardSettingsToSave, teamContext, board) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "work", "07c3b467-bc60-4f05-8e34-599ce288fafc", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, boardCardSettingsToSave, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update taskboard card settings
       *
       * @param {WorkInterfaces.BoardCardSettings} boardCardSettingsToSave
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      updateTaskboardCardSettings(boardCardSettingsToSave, teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "work", "0d63745f-31f3-4cf3-9056-2a064e567637", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, boardCardSettingsToSave, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a board chart
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board - Identifier for board, either board's backlog level name (Eg:"Stories") or Id
       * @param {string} name - The chart name
       */
      getBoardChart(teamContext, board, name) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board,
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "45fe888c-239e-49fd-958c-df1a1ab21d97", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get board charts
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board - Identifier for board, either board's backlog level name (Eg:"Stories") or Id
       */
      getBoardCharts(teamContext, board) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "45fe888c-239e-49fd-958c-df1a1ab21d97", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a board chart
       *
       * @param {WorkInterfaces.BoardChart} chart
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board - Identifier for board, either board's backlog level name (Eg:"Stories") or Id
       * @param {string} name - The chart name
       */
      updateBoardChart(chart, teamContext, board, name) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board,
              name
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "45fe888c-239e-49fd-958c-df1a1ab21d97", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, chart, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get columns on a board
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board - Name or ID of the specific board
       */
      getBoardColumns(teamContext, board) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c555d7ff-84e1-47df-9923-a3fe0cd8751b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.BoardColumn, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update columns on a board
       *
       * @param {WorkInterfaces.BoardColumn[]} boardColumns - List of board columns to update
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board - Name or ID of the specific board
       */
      updateBoardColumns(boardColumns, teamContext, board) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c555d7ff-84e1-47df-9923-a3fe0cd8751b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, boardColumns, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.BoardColumn, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get Delivery View Data
       *
       * @param {string} project - Project ID or project name
       * @param {string} id - Identifier for delivery view
       * @param {number} revision - Revision of the plan for which you want data. If the current plan is a different revision you will get an ViewRevisionMismatchException exception. If you do not supply a revision you will get data for the latest revision.
       * @param {Date} startDate - The start date of timeline
       * @param {Date} endDate - The end date of timeline
       */
      getDeliveryTimelineData(project, id, revision, startDate, endDate) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              revision,
              startDate,
              endDate
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "bdd0834e-101f-49f0-a6ae-509f384a12b4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.DeliveryViewData, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get an iteration's capacity for all teams in iteration
       *
       * @param {string} project - Project ID or project name
       * @param {string} iterationId - ID of the iteration
       */
      getTotalIterationCapacities(project, iterationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "1e385ce0-396b-4273-8171-d64562c18d37", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a team's iteration by iterationId
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} id - ID of the iteration
       */
      deleteTeamIteration(teamContext, id) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c9175577-28a1-4b06-9197-8636af9f64ad", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get team's iteration by iterationId
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} id - ID of the iteration
       */
      getTeamIteration(teamContext, id) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c9175577-28a1-4b06-9197-8636af9f64ad", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamSettingsIteration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a team's iterations using timeframe filter
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} timeframe - A filter for which iterations are returned based on relative time. Only Current is supported currently.
       */
      getTeamIterations(teamContext, timeframe) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            let queryValues = {
              "$timeframe": timeframe
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c9175577-28a1-4b06-9197-8636af9f64ad", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamSettingsIteration, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add an iteration to the team
       *
       * @param {WorkInterfaces.TeamSettingsIteration} iteration - Iteration to add
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      postTeamIteration(iteration, teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c9175577-28a1-4b06-9197-8636af9f64ad", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, iteration, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamSettingsIteration, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add a new plan for the team
       *
       * @param {WorkInterfaces.CreatePlan} postedPlan - Plan definition
       * @param {string} project - Project ID or project name
       */
      createPlan(postedPlan, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0b42cb47-cd73-4810-ac90-19c9ba147453", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, postedPlan, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.Plan, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete the specified plan
       *
       * @param {string} project - Project ID or project name
       * @param {string} id - Identifier of the plan
       */
      deletePlan(project, id) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0b42cb47-cd73-4810-ac90-19c9ba147453", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the information for the specified plan
       *
       * @param {string} project - Project ID or project name
       * @param {string} id - Identifier of the plan
       */
      getPlan(project, id) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0b42cb47-cd73-4810-ac90-19c9ba147453", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.Plan, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the information for all the plans configured for the given team
       *
       * @param {string} project - Project ID or project name
       */
      getPlans(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0b42cb47-cd73-4810-ac90-19c9ba147453", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.Plan, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update the information for the specified plan
       *
       * @param {WorkInterfaces.UpdatePlan} updatedPlan - Plan definition to be updated
       * @param {string} project - Project ID or project name
       * @param {string} id - Identifier of the plan
       */
      updatePlan(updatedPlan, project, id) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0b42cb47-cd73-4810-ac90-19c9ba147453", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, updatedPlan, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.Plan, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get process configuration
       *
       * @param {string} project - Project ID or project name
       */
      getProcessConfiguration(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "f901ba42-86d2-4b0c-89c1-3f86d06daa84", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get rows on a board
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board - Name or ID of the specific board
       */
      getBoardRows(teamContext, board) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0863355d-aefd-4d63-8669-984c9b7b0e78", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update rows on a board
       *
       * @param {WorkInterfaces.BoardRow[]} boardRows - List of board rows to update
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} board - Name or ID of the specific board
       */
      updateBoardRows(boardRows, teamContext, board) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              board
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "0863355d-aefd-4d63-8669-984c9b7b0e78", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, boardRows, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      getColumns(teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c6815dbe-8e7e-4ffe-9a79-e83ee712aa92", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {WorkInterfaces.UpdateTaskboardColumn[]} updateColumns
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      updateColumns(updateColumns, teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c6815dbe-8e7e-4ffe-9a79-e83ee712aa92", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, updateColumns, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId
       */
      getWorkItemColumns(teamContext, iterationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "1be23c36-8872-4abc-b57d-402cd6c669d9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {WorkInterfaces.UpdateTaskboardWorkItemColumn} updateColumn
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId
       * @param {number} workItemId
       */
      updateWorkItemColumn(updateColumn, teamContext, iterationId, workItemId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId,
              workItemId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "1be23c36-8872-4abc-b57d-402cd6c669d9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateColumn, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get team's days off for an iteration
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId - ID of the iteration
       */
      getTeamDaysOff(teamContext, iterationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "2d4faa2e-9150-4cbf-a47a-932b1b4a0773", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamSettingsDaysOff, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Set a team's days off for an iteration
       *
       * @param {WorkInterfaces.TeamSettingsDaysOffPatch} daysOffPatch - Team's days off patch containing a list of start and end dates
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId - ID of the iteration
       */
      updateTeamDaysOff(daysOffPatch, teamContext, iterationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "2d4faa2e-9150-4cbf-a47a-932b1b4a0773", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, daysOffPatch, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamSettingsDaysOff, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a collection of team field values
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      getTeamFieldValues(teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "07ced576-58ed-49e6-9c1e-5cb53ab8bf2a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update team field values
       *
       * @param {WorkInterfaces.TeamFieldValuesPatch} patch
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      updateTeamFieldValues(patch, teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "07ced576-58ed-49e6-9c1e-5cb53ab8bf2a", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, patch, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a team's settings
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      getTeamSettings(teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c3c1012b-bea7-49d7-b45e-1664e566f84c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamSetting, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a team's settings
       *
       * @param {WorkInterfaces.TeamSettingsPatch} teamSettingsPatch - TeamSettings changes
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      updateTeamSettings(teamSettingsPatch, teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "c3c1012b-bea7-49d7-b45e-1664e566f84c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, teamSettingsPatch, options);
              let ret = this.formatResponse(res.result, WorkInterfaces.TypeInfo.TeamSetting, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get work items for iteration
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId - ID of the iteration
       */
      getIterationWorkItems(teamContext, iterationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "5b3ef1a6-d3ab-44cd-bafd-c7f45db850fa", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Reorder Product Backlog/Boards Work Items
       *
       * @param {WorkInterfaces.ReorderOperation} operation
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      reorderBacklogWorkItems(operation, teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "1c22b714-e7e4-41b9-85e0-56ee13ef55ed", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, operation, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Reorder Sprint Backlog/Taskboard Work Items
       *
       * @param {WorkInterfaces.ReorderOperation} operation
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} iterationId - The id of the iteration
       */
      reorderIterationWorkItems(operation, teamContext, iterationId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              iterationId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "work", "47755db2-d7eb-405a-8c25-675401525fc9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, operation, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.WorkApi = WorkApi;
    WorkApi.RESOURCE_AREA_ID = "1d4f49f9-02b9-4e26-b826-2cdb6195f2a9";
  }
});

// ../node_modules/azure-devops-node-api/interfaces/PipelinesInterfaces.js
var require_PipelinesInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/PipelinesInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.RunState = exports2.RunResult = exports2.RepositoryType = exports2.GetLogExpandOptions = exports2.GetArtifactExpandOptions = exports2.ConfigurationType = void 0;
    var VSSInterfaces = require_VSSInterfaces();
    var ConfigurationType;
    (function(ConfigurationType2) {
      ConfigurationType2[ConfigurationType2["Unknown"] = 0] = "Unknown";
      ConfigurationType2[ConfigurationType2["Yaml"] = 1] = "Yaml";
      ConfigurationType2[ConfigurationType2["DesignerJson"] = 2] = "DesignerJson";
      ConfigurationType2[ConfigurationType2["JustInTime"] = 3] = "JustInTime";
      ConfigurationType2[ConfigurationType2["DesignerHyphenJson"] = 2] = "DesignerHyphenJson";
    })(ConfigurationType = exports2.ConfigurationType || (exports2.ConfigurationType = {}));
    var GetArtifactExpandOptions;
    (function(GetArtifactExpandOptions2) {
      GetArtifactExpandOptions2[GetArtifactExpandOptions2["None"] = 0] = "None";
      GetArtifactExpandOptions2[GetArtifactExpandOptions2["SignedContent"] = 1] = "SignedContent";
    })(GetArtifactExpandOptions = exports2.GetArtifactExpandOptions || (exports2.GetArtifactExpandOptions = {}));
    var GetLogExpandOptions;
    (function(GetLogExpandOptions2) {
      GetLogExpandOptions2[GetLogExpandOptions2["None"] = 0] = "None";
      GetLogExpandOptions2[GetLogExpandOptions2["SignedContent"] = 1] = "SignedContent";
    })(GetLogExpandOptions = exports2.GetLogExpandOptions || (exports2.GetLogExpandOptions = {}));
    var RepositoryType;
    (function(RepositoryType2) {
      RepositoryType2[RepositoryType2["Unknown"] = 0] = "Unknown";
      RepositoryType2[RepositoryType2["GitHub"] = 1] = "GitHub";
      RepositoryType2[RepositoryType2["AzureReposGit"] = 2] = "AzureReposGit";
      RepositoryType2[RepositoryType2["GitHubEnterprise"] = 3] = "GitHubEnterprise";
      RepositoryType2[RepositoryType2["AzureReposGitHyphenated"] = 2] = "AzureReposGitHyphenated";
    })(RepositoryType = exports2.RepositoryType || (exports2.RepositoryType = {}));
    var RunResult;
    (function(RunResult2) {
      RunResult2[RunResult2["Unknown"] = 0] = "Unknown";
      RunResult2[RunResult2["Succeeded"] = 1] = "Succeeded";
      RunResult2[RunResult2["Failed"] = 2] = "Failed";
      RunResult2[RunResult2["Canceled"] = 4] = "Canceled";
    })(RunResult = exports2.RunResult || (exports2.RunResult = {}));
    var RunState;
    (function(RunState2) {
      RunState2[RunState2["Unknown"] = 0] = "Unknown";
      RunState2[RunState2["InProgress"] = 1] = "InProgress";
      RunState2[RunState2["Canceling"] = 2] = "Canceling";
      RunState2[RunState2["Completed"] = 4] = "Completed";
    })(RunState = exports2.RunState || (exports2.RunState = {}));
    exports2.TypeInfo = {
      Artifact: {},
      ConfigurationType: {
        enumValues: {
          "unknown": 0,
          "yaml": 1,
          "designerJson": 2,
          "justInTime": 3,
          "designerHyphenJson": 2
        }
      },
      CreatePipelineConfigurationParameters: {},
      CreatePipelineParameters: {},
      GetArtifactExpandOptions: {
        enumValues: {
          "none": 0,
          "signedContent": 1
        }
      },
      GetLogExpandOptions: {
        enumValues: {
          "none": 0,
          "signedContent": 1
        }
      },
      Log: {},
      LogCollection: {},
      Pipeline: {},
      PipelineConfiguration: {},
      Repository: {},
      RepositoryResource: {},
      RepositoryType: {
        enumValues: {
          "unknown": 0,
          "gitHub": 1,
          "azureReposGit": 2,
          "gitHubEnterprise": 3,
          "azureReposGitHyphenated": 2
        }
      },
      Run: {},
      RunResources: {},
      RunResult: {
        enumValues: {
          "unknown": 0,
          "succeeded": 1,
          "failed": 2,
          "canceled": 4
        }
      },
      RunState: {
        enumValues: {
          "unknown": 0,
          "inProgress": 1,
          "canceling": 2,
          "completed": 4
        }
      },
      SignalRConnection: {}
    };
    exports2.TypeInfo.Artifact.fields = {
      signedContent: {
        typeInfo: VSSInterfaces.TypeInfo.SignedUrl
      }
    };
    exports2.TypeInfo.CreatePipelineConfigurationParameters.fields = {
      type: {
        enumType: exports2.TypeInfo.ConfigurationType
      }
    };
    exports2.TypeInfo.CreatePipelineParameters.fields = {
      configuration: {
        typeInfo: exports2.TypeInfo.CreatePipelineConfigurationParameters
      }
    };
    exports2.TypeInfo.Log.fields = {
      createdOn: {
        isDate: true
      },
      lastChangedOn: {
        isDate: true
      },
      signedContent: {
        typeInfo: VSSInterfaces.TypeInfo.SignedUrl
      }
    };
    exports2.TypeInfo.LogCollection.fields = {
      logs: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Log
      },
      signedContent: {
        typeInfo: VSSInterfaces.TypeInfo.SignedUrl
      }
    };
    exports2.TypeInfo.Pipeline.fields = {
      configuration: {
        typeInfo: exports2.TypeInfo.PipelineConfiguration
      }
    };
    exports2.TypeInfo.PipelineConfiguration.fields = {
      type: {
        enumType: exports2.TypeInfo.ConfigurationType
      }
    };
    exports2.TypeInfo.Repository.fields = {
      type: {
        enumType: exports2.TypeInfo.RepositoryType
      }
    };
    exports2.TypeInfo.RepositoryResource.fields = {
      repository: {
        typeInfo: exports2.TypeInfo.Repository
      }
    };
    exports2.TypeInfo.Run.fields = {
      createdDate: {
        isDate: true
      },
      finishedDate: {
        isDate: true
      },
      resources: {
        typeInfo: exports2.TypeInfo.RunResources
      },
      result: {
        enumType: exports2.TypeInfo.RunResult
      },
      state: {
        enumType: exports2.TypeInfo.RunState
      }
    };
    exports2.TypeInfo.RunResources.fields = {
      repositories: {
        isDictionary: true,
        dictionaryValueTypeInfo: exports2.TypeInfo.RepositoryResource
      }
    };
    exports2.TypeInfo.SignalRConnection.fields = {
      signedContent: {
        typeInfo: VSSInterfaces.TypeInfo.SignedUrl
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/PipelinesApi.js
var require_PipelinesApi = __commonJS({
  "../node_modules/azure-devops-node-api/PipelinesApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PipelinesApi = void 0;
    var basem = require_ClientApiBases();
    var PipelinesInterfaces = require_PipelinesInterfaces();
    var PipelinesApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Pipelines-api", options);
      }
      /**
       * Get a specific artifact from a pipeline run
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - ID of the pipeline.
       * @param {number} runId - ID of the run of that pipeline.
       * @param {string} artifactName - Name of the artifact.
       * @param {PipelinesInterfaces.GetArtifactExpandOptions} expand - Expand options. Default is None.
       */
      getArtifact(project, pipelineId, runId, artifactName, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (artifactName == null) {
            throw new TypeError("artifactName can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pipelineId,
              runId
            };
            let queryValues = {
              artifactName,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "85023071-bd5e-4438-89b0-2a5bf362a19d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.Artifact, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a specific log from a pipeline run
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - ID of the pipeline.
       * @param {number} runId - ID of the run of that pipeline.
       * @param {number} logId - ID of the log.
       * @param {PipelinesInterfaces.GetLogExpandOptions} expand - Expand options. Default is None.
       */
      getLog(project, pipelineId, runId, logId, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pipelineId,
              runId,
              logId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "fb1b6d27-3957-43d5-a14b-a2d70403e545", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.Log, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of logs from a pipeline run.
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - ID of the pipeline.
       * @param {number} runId - ID of the run of that pipeline.
       * @param {PipelinesInterfaces.GetLogExpandOptions} expand - Expand options. Default is None.
       */
      listLogs(project, pipelineId, runId, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pipelineId,
              runId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "fb1b6d27-3957-43d5-a14b-a2d70403e545", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.LogCollection, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a pipeline.
       *
       * @param {PipelinesInterfaces.CreatePipelineParameters} inputParameters - Input parameters.
       * @param {string} project - Project ID or project name
       */
      createPipeline(inputParameters, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "28e1305e-2afe-47bf-abaf-cbb0e6a91988", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, inputParameters, options);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.Pipeline, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a pipeline, optionally at the specified version
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - The pipeline ID
       * @param {number} pipelineVersion - The pipeline version
       */
      getPipeline(project, pipelineId, pipelineVersion) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pipelineId
            };
            let queryValues = {
              pipelineVersion
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "28e1305e-2afe-47bf-abaf-cbb0e6a91988", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.Pipeline, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of pipelines.
       *
       * @param {string} project - Project ID or project name
       * @param {string} orderBy - A sort expression. Defaults to "name asc"
       * @param {number} top - The maximum number of pipelines to return
       * @param {string} continuationToken - A continuation token from a previous request, to retrieve the next page of results
       */
      listPipelines(project, orderBy, top, continuationToken) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              orderBy,
              "$top": top,
              continuationToken
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "28e1305e-2afe-47bf-abaf-cbb0e6a91988", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.Pipeline, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Queues a dry run of the pipeline and returns an object containing the final yaml.
       *
       * @param {PipelinesInterfaces.RunPipelineParameters} runParameters - Optional additional parameters for this run.
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - The pipeline ID.
       * @param {number} pipelineVersion - The pipeline version.
       */
      preview(runParameters, project, pipelineId, pipelineVersion) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pipelineId
            };
            let queryValues = {
              pipelineVersion
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "53df2d18-29ea-46a9-bee0-933540f80abf", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, runParameters, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a run for a particular pipeline.
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - The pipeline id
       * @param {number} runId - The run id
       */
      getRun(project, pipelineId, runId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pipelineId,
              runId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "7859261e-d2e9-4a68-b820-a5d84cc5bb3d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.Run, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets top 10000 runs for a particular pipeline.
       *
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - The pipeline id
       */
      listRuns(project, pipelineId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pipelineId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "7859261e-d2e9-4a68-b820-a5d84cc5bb3d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.Run, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Runs a pipeline.
       *
       * @param {PipelinesInterfaces.RunPipelineParameters} runParameters - Optional additional parameters for this run.
       * @param {string} project - Project ID or project name
       * @param {number} pipelineId - The pipeline ID.
       * @param {number} pipelineVersion - The pipeline version.
       */
      runPipeline(runParameters, project, pipelineId, pipelineVersion) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              pipelineId
            };
            let queryValues = {
              pipelineVersion
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "7859261e-d2e9-4a68-b820-a5d84cc5bb3d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, runParameters, options);
              let ret = this.formatResponse(res.result, PipelinesInterfaces.TypeInfo.Run, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.PipelinesApi = PipelinesApi;
  }
});

// ../node_modules/azure-devops-node-api/CIXApi.js
var require_CIXApi = __commonJS({
  "../node_modules/azure-devops-node-api/CIXApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.CixApi = void 0;
    var basem = require_ClientApiBases();
    var CixApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-Pipelines-api", options);
      }
      /**
       * Gets a list of existing configuration files for the given repository.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryType - The type of the repository such as GitHub, TfsGit (i.e. Azure Repos), Bitbucket, etc.
       * @param {string} repositoryId - The vendor-specific identifier or the name of the repository, e.g. Microsoft/vscode (GitHub) or e9d82045-ddba-4e01-a63d-2ab9f040af62 (Azure Repos)
       * @param {string} branch - The repository branch where to look for the configuration file.
       * @param {string} serviceConnectionId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TfsGit (i.e. Azure Repos).
       */
      getConfigurations(project, repositoryType, repositoryId, branch, serviceConnectionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              repositoryType,
              repositoryId,
              branch,
              serviceConnectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "8fc87684-9ebc-4c37-ab92-f4ac4a58cb3a", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a new Pipeline connection between the provider installation and the specified project. Returns the PipelineConnection object created.
       *
       * @param {CIXInterfaces.CreatePipelineConnectionInputs} createConnectionInputs
       * @param {string} project
       */
      createProjectConnection(createConnectionInputs, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (project == null) {
            throw new TypeError("project can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "00df4879-9216-45d5-b38d-4a487b626b2c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, createConnectionInputs, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of build frameworks that best match the given repository based on its contents.
       *
       * @param {string} project - Project ID or project name
       * @param {string} repositoryType - The type of the repository such as GitHub, TfsGit (i.e. Azure Repos), Bitbucket, etc.
       * @param {string} repositoryId - The vendor-specific identifier or the name of the repository, e.g. Microsoft/vscode (GitHub) or e9d82045-ddba-4e01-a63d-2ab9f040af62 (Azure Repos)
       * @param {string} branch - The repository branch to detect build frameworks for.
       * @param {CIXInterfaces.BuildFrameworkDetectionType} detectionType
       * @param {string} serviceConnectionId - If specified, the ID of the service endpoint to query. Can only be omitted for providers that do not use service endpoints, e.g. TfsGit (i.e. Azure Repos).
       */
      getDetectedBuildFrameworks(project, repositoryType, repositoryId, branch, detectionType, serviceConnectionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              repositoryType,
              repositoryId,
              branch,
              detectionType,
              serviceConnectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "29a30bab-9efb-4652-bf1b-9269baca0980", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {{ [key: string] : CIXInterfaces.ResourceCreationParameter; }} creationParameters
       * @param {string} project - Project ID or project name
       */
      createResources(creationParameters, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "pipelines", "43201899-7690-4870-9c79-ab69605f21ed", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, creationParameters, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.CixApi = CixApi;
  }
});

// ../node_modules/azure-devops-node-api/interfaces/WorkItemTrackingInterfaces.js
var require_WorkItemTrackingInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/WorkItemTrackingInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.WorkItemTypeFieldsExpandLevel = exports2.WorkItemRecentActivityType = exports2.WorkItemExpand = exports2.WorkItemErrorPolicy = exports2.TreeStructureGroup = exports2.TreeNodeStructureType = exports2.TemplateType = exports2.ReportingRevisionsExpand = exports2.QueryType = exports2.QueryResultType = exports2.QueryRecursionOption = exports2.QueryOption = exports2.QueryExpand = exports2.QueryErrorPolicy = exports2.ProvisioningActionType = exports2.LogicalOperation = exports2.LinkQueryMode = exports2.GetFieldsExpand = exports2.FieldUsage = exports2.FieldType = exports2.CommentSortOrder = exports2.CommentReactionType = exports2.CommentFormat = exports2.CommentExpandOptions = exports2.ClassificationNodesErrorPolicy = void 0;
    var ClassificationNodesErrorPolicy;
    (function(ClassificationNodesErrorPolicy2) {
      ClassificationNodesErrorPolicy2[ClassificationNodesErrorPolicy2["Fail"] = 1] = "Fail";
      ClassificationNodesErrorPolicy2[ClassificationNodesErrorPolicy2["Omit"] = 2] = "Omit";
    })(ClassificationNodesErrorPolicy = exports2.ClassificationNodesErrorPolicy || (exports2.ClassificationNodesErrorPolicy = {}));
    var CommentExpandOptions;
    (function(CommentExpandOptions2) {
      CommentExpandOptions2[CommentExpandOptions2["None"] = 0] = "None";
      CommentExpandOptions2[CommentExpandOptions2["Reactions"] = 1] = "Reactions";
      CommentExpandOptions2[CommentExpandOptions2["RenderedText"] = 8] = "RenderedText";
      CommentExpandOptions2[CommentExpandOptions2["RenderedTextOnly"] = 16] = "RenderedTextOnly";
      CommentExpandOptions2[CommentExpandOptions2["All"] = -17] = "All";
    })(CommentExpandOptions = exports2.CommentExpandOptions || (exports2.CommentExpandOptions = {}));
    var CommentFormat;
    (function(CommentFormat2) {
      CommentFormat2[CommentFormat2["Markdown"] = 0] = "Markdown";
      CommentFormat2[CommentFormat2["Html"] = 1] = "Html";
    })(CommentFormat = exports2.CommentFormat || (exports2.CommentFormat = {}));
    var CommentReactionType;
    (function(CommentReactionType2) {
      CommentReactionType2[CommentReactionType2["Like"] = 0] = "Like";
      CommentReactionType2[CommentReactionType2["Dislike"] = 1] = "Dislike";
      CommentReactionType2[CommentReactionType2["Heart"] = 2] = "Heart";
      CommentReactionType2[CommentReactionType2["Hooray"] = 3] = "Hooray";
      CommentReactionType2[CommentReactionType2["Smile"] = 4] = "Smile";
      CommentReactionType2[CommentReactionType2["Confused"] = 5] = "Confused";
    })(CommentReactionType = exports2.CommentReactionType || (exports2.CommentReactionType = {}));
    var CommentSortOrder;
    (function(CommentSortOrder2) {
      CommentSortOrder2[CommentSortOrder2["Asc"] = 1] = "Asc";
      CommentSortOrder2[CommentSortOrder2["Desc"] = 2] = "Desc";
    })(CommentSortOrder = exports2.CommentSortOrder || (exports2.CommentSortOrder = {}));
    var FieldType;
    (function(FieldType2) {
      FieldType2[FieldType2["String"] = 0] = "String";
      FieldType2[FieldType2["Integer"] = 1] = "Integer";
      FieldType2[FieldType2["DateTime"] = 2] = "DateTime";
      FieldType2[FieldType2["PlainText"] = 3] = "PlainText";
      FieldType2[FieldType2["Html"] = 4] = "Html";
      FieldType2[FieldType2["TreePath"] = 5] = "TreePath";
      FieldType2[FieldType2["History"] = 6] = "History";
      FieldType2[FieldType2["Double"] = 7] = "Double";
      FieldType2[FieldType2["Guid"] = 8] = "Guid";
      FieldType2[FieldType2["Boolean"] = 9] = "Boolean";
      FieldType2[FieldType2["Identity"] = 10] = "Identity";
      FieldType2[FieldType2["PicklistString"] = 11] = "PicklistString";
      FieldType2[FieldType2["PicklistInteger"] = 12] = "PicklistInteger";
      FieldType2[FieldType2["PicklistDouble"] = 13] = "PicklistDouble";
    })(FieldType = exports2.FieldType || (exports2.FieldType = {}));
    var FieldUsage;
    (function(FieldUsage2) {
      FieldUsage2[FieldUsage2["None"] = 0] = "None";
      FieldUsage2[FieldUsage2["WorkItem"] = 1] = "WorkItem";
      FieldUsage2[FieldUsage2["WorkItemLink"] = 2] = "WorkItemLink";
      FieldUsage2[FieldUsage2["Tree"] = 3] = "Tree";
      FieldUsage2[FieldUsage2["WorkItemTypeExtension"] = 4] = "WorkItemTypeExtension";
    })(FieldUsage = exports2.FieldUsage || (exports2.FieldUsage = {}));
    var GetFieldsExpand;
    (function(GetFieldsExpand2) {
      GetFieldsExpand2[GetFieldsExpand2["None"] = 0] = "None";
      GetFieldsExpand2[GetFieldsExpand2["ExtensionFields"] = 1] = "ExtensionFields";
      GetFieldsExpand2[GetFieldsExpand2["IncludeDeleted"] = 2] = "IncludeDeleted";
    })(GetFieldsExpand = exports2.GetFieldsExpand || (exports2.GetFieldsExpand = {}));
    var LinkQueryMode;
    (function(LinkQueryMode2) {
      LinkQueryMode2[LinkQueryMode2["WorkItems"] = 0] = "WorkItems";
      LinkQueryMode2[LinkQueryMode2["LinksOneHopMustContain"] = 1] = "LinksOneHopMustContain";
      LinkQueryMode2[LinkQueryMode2["LinksOneHopMayContain"] = 2] = "LinksOneHopMayContain";
      LinkQueryMode2[LinkQueryMode2["LinksOneHopDoesNotContain"] = 3] = "LinksOneHopDoesNotContain";
      LinkQueryMode2[LinkQueryMode2["LinksRecursiveMustContain"] = 4] = "LinksRecursiveMustContain";
      LinkQueryMode2[LinkQueryMode2["LinksRecursiveMayContain"] = 5] = "LinksRecursiveMayContain";
      LinkQueryMode2[LinkQueryMode2["LinksRecursiveDoesNotContain"] = 6] = "LinksRecursiveDoesNotContain";
    })(LinkQueryMode = exports2.LinkQueryMode || (exports2.LinkQueryMode = {}));
    var LogicalOperation;
    (function(LogicalOperation2) {
      LogicalOperation2[LogicalOperation2["NONE"] = 0] = "NONE";
      LogicalOperation2[LogicalOperation2["AND"] = 1] = "AND";
      LogicalOperation2[LogicalOperation2["OR"] = 2] = "OR";
    })(LogicalOperation = exports2.LogicalOperation || (exports2.LogicalOperation = {}));
    var ProvisioningActionType;
    (function(ProvisioningActionType2) {
      ProvisioningActionType2[ProvisioningActionType2["Import"] = 0] = "Import";
      ProvisioningActionType2[ProvisioningActionType2["Validate"] = 1] = "Validate";
    })(ProvisioningActionType = exports2.ProvisioningActionType || (exports2.ProvisioningActionType = {}));
    var QueryErrorPolicy;
    (function(QueryErrorPolicy2) {
      QueryErrorPolicy2[QueryErrorPolicy2["Fail"] = 1] = "Fail";
      QueryErrorPolicy2[QueryErrorPolicy2["Omit"] = 2] = "Omit";
    })(QueryErrorPolicy = exports2.QueryErrorPolicy || (exports2.QueryErrorPolicy = {}));
    var QueryExpand;
    (function(QueryExpand2) {
      QueryExpand2[QueryExpand2["None"] = 0] = "None";
      QueryExpand2[QueryExpand2["Wiql"] = 1] = "Wiql";
      QueryExpand2[QueryExpand2["Clauses"] = 2] = "Clauses";
      QueryExpand2[QueryExpand2["All"] = 3] = "All";
      QueryExpand2[QueryExpand2["Minimal"] = 4] = "Minimal";
    })(QueryExpand = exports2.QueryExpand || (exports2.QueryExpand = {}));
    var QueryOption;
    (function(QueryOption2) {
      QueryOption2[QueryOption2["Doing"] = 1] = "Doing";
      QueryOption2[QueryOption2["Done"] = 2] = "Done";
      QueryOption2[QueryOption2["Followed"] = 3] = "Followed";
    })(QueryOption = exports2.QueryOption || (exports2.QueryOption = {}));
    var QueryRecursionOption;
    (function(QueryRecursionOption2) {
      QueryRecursionOption2[QueryRecursionOption2["ParentFirst"] = 0] = "ParentFirst";
      QueryRecursionOption2[QueryRecursionOption2["ChildFirst"] = 1] = "ChildFirst";
    })(QueryRecursionOption = exports2.QueryRecursionOption || (exports2.QueryRecursionOption = {}));
    var QueryResultType;
    (function(QueryResultType2) {
      QueryResultType2[QueryResultType2["WorkItem"] = 1] = "WorkItem";
      QueryResultType2[QueryResultType2["WorkItemLink"] = 2] = "WorkItemLink";
    })(QueryResultType = exports2.QueryResultType || (exports2.QueryResultType = {}));
    var QueryType;
    (function(QueryType2) {
      QueryType2[QueryType2["Flat"] = 1] = "Flat";
      QueryType2[QueryType2["Tree"] = 2] = "Tree";
      QueryType2[QueryType2["OneHop"] = 3] = "OneHop";
    })(QueryType = exports2.QueryType || (exports2.QueryType = {}));
    var ReportingRevisionsExpand;
    (function(ReportingRevisionsExpand2) {
      ReportingRevisionsExpand2[ReportingRevisionsExpand2["None"] = 0] = "None";
      ReportingRevisionsExpand2[ReportingRevisionsExpand2["Fields"] = 1] = "Fields";
    })(ReportingRevisionsExpand = exports2.ReportingRevisionsExpand || (exports2.ReportingRevisionsExpand = {}));
    var TemplateType;
    (function(TemplateType2) {
      TemplateType2[TemplateType2["WorkItemType"] = 0] = "WorkItemType";
      TemplateType2[TemplateType2["GlobalWorkflow"] = 1] = "GlobalWorkflow";
    })(TemplateType = exports2.TemplateType || (exports2.TemplateType = {}));
    var TreeNodeStructureType;
    (function(TreeNodeStructureType2) {
      TreeNodeStructureType2[TreeNodeStructureType2["Area"] = 0] = "Area";
      TreeNodeStructureType2[TreeNodeStructureType2["Iteration"] = 1] = "Iteration";
    })(TreeNodeStructureType = exports2.TreeNodeStructureType || (exports2.TreeNodeStructureType = {}));
    var TreeStructureGroup;
    (function(TreeStructureGroup2) {
      TreeStructureGroup2[TreeStructureGroup2["Areas"] = 0] = "Areas";
      TreeStructureGroup2[TreeStructureGroup2["Iterations"] = 1] = "Iterations";
    })(TreeStructureGroup = exports2.TreeStructureGroup || (exports2.TreeStructureGroup = {}));
    var WorkItemErrorPolicy;
    (function(WorkItemErrorPolicy2) {
      WorkItemErrorPolicy2[WorkItemErrorPolicy2["Fail"] = 1] = "Fail";
      WorkItemErrorPolicy2[WorkItemErrorPolicy2["Omit"] = 2] = "Omit";
    })(WorkItemErrorPolicy = exports2.WorkItemErrorPolicy || (exports2.WorkItemErrorPolicy = {}));
    var WorkItemExpand;
    (function(WorkItemExpand2) {
      WorkItemExpand2[WorkItemExpand2["None"] = 0] = "None";
      WorkItemExpand2[WorkItemExpand2["Relations"] = 1] = "Relations";
      WorkItemExpand2[WorkItemExpand2["Fields"] = 2] = "Fields";
      WorkItemExpand2[WorkItemExpand2["Links"] = 3] = "Links";
      WorkItemExpand2[WorkItemExpand2["All"] = 4] = "All";
    })(WorkItemExpand = exports2.WorkItemExpand || (exports2.WorkItemExpand = {}));
    var WorkItemRecentActivityType;
    (function(WorkItemRecentActivityType2) {
      WorkItemRecentActivityType2[WorkItemRecentActivityType2["Visited"] = 0] = "Visited";
      WorkItemRecentActivityType2[WorkItemRecentActivityType2["Edited"] = 1] = "Edited";
      WorkItemRecentActivityType2[WorkItemRecentActivityType2["Deleted"] = 2] = "Deleted";
      WorkItemRecentActivityType2[WorkItemRecentActivityType2["Restored"] = 3] = "Restored";
    })(WorkItemRecentActivityType = exports2.WorkItemRecentActivityType || (exports2.WorkItemRecentActivityType = {}));
    var WorkItemTypeFieldsExpandLevel;
    (function(WorkItemTypeFieldsExpandLevel2) {
      WorkItemTypeFieldsExpandLevel2[WorkItemTypeFieldsExpandLevel2["None"] = 0] = "None";
      WorkItemTypeFieldsExpandLevel2[WorkItemTypeFieldsExpandLevel2["AllowedValues"] = 1] = "AllowedValues";
      WorkItemTypeFieldsExpandLevel2[WorkItemTypeFieldsExpandLevel2["DependentFields"] = 2] = "DependentFields";
      WorkItemTypeFieldsExpandLevel2[WorkItemTypeFieldsExpandLevel2["All"] = 3] = "All";
    })(WorkItemTypeFieldsExpandLevel = exports2.WorkItemTypeFieldsExpandLevel || (exports2.WorkItemTypeFieldsExpandLevel = {}));
    exports2.TypeInfo = {
      AccountMyWorkResult: {},
      AccountRecentActivityWorkItemModel: {},
      AccountRecentActivityWorkItemModel2: {},
      AccountRecentActivityWorkItemModelBase: {},
      AccountRecentMentionWorkItemModel: {},
      AccountWorkWorkItemModel: {},
      ClassificationNodesErrorPolicy: {
        enumValues: {
          "fail": 1,
          "omit": 2
        }
      },
      Comment: {},
      CommentExpandOptions: {
        enumValues: {
          "none": 0,
          "reactions": 1,
          "renderedText": 8,
          "renderedTextOnly": 16,
          "all": -17
        }
      },
      CommentFormat: {
        enumValues: {
          "markdown": 0,
          "html": 1
        }
      },
      CommentList: {},
      CommentReaction: {},
      CommentReactionType: {
        enumValues: {
          "like": 0,
          "dislike": 1,
          "heart": 2,
          "hooray": 3,
          "smile": 4,
          "confused": 5
        }
      },
      CommentSortOrder: {
        enumValues: {
          "asc": 1,
          "desc": 2
        }
      },
      CommentVersion: {},
      ExternalDeployment: {},
      FieldType: {
        enumValues: {
          "string": 0,
          "integer": 1,
          "dateTime": 2,
          "plainText": 3,
          "html": 4,
          "treePath": 5,
          "history": 6,
          "double": 7,
          "guid": 8,
          "boolean": 9,
          "identity": 10,
          "picklistString": 11,
          "picklistInteger": 12,
          "picklistDouble": 13
        }
      },
      FieldUsage: {
        enumValues: {
          "none": 0,
          "workItem": 1,
          "workItemLink": 2,
          "tree": 3,
          "workItemTypeExtension": 4
        }
      },
      GetFieldsExpand: {
        enumValues: {
          "none": 0,
          "extensionFields": 1,
          "includeDeleted": 2
        }
      },
      LinkQueryMode: {
        enumValues: {
          "workItems": 0,
          "linksOneHopMustContain": 1,
          "linksOneHopMayContain": 2,
          "linksOneHopDoesNotContain": 3,
          "linksRecursiveMustContain": 4,
          "linksRecursiveMayContain": 5,
          "linksRecursiveDoesNotContain": 6
        }
      },
      LogicalOperation: {
        enumValues: {
          "none": 0,
          "and": 1,
          "or": 2
        }
      },
      ProvisioningActionType: {
        enumValues: {
          "import": 0,
          "validate": 1
        }
      },
      QueryBatchGetRequest: {},
      QueryErrorPolicy: {
        enumValues: {
          "fail": 1,
          "omit": 2
        }
      },
      QueryExpand: {
        enumValues: {
          "none": 0,
          "wiql": 1,
          "clauses": 2,
          "all": 3,
          "minimal": 4
        }
      },
      QueryHierarchyItem: {},
      QueryHierarchyItemsResult: {},
      QueryOption: {
        enumValues: {
          "doing": 1,
          "done": 2,
          "followed": 3
        }
      },
      QueryRecursionOption: {
        enumValues: {
          "parentFirst": 0,
          "childFirst": 1
        }
      },
      QueryResultType: {
        enumValues: {
          "workItem": 1,
          "workItemLink": 2
        }
      },
      QueryType: {
        enumValues: {
          "flat": 1,
          "tree": 2,
          "oneHop": 3
        }
      },
      ReportingRevisionsExpand: {
        enumValues: {
          "none": 0,
          "fields": 1
        }
      },
      TemplateType: {
        enumValues: {
          "workItemType": 0,
          "globalWorkflow": 1
        }
      },
      TreeNodeStructureType: {
        enumValues: {
          "area": 0,
          "iteration": 1
        }
      },
      TreeStructureGroup: {
        enumValues: {
          "areas": 0,
          "iterations": 1
        }
      },
      WorkItemBatchGetRequest: {},
      WorkItemClassificationNode: {},
      WorkItemComment: {},
      WorkItemComments: {},
      WorkItemErrorPolicy: {
        enumValues: {
          "fail": 1,
          "omit": 2
        }
      },
      WorkItemExpand: {
        enumValues: {
          "none": 0,
          "relations": 1,
          "fields": 2,
          "links": 3,
          "all": 4
        }
      },
      WorkItemField: {},
      WorkItemField2: {},
      WorkItemHistory: {},
      WorkItemQueryClause: {},
      WorkItemQueryResult: {},
      WorkItemRecentActivityType: {
        enumValues: {
          "visited": 0,
          "edited": 1,
          "deleted": 2,
          "restored": 3
        }
      },
      WorkItemTagDefinition: {},
      WorkItemTypeFieldsExpandLevel: {
        enumValues: {
          "none": 0,
          "allowedValues": 1,
          "dependentFields": 2,
          "all": 3
        }
      },
      WorkItemTypeTemplateUpdateModel: {},
      WorkItemUpdate: {}
    };
    exports2.TypeInfo.AccountMyWorkResult.fields = {
      workItemDetails: {
        isArray: true,
        typeInfo: exports2.TypeInfo.AccountWorkWorkItemModel
      }
    };
    exports2.TypeInfo.AccountRecentActivityWorkItemModel.fields = {
      activityDate: {
        isDate: true
      },
      activityType: {
        enumType: exports2.TypeInfo.WorkItemRecentActivityType
      },
      changedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.AccountRecentActivityWorkItemModel2.fields = {
      activityDate: {
        isDate: true
      },
      activityType: {
        enumType: exports2.TypeInfo.WorkItemRecentActivityType
      },
      changedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.AccountRecentActivityWorkItemModelBase.fields = {
      activityDate: {
        isDate: true
      },
      activityType: {
        enumType: exports2.TypeInfo.WorkItemRecentActivityType
      },
      changedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.AccountRecentMentionWorkItemModel.fields = {
      mentionedDateField: {
        isDate: true
      }
    };
    exports2.TypeInfo.AccountWorkWorkItemModel.fields = {
      changedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.Comment.fields = {
      createdDate: {
        isDate: true
      },
      createdOnBehalfDate: {
        isDate: true
      },
      format: {
        enumType: exports2.TypeInfo.CommentFormat
      },
      modifiedDate: {
        isDate: true
      },
      reactions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.CommentReaction
      }
    };
    exports2.TypeInfo.CommentList.fields = {
      comments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Comment
      }
    };
    exports2.TypeInfo.CommentReaction.fields = {
      type: {
        enumType: exports2.TypeInfo.CommentReactionType
      }
    };
    exports2.TypeInfo.CommentVersion.fields = {
      createdDate: {
        isDate: true
      },
      createdOnBehalfDate: {
        isDate: true
      },
      modifiedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.ExternalDeployment.fields = {
      statusDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.QueryBatchGetRequest.fields = {
      $expand: {
        enumType: exports2.TypeInfo.QueryExpand
      },
      errorPolicy: {
        enumType: exports2.TypeInfo.QueryErrorPolicy
      }
    };
    exports2.TypeInfo.QueryHierarchyItem.fields = {
      children: {
        isArray: true,
        typeInfo: exports2.TypeInfo.QueryHierarchyItem
      },
      clauses: {
        typeInfo: exports2.TypeInfo.WorkItemQueryClause
      },
      createdDate: {
        isDate: true
      },
      filterOptions: {
        enumType: exports2.TypeInfo.LinkQueryMode
      },
      lastExecutedDate: {
        isDate: true
      },
      lastModifiedDate: {
        isDate: true
      },
      linkClauses: {
        typeInfo: exports2.TypeInfo.WorkItemQueryClause
      },
      queryRecursionOption: {
        enumType: exports2.TypeInfo.QueryRecursionOption
      },
      queryType: {
        enumType: exports2.TypeInfo.QueryType
      },
      sourceClauses: {
        typeInfo: exports2.TypeInfo.WorkItemQueryClause
      },
      targetClauses: {
        typeInfo: exports2.TypeInfo.WorkItemQueryClause
      }
    };
    exports2.TypeInfo.QueryHierarchyItemsResult.fields = {
      value: {
        isArray: true,
        typeInfo: exports2.TypeInfo.QueryHierarchyItem
      }
    };
    exports2.TypeInfo.WorkItemBatchGetRequest.fields = {
      $expand: {
        enumType: exports2.TypeInfo.WorkItemExpand
      },
      asOf: {
        isDate: true
      },
      errorPolicy: {
        enumType: exports2.TypeInfo.WorkItemErrorPolicy
      }
    };
    exports2.TypeInfo.WorkItemClassificationNode.fields = {
      children: {
        isArray: true,
        typeInfo: exports2.TypeInfo.WorkItemClassificationNode
      },
      structureType: {
        enumType: exports2.TypeInfo.TreeNodeStructureType
      }
    };
    exports2.TypeInfo.WorkItemComment.fields = {
      format: {
        enumType: exports2.TypeInfo.CommentFormat
      },
      revisedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.WorkItemComments.fields = {
      comments: {
        isArray: true,
        typeInfo: exports2.TypeInfo.WorkItemComment
      }
    };
    exports2.TypeInfo.WorkItemField.fields = {
      type: {
        enumType: exports2.TypeInfo.FieldType
      },
      usage: {
        enumType: exports2.TypeInfo.FieldUsage
      }
    };
    exports2.TypeInfo.WorkItemField2.fields = {
      type: {
        enumType: exports2.TypeInfo.FieldType
      },
      usage: {
        enumType: exports2.TypeInfo.FieldUsage
      }
    };
    exports2.TypeInfo.WorkItemHistory.fields = {
      revisedDate: {
        isDate: true
      }
    };
    exports2.TypeInfo.WorkItemQueryClause.fields = {
      clauses: {
        isArray: true,
        typeInfo: exports2.TypeInfo.WorkItemQueryClause
      },
      logicalOperator: {
        enumType: exports2.TypeInfo.LogicalOperation
      }
    };
    exports2.TypeInfo.WorkItemQueryResult.fields = {
      asOf: {
        isDate: true
      },
      queryResultType: {
        enumType: exports2.TypeInfo.QueryResultType
      },
      queryType: {
        enumType: exports2.TypeInfo.QueryType
      }
    };
    exports2.TypeInfo.WorkItemTagDefinition.fields = {
      lastUpdated: {
        isDate: true
      }
    };
    exports2.TypeInfo.WorkItemTypeTemplateUpdateModel.fields = {
      actionType: {
        enumType: exports2.TypeInfo.ProvisioningActionType
      },
      templateType: {
        enumType: exports2.TypeInfo.TemplateType
      }
    };
    exports2.TypeInfo.WorkItemUpdate.fields = {
      revisedDate: {
        isDate: true
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/WorkItemTrackingApi.js
var require_WorkItemTrackingApi = __commonJS({
  "../node_modules/azure-devops-node-api/WorkItemTrackingApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkItemTrackingApi = void 0;
    var basem = require_ClientApiBases();
    var WorkItemTrackingInterfaces = require_WorkItemTrackingInterfaces();
    var WorkItemTrackingApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-WorkItemTracking-api", options);
      }
      /**
       * INTERNAL ONLY: USED BY ACCOUNT MY WORK PAGE. This returns Doing, Done, Follows and activity work items details.
       *
       * @param {WorkItemTrackingInterfaces.QueryOption} queryOption
       */
      getAccountMyWorkData(queryOption) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$queryOption": queryOption
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "def3d688-ddf5-4096-9024-69beea15cdbd", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.AccountMyWorkResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets recent work item activities
       *
       */
      getRecentActivityData() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "1bc988f4-c15f-4072-ad35-497c87e3a909", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.AccountRecentActivityWorkItemModel2, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * INTERNAL ONLY: USED BY ACCOUNT MY WORK PAGE.
       *
       */
      getRecentMentions() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "d60eeb6e-e18c-4478-9e94-a0094e28f41c", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.AccountRecentMentionWorkItemModel, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get the list of work item tracking outbound artifact link types.
       *
       */
      getWorkArtifactLinkTypes() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "1a31de40-e318-41cd-a6c6-881077df52e3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Queries work items linked to a given list of artifact URI.
       *
       * @param {WorkItemTrackingInterfaces.ArtifactUriQuery} artifactUriQuery - Defines a list of artifact URI for querying work items.
       * @param {string} project - Project ID or project name
       */
      queryWorkItemsForArtifactUris(artifactUriQuery, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "a9a9aa7a-8c09-44d3-ad1b-46e855c1e3d3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, artifactUriQuery, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Uploads an attachment.
       *
       * @param {NodeJS.ReadableStream} contentStream - Content to upload
       * @param {string} fileName - The name of the file
       * @param {string} uploadType - Attachment upload type: Simple or Chunked
       * @param {string} project - Project ID or project name
       * @param {string} areaPath - Target project Area Path
       */
      createAttachment(customHeaders, contentStream, fileName, uploadType, project, areaPath) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              fileName,
              uploadType,
              areaPath
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/octet-stream";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "e07b5fa4-1499-494d-a496-64b860fd64ff", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.uploadStream("POST", url, contentStream, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Downloads an attachment.
       *
       * @param {string} id - Attachment ID
       * @param {string} fileName - Name of the file
       * @param {string} project - Project ID or project name
       * @param {boolean} download - If set to <c>true</c> always download attachment
       */
      getAttachmentContent(id, fileName, project, download) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              fileName,
              download
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "e07b5fa4-1499-494d-a496-64b860fd64ff", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/octet-stream", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Downloads an attachment.
       *
       * @param {string} id - Attachment ID
       * @param {string} fileName - Name of the file
       * @param {string} project - Project ID or project name
       * @param {boolean} download - If set to <c>true</c> always download attachment
       */
      getAttachmentZip(id, fileName, project, download) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              fileName,
              download
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "e07b5fa4-1499-494d-a496-64b860fd64ff", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("application/zip", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets root classification nodes or list of classification nodes for a given list of nodes ids, for a given project. In case ids parameter is supplied you will  get list of classification nodes for those ids. Otherwise you will get root classification nodes for this project.
       *
       * @param {string} project - Project ID or project name
       * @param {number[]} ids - Comma separated integer classification nodes ids. It's not required, if you want root nodes.
       * @param {number} depth - Depth of children to fetch.
       * @param {WorkItemTrackingInterfaces.ClassificationNodesErrorPolicy} errorPolicy - Flag to handle errors in getting some nodes. Possible options are Fail and Omit.
       */
      getClassificationNodes(project, ids, depth, errorPolicy) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (ids == null) {
            throw new TypeError("ids can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              ids: ids && ids.join(","),
              "$depth": depth,
              errorPolicy
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a70579d1-f53a-48ee-a5be-7be8659023b9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemClassificationNode, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets root classification nodes under the project.
       *
       * @param {string} project - Project ID or project name
       * @param {number} depth - Depth of children to fetch.
       */
      getRootNodes(project, depth) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              "$depth": depth
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a70579d1-f53a-48ee-a5be-7be8659023b9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemClassificationNode, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create new or update an existing classification node.
       *
       * @param {WorkItemTrackingInterfaces.WorkItemClassificationNode} postedNode - Node to create or update.
       * @param {string} project - Project ID or project name
       * @param {WorkItemTrackingInterfaces.TreeStructureGroup} structureGroup - Structure group of the classification node, area or iteration.
       * @param {string} path - Path of the classification node.
       */
      createOrUpdateClassificationNode(postedNode, project, structureGroup, path2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              structureGroup,
              path: path2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "5a172953-1b41-49d3-840a-33f79c3ce89f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, postedNode, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemClassificationNode, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete an existing classification node.
       *
       * @param {string} project - Project ID or project name
       * @param {WorkItemTrackingInterfaces.TreeStructureGroup} structureGroup - Structure group of the classification node, area or iteration.
       * @param {string} path - Path of the classification node.
       * @param {number} reclassifyId - Id of the target classification node for reclassification.
       */
      deleteClassificationNode(project, structureGroup, path2, reclassifyId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              structureGroup,
              path: path2
            };
            let queryValues = {
              "$reclassifyId": reclassifyId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "5a172953-1b41-49d3-840a-33f79c3ce89f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the classification node for a given node path.
       *
       * @param {string} project - Project ID or project name
       * @param {WorkItemTrackingInterfaces.TreeStructureGroup} structureGroup - Structure group of the classification node, area or iteration.
       * @param {string} path - Path of the classification node.
       * @param {number} depth - Depth of children to fetch.
       */
      getClassificationNode(project, structureGroup, path2, depth) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              structureGroup,
              path: path2
            };
            let queryValues = {
              "$depth": depth
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "5a172953-1b41-49d3-840a-33f79c3ce89f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemClassificationNode, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update an existing classification node.
       *
       * @param {WorkItemTrackingInterfaces.WorkItemClassificationNode} postedNode - Node to create or update.
       * @param {string} project - Project ID or project name
       * @param {WorkItemTrackingInterfaces.TreeStructureGroup} structureGroup - Structure group of the classification node, area or iteration.
       * @param {string} path - Path of the classification node.
       */
      updateClassificationNode(postedNode, project, structureGroup, path2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              structureGroup,
              path: path2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "5a172953-1b41-49d3-840a-33f79c3ce89f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, postedNode, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemClassificationNode, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get users who reacted on the comment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - WorkItem ID.
       * @param {number} commentId - Comment ID.
       * @param {WorkItemTrackingInterfaces.CommentReactionType} reactionType - Type of the reaction.
       * @param {number} top
       * @param {number} skip
       */
      getEngagedUsers(project, workItemId, commentId, reactionType, top, skip) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId,
              reactionType
            };
            let queryValues = {
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "e33ca5e0-2349-4285-af3d-d72d86781c35", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add a comment on a work item.
       *
       * @param {WorkItemTrackingInterfaces.CommentCreate} request - Comment create request.
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - Id of a work item.
       */
      addComment(request, project, workItemId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "608aac0a-32e1-4493-a863-b9cf4566d257", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, request, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a comment on a work item.
       *
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - Id of a work item.
       * @param {number} commentId
       */
      deleteComment(project, workItemId, commentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "608aac0a-32e1-4493-a863-b9cf4566d257", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a work item comment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - Id of a work item to get the comment.
       * @param {number} commentId - Id of the comment to return.
       * @param {boolean} includeDeleted - Specify if the deleted comment should be retrieved.
       * @param {WorkItemTrackingInterfaces.CommentExpandOptions} expand - Specifies the additional data retrieval options for work item comments.
       */
      getComment(project, workItemId, commentId, includeDeleted, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId
            };
            let queryValues = {
              includeDeleted,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "608aac0a-32e1-4493-a863-b9cf4566d257", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of work item comments, pageable.
       *
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - Id of a work item to get comments for.
       * @param {number} top - Max number of comments to return.
       * @param {string} continuationToken - Used to query for the next page of comments.
       * @param {boolean} includeDeleted - Specify if the deleted comments should be retrieved.
       * @param {WorkItemTrackingInterfaces.CommentExpandOptions} expand - Specifies the additional data retrieval options for work item comments.
       * @param {WorkItemTrackingInterfaces.CommentSortOrder} order - Order in which the comments should be returned.
       */
      getComments(project, workItemId, top, continuationToken, includeDeleted, expand, order) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId
            };
            let queryValues = {
              "$top": top,
              continuationToken,
              includeDeleted,
              "$expand": expand,
              order
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "608aac0a-32e1-4493-a863-b9cf4566d257", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.CommentList, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of work item comments by ids.
       *
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - Id of a work item to get comments for.
       * @param {number[]} ids - Comma-separated list of comment ids to return.
       * @param {boolean} includeDeleted - Specify if the deleted comments should be retrieved.
       * @param {WorkItemTrackingInterfaces.CommentExpandOptions} expand - Specifies the additional data retrieval options for work item comments.
       */
      getCommentsBatch(project, workItemId, ids, includeDeleted, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (ids == null) {
            throw new TypeError("ids can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId
            };
            let queryValues = {
              ids: ids && ids.join(","),
              includeDeleted,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "608aac0a-32e1-4493-a863-b9cf4566d257", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.CommentList, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a comment on a work item.
       *
       * @param {WorkItemTrackingInterfaces.CommentUpdate} request - Comment update request.
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - Id of a work item.
       * @param {number} commentId
       */
      updateComment(request, project, workItemId, commentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "608aac0a-32e1-4493-a863-b9cf4566d257", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, request, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.Comment, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a new reaction to a comment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - WorkItem ID
       * @param {number} commentId - Comment ID
       * @param {WorkItemTrackingInterfaces.CommentReactionType} reactionType - Type of the reaction
       */
      createCommentReaction(project, workItemId, commentId, reactionType) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId,
              reactionType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "f6cb3f27-1028-4851-af96-887e570dc21f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, null, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.CommentReaction, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes an existing reaction on a comment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - WorkItem ID
       * @param {number} commentId - Comment ID
       * @param {WorkItemTrackingInterfaces.CommentReactionType} reactionType - Type of the reaction
       */
      deleteCommentReaction(project, workItemId, commentId, reactionType) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId,
              reactionType
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "f6cb3f27-1028-4851-af96-887e570dc21f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.CommentReaction, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets reactions of a comment.
       *
       * @param {string} project - Project ID or project name
       * @param {number} workItemId - WorkItem ID
       * @param {number} commentId - Comment ID
       */
      getCommentReactions(project, workItemId, commentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "f6cb3f27-1028-4851-af96-887e570dc21f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.CommentReaction, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} workItemId
       * @param {number} commentId
       * @param {number} version
       */
      getCommentVersion(project, workItemId, commentId, version2) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId,
              version: version2
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "49e03b34-3be0-42e3-8a5d-e8dfb88ac954", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.CommentVersion, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {number} workItemId
       * @param {number} commentId
       */
      getCommentVersions(project, workItemId, commentId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              workItemId,
              commentId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "49e03b34-3be0-42e3-8a5d-e8dfb88ac954", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.CommentVersion, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Create a new field.
       *
       * @param {WorkItemTrackingInterfaces.WorkItemField} workItemField - New field definition
       * @param {string} project - Project ID or project name
       */
      createField(workItemField, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b51fd764-e5c2-4b9b-aaf7-3395cf4bdd94", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, workItemField, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemField, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes the field. To undelete a filed, see "Update Field" API.
       *
       * @param {string} fieldNameOrRefName - Field simple name or reference name
       * @param {string} project - Project ID or project name
       */
      deleteField(fieldNameOrRefName, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              fieldNameOrRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b51fd764-e5c2-4b9b-aaf7-3395cf4bdd94", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets information on a specific field.
       *
       * @param {string} fieldNameOrRefName - Field simple name or reference name
       * @param {string} project - Project ID or project name
       */
      getField(fieldNameOrRefName, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              fieldNameOrRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b51fd764-e5c2-4b9b-aaf7-3395cf4bdd94", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemField, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns information for all fields. The project ID/name parameter is optional.
       *
       * @param {string} project - Project ID or project name
       * @param {WorkItemTrackingInterfaces.GetFieldsExpand} expand - Use ExtensionFields to include extension fields, otherwise exclude them. Unless the feature flag for this parameter is enabled, extension fields are always included.
       */
      getFields(project, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b51fd764-e5c2-4b9b-aaf7-3395cf4bdd94", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemField, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a field.
       *
       * @param {WorkItemTrackingInterfaces.UpdateWorkItemField} payload - Payload contains desired value of the field's properties
       * @param {string} fieldNameOrRefName - Name/reference name of the field to be updated
       * @param {string} project - Project ID or project name
       */
      updateField(payload, fieldNameOrRefName, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              fieldNameOrRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b51fd764-e5c2-4b9b-aaf7-3395cf4bdd94", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, payload, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemField, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Migrates a project to a different process within the same OOB type. For example, you can only migrate a project from agile/custom-agile to agile/custom-agile.
       *
       * @param {WorkItemTrackingInterfaces.ProcessIdModel} newProcess
       * @param {string} project - Project ID or project name
       */
      migrateProjectsProcess(newProcess, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "19801631-d4e5-47e9-8166-0330de0ff1e6", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, newProcess, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a query, or moves a query.
       *
       * @param {WorkItemTrackingInterfaces.QueryHierarchyItem} postedQuery - The query to create.
       * @param {string} project - Project ID or project name
       * @param {string} query - The parent id or path under which the query is to be created.
       * @param {boolean} validateWiqlOnly - If you only want to validate your WIQL query without actually creating one, set it to true. Default is false.
       */
      createQuery(postedQuery, project, query, validateWiqlOnly) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              query
            };
            let queryValues = {
              validateWiqlOnly
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a67d190c-c41f-424b-814d-0e906f659301", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, postedQuery, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.QueryHierarchyItem, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Delete a query or a folder. This deletes any permission change on the deleted query or folder and any of its descendants if it is a folder. It is important to note that the deleted permission changes cannot be recovered upon undeleting the query or folder.
       *
       * @param {string} project - Project ID or project name
       * @param {string} query - ID or path of the query or folder to delete.
       */
      deleteQuery(project, query) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              query
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a67d190c-c41f-424b-814d-0e906f659301", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the root queries and their children
       *
       * @param {string} project - Project ID or project name
       * @param {WorkItemTrackingInterfaces.QueryExpand} expand - Include the query string (wiql), clauses, query result columns, and sort options in the results.
       * @param {number} depth - In the folder of queries, return child queries and folders to this depth.
       * @param {boolean} includeDeleted - Include deleted queries and folders
       */
      getQueries(project, expand, depth, includeDeleted) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              "$expand": expand,
              "$depth": depth,
              "$includeDeleted": includeDeleted
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a67d190c-c41f-424b-814d-0e906f659301", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.QueryHierarchyItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Retrieves an individual query and its children
       *
       * @param {string} project - Project ID or project name
       * @param {string} query - ID or path of the query.
       * @param {WorkItemTrackingInterfaces.QueryExpand} expand - Include the query string (wiql), clauses, query result columns, and sort options in the results.
       * @param {number} depth - In the folder of queries, return child queries and folders to this depth.
       * @param {boolean} includeDeleted - Include deleted queries and folders
       * @param {boolean} useIsoDateFormat - DateTime query clauses will be formatted using a ISO 8601 compliant format
       */
      getQuery(project, query, expand, depth, includeDeleted, useIsoDateFormat) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              query
            };
            let queryValues = {
              "$expand": expand,
              "$depth": depth,
              "$includeDeleted": includeDeleted,
              "$useIsoDateFormat": useIsoDateFormat
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a67d190c-c41f-424b-814d-0e906f659301", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.QueryHierarchyItem, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Searches all queries the user has access to in the current project
       *
       * @param {string} project - Project ID or project name
       * @param {string} filter - The text to filter the queries with.
       * @param {number} top - The number of queries to return (Default is 50 and maximum is 200).
       * @param {WorkItemTrackingInterfaces.QueryExpand} expand
       * @param {boolean} includeDeleted - Include deleted queries and folders
       */
      searchQueries(project, filter2, top, expand, includeDeleted) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (filter2 == null) {
            throw new TypeError("filter can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              "$filter": filter2,
              "$top": top,
              "$expand": expand,
              "$includeDeleted": includeDeleted
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a67d190c-c41f-424b-814d-0e906f659301", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.QueryHierarchyItemsResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Update a query or a folder. This allows you to update, rename and move queries and folders.
       *
       * @param {WorkItemTrackingInterfaces.QueryHierarchyItem} queryUpdate - The query to update.
       * @param {string} project - Project ID or project name
       * @param {string} query - The ID or path for the query to update.
       * @param {boolean} undeleteDescendants - Undelete the children of this folder. It is important to note that this will not bring back the permission changes that were previously applied to the descendants.
       */
      updateQuery(queryUpdate, project, query, undeleteDescendants) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              query
            };
            let queryValues = {
              "$undeleteDescendants": undeleteDescendants
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a67d190c-c41f-424b-814d-0e906f659301", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, queryUpdate, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.QueryHierarchyItem, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of queries by ids (Maximum 1000)
       *
       * @param {WorkItemTrackingInterfaces.QueryBatchGetRequest} queryGetRequest
       * @param {string} project - Project ID or project name
       */
      getQueriesBatch(queryGetRequest, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "549816f9-09b0-4e75-9e81-01fbfcd07426", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, queryGetRequest, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.QueryHierarchyItem, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Destroys the specified work item permanently from the Recycle Bin. This action can not be undone.
       *
       * @param {number} id - ID of the work item to be destroyed permanently
       * @param {string} project - Project ID or project name
       */
      destroyWorkItem(id, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b70d8d39-926c-465e-b927-b1bf0e5ca0e0", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a deleted work item from Recycle Bin.
       *
       * @param {number} id - ID of the work item to be returned
       * @param {string} project - Project ID or project name
       */
      getDeletedWorkItem(id, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b70d8d39-926c-465e-b927-b1bf0e5ca0e0", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the work items from the recycle bin, whose IDs have been specified in the parameters
       *
       * @param {number[]} ids - Comma separated list of IDs of the deleted work items to be returned
       * @param {string} project - Project ID or project name
       */
      getDeletedWorkItems(ids, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (ids == null) {
            throw new TypeError("ids can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              ids: ids && ids.join(",")
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b70d8d39-926c-465e-b927-b1bf0e5ca0e0", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets a list of the IDs and the URLs of the deleted the work items in the Recycle Bin.
       *
       * @param {string} project - Project ID or project name
       */
      getDeletedWorkItemShallowReferences(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b70d8d39-926c-465e-b927-b1bf0e5ca0e0", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Restores the deleted work item from Recycle Bin.
       *
       * @param {WorkItemTrackingInterfaces.WorkItemDeleteUpdate} payload - Paylod with instructions to update the IsDeleted flag to false
       * @param {number} id - ID of the work item to be restored
       * @param {string} project - Project ID or project name
       */
      restoreWorkItem(payload, id, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "b70d8d39-926c-465e-b927-b1bf0e5ca0e0", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, payload, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a fully hydrated work item for the requested revision
       *
       * @param {number} id
       * @param {number} revisionNumber
       * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand
       * @param {string} project - Project ID or project name
       */
      getRevision(id, revisionNumber, expand, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id,
              revisionNumber
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "a00c85a5-80fa-4565-99c3-bcd2181434bb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the list of fully hydrated work item revisions, paged.
       *
       * @param {number} id
       * @param {number} top
       * @param {number} skip
       * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand
       * @param {string} project - Project ID or project name
       */
      getRevisions(id, top, skip, expand, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              "$top": top,
              "$skip": skip,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "a00c85a5-80fa-4565-99c3-bcd2181434bb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * RESTful method to send mail for selected/queried work items.
       *
       * @param {WorkItemTrackingInterfaces.SendMailBody} body
       * @param {string} project - Project ID or project name
       */
      sendMail(body, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "12438500-2f84-4fa7-9f1a-c31871b4959d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, body, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} tagIdOrName
       */
      deleteTag(project, tagIdOrName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              tagIdOrName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "bc15bc60-e7a8-43cb-ab01-2106be3983a1", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} tagIdOrName
       */
      getTag(project, tagIdOrName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              tagIdOrName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "bc15bc60-e7a8-43cb-ab01-2106be3983a1", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       */
      getTags(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "bc15bc60-e7a8-43cb-ab01-2106be3983a1", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {WorkItemTrackingInterfaces.WorkItemTagDefinition} tagData
       * @param {string} project - Project ID or project name
       * @param {string} tagIdOrName
       */
      updateTag(tagData, project, tagIdOrName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              tagIdOrName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "bc15bc60-e7a8-43cb-ab01-2106be3983a1", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, tagData, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a template
       *
       * @param {WorkItemTrackingInterfaces.WorkItemTemplate} template - Template contents
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       */
      createTemplate(template2, teamContext) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "6a90345f-a676-4969-afce-8e163e1d5642", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, template2, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets template
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} workitemtypename - Optional, When specified returns templates for given Work item type.
       */
      getTemplates(teamContext, workitemtypename) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            let queryValues = {
              workitemtypename
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "6a90345f-a676-4969-afce-8e163e1d5642", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes the template with given id
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} templateId - Template id
       */
      deleteTemplate(teamContext, templateId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "fb10264a-8836-48a0-8033-1b0ccd2748d5", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the template with specified id
       *
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} templateId - Template Id
       */
      getTemplate(teamContext, templateId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "fb10264a-8836-48a0-8033-1b0ccd2748d5", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Replace template contents
       *
       * @param {WorkItemTrackingInterfaces.WorkItemTemplate} templateContent - Template contents to replace with
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {string} templateId - Template id
       */
      replaceTemplate(templateContent, teamContext, templateId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              templateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "fb10264a-8836-48a0-8033-1b0ccd2748d5", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, templateContent, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a single update for a work item
       *
       * @param {number} id
       * @param {number} updateNumber
       * @param {string} project - Project ID or project name
       */
      getUpdate(id, updateNumber, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id,
              updateNumber
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "6570bf97-d02c-4a91-8d93-3abe9895b1a9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemUpdate, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a the deltas between work item revisions
       *
       * @param {number} id
       * @param {number} top
       * @param {number} skip
       * @param {string} project - Project ID or project name
       */
      getUpdates(id, top, skip, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              "$top": top,
              "$skip": skip
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "6570bf97-d02c-4a91-8d93-3abe9895b1a9", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemUpdate, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the results of the query given its WIQL.
       *
       * @param {WorkItemTrackingInterfaces.Wiql} wiql - The query containing the WIQL.
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {boolean} timePrecision - Whether or not to use time precision.
       * @param {number} top - The max number of results to return.
       */
      queryByWiql(wiql, teamContext, timePrecision, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team
            };
            let queryValues = {
              timePrecision,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "1a9c53f7-f243-4447-b110-35ef023636e4", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, wiql, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemQueryResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the results of the query given the query ID.
       *
       * @param {string} id - The query ID.
       * @param {TfsCoreInterfaces.TeamContext} teamContext - The team context for the operation
       * @param {boolean} timePrecision - Whether or not to use time precision.
       * @param {number} top - The max number of results to return.
       */
      queryById(id, teamContext, timePrecision, top) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let project = null;
            let team = null;
            if (teamContext) {
              project = teamContext.projectId || teamContext.project;
              team = teamContext.teamId || teamContext.team;
            }
            let routeValues = {
              project,
              team,
              id
            };
            let queryValues = {
              timePrecision,
              "$top": top
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "a02355f5-5f8a-4671-8e32-369d23aac83d", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingInterfaces.TypeInfo.WorkItemQueryResult, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a work item icon given the friendly name and icon color.
       *
       * @param {string} icon - The name of the icon
       * @param {string} color - The 6-digit hex color for the icon
       * @param {number} v - The version of the icon (used only for cache invalidation)
       */
      getWorkItemIconJson(icon, color, v) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              icon
            };
            let queryValues = {
              color,
              v
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "4e1eb4a5-1970-4228-a682-ec48eb2dca30", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of all work item icons.
       *
       */
      getWorkItemIcons() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "4e1eb4a5-1970-4228-a682-ec48eb2dca30", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a work item icon given the friendly name and icon color.
       *
       * @param {string} icon - The name of the icon
       * @param {string} color - The 6-digit hex color for the icon
       * @param {number} v - The version of the icon (used only for cache invalidation)
       */
      getWorkItemIconSvg(icon, color, v) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              icon
            };
            let queryValues = {
              color,
              v
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "4e1eb4a5-1970-4228-a682-ec48eb2dca30", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("image/svg+xml", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a work item icon given the friendly name and icon color.
       *
       * @param {string} icon - The name of the icon
       * @param {string} color - The 6-digit hex color for the icon
       * @param {number} v - The version of the icon (used only for cache invalidation)
       */
      getWorkItemIconXaml(icon, color, v) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              icon
            };
            let queryValues = {
              color,
              v
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "4e1eb4a5-1970-4228-a682-ec48eb2dca30", routeValues, queryValues);
              let url = verData.requestUrl;
              let apiVersion = verData.apiVersion;
              let accept = this.createAcceptHeader("image/xaml+xml", apiVersion);
              resolve((yield this.http.get(url, { "Accept": accept })).message);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a batch of work item links
       *
       * @param {string} project - Project ID or project name
       * @param {string[]} linkTypes - A list of types to filter the results to specific link types. Omit this parameter to get work item links of all link types.
       * @param {string[]} types - A list of types to filter the results to specific work item types. Omit this parameter to get work item links of all work item types.
       * @param {string} continuationToken - Specifies the continuationToken to start the batch from. Omit this parameter to get the first batch of links.
       * @param {Date} startDateTime - Date/time to use as a starting point for link changes. Only link changes that occurred after that date/time will be returned. Cannot be used in conjunction with 'watermark' parameter.
       */
      getReportingLinksByLinkType(project, linkTypes, types, continuationToken, startDateTime) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              linkTypes: linkTypes && linkTypes.join(","),
              types: types && types.join(","),
              continuationToken,
              startDateTime
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "b5b5b6d0-0308-40a1-b3f4-b9bb3c66878f", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the work item relation type definition.
       *
       * @param {string} relation - The relation name
       */
      getRelationType(relation) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              relation
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "f5d33bc9-5b49-4a3c-a9bd-f3cd46dd2165", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the work item relation types.
       *
       */
      getRelationTypes() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "f5d33bc9-5b49-4a3c-a9bd-f3cd46dd2165", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a batch of work item revisions with the option of including deleted items
       *
       * @param {string} project - Project ID or project name
       * @param {string[]} fields - A list of fields to return in work item revisions. Omit this parameter to get all reportable fields.
       * @param {string[]} types - A list of types to filter the results to specific work item types. Omit this parameter to get work item revisions of all work item types.
       * @param {string} continuationToken - Specifies the watermark to start the batch from. Omit this parameter to get the first batch of revisions.
       * @param {Date} startDateTime - Date/time to use as a starting point for revisions, all revisions will occur after this date/time. Cannot be used in conjunction with 'watermark' parameter.
       * @param {boolean} includeIdentityRef - Return an identity reference instead of a string value for identity fields.
       * @param {boolean} includeDeleted - Specify if the deleted item should be returned.
       * @param {boolean} includeTagRef - Specify if the tag objects should be returned for System.Tags field.
       * @param {boolean} includeLatestOnly - Return only the latest revisions of work items, skipping all historical revisions
       * @param {WorkItemTrackingInterfaces.ReportingRevisionsExpand} expand - Return all the fields in work item revisions, including long text fields which are not returned by default
       * @param {boolean} includeDiscussionChangesOnly - Return only the those revisions of work items, where only history field was changed
       * @param {number} maxPageSize - The maximum number of results to return in this batch
       */
      readReportingRevisionsGet(project, fields, types, continuationToken, startDateTime, includeIdentityRef, includeDeleted, includeTagRef, includeLatestOnly, expand, includeDiscussionChangesOnly, maxPageSize) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              fields: fields && fields.join(","),
              types: types && types.join(","),
              continuationToken,
              startDateTime,
              includeIdentityRef,
              includeDeleted,
              includeTagRef,
              includeLatestOnly,
              "$expand": expand,
              includeDiscussionChangesOnly,
              "$maxPageSize": maxPageSize
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "f828fe59-dd87-495d-a17c-7a8d6211ca6c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a batch of work item revisions. This request may be used if your list of fields is large enough that it may run the URL over the length limit.
       *
       * @param {WorkItemTrackingInterfaces.ReportingWorkItemRevisionsFilter} filter - An object that contains request settings: field filter, type filter, identity format
       * @param {string} project - Project ID or project name
       * @param {string} continuationToken - Specifies the watermark to start the batch from. Omit this parameter to get the first batch of revisions.
       * @param {Date} startDateTime - Date/time to use as a starting point for revisions, all revisions will occur after this date/time. Cannot be used in conjunction with 'watermark' parameter.
       * @param {WorkItemTrackingInterfaces.ReportingRevisionsExpand} expand
       */
      readReportingRevisionsPost(filter2, project, continuationToken, startDateTime, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              continuationToken,
              startDateTime,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "f828fe59-dd87-495d-a17c-7a8d6211ca6c", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, filter2, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * @param {string} project - Project ID or project name
       * @param {string} continuationToken
       * @param {number} maxPageSize
       */
      readReportingDiscussions(project, continuationToken, maxPageSize) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              continuationToken,
              "$maxPageSize": maxPageSize
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "4a644469-90c5-4fcc-9a9f-be0827d369ec", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a single work item.
       *
       * @param {VSSInterfaces.JsonPatchDocument} document - The JSON Patch document representing the work item
       * @param {string} project - Project ID or project name
       * @param {string} type - The work item type of the work item to create
       * @param {boolean} validateOnly - Indicate if you only want to validate the changes without saving the work item
       * @param {boolean} bypassRules - Do not enforce the work item type rules on this update
       * @param {boolean} suppressNotifications - Do not fire any notifications for this change
       * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand - The expand parameters for work item attributes. Possible options are { None, Relations, Fields, Links, All }.
       */
      createWorkItem(customHeaders, document, project, type, validateOnly, bypassRules, suppressNotifications, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              type
            };
            let queryValues = {
              validateOnly,
              bypassRules,
              suppressNotifications,
              "$expand": expand
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/json-patch+json";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "62d3d110-0047-428c-ad3c-4fe872c91c74", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.create(url, document, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a single work item from a template.
       *
       * @param {string} project - Project ID or project name
       * @param {string} type - The work item type name
       * @param {string} fields - Comma-separated list of requested fields
       * @param {Date} asOf - AsOf UTC date time string
       * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand - The expand parameters for work item attributes. Possible options are { None, Relations, Fields, Links, All }.
       */
      getWorkItemTemplate(project, type, fields, asOf, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              type
            };
            let queryValues = {
              fields,
              asOf,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "62d3d110-0047-428c-ad3c-4fe872c91c74", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes the specified work item and sends it to the Recycle Bin, so that it can be restored back, if required. Optionally, if the destroy parameter has been set to true, it destroys the work item permanently. WARNING: If the destroy parameter is set to true, work items deleted by this command will NOT go to recycle-bin and there is no way to restore/recover them after deletion. It is recommended NOT to use this parameter. If you do, please use this parameter with extreme caution.
       *
       * @param {number} id - ID of the work item to be deleted
       * @param {string} project - Project ID or project name
       * @param {boolean} destroy - Optional parameter, if set to true, the work item is deleted permanently. Please note: the destroy action is PERMANENT and cannot be undone.
       */
      deleteWorkItem(id, project, destroy) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              destroy
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "72c7ddf8-2cdc-4f60-90cd-ab71c14a399b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a single work item.
       *
       * @param {number} id - The work item id
       * @param {string[]} fields - Comma-separated list of requested fields
       * @param {Date} asOf - AsOf UTC date time string
       * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand - The expand parameters for work item attributes. Possible options are { None, Relations, Fields, Links, All }.
       * @param {string} project - Project ID or project name
       */
      getWorkItem(id, fields, asOf, expand, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              fields: fields && fields.join(","),
              asOf,
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "72c7ddf8-2cdc-4f60-90cd-ab71c14a399b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of work items (Maximum 200)
       *
       * @param {number[]} ids - The comma-separated list of requested work item ids. (Maximum 200 ids allowed).
       * @param {string[]} fields - Comma-separated list of requested fields
       * @param {Date} asOf - AsOf UTC date time string
       * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand - The expand parameters for work item attributes. Possible options are { None, Relations, Fields, Links, All }.
       * @param {WorkItemTrackingInterfaces.WorkItemErrorPolicy} errorPolicy - The flag to control error policy in a bulk get work items request. Possible options are {Fail, Omit}.
       * @param {string} project - Project ID or project name
       */
      getWorkItems(ids, fields, asOf, expand, errorPolicy, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (ids == null) {
            throw new TypeError("ids can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            let queryValues = {
              ids: ids && ids.join(","),
              fields: fields && fields.join(","),
              asOf,
              "$expand": expand,
              errorPolicy
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "72c7ddf8-2cdc-4f60-90cd-ab71c14a399b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a single work item.
       *
       * @param {VSSInterfaces.JsonPatchDocument} document - The JSON Patch document representing the update
       * @param {number} id - The id of the work item to update
       * @param {string} project - Project ID or project name
       * @param {boolean} validateOnly - Indicate if you only want to validate the changes without saving the work item
       * @param {boolean} bypassRules - Do not enforce the work item type rules on this update
       * @param {boolean} suppressNotifications - Do not fire any notifications for this change
       * @param {WorkItemTrackingInterfaces.WorkItemExpand} expand - The expand parameters for work item attributes. Possible options are { None, Relations, Fields, Links, All }.
       */
      updateWorkItem(customHeaders, document, id, project, validateOnly, bypassRules, suppressNotifications, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              id
            };
            let queryValues = {
              validateOnly,
              bypassRules,
              suppressNotifications,
              "$expand": expand
            };
            customHeaders = customHeaders || {};
            customHeaders["Content-Type"] = "application/json-patch+json";
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "72c7ddf8-2cdc-4f60-90cd-ab71c14a399b", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              options.additionalHeaders = customHeaders;
              let res;
              res = yield this.rest.update(url, document, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets work items for a list of work item ids (Maximum 200)
       *
       * @param {WorkItemTrackingInterfaces.WorkItemBatchGetRequest} workItemGetRequest
       * @param {string} project - Project ID or project name
       */
      getWorkItemsBatch(workItemGetRequest, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "908509b6-4248-4475-a1cd-829139ba419f", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, workItemGetRequest, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * INTERNAL ONLY: It will be used for My account work experience. Get the work item type state color for multiple projects
       *
       * @param {string[]} projectNames
       */
      getWorkItemStateColors(projectNames) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "0b83df8a-3496-4ddb-ba44-63634f4cda61", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, projectNames, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the next state on the given work item IDs.
       *
       * @param {number[]} ids - list of work item ids
       * @param {string} action - possible actions. Currently only supports checkin
       */
      getWorkItemNextStatesOnCheckinAction(ids, action) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (ids == null) {
            throw new TypeError("ids can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              ids: ids && ids.join(","),
              action
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "afae844b-e2f6-44c2-8053-17b3bb936a40", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get all work item type categories.
       *
       * @param {string} project - Project ID or project name
       */
      getWorkItemTypeCategories(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "9b9f5734-36c8-415e-ba67-f83b45c31408", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get specific work item type category by name.
       *
       * @param {string} project - Project ID or project name
       * @param {string} category - The category name
       */
      getWorkItemTypeCategory(project, category) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              category
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "9b9f5734-36c8-415e-ba67-f83b45c31408", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * INTERNAL ONLY: It will be used for My account work experience. Get the wit type color for multiple projects
       *
       * @param {string[]} projectNames
       */
      getWorkItemTypeColors(projectNames) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "958fde80-115e-43fb-bd65-749c48057faf", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, projectNames, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * INTERNAL ONLY: It is used for color and icon providers. Get the wit type color for multiple projects
       *
       * @param {string[]} projectNames
       */
      getWorkItemTypeColorAndIcons(projectNames) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "f0f8dc62-3975-48ce-8051-f636b68b52e3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, projectNames, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a work item type definition.
       *
       * @param {string} project - Project ID or project name
       * @param {string} type - Work item type name
       */
      getWorkItemType(project, type) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "7c8d7a76-4a09-43e8-b5df-bd792f4ac6aa", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the list of work item types
       *
       * @param {string} project - Project ID or project name
       */
      getWorkItemTypes(project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.2", "wit", "7c8d7a76-4a09-43e8-b5df-bd792f4ac6aa", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a list of fields for a work item type with detailed references.
       *
       * @param {string} project - Project ID or project name
       * @param {string} type - Work item type.
       * @param {WorkItemTrackingInterfaces.WorkItemTypeFieldsExpandLevel} expand - Expand level for the API response. Properties: to include allowedvalues, default value, isRequired etc. as a part of response; None: to skip these properties.
       */
      getWorkItemTypeFieldsWithReferences(project, type, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              type
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "bd293ce5-3d25-4192-8e67-e8092e879efb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a field for a work item type with detailed references.
       *
       * @param {string} project - Project ID or project name
       * @param {string} type - Work item type.
       * @param {string} field
       * @param {WorkItemTrackingInterfaces.WorkItemTypeFieldsExpandLevel} expand - Expand level for the API response. Properties: to include allowedvalues, default value, isRequired etc. as a part of response; None: to skip these properties.
       */
      getWorkItemTypeFieldWithReferences(project, type, field, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              type,
              field
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.3", "wit", "bd293ce5-3d25-4192-8e67-e8092e879efb", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns the state names and colors for a work item type.
       *
       * @param {string} project - Project ID or project name
       * @param {string} type - The state name
       */
      getWorkItemTypeStates(project, type) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              type
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "7c9d7a76-4a09-43e8-b5df-bd792f4ac6aa", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Export work item type
       *
       * @param {string} project - Project ID or project name
       * @param {string} type
       * @param {boolean} exportGlobalLists
       */
      exportWorkItemTypeDefinition(project, type, exportGlobalLists) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project,
              type
            };
            let queryValues = {
              exportGlobalLists
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "8637ac8b-5eb6-4f90-b3f7-4f2ff576a459", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Add/updates a work item type
       *
       * @param {WorkItemTrackingInterfaces.WorkItemTypeTemplateUpdateModel} updateModel
       * @param {string} project - Project ID or project name
       */
      updateWorkItemTypeDefinition(updateModel, project) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              project
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.1-preview.1", "wit", "8637ac8b-5eb6-4f90-b3f7-4f2ff576a459", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, updateModel, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.WorkItemTrackingApi = WorkItemTrackingApi;
    WorkItemTrackingApi.RESOURCE_AREA_ID = "5264459e-e5e0-4bd8-b118-0985e68a4ec5";
  }
});

// ../node_modules/azure-devops-node-api/interfaces/WorkItemTrackingProcessInterfaces.js
var require_WorkItemTrackingProcessInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/WorkItemTrackingProcessInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.WorkItemTypeClass = exports2.RuleConditionType = exports2.RuleActionType = exports2.ProcessWorkItemTypeFieldsExpandLevel = exports2.ProcessClass = exports2.PageType = exports2.GetWorkItemTypeExpand = exports2.GetProcessExpandLevel = exports2.GetBehaviorsExpand = exports2.FieldType = exports2.CustomizationType = void 0;
    var CustomizationType;
    (function(CustomizationType2) {
      CustomizationType2[CustomizationType2["System"] = 1] = "System";
      CustomizationType2[CustomizationType2["Inherited"] = 2] = "Inherited";
      CustomizationType2[CustomizationType2["Custom"] = 3] = "Custom";
    })(CustomizationType = exports2.CustomizationType || (exports2.CustomizationType = {}));
    var FieldType;
    (function(FieldType2) {
      FieldType2[FieldType2["String"] = 1] = "String";
      FieldType2[FieldType2["Integer"] = 2] = "Integer";
      FieldType2[FieldType2["DateTime"] = 3] = "DateTime";
      FieldType2[FieldType2["PlainText"] = 5] = "PlainText";
      FieldType2[FieldType2["Html"] = 7] = "Html";
      FieldType2[FieldType2["TreePath"] = 8] = "TreePath";
      FieldType2[FieldType2["History"] = 9] = "History";
      FieldType2[FieldType2["Double"] = 10] = "Double";
      FieldType2[FieldType2["Guid"] = 11] = "Guid";
      FieldType2[FieldType2["Boolean"] = 12] = "Boolean";
      FieldType2[FieldType2["Identity"] = 13] = "Identity";
      FieldType2[FieldType2["PicklistInteger"] = 14] = "PicklistInteger";
      FieldType2[FieldType2["PicklistString"] = 15] = "PicklistString";
      FieldType2[FieldType2["PicklistDouble"] = 16] = "PicklistDouble";
    })(FieldType = exports2.FieldType || (exports2.FieldType = {}));
    var GetBehaviorsExpand;
    (function(GetBehaviorsExpand2) {
      GetBehaviorsExpand2[GetBehaviorsExpand2["None"] = 0] = "None";
      GetBehaviorsExpand2[GetBehaviorsExpand2["Fields"] = 1] = "Fields";
      GetBehaviorsExpand2[GetBehaviorsExpand2["CombinedFields"] = 2] = "CombinedFields";
    })(GetBehaviorsExpand = exports2.GetBehaviorsExpand || (exports2.GetBehaviorsExpand = {}));
    var GetProcessExpandLevel;
    (function(GetProcessExpandLevel2) {
      GetProcessExpandLevel2[GetProcessExpandLevel2["None"] = 0] = "None";
      GetProcessExpandLevel2[GetProcessExpandLevel2["Projects"] = 1] = "Projects";
    })(GetProcessExpandLevel = exports2.GetProcessExpandLevel || (exports2.GetProcessExpandLevel = {}));
    var GetWorkItemTypeExpand;
    (function(GetWorkItemTypeExpand2) {
      GetWorkItemTypeExpand2[GetWorkItemTypeExpand2["None"] = 0] = "None";
      GetWorkItemTypeExpand2[GetWorkItemTypeExpand2["States"] = 1] = "States";
      GetWorkItemTypeExpand2[GetWorkItemTypeExpand2["Behaviors"] = 2] = "Behaviors";
      GetWorkItemTypeExpand2[GetWorkItemTypeExpand2["Layout"] = 4] = "Layout";
    })(GetWorkItemTypeExpand = exports2.GetWorkItemTypeExpand || (exports2.GetWorkItemTypeExpand = {}));
    var PageType;
    (function(PageType2) {
      PageType2[PageType2["Custom"] = 1] = "Custom";
      PageType2[PageType2["History"] = 2] = "History";
      PageType2[PageType2["Links"] = 3] = "Links";
      PageType2[PageType2["Attachments"] = 4] = "Attachments";
    })(PageType = exports2.PageType || (exports2.PageType = {}));
    var ProcessClass;
    (function(ProcessClass2) {
      ProcessClass2[ProcessClass2["System"] = 0] = "System";
      ProcessClass2[ProcessClass2["Derived"] = 1] = "Derived";
      ProcessClass2[ProcessClass2["Custom"] = 2] = "Custom";
    })(ProcessClass = exports2.ProcessClass || (exports2.ProcessClass = {}));
    var ProcessWorkItemTypeFieldsExpandLevel;
    (function(ProcessWorkItemTypeFieldsExpandLevel2) {
      ProcessWorkItemTypeFieldsExpandLevel2[ProcessWorkItemTypeFieldsExpandLevel2["None"] = 0] = "None";
      ProcessWorkItemTypeFieldsExpandLevel2[ProcessWorkItemTypeFieldsExpandLevel2["AllowedValues"] = 1] = "AllowedValues";
      ProcessWorkItemTypeFieldsExpandLevel2[ProcessWorkItemTypeFieldsExpandLevel2["All"] = 2] = "All";
    })(ProcessWorkItemTypeFieldsExpandLevel = exports2.ProcessWorkItemTypeFieldsExpandLevel || (exports2.ProcessWorkItemTypeFieldsExpandLevel = {}));
    var RuleActionType;
    (function(RuleActionType2) {
      RuleActionType2[RuleActionType2["MakeRequired"] = 1] = "MakeRequired";
      RuleActionType2[RuleActionType2["MakeReadOnly"] = 2] = "MakeReadOnly";
      RuleActionType2[RuleActionType2["SetDefaultValue"] = 3] = "SetDefaultValue";
      RuleActionType2[RuleActionType2["SetDefaultFromClock"] = 4] = "SetDefaultFromClock";
      RuleActionType2[RuleActionType2["SetDefaultFromCurrentUser"] = 5] = "SetDefaultFromCurrentUser";
      RuleActionType2[RuleActionType2["SetDefaultFromField"] = 6] = "SetDefaultFromField";
      RuleActionType2[RuleActionType2["CopyValue"] = 7] = "CopyValue";
      RuleActionType2[RuleActionType2["CopyFromClock"] = 8] = "CopyFromClock";
      RuleActionType2[RuleActionType2["CopyFromCurrentUser"] = 9] = "CopyFromCurrentUser";
      RuleActionType2[RuleActionType2["CopyFromField"] = 10] = "CopyFromField";
      RuleActionType2[RuleActionType2["SetValueToEmpty"] = 11] = "SetValueToEmpty";
      RuleActionType2[RuleActionType2["CopyFromServerClock"] = 12] = "CopyFromServerClock";
      RuleActionType2[RuleActionType2["CopyFromServerCurrentUser"] = 13] = "CopyFromServerCurrentUser";
      RuleActionType2[RuleActionType2["HideTargetField"] = 14] = "HideTargetField";
      RuleActionType2[RuleActionType2["DisallowValue"] = 15] = "DisallowValue";
    })(RuleActionType = exports2.RuleActionType || (exports2.RuleActionType = {}));
    var RuleConditionType;
    (function(RuleConditionType2) {
      RuleConditionType2[RuleConditionType2["When"] = 1] = "When";
      RuleConditionType2[RuleConditionType2["WhenNot"] = 2] = "WhenNot";
      RuleConditionType2[RuleConditionType2["WhenChanged"] = 3] = "WhenChanged";
      RuleConditionType2[RuleConditionType2["WhenNotChanged"] = 4] = "WhenNotChanged";
      RuleConditionType2[RuleConditionType2["WhenWas"] = 5] = "WhenWas";
      RuleConditionType2[RuleConditionType2["WhenStateChangedTo"] = 6] = "WhenStateChangedTo";
      RuleConditionType2[RuleConditionType2["WhenStateChangedFromAndTo"] = 7] = "WhenStateChangedFromAndTo";
      RuleConditionType2[RuleConditionType2["WhenWorkItemIsCreated"] = 8] = "WhenWorkItemIsCreated";
      RuleConditionType2[RuleConditionType2["WhenValueIsDefined"] = 9] = "WhenValueIsDefined";
      RuleConditionType2[RuleConditionType2["WhenValueIsNotDefined"] = 10] = "WhenValueIsNotDefined";
      RuleConditionType2[RuleConditionType2["WhenCurrentUserIsMemberOfGroup"] = 11] = "WhenCurrentUserIsMemberOfGroup";
      RuleConditionType2[RuleConditionType2["WhenCurrentUserIsNotMemberOfGroup"] = 12] = "WhenCurrentUserIsNotMemberOfGroup";
    })(RuleConditionType = exports2.RuleConditionType || (exports2.RuleConditionType = {}));
    var WorkItemTypeClass;
    (function(WorkItemTypeClass2) {
      WorkItemTypeClass2[WorkItemTypeClass2["System"] = 0] = "System";
      WorkItemTypeClass2[WorkItemTypeClass2["Derived"] = 1] = "Derived";
      WorkItemTypeClass2[WorkItemTypeClass2["Custom"] = 2] = "Custom";
    })(WorkItemTypeClass = exports2.WorkItemTypeClass || (exports2.WorkItemTypeClass = {}));
    exports2.TypeInfo = {
      CreateProcessRuleRequest: {},
      CustomizationType: {
        enumValues: {
          "system": 1,
          "inherited": 2,
          "custom": 3
        }
      },
      FieldModel: {},
      FieldType: {
        enumValues: {
          "string": 1,
          "integer": 2,
          "dateTime": 3,
          "plainText": 5,
          "html": 7,
          "treePath": 8,
          "history": 9,
          "double": 10,
          "guid": 11,
          "boolean": 12,
          "identity": 13,
          "picklistInteger": 14,
          "picklistString": 15,
          "picklistDouble": 16
        }
      },
      FormLayout: {},
      GetBehaviorsExpand: {
        enumValues: {
          "none": 0,
          "fields": 1,
          "combinedFields": 2
        }
      },
      GetProcessExpandLevel: {
        enumValues: {
          "none": 0,
          "projects": 1
        }
      },
      GetWorkItemTypeExpand: {
        enumValues: {
          "none": 0,
          "states": 1,
          "behaviors": 2,
          "layout": 4
        }
      },
      Page: {},
      PageType: {
        enumValues: {
          "custom": 1,
          "history": 2,
          "links": 3,
          "attachments": 4
        }
      },
      ProcessBehavior: {},
      ProcessClass: {
        enumValues: {
          "system": 0,
          "derived": 1,
          "custom": 2
        }
      },
      ProcessInfo: {},
      ProcessModel: {},
      ProcessProperties: {},
      ProcessRule: {},
      ProcessWorkItemType: {},
      ProcessWorkItemTypeField: {},
      ProcessWorkItemTypeFieldsExpandLevel: {
        enumValues: {
          "none": 0,
          "allowedValues": 1,
          "all": 2
        }
      },
      RuleAction: {},
      RuleActionType: {
        enumValues: {
          "makeRequired": 1,
          "makeReadOnly": 2,
          "setDefaultValue": 3,
          "setDefaultFromClock": 4,
          "setDefaultFromCurrentUser": 5,
          "setDefaultFromField": 6,
          "copyValue": 7,
          "copyFromClock": 8,
          "copyFromCurrentUser": 9,
          "copyFromField": 10,
          "setValueToEmpty": 11,
          "copyFromServerClock": 12,
          "copyFromServerCurrentUser": 13,
          "hideTargetField": 14,
          "disallowValue": 15
        }
      },
      RuleCondition: {},
      RuleConditionType: {
        enumValues: {
          "when": 1,
          "whenNot": 2,
          "whenChanged": 3,
          "whenNotChanged": 4,
          "whenWas": 5,
          "whenStateChangedTo": 6,
          "whenStateChangedFromAndTo": 7,
          "whenWorkItemIsCreated": 8,
          "whenValueIsDefined": 9,
          "whenValueIsNotDefined": 10,
          "whenCurrentUserIsMemberOfGroup": 11,
          "whenCurrentUserIsNotMemberOfGroup": 12
        }
      },
      UpdateProcessRuleRequest: {},
      WorkItemStateResultModel: {},
      WorkItemTypeClass: {
        enumValues: {
          "system": 0,
          "derived": 1,
          "custom": 2
        }
      },
      WorkItemTypeModel: {}
    };
    exports2.TypeInfo.CreateProcessRuleRequest.fields = {
      actions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RuleAction
      },
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RuleCondition
      }
    };
    exports2.TypeInfo.FieldModel.fields = {
      type: {
        enumType: exports2.TypeInfo.FieldType
      }
    };
    exports2.TypeInfo.FormLayout.fields = {
      pages: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Page
      }
    };
    exports2.TypeInfo.Page.fields = {
      pageType: {
        enumType: exports2.TypeInfo.PageType
      }
    };
    exports2.TypeInfo.ProcessBehavior.fields = {
      customization: {
        enumType: exports2.TypeInfo.CustomizationType
      }
    };
    exports2.TypeInfo.ProcessInfo.fields = {
      customizationType: {
        enumType: exports2.TypeInfo.CustomizationType
      }
    };
    exports2.TypeInfo.ProcessModel.fields = {
      properties: {
        typeInfo: exports2.TypeInfo.ProcessProperties
      }
    };
    exports2.TypeInfo.ProcessProperties.fields = {
      class: {
        enumType: exports2.TypeInfo.ProcessClass
      }
    };
    exports2.TypeInfo.ProcessRule.fields = {
      actions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RuleAction
      },
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RuleCondition
      },
      customizationType: {
        enumType: exports2.TypeInfo.CustomizationType
      }
    };
    exports2.TypeInfo.ProcessWorkItemType.fields = {
      customization: {
        enumType: exports2.TypeInfo.CustomizationType
      },
      layout: {
        typeInfo: exports2.TypeInfo.FormLayout
      },
      states: {
        isArray: true,
        typeInfo: exports2.TypeInfo.WorkItemStateResultModel
      }
    };
    exports2.TypeInfo.ProcessWorkItemTypeField.fields = {
      customization: {
        enumType: exports2.TypeInfo.CustomizationType
      },
      type: {
        enumType: exports2.TypeInfo.FieldType
      }
    };
    exports2.TypeInfo.RuleAction.fields = {
      actionType: {
        enumType: exports2.TypeInfo.RuleActionType
      }
    };
    exports2.TypeInfo.RuleCondition.fields = {
      conditionType: {
        enumType: exports2.TypeInfo.RuleConditionType
      }
    };
    exports2.TypeInfo.UpdateProcessRuleRequest.fields = {
      actions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RuleAction
      },
      conditions: {
        isArray: true,
        typeInfo: exports2.TypeInfo.RuleCondition
      }
    };
    exports2.TypeInfo.WorkItemStateResultModel.fields = {
      customizationType: {
        enumType: exports2.TypeInfo.CustomizationType
      }
    };
    exports2.TypeInfo.WorkItemTypeModel.fields = {
      class: {
        enumType: exports2.TypeInfo.WorkItemTypeClass
      },
      layout: {
        typeInfo: exports2.TypeInfo.FormLayout
      },
      states: {
        isArray: true,
        typeInfo: exports2.TypeInfo.WorkItemStateResultModel
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/WorkItemTrackingProcessApi.js
var require_WorkItemTrackingProcessApi = __commonJS({
  "../node_modules/azure-devops-node-api/WorkItemTrackingProcessApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkItemTrackingProcessApi = void 0;
    var basem = require_ClientApiBases();
    var WorkItemTrackingProcessInterfaces = require_WorkItemTrackingProcessInterfaces();
    var WorkItemTrackingProcessApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-WorkItemTracking-api", options);
      }
      /**
       * Creates a single behavior in the given process.
       *
       * @param {WorkItemTrackingProcessInterfaces.ProcessBehaviorCreateRequest} behavior
       * @param {string} processId - The ID of the process
       */
      createProcessBehavior(behavior, processId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "d1800200-f184-4e75-a5f2-ad0b04b4373e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, behavior, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessBehavior, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a behavior in the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} behaviorRefName - The reference name of the behavior
       */
      deleteProcessBehavior(processId, behaviorRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              behaviorRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "d1800200-f184-4e75-a5f2-ad0b04b4373e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a behavior of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} behaviorRefName - The reference name of the behavior
       * @param {WorkItemTrackingProcessInterfaces.GetBehaviorsExpand} expand
       */
      getProcessBehavior(processId, behaviorRefName, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              behaviorRefName
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "d1800200-f184-4e75-a5f2-ad0b04b4373e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessBehavior, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all behaviors in the process.
       *
       * @param {string} processId - The ID of the process
       * @param {WorkItemTrackingProcessInterfaces.GetBehaviorsExpand} expand
       */
      getProcessBehaviors(processId, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "d1800200-f184-4e75-a5f2-ad0b04b4373e", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessBehavior, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Replaces a behavior in the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.ProcessBehaviorUpdateRequest} behaviorData
       * @param {string} processId - The ID of the process
       * @param {string} behaviorRefName - The reference name of the behavior
       */
      updateProcessBehavior(behaviorData, processId, behaviorRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              behaviorRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "d1800200-f184-4e75-a5f2-ad0b04b4373e", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, behaviorData, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessBehavior, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a control in a group.
       *
       * @param {WorkItemTrackingProcessInterfaces.Control} control - The control.
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} groupId - The ID of the group to add the control to.
       */
      createControlInGroup(control, processId, witRefName, groupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              groupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "1f59b363-a2d0-4b7e-9bc6-eb9f5f3f0e58", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, control, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Moves a control to a specified group.
       *
       * @param {WorkItemTrackingProcessInterfaces.Control} control - The control.
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} groupId - The ID of the group to move the control to.
       * @param {string} controlId - The ID of the control.
       * @param {string} removeFromGroupId - The group ID to remove the control from.
       */
      moveControlToGroup(control, processId, witRefName, groupId, controlId, removeFromGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              groupId,
              controlId
            };
            let queryValues = {
              removeFromGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "1f59b363-a2d0-4b7e-9bc6-eb9f5f3f0e58", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, control, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a control from the work item form.
       *
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} groupId - The ID of the group.
       * @param {string} controlId - The ID of the control to remove.
       */
      removeControlFromGroup(processId, witRefName, groupId, controlId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              groupId,
              controlId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "1f59b363-a2d0-4b7e-9bc6-eb9f5f3f0e58", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a control on the work item form.
       *
       * @param {WorkItemTrackingProcessInterfaces.Control} control - The updated control.
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} groupId - The ID of the group.
       * @param {string} controlId - The ID of the control.
       */
      updateControl(control, processId, witRefName, groupId, controlId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              groupId,
              controlId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "1f59b363-a2d0-4b7e-9bc6-eb9f5f3f0e58", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, control, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a field to a work item type.
       *
       * @param {WorkItemTrackingProcessInterfaces.AddProcessWorkItemTypeFieldRequest} field
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       */
      addFieldToWorkItemType(field, processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "bc0ad8dc-e3f3-46b0-b06c-5bf861793196", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, field, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessWorkItemTypeField, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all fields in a work item type.
       *
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       */
      getAllWorkItemTypeFields(processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "bc0ad8dc-e3f3-46b0-b06c-5bf861793196", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessWorkItemTypeField, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a field in a work item type.
       *
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} fieldRefName - The reference name of the field.
       * @param {WorkItemTrackingProcessInterfaces.ProcessWorkItemTypeFieldsExpandLevel} expand
       */
      getWorkItemTypeField(processId, witRefName, fieldRefName, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              fieldRefName
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "bc0ad8dc-e3f3-46b0-b06c-5bf861793196", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessWorkItemTypeField, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a field from a work item type. Does not permanently delete the field.
       *
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} fieldRefName - The reference name of the field.
       */
      removeWorkItemTypeField(processId, witRefName, fieldRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              fieldRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "bc0ad8dc-e3f3-46b0-b06c-5bf861793196", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a field in a work item type.
       *
       * @param {WorkItemTrackingProcessInterfaces.UpdateProcessWorkItemTypeFieldRequest} field
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} fieldRefName - The reference name of the field.
       */
      updateWorkItemTypeField(field, processId, witRefName, fieldRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              fieldRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "bc0ad8dc-e3f3-46b0-b06c-5bf861793196", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, field, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessWorkItemTypeField, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a group to the work item form.
       *
       * @param {WorkItemTrackingProcessInterfaces.Group} group - The group.
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} pageId - The ID of the page to add the group to.
       * @param {string} sectionId - The ID of the section to add the group to.
       */
      addGroup(group2, processId, witRefName, pageId, sectionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "766e44e1-36a8-41d7-9050-c343ff02f7a5", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, group2, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Moves a group to a different page and section.
       *
       * @param {WorkItemTrackingProcessInterfaces.Group} group - The updated group.
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} pageId - The ID of the page the group is in.
       * @param {string} sectionId - The ID of the section the group is i.n
       * @param {string} groupId - The ID of the group.
       * @param {string} removeFromPageId - ID of the page to remove the group from.
       * @param {string} removeFromSectionId - ID of the section to remove the group from.
       */
      moveGroupToPage(group2, processId, witRefName, pageId, sectionId, groupId, removeFromPageId, removeFromSectionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (removeFromPageId == null) {
            throw new TypeError("removeFromPageId can not be null or undefined");
          }
          if (removeFromSectionId == null) {
            throw new TypeError("removeFromSectionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId,
              groupId
            };
            let queryValues = {
              removeFromPageId,
              removeFromSectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "766e44e1-36a8-41d7-9050-c343ff02f7a5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, group2, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Moves a group to a different section.
       *
       * @param {WorkItemTrackingProcessInterfaces.Group} group - The updated group.
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} pageId - The ID of the page the group is in.
       * @param {string} sectionId - The ID of the section the group is in.
       * @param {string} groupId - The ID of the group.
       * @param {string} removeFromSectionId - ID of the section to remove the group from.
       */
      moveGroupToSection(group2, processId, witRefName, pageId, sectionId, groupId, removeFromSectionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (removeFromSectionId == null) {
            throw new TypeError("removeFromSectionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId,
              groupId
            };
            let queryValues = {
              removeFromSectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "766e44e1-36a8-41d7-9050-c343ff02f7a5", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, group2, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a group from the work item form.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} pageId - The ID of the page the group is in
       * @param {string} sectionId - The ID of the section to the group is in
       * @param {string} groupId - The ID of the group
       */
      removeGroup(processId, witRefName, pageId, sectionId, groupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId,
              groupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "766e44e1-36a8-41d7-9050-c343ff02f7a5", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a group in the work item form.
       *
       * @param {WorkItemTrackingProcessInterfaces.Group} group - The updated group.
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} pageId - The ID of the page the group is in.
       * @param {string} sectionId - The ID of the section the group is in.
       * @param {string} groupId - The ID of the group.
       */
      updateGroup(group2, processId, witRefName, pageId, sectionId, groupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId,
              groupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "766e44e1-36a8-41d7-9050-c343ff02f7a5", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, group2, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the form layout.
       *
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       */
      getFormLayout(processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "fa8646eb-43cd-4b71-9564-40106fd63e40", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.FormLayout, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a picklist.
       *
       * @param {WorkItemTrackingProcessInterfaces.PickList} picklist - Picklist
       */
      createList(picklist) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "01e15468-e27c-4e20-a974-bd957dcccebc", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, picklist, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a picklist.
       *
       * @param {string} listId - The ID of the list
       */
      deleteList(listId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              listId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "01e15468-e27c-4e20-a974-bd957dcccebc", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a picklist.
       *
       * @param {string} listId - The ID of the list
       */
      getList(listId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              listId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "01e15468-e27c-4e20-a974-bd957dcccebc", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns meta data of the picklist.
       *
       */
      getListsMetadata() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "01e15468-e27c-4e20-a974-bd957dcccebc", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a list.
       *
       * @param {WorkItemTrackingProcessInterfaces.PickList} picklist
       * @param {string} listId - The ID of the list
       */
      updateList(picklist, listId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              listId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "01e15468-e27c-4e20-a974-bd957dcccebc", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, picklist, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a page to the work item form.
       *
       * @param {WorkItemTrackingProcessInterfaces.Page} page - The page.
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       */
      addPage(page, processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "1cc7b29f-6697-4d9d-b0a1-2650d3e1d584", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, page, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.Page, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a page from the work item form
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} pageId - The ID of the page
       */
      removePage(processId, witRefName, pageId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "1cc7b29f-6697-4d9d-b0a1-2650d3e1d584", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a page on the work item form
       *
       * @param {WorkItemTrackingProcessInterfaces.Page} page - The page
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      updatePage(page, processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "1cc7b29f-6697-4d9d-b0a1-2650d3e1d584", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, page, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.Page, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a process.
       *
       * @param {WorkItemTrackingProcessInterfaces.CreateProcessModel} createRequest - CreateProcessModel.
       */
      createNewProcess(createRequest) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "02cc6a73-5cfb-427d-8c8e-b49fb086e8af", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, createRequest, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessInfo, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a process of a specific ID.
       *
       * @param {string} processTypeId
       */
      deleteProcessById(processTypeId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processTypeId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "02cc6a73-5cfb-427d-8c8e-b49fb086e8af", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Edit a process of a specific ID.
       *
       * @param {WorkItemTrackingProcessInterfaces.UpdateProcessModel} updateRequest
       * @param {string} processTypeId
       */
      editProcess(updateRequest, processTypeId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processTypeId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "02cc6a73-5cfb-427d-8c8e-b49fb086e8af", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, updateRequest, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessInfo, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get list of all processes including system and inherited.
       *
       * @param {WorkItemTrackingProcessInterfaces.GetProcessExpandLevel} expand
       */
      getListOfProcesses(expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "02cc6a73-5cfb-427d-8c8e-b49fb086e8af", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessInfo, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Get a single process of a specified ID.
       *
       * @param {string} processTypeId
       * @param {WorkItemTrackingProcessInterfaces.GetProcessExpandLevel} expand
       */
      getProcessByItsId(processTypeId, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processTypeId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "02cc6a73-5cfb-427d-8c8e-b49fb086e8af", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessInfo, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a rule to work item type in the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.CreateProcessRuleRequest} processRuleCreate
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      addProcessWorkItemTypeRule(processRuleCreate, processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "76fe3432-d825-479d-a5f6-983bbb78b4f3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, processRuleCreate, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessRule, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a rule from the work item type in the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} ruleId - The ID of the rule
       */
      deleteProcessWorkItemTypeRule(processId, witRefName, ruleId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              ruleId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "76fe3432-d825-479d-a5f6-983bbb78b4f3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a single rule in the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} ruleId - The ID of the rule
       */
      getProcessWorkItemTypeRule(processId, witRefName, ruleId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              ruleId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "76fe3432-d825-479d-a5f6-983bbb78b4f3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessRule, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all rules in the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      getProcessWorkItemTypeRules(processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "76fe3432-d825-479d-a5f6-983bbb78b4f3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessRule, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a rule in the work item type of the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.UpdateProcessRuleRequest} processRule
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} ruleId - The ID of the rule
       */
      updateProcessWorkItemTypeRule(processRule, processId, witRefName, ruleId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              ruleId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "76fe3432-d825-479d-a5f6-983bbb78b4f3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, processRule, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessRule, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a state definition in the work item type of the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.WorkItemStateInputModel} stateModel
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      createStateDefinition(stateModel, processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "31015d57-2dff-4a46-adb3-2fb4ee3dcec9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, stateModel, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.WorkItemStateResultModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a state definition in the work item type of the process.
       *
       * @param {string} processId - ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} stateId - ID of the state
       */
      deleteStateDefinition(processId, witRefName, stateId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              stateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "31015d57-2dff-4a46-adb3-2fb4ee3dcec9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a single state definition in a work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} stateId - The ID of the state
       */
      getStateDefinition(processId, witRefName, stateId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              stateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "31015d57-2dff-4a46-adb3-2fb4ee3dcec9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.WorkItemStateResultModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all state definitions in a work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      getStateDefinitions(processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "31015d57-2dff-4a46-adb3-2fb4ee3dcec9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.WorkItemStateResultModel, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Hides a state definition in the work item type of the process.Only states with customizationType:System can be hidden.
       *
       * @param {WorkItemTrackingProcessInterfaces.HideStateModel} hideStateModel
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} stateId - The ID of the state
       */
      hideStateDefinition(hideStateModel, processId, witRefName, stateId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              stateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "31015d57-2dff-4a46-adb3-2fb4ee3dcec9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, hideStateModel, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.WorkItemStateResultModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a given state definition in the work item type of the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.WorkItemStateInputModel} stateModel
       * @param {string} processId - ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} stateId - ID of the state
       */
      updateStateDefinition(stateModel, processId, witRefName, stateId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              stateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "31015d57-2dff-4a46-adb3-2fb4ee3dcec9", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, stateModel, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.WorkItemStateResultModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Deletes a system control modification on the work item form.
       *
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} controlId - The ID of the control.
       */
      deleteSystemControl(processId, witRefName, controlId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              controlId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "ff9a3d2c-32b7-4c6c-991c-d5a251fb9098", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets edited system controls for a work item type in a process. To get all system controls (base + edited) use layout API(s)
       *
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       */
      getSystemControls(processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "ff9a3d2c-32b7-4c6c-991c-d5a251fb9098", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates/adds a system control on the work item form.
       *
       * @param {WorkItemTrackingProcessInterfaces.Control} control
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       * @param {string} controlId - The ID of the control.
       */
      updateSystemControl(control, processId, witRefName, controlId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              controlId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "ff9a3d2c-32b7-4c6c-991c-d5a251fb9098", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, control, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a work item type in the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.CreateProcessWorkItemTypeRequest} workItemType
       * @param {string} processId - The ID of the process on which to create work item type.
       */
      createProcessWorkItemType(workItemType, processId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "e2e9d1a6-432d-4062-8870-bfcb8c324ad7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, workItemType, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessWorkItemType, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a work item type in the process.
       *
       * @param {string} processId - The ID of the process.
       * @param {string} witRefName - The reference name of the work item type.
       */
      deleteProcessWorkItemType(processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "e2e9d1a6-432d-4062-8870-bfcb8c324ad7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a single work item type in a process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {WorkItemTrackingProcessInterfaces.GetWorkItemTypeExpand} expand - Flag to determine what properties of work item type to return
       */
      getProcessWorkItemType(processId, witRefName, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "e2e9d1a6-432d-4062-8870-bfcb8c324ad7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessWorkItemType, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all work item types in a process.
       *
       * @param {string} processId - The ID of the process
       * @param {WorkItemTrackingProcessInterfaces.GetWorkItemTypeExpand} expand - Flag to determine what properties of work item type to return
       */
      getProcessWorkItemTypes(processId, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "e2e9d1a6-432d-4062-8870-bfcb8c324ad7", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessWorkItemType, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a work item type of the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.UpdateProcessWorkItemTypeRequest} workItemTypeUpdate
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      updateProcessWorkItemType(workItemTypeUpdate, processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.2", "processes", "e2e9d1a6-432d-4062-8870-bfcb8c324ad7", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, workItemTypeUpdate, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessInterfaces.TypeInfo.ProcessWorkItemType, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a behavior to the work item type of the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.WorkItemTypeBehavior} behavior
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       */
      addBehaviorToWorkItemType(behavior, processId, witRefNameForBehaviors) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "6d765a2e-4e1b-4b11-be93-f953be676024", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, behavior, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a behavior for the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       * @param {string} behaviorRefName - The reference name of the behavior
       */
      getBehaviorForWorkItemType(processId, witRefNameForBehaviors, behaviorRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors,
              behaviorRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "6d765a2e-4e1b-4b11-be93-f953be676024", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all behaviors for the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       */
      getBehaviorsForWorkItemType(processId, witRefNameForBehaviors) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "6d765a2e-4e1b-4b11-be93-f953be676024", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a behavior for the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       * @param {string} behaviorRefName - The reference name of the behavior
       */
      removeBehaviorFromWorkItemType(processId, witRefNameForBehaviors, behaviorRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors,
              behaviorRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "6d765a2e-4e1b-4b11-be93-f953be676024", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a behavior for the work item type of the process.
       *
       * @param {WorkItemTrackingProcessInterfaces.WorkItemTypeBehavior} behavior
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       */
      updateBehaviorToWorkItemType(behavior, processId, witRefNameForBehaviors) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processes", "6d765a2e-4e1b-4b11-be93-f953be676024", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, behavior, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.WorkItemTrackingProcessApi = WorkItemTrackingProcessApi;
    WorkItemTrackingProcessApi.RESOURCE_AREA_ID = "5264459e-e5e0-4bd8-b118-0985e68a4ec5";
  }
});

// ../node_modules/azure-devops-node-api/interfaces/WorkItemTrackingProcessDefinitionsInterfaces.js
var require_WorkItemTrackingProcessDefinitionsInterfaces = __commonJS({
  "../node_modules/azure-devops-node-api/interfaces/WorkItemTrackingProcessDefinitionsInterfaces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.TypeInfo = exports2.WorkItemTypeClass = exports2.PageType = exports2.GetWorkItemTypeExpand = exports2.FieldType = void 0;
    var FieldType;
    (function(FieldType2) {
      FieldType2[FieldType2["String"] = 1] = "String";
      FieldType2[FieldType2["Integer"] = 2] = "Integer";
      FieldType2[FieldType2["DateTime"] = 3] = "DateTime";
      FieldType2[FieldType2["PlainText"] = 5] = "PlainText";
      FieldType2[FieldType2["Html"] = 7] = "Html";
      FieldType2[FieldType2["TreePath"] = 8] = "TreePath";
      FieldType2[FieldType2["History"] = 9] = "History";
      FieldType2[FieldType2["Double"] = 10] = "Double";
      FieldType2[FieldType2["Guid"] = 11] = "Guid";
      FieldType2[FieldType2["Boolean"] = 12] = "Boolean";
      FieldType2[FieldType2["Identity"] = 13] = "Identity";
      FieldType2[FieldType2["PicklistInteger"] = 14] = "PicklistInteger";
      FieldType2[FieldType2["PicklistString"] = 15] = "PicklistString";
      FieldType2[FieldType2["PicklistDouble"] = 16] = "PicklistDouble";
    })(FieldType = exports2.FieldType || (exports2.FieldType = {}));
    var GetWorkItemTypeExpand;
    (function(GetWorkItemTypeExpand2) {
      GetWorkItemTypeExpand2[GetWorkItemTypeExpand2["None"] = 0] = "None";
      GetWorkItemTypeExpand2[GetWorkItemTypeExpand2["States"] = 1] = "States";
      GetWorkItemTypeExpand2[GetWorkItemTypeExpand2["Behaviors"] = 2] = "Behaviors";
      GetWorkItemTypeExpand2[GetWorkItemTypeExpand2["Layout"] = 4] = "Layout";
    })(GetWorkItemTypeExpand = exports2.GetWorkItemTypeExpand || (exports2.GetWorkItemTypeExpand = {}));
    var PageType;
    (function(PageType2) {
      PageType2[PageType2["Custom"] = 1] = "Custom";
      PageType2[PageType2["History"] = 2] = "History";
      PageType2[PageType2["Links"] = 3] = "Links";
      PageType2[PageType2["Attachments"] = 4] = "Attachments";
    })(PageType = exports2.PageType || (exports2.PageType = {}));
    var WorkItemTypeClass;
    (function(WorkItemTypeClass2) {
      WorkItemTypeClass2[WorkItemTypeClass2["System"] = 0] = "System";
      WorkItemTypeClass2[WorkItemTypeClass2["Derived"] = 1] = "Derived";
      WorkItemTypeClass2[WorkItemTypeClass2["Custom"] = 2] = "Custom";
    })(WorkItemTypeClass = exports2.WorkItemTypeClass || (exports2.WorkItemTypeClass = {}));
    exports2.TypeInfo = {
      FieldModel: {},
      FieldType: {
        enumValues: {
          "string": 1,
          "integer": 2,
          "dateTime": 3,
          "plainText": 5,
          "html": 7,
          "treePath": 8,
          "history": 9,
          "double": 10,
          "guid": 11,
          "boolean": 12,
          "identity": 13,
          "picklistInteger": 14,
          "picklistString": 15,
          "picklistDouble": 16
        }
      },
      FormLayout: {},
      GetWorkItemTypeExpand: {
        enumValues: {
          "none": 0,
          "states": 1,
          "behaviors": 2,
          "layout": 4
        }
      },
      Page: {},
      PageType: {
        enumValues: {
          "custom": 1,
          "history": 2,
          "links": 3,
          "attachments": 4
        }
      },
      WorkItemTypeClass: {
        enumValues: {
          "system": 0,
          "derived": 1,
          "custom": 2
        }
      },
      WorkItemTypeFieldModel: {},
      WorkItemTypeFieldModel2: {},
      WorkItemTypeModel: {}
    };
    exports2.TypeInfo.FieldModel.fields = {
      type: {
        enumType: exports2.TypeInfo.FieldType
      }
    };
    exports2.TypeInfo.FormLayout.fields = {
      pages: {
        isArray: true,
        typeInfo: exports2.TypeInfo.Page
      }
    };
    exports2.TypeInfo.Page.fields = {
      pageType: {
        enumType: exports2.TypeInfo.PageType
      }
    };
    exports2.TypeInfo.WorkItemTypeFieldModel.fields = {
      type: {
        enumType: exports2.TypeInfo.FieldType
      }
    };
    exports2.TypeInfo.WorkItemTypeFieldModel2.fields = {
      type: {
        enumType: exports2.TypeInfo.FieldType
      }
    };
    exports2.TypeInfo.WorkItemTypeModel.fields = {
      class: {
        enumType: exports2.TypeInfo.WorkItemTypeClass
      },
      layout: {
        typeInfo: exports2.TypeInfo.FormLayout
      }
    };
  }
});

// ../node_modules/azure-devops-node-api/WorkItemTrackingProcessDefinitionsApi.js
var require_WorkItemTrackingProcessDefinitionsApi = __commonJS({
  "../node_modules/azure-devops-node-api/WorkItemTrackingProcessDefinitionsApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WorkItemTrackingProcessDefinitionsApi = void 0;
    var basem = require_ClientApiBases();
    var WorkItemTrackingProcessDefinitionsInterfaces = require_WorkItemTrackingProcessDefinitionsInterfaces();
    var WorkItemTrackingProcessDefinitionsApi = class extends basem.ClientApiBase {
      constructor(baseUrl, handlers, options) {
        super(baseUrl, handlers, "node-WorkItemTracking-api", options);
      }
      /**
       * Creates a single behavior in the given process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.BehaviorCreateModel} behavior
       * @param {string} processId - The ID of the process
       */
      createBehavior(behavior, processId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "47a651f4-fb70-43bf-b96b-7c0ba947142b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, behavior, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a behavior in the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} behaviorId - The ID of the behavior
       */
      deleteBehavior(processId, behaviorId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              behaviorId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "47a651f4-fb70-43bf-b96b-7c0ba947142b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a single behavior in the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} behaviorId - The ID of the behavior
       */
      getBehavior(processId, behaviorId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              behaviorId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "47a651f4-fb70-43bf-b96b-7c0ba947142b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all behaviors in the process.
       *
       * @param {string} processId - The ID of the process
       */
      getBehaviors(processId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "47a651f4-fb70-43bf-b96b-7c0ba947142b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Replaces a behavior in the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.BehaviorReplaceModel} behaviorData
       * @param {string} processId - The ID of the process
       * @param {string} behaviorId - The ID of the behavior
       */
      replaceBehavior(behaviorData, processId, behaviorId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              behaviorId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "47a651f4-fb70-43bf-b96b-7c0ba947142b", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, behaviorData, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a control in a group
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Control} control - The control
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} groupId - The ID of the group to add the control to
       */
      addControlToGroup(control, processId, witRefName, groupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              groupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "e2e3166a-627a-4e9b-85b2-d6a097bbd731", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, control, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a control on the work item form
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Control} control - The updated control
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} groupId - The ID of the group
       * @param {string} controlId - The ID of the control
       */
      editControl(control, processId, witRefName, groupId, controlId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              groupId,
              controlId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "e2e3166a-627a-4e9b-85b2-d6a097bbd731", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, control, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a control from the work item form
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} groupId - The ID of the group
       * @param {string} controlId - The ID of the control to remove
       */
      removeControlFromGroup(processId, witRefName, groupId, controlId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              groupId,
              controlId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "e2e3166a-627a-4e9b-85b2-d6a097bbd731", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Moves a control to a new group
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Control} control - The control
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} groupId - The ID of the group to move the control to
       * @param {string} controlId - The id of the control
       * @param {string} removeFromGroupId - The group to remove the control from
       */
      setControlInGroup(control, processId, witRefName, groupId, controlId, removeFromGroupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              groupId,
              controlId
            };
            let queryValues = {
              removeFromGroupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "e2e3166a-627a-4e9b-85b2-d6a097bbd731", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, control, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a single field in the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.FieldModel} field
       * @param {string} processId - The ID of the process
       */
      createField(field, processId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "f36c66c7-911d-4163-8938-d3c5d0d7f5aa", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, field, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.FieldModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a given field in the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.FieldUpdate} field
       * @param {string} processId - The ID of the process
       */
      updateField(field, processId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "f36c66c7-911d-4163-8938-d3c5d0d7f5aa", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, field, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.FieldModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a group to the work item form
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Group} group - The group
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} pageId - The ID of the page to add the group to
       * @param {string} sectionId - The ID of the section to add the group to
       */
      addGroup(group2, processId, witRefName, pageId, sectionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "2617828b-e850-4375-a92a-04855704d4c3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, group2, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a group in the work item form
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Group} group - The updated group
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} pageId - The ID of the page the group is in
       * @param {string} sectionId - The ID of the section the group is in
       * @param {string} groupId - The ID of the group
       */
      editGroup(group2, processId, witRefName, pageId, sectionId, groupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId,
              groupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "2617828b-e850-4375-a92a-04855704d4c3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, group2, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a group from the work item form
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} pageId - The ID of the page the group is in
       * @param {string} sectionId - The ID of the section to the group is in
       * @param {string} groupId - The ID of the group
       */
      removeGroup(processId, witRefName, pageId, sectionId, groupId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId,
              groupId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "2617828b-e850-4375-a92a-04855704d4c3", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Moves a group to a different page and section
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Group} group - The updated group
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} pageId - The ID of the page the group is in
       * @param {string} sectionId - The ID of the section the group is in
       * @param {string} groupId - The ID of the group
       * @param {string} removeFromPageId - ID of the page to remove the group from
       * @param {string} removeFromSectionId - ID of the section to remove the group from
       */
      setGroupInPage(group2, processId, witRefName, pageId, sectionId, groupId, removeFromPageId, removeFromSectionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (removeFromPageId == null) {
            throw new TypeError("removeFromPageId can not be null or undefined");
          }
          if (removeFromSectionId == null) {
            throw new TypeError("removeFromSectionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId,
              groupId
            };
            let queryValues = {
              removeFromPageId,
              removeFromSectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "2617828b-e850-4375-a92a-04855704d4c3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, group2, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Moves a group to a different section
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Group} group - The updated group
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} pageId - The ID of the page the group is in
       * @param {string} sectionId - The ID of the section the group is in
       * @param {string} groupId - The ID of the group
       * @param {string} removeFromSectionId - ID of the section to remove the group from
       */
      setGroupInSection(group2, processId, witRefName, pageId, sectionId, groupId, removeFromSectionId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (removeFromSectionId == null) {
            throw new TypeError("removeFromSectionId can not be null or undefined");
          }
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId,
              sectionId,
              groupId
            };
            let queryValues = {
              removeFromSectionId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "2617828b-e850-4375-a92a-04855704d4c3", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, group2, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Gets the form layout
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      getFormLayout(processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "3eacc80a-ddca-4404-857a-6331aac99063", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.FormLayout, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns meta data of the picklist.
       *
       */
      getListsMetadata() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "b45cc931-98e3-44a1-b1cd-2e8e9c6dc1c6", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a picklist.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.PickListModel} picklist
       */
      createList(picklist) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {};
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "0b6179e2-23ce-46b2-b094-2ffa5ee70286", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, picklist, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a picklist.
       *
       * @param {string} listId - The ID of the list
       */
      deleteList(listId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              listId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "0b6179e2-23ce-46b2-b094-2ffa5ee70286", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a picklist.
       *
       * @param {string} listId - The ID of the list
       */
      getList(listId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              listId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "0b6179e2-23ce-46b2-b094-2ffa5ee70286", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a list.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.PickListModel} picklist
       * @param {string} listId - The ID of the list
       */
      updateList(picklist, listId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              listId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "0b6179e2-23ce-46b2-b094-2ffa5ee70286", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, picklist, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a page to the work item form
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Page} page - The page
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      addPage(page, processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "1b4ac126-59b2-4f37-b4df-0a48ba807edb", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, page, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.Page, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a page on the work item form
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.Page} page - The page
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      editPage(page, processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "1b4ac126-59b2-4f37-b4df-0a48ba807edb", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, page, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.Page, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a page from the work item form
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} pageId - The ID of the page
       */
      removePage(processId, witRefName, pageId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              pageId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "1b4ac126-59b2-4f37-b4df-0a48ba807edb", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a state definition in the work item type of the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.WorkItemStateInputModel} stateModel
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      createStateDefinition(stateModel, processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "4303625d-08f4-4461-b14b-32c65bba5599", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, stateModel, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a state definition in the work item type of the process.
       *
       * @param {string} processId - ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} stateId - ID of the state
       */
      deleteStateDefinition(processId, witRefName, stateId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              stateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "4303625d-08f4-4461-b14b-32c65bba5599", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a state definition in the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} stateId - The ID of the state
       */
      getStateDefinition(processId, witRefName, stateId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              stateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "4303625d-08f4-4461-b14b-32c65bba5599", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all state definitions in the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      getStateDefinitions(processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "4303625d-08f4-4461-b14b-32c65bba5599", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Hides a state definition in the work item type of the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.HideStateModel} hideStateModel
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} stateId - The ID of the state
       */
      hideStateDefinition(hideStateModel, processId, witRefName, stateId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              stateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "4303625d-08f4-4461-b14b-32c65bba5599", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.replace(url, hideStateModel, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a given state definition in the work item type of the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.WorkItemStateInputModel} stateModel
       * @param {string} processId - ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {string} stateId - ID of the state
       */
      updateStateDefinition(stateModel, processId, witRefName, stateId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName,
              stateId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "4303625d-08f4-4461-b14b-32c65bba5599", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, stateModel, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a behavior to the work item type of the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.WorkItemTypeBehavior} behavior
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       */
      addBehaviorToWorkItemType(behavior, processId, witRefNameForBehaviors) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "921dfb88-ef57-4c69-94e5-dd7da2d7031d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, behavior, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a behavior for the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       * @param {string} behaviorRefName - The reference name of the behavior
       */
      getBehaviorForWorkItemType(processId, witRefNameForBehaviors, behaviorRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors,
              behaviorRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "921dfb88-ef57-4c69-94e5-dd7da2d7031d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all behaviors for the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       */
      getBehaviorsForWorkItemType(processId, witRefNameForBehaviors) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "921dfb88-ef57-4c69-94e5-dd7da2d7031d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, null, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a behavior for the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       * @param {string} behaviorRefName - The reference name of the behavior
       */
      removeBehaviorFromWorkItemType(processId, witRefNameForBehaviors, behaviorRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors,
              behaviorRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "921dfb88-ef57-4c69-94e5-dd7da2d7031d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates default work item type for the behavior of the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.WorkItemTypeBehavior} behavior
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForBehaviors - Work item type reference name for the behavior
       */
      updateBehaviorToWorkItemType(behavior, processId, witRefNameForBehaviors) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForBehaviors
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "921dfb88-ef57-4c69-94e5-dd7da2d7031d", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, behavior, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Creates a work item type in the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.WorkItemTypeModel} workItemType
       * @param {string} processId - The ID of the process
       */
      createWorkItemType(workItemType, processId) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "1ce0acad-4638-49c3-969c-04aa65ba6bea", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, workItemType, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.WorkItemTypeModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a work item type in the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      deleteWorkItemType(processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "1ce0acad-4638-49c3-969c-04aa65ba6bea", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.GetWorkItemTypeExpand} expand
       */
      getWorkItemType(processId, witRefName, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "1ce0acad-4638-49c3-969c-04aa65ba6bea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.WorkItemTypeModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all work item types in the process.
       *
       * @param {string} processId - The ID of the process
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.GetWorkItemTypeExpand} expand
       */
      getWorkItemTypes(processId, expand) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId
            };
            let queryValues = {
              "$expand": expand
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "1ce0acad-4638-49c3-969c-04aa65ba6bea", routeValues, queryValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.WorkItemTypeModel, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a work item type of the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.WorkItemTypeUpdateModel} workItemTypeUpdate
       * @param {string} processId - The ID of the process
       * @param {string} witRefName - The reference name of the work item type
       */
      updateWorkItemType(workItemTypeUpdate, processId, witRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "1ce0acad-4638-49c3-969c-04aa65ba6bea", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, workItemTypeUpdate, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.WorkItemTypeModel, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Adds a field to the work item type in the process.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.WorkItemTypeFieldModel2} field
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForFields - Work item type reference name for the field
       */
      addFieldToWorkItemType(field, processId, witRefNameForFields) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForFields
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "976713b4-a62e-499e-94dc-eeb869ea9126", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.create(url, field, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.WorkItemTypeFieldModel2, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a single field in the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForFields - Work item type reference name for fields
       * @param {string} fieldRefName - The reference name of the field
       */
      getWorkItemTypeField(processId, witRefNameForFields, fieldRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForFields,
              fieldRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "976713b4-a62e-499e-94dc-eeb869ea9126", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.WorkItemTypeFieldModel2, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Returns a list of all fields in the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForFields - Work item type reference name for fields
       */
      getWorkItemTypeFields(processId, witRefNameForFields) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForFields
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "976713b4-a62e-499e-94dc-eeb869ea9126", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.get(url, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.WorkItemTypeFieldModel2, true);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Removes a field in the work item type of the process.
       *
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForFields - Work item type reference name for fields
       * @param {string} fieldRefName - The reference name of the field
       */
      removeFieldFromWorkItemType(processId, witRefNameForFields, fieldRefName) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForFields,
              fieldRefName
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "976713b4-a62e-499e-94dc-eeb869ea9126", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.del(url, options);
              let ret = this.formatResponse(res.result, null, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Updates a single field in the scope of the given process and work item type.
       *
       * @param {WorkItemTrackingProcessDefinitionsInterfaces.WorkItemTypeFieldModel2} field - The model with which to update the field
       * @param {string} processId - The ID of the process
       * @param {string} witRefNameForFields - Work item type reference name for fields
       */
      updateWorkItemTypeField(field, processId, witRefNameForFields) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            let routeValues = {
              processId,
              witRefNameForFields
            };
            try {
              let verData = yield this.vsoClient.getVersioningData("7.2-preview.1", "processDefinitions", "976713b4-a62e-499e-94dc-eeb869ea9126", routeValues);
              let url = verData.requestUrl;
              let options = this.createRequestOptions("application/json", verData.apiVersion);
              let res;
              res = yield this.rest.update(url, field, options);
              let ret = this.formatResponse(res.result, WorkItemTrackingProcessDefinitionsInterfaces.TypeInfo.WorkItemTypeFieldModel2, false);
              resolve(ret);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
    };
    exports2.WorkItemTrackingProcessDefinitionsApi = WorkItemTrackingProcessDefinitionsApi;
    WorkItemTrackingProcessDefinitionsApi.RESOURCE_AREA_ID = "5264459e-e5e0-4bd8-b118-0985e68a4ec5";
  }
});

// ../node_modules/azure-devops-node-api/node_modules/typed-rest-client/handlers/basiccreds.js
var require_basiccreds = __commonJS({
  "../node_modules/azure-devops-node-api/node_modules/typed-rest-client/handlers/basiccreds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BasicCredentialHandler = void 0;
    var BasicCredentialHandler = class {
      constructor(username, password, allowCrossOriginAuthentication) {
        this.username = username;
        this.password = password;
        this.allowCrossOriginAuthentication = allowCrossOriginAuthentication;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!this.origin) {
          this.origin = options.host;
        }
        if (this.origin === options.host || this.allowCrossOriginAuthentication) {
          options.headers["Authorization"] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
        }
        options.headers["X-TFS-FedAuthRedirect"] = "Suppress";
      }
      // This handler cannot handle 401
      canHandleAuthentication(response) {
        return false;
      }
      handleAuthentication(httpClient, requestInfo, objs) {
        return null;
      }
    };
    exports2.BasicCredentialHandler = BasicCredentialHandler;
  }
});

// ../node_modules/azure-devops-node-api/node_modules/typed-rest-client/handlers/bearertoken.js
var require_bearertoken = __commonJS({
  "../node_modules/azure-devops-node-api/node_modules/typed-rest-client/handlers/bearertoken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BearerCredentialHandler = void 0;
    var BearerCredentialHandler = class {
      constructor(token, allowCrossOriginAuthentication) {
        this.token = token;
        this.allowCrossOriginAuthentication = allowCrossOriginAuthentication;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!this.origin) {
          this.origin = options.host;
        }
        if (this.origin === options.host || this.allowCrossOriginAuthentication) {
          options.headers["Authorization"] = `Bearer ${this.token}`;
        }
        options.headers["X-TFS-FedAuthRedirect"] = "Suppress";
      }
      // This handler cannot handle 401
      canHandleAuthentication(response) {
        return false;
      }
      handleAuthentication(httpClient, requestInfo, objs) {
        return null;
      }
    };
    exports2.BearerCredentialHandler = BearerCredentialHandler;
  }
});

// ../node_modules/underscore/modules/_setup.js
var VERSION2, root, ArrayProto, ObjProto, SymbolProto, push, slice, toString, hasOwnProperty, supportsArrayBuffer, supportsDataView, nativeIsArray, nativeKeys, nativeCreate, nativeIsView, _isNaN, _isFinite, hasEnumBug, nonEnumerableProps, MAX_ARRAY_INDEX;
var init_setup = __esm({
  "../node_modules/underscore/modules/_setup.js"() {
    VERSION2 = "1.13.6";
    root = typeof self == "object" && self.self === self && self || typeof global == "object" && global.global === global && global || Function("return this")() || {};
    ArrayProto = Array.prototype;
    ObjProto = Object.prototype;
    SymbolProto = typeof Symbol !== "undefined" ? Symbol.prototype : null;
    push = ArrayProto.push;
    slice = ArrayProto.slice;
    toString = ObjProto.toString;
    hasOwnProperty = ObjProto.hasOwnProperty;
    supportsArrayBuffer = typeof ArrayBuffer !== "undefined";
    supportsDataView = typeof DataView !== "undefined";
    nativeIsArray = Array.isArray;
    nativeKeys = Object.keys;
    nativeCreate = Object.create;
    nativeIsView = supportsArrayBuffer && ArrayBuffer.isView;
    _isNaN = isNaN;
    _isFinite = isFinite;
    hasEnumBug = !{ toString: null }.propertyIsEnumerable("toString");
    nonEnumerableProps = [
      "valueOf",
      "isPrototypeOf",
      "toString",
      "propertyIsEnumerable",
      "hasOwnProperty",
      "toLocaleString"
    ];
    MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  }
});

// ../node_modules/underscore/modules/restArguments.js
function restArguments(func, startIndex) {
  startIndex = startIndex == null ? func.length - 1 : +startIndex;
  return function() {
    var length = Math.max(arguments.length - startIndex, 0), rest2 = Array(length), index = 0;
    for (; index < length; index++) {
      rest2[index] = arguments[index + startIndex];
    }
    switch (startIndex) {
      case 0:
        return func.call(this, rest2);
      case 1:
        return func.call(this, arguments[0], rest2);
      case 2:
        return func.call(this, arguments[0], arguments[1], rest2);
    }
    var args = Array(startIndex + 1);
    for (index = 0; index < startIndex; index++) {
      args[index] = arguments[index];
    }
    args[startIndex] = rest2;
    return func.apply(this, args);
  };
}
var init_restArguments = __esm({
  "../node_modules/underscore/modules/restArguments.js"() {
  }
});

// ../node_modules/underscore/modules/isObject.js
function isObject(obj) {
  var type = typeof obj;
  return type === "function" || type === "object" && !!obj;
}
var init_isObject = __esm({
  "../node_modules/underscore/modules/isObject.js"() {
  }
});

// ../node_modules/underscore/modules/isNull.js
function isNull(obj) {
  return obj === null;
}
var init_isNull = __esm({
  "../node_modules/underscore/modules/isNull.js"() {
  }
});

// ../node_modules/underscore/modules/isUndefined.js
function isUndefined(obj) {
  return obj === void 0;
}
var init_isUndefined = __esm({
  "../node_modules/underscore/modules/isUndefined.js"() {
  }
});

// ../node_modules/underscore/modules/isBoolean.js
function isBoolean(obj) {
  return obj === true || obj === false || toString.call(obj) === "[object Boolean]";
}
var init_isBoolean = __esm({
  "../node_modules/underscore/modules/isBoolean.js"() {
    init_setup();
  }
});

// ../node_modules/underscore/modules/isElement.js
function isElement(obj) {
  return !!(obj && obj.nodeType === 1);
}
var init_isElement = __esm({
  "../node_modules/underscore/modules/isElement.js"() {
  }
});

// ../node_modules/underscore/modules/_tagTester.js
function tagTester(name) {
  var tag = "[object " + name + "]";
  return function(obj) {
    return toString.call(obj) === tag;
  };
}
var init_tagTester = __esm({
  "../node_modules/underscore/modules/_tagTester.js"() {
    init_setup();
  }
});

// ../node_modules/underscore/modules/isString.js
var isString_default;
var init_isString = __esm({
  "../node_modules/underscore/modules/isString.js"() {
    init_tagTester();
    isString_default = tagTester("String");
  }
});

// ../node_modules/underscore/modules/isNumber.js
var isNumber_default;
var init_isNumber = __esm({
  "../node_modules/underscore/modules/isNumber.js"() {
    init_tagTester();
    isNumber_default = tagTester("Number");
  }
});

// ../node_modules/underscore/modules/isDate.js
var isDate_default;
var init_isDate = __esm({
  "../node_modules/underscore/modules/isDate.js"() {
    init_tagTester();
    isDate_default = tagTester("Date");
  }
});

// ../node_modules/underscore/modules/isRegExp.js
var isRegExp_default;
var init_isRegExp = __esm({
  "../node_modules/underscore/modules/isRegExp.js"() {
    init_tagTester();
    isRegExp_default = tagTester("RegExp");
  }
});

// ../node_modules/underscore/modules/isError.js
var isError_default;
var init_isError = __esm({
  "../node_modules/underscore/modules/isError.js"() {
    init_tagTester();
    isError_default = tagTester("Error");
  }
});

// ../node_modules/underscore/modules/isSymbol.js
var isSymbol_default;
var init_isSymbol = __esm({
  "../node_modules/underscore/modules/isSymbol.js"() {
    init_tagTester();
    isSymbol_default = tagTester("Symbol");
  }
});

// ../node_modules/underscore/modules/isArrayBuffer.js
var isArrayBuffer_default;
var init_isArrayBuffer = __esm({
  "../node_modules/underscore/modules/isArrayBuffer.js"() {
    init_tagTester();
    isArrayBuffer_default = tagTester("ArrayBuffer");
  }
});

// ../node_modules/underscore/modules/isFunction.js
var isFunction, nodelist, isFunction_default;
var init_isFunction = __esm({
  "../node_modules/underscore/modules/isFunction.js"() {
    init_tagTester();
    init_setup();
    isFunction = tagTester("Function");
    nodelist = root.document && root.document.childNodes;
    if (typeof /./ != "function" && typeof Int8Array != "object" && typeof nodelist != "function") {
      isFunction = function(obj) {
        return typeof obj == "function" || false;
      };
    }
    isFunction_default = isFunction;
  }
});

// ../node_modules/underscore/modules/_hasObjectTag.js
var hasObjectTag_default;
var init_hasObjectTag = __esm({
  "../node_modules/underscore/modules/_hasObjectTag.js"() {
    init_tagTester();
    hasObjectTag_default = tagTester("Object");
  }
});

// ../node_modules/underscore/modules/_stringTagBug.js
var hasStringTagBug, isIE11;
var init_stringTagBug = __esm({
  "../node_modules/underscore/modules/_stringTagBug.js"() {
    init_setup();
    init_hasObjectTag();
    hasStringTagBug = supportsDataView && hasObjectTag_default(new DataView(new ArrayBuffer(8)));
    isIE11 = typeof Map !== "undefined" && hasObjectTag_default(/* @__PURE__ */ new Map());
  }
});

// ../node_modules/underscore/modules/isDataView.js
function ie10IsDataView(obj) {
  return obj != null && isFunction_default(obj.getInt8) && isArrayBuffer_default(obj.buffer);
}
var isDataView, isDataView_default;
var init_isDataView = __esm({
  "../node_modules/underscore/modules/isDataView.js"() {
    init_tagTester();
    init_isFunction();
    init_isArrayBuffer();
    init_stringTagBug();
    isDataView = tagTester("DataView");
    isDataView_default = hasStringTagBug ? ie10IsDataView : isDataView;
  }
});

// ../node_modules/underscore/modules/isArray.js
var isArray_default;
var init_isArray = __esm({
  "../node_modules/underscore/modules/isArray.js"() {
    init_setup();
    init_tagTester();
    isArray_default = nativeIsArray || tagTester("Array");
  }
});

// ../node_modules/underscore/modules/_has.js
function has(obj, key) {
  return obj != null && hasOwnProperty.call(obj, key);
}
var init_has = __esm({
  "../node_modules/underscore/modules/_has.js"() {
    init_setup();
  }
});

// ../node_modules/underscore/modules/isArguments.js
var isArguments, isArguments_default;
var init_isArguments = __esm({
  "../node_modules/underscore/modules/isArguments.js"() {
    init_tagTester();
    init_has();
    isArguments = tagTester("Arguments");
    (function() {
      if (!isArguments(arguments)) {
        isArguments = function(obj) {
          return has(obj, "callee");
        };
      }
    })();
    isArguments_default = isArguments;
  }
});

// ../node_modules/underscore/modules/isFinite.js
function isFinite2(obj) {
  return !isSymbol_default(obj) && _isFinite(obj) && !isNaN(parseFloat(obj));
}
var init_isFinite = __esm({
  "../node_modules/underscore/modules/isFinite.js"() {
    init_setup();
    init_isSymbol();
  }
});

// ../node_modules/underscore/modules/isNaN.js
function isNaN2(obj) {
  return isNumber_default(obj) && _isNaN(obj);
}
var init_isNaN = __esm({
  "../node_modules/underscore/modules/isNaN.js"() {
    init_setup();
    init_isNumber();
  }
});

// ../node_modules/underscore/modules/constant.js
function constant(value) {
  return function() {
    return value;
  };
}
var init_constant = __esm({
  "../node_modules/underscore/modules/constant.js"() {
  }
});

// ../node_modules/underscore/modules/_createSizePropertyCheck.js
function createSizePropertyCheck(getSizeProperty) {
  return function(collection) {
    var sizeProperty = getSizeProperty(collection);
    return typeof sizeProperty == "number" && sizeProperty >= 0 && sizeProperty <= MAX_ARRAY_INDEX;
  };
}
var init_createSizePropertyCheck = __esm({
  "../node_modules/underscore/modules/_createSizePropertyCheck.js"() {
    init_setup();
  }
});

// ../node_modules/underscore/modules/_shallowProperty.js
function shallowProperty(key) {
  return function(obj) {
    return obj == null ? void 0 : obj[key];
  };
}
var init_shallowProperty = __esm({
  "../node_modules/underscore/modules/_shallowProperty.js"() {
  }
});

// ../node_modules/underscore/modules/_getByteLength.js
var getByteLength_default;
var init_getByteLength = __esm({
  "../node_modules/underscore/modules/_getByteLength.js"() {
    init_shallowProperty();
    getByteLength_default = shallowProperty("byteLength");
  }
});

// ../node_modules/underscore/modules/_isBufferLike.js
var isBufferLike_default;
var init_isBufferLike = __esm({
  "../node_modules/underscore/modules/_isBufferLike.js"() {
    init_createSizePropertyCheck();
    init_getByteLength();
    isBufferLike_default = createSizePropertyCheck(getByteLength_default);
  }
});

// ../node_modules/underscore/modules/isTypedArray.js
function isTypedArray(obj) {
  return nativeIsView ? nativeIsView(obj) && !isDataView_default(obj) : isBufferLike_default(obj) && typedArrayPattern.test(toString.call(obj));
}
var typedArrayPattern, isTypedArray_default;
var init_isTypedArray = __esm({
  "../node_modules/underscore/modules/isTypedArray.js"() {
    init_setup();
    init_isDataView();
    init_constant();
    init_isBufferLike();
    typedArrayPattern = /\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;
    isTypedArray_default = supportsArrayBuffer ? isTypedArray : constant(false);
  }
});

// ../node_modules/underscore/modules/_getLength.js
var getLength_default;
var init_getLength = __esm({
  "../node_modules/underscore/modules/_getLength.js"() {
    init_shallowProperty();
    getLength_default = shallowProperty("length");
  }
});

// ../node_modules/underscore/modules/_collectNonEnumProps.js
function emulatedSet(keys2) {
  var hash = {};
  for (var l = keys2.length, i = 0; i < l; ++i) hash[keys2[i]] = true;
  return {
    contains: function(key) {
      return hash[key] === true;
    },
    push: function(key) {
      hash[key] = true;
      return keys2.push(key);
    }
  };
}
function collectNonEnumProps(obj, keys2) {
  keys2 = emulatedSet(keys2);
  var nonEnumIdx = nonEnumerableProps.length;
  var constructor = obj.constructor;
  var proto = isFunction_default(constructor) && constructor.prototype || ObjProto;
  var prop = "constructor";
  if (has(obj, prop) && !keys2.contains(prop)) keys2.push(prop);
  while (nonEnumIdx--) {
    prop = nonEnumerableProps[nonEnumIdx];
    if (prop in obj && obj[prop] !== proto[prop] && !keys2.contains(prop)) {
      keys2.push(prop);
    }
  }
}
var init_collectNonEnumProps = __esm({
  "../node_modules/underscore/modules/_collectNonEnumProps.js"() {
    init_setup();
    init_isFunction();
    init_has();
  }
});

// ../node_modules/underscore/modules/keys.js
function keys(obj) {
  if (!isObject(obj)) return [];
  if (nativeKeys) return nativeKeys(obj);
  var keys2 = [];
  for (var key in obj) if (has(obj, key)) keys2.push(key);
  if (hasEnumBug) collectNonEnumProps(obj, keys2);
  return keys2;
}
var init_keys = __esm({
  "../node_modules/underscore/modules/keys.js"() {
    init_isObject();
    init_setup();
    init_has();
    init_collectNonEnumProps();
  }
});

// ../node_modules/underscore/modules/isEmpty.js
function isEmpty(obj) {
  if (obj == null) return true;
  var length = getLength_default(obj);
  if (typeof length == "number" && (isArray_default(obj) || isString_default(obj) || isArguments_default(obj))) return length === 0;
  return getLength_default(keys(obj)) === 0;
}
var init_isEmpty = __esm({
  "../node_modules/underscore/modules/isEmpty.js"() {
    init_getLength();
    init_isArray();
    init_isString();
    init_isArguments();
    init_keys();
  }
});

// ../node_modules/underscore/modules/isMatch.js
function isMatch(object2, attrs) {
  var _keys = keys(attrs), length = _keys.length;
  if (object2 == null) return !length;
  var obj = Object(object2);
  for (var i = 0; i < length; i++) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) return false;
  }
  return true;
}
var init_isMatch = __esm({
  "../node_modules/underscore/modules/isMatch.js"() {
    init_keys();
  }
});

// ../node_modules/underscore/modules/underscore.js
function _(obj) {
  if (obj instanceof _) return obj;
  if (!(this instanceof _)) return new _(obj);
  this._wrapped = obj;
}
var init_underscore = __esm({
  "../node_modules/underscore/modules/underscore.js"() {
    init_setup();
    _.VERSION = VERSION2;
    _.prototype.value = function() {
      return this._wrapped;
    };
    _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
    _.prototype.toString = function() {
      return String(this._wrapped);
    };
  }
});

// ../node_modules/underscore/modules/_toBufferView.js
function toBufferView(bufferSource) {
  return new Uint8Array(
    bufferSource.buffer || bufferSource,
    bufferSource.byteOffset || 0,
    getByteLength_default(bufferSource)
  );
}
var init_toBufferView = __esm({
  "../node_modules/underscore/modules/_toBufferView.js"() {
    init_getByteLength();
  }
});

// ../node_modules/underscore/modules/isEqual.js
function eq(a, b, aStack, bStack) {
  if (a === b) return a !== 0 || 1 / a === 1 / b;
  if (a == null || b == null) return false;
  if (a !== a) return b !== b;
  var type = typeof a;
  if (type !== "function" && type !== "object" && typeof b != "object") return false;
  return deepEq(a, b, aStack, bStack);
}
function deepEq(a, b, aStack, bStack) {
  if (a instanceof _) a = a._wrapped;
  if (b instanceof _) b = b._wrapped;
  var className = toString.call(a);
  if (className !== toString.call(b)) return false;
  if (hasStringTagBug && className == "[object Object]" && isDataView_default(a)) {
    if (!isDataView_default(b)) return false;
    className = tagDataView;
  }
  switch (className) {
    // These types are compared by value.
    case "[object RegExp]":
    // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
    case "[object String]":
      return "" + a === "" + b;
    case "[object Number]":
      if (+a !== +a) return +b !== +b;
      return +a === 0 ? 1 / +a === 1 / b : +a === +b;
    case "[object Date]":
    case "[object Boolean]":
      return +a === +b;
    case "[object Symbol]":
      return SymbolProto.valueOf.call(a) === SymbolProto.valueOf.call(b);
    case "[object ArrayBuffer]":
    case tagDataView:
      return deepEq(toBufferView(a), toBufferView(b), aStack, bStack);
  }
  var areArrays = className === "[object Array]";
  if (!areArrays && isTypedArray_default(a)) {
    var byteLength = getByteLength_default(a);
    if (byteLength !== getByteLength_default(b)) return false;
    if (a.buffer === b.buffer && a.byteOffset === b.byteOffset) return true;
    areArrays = true;
  }
  if (!areArrays) {
    if (typeof a != "object" || typeof b != "object") return false;
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(isFunction_default(aCtor) && aCtor instanceof aCtor && isFunction_default(bCtor) && bCtor instanceof bCtor) && ("constructor" in a && "constructor" in b)) {
      return false;
    }
  }
  aStack = aStack || [];
  bStack = bStack || [];
  var length = aStack.length;
  while (length--) {
    if (aStack[length] === a) return bStack[length] === b;
  }
  aStack.push(a);
  bStack.push(b);
  if (areArrays) {
    length = a.length;
    if (length !== b.length) return false;
    while (length--) {
      if (!eq(a[length], b[length], aStack, bStack)) return false;
    }
  } else {
    var _keys = keys(a), key;
    length = _keys.length;
    if (keys(b).length !== length) return false;
    while (length--) {
      key = _keys[length];
      if (!(has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
    }
  }
  aStack.pop();
  bStack.pop();
  return true;
}
function isEqual(a, b) {
  return eq(a, b);
}
var tagDataView;
var init_isEqual = __esm({
  "../node_modules/underscore/modules/isEqual.js"() {
    init_underscore();
    init_setup();
    init_getByteLength();
    init_isTypedArray();
    init_isFunction();
    init_stringTagBug();
    init_isDataView();
    init_keys();
    init_has();
    init_toBufferView();
    tagDataView = "[object DataView]";
  }
});

// ../node_modules/underscore/modules/allKeys.js
function allKeys(obj) {
  if (!isObject(obj)) return [];
  var keys2 = [];
  for (var key in obj) keys2.push(key);
  if (hasEnumBug) collectNonEnumProps(obj, keys2);
  return keys2;
}
var init_allKeys = __esm({
  "../node_modules/underscore/modules/allKeys.js"() {
    init_isObject();
    init_setup();
    init_collectNonEnumProps();
  }
});

// ../node_modules/underscore/modules/_methodFingerprint.js
function ie11fingerprint(methods) {
  var length = getLength_default(methods);
  return function(obj) {
    if (obj == null) return false;
    var keys2 = allKeys(obj);
    if (getLength_default(keys2)) return false;
    for (var i = 0; i < length; i++) {
      if (!isFunction_default(obj[methods[i]])) return false;
    }
    return methods !== weakMapMethods || !isFunction_default(obj[forEachName]);
  };
}
var forEachName, hasName, commonInit, mapTail, mapMethods, weakMapMethods, setMethods;
var init_methodFingerprint = __esm({
  "../node_modules/underscore/modules/_methodFingerprint.js"() {
    init_getLength();
    init_isFunction();
    init_allKeys();
    forEachName = "forEach";
    hasName = "has";
    commonInit = ["clear", "delete"];
    mapTail = ["get", hasName, "set"];
    mapMethods = commonInit.concat(forEachName, mapTail);
    weakMapMethods = commonInit.concat(mapTail);
    setMethods = ["add"].concat(commonInit, forEachName, hasName);
  }
});

// ../node_modules/underscore/modules/isMap.js
var isMap_default;
var init_isMap = __esm({
  "../node_modules/underscore/modules/isMap.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isMap_default = isIE11 ? ie11fingerprint(mapMethods) : tagTester("Map");
  }
});

// ../node_modules/underscore/modules/isWeakMap.js
var isWeakMap_default;
var init_isWeakMap = __esm({
  "../node_modules/underscore/modules/isWeakMap.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isWeakMap_default = isIE11 ? ie11fingerprint(weakMapMethods) : tagTester("WeakMap");
  }
});

// ../node_modules/underscore/modules/isSet.js
var isSet_default;
var init_isSet = __esm({
  "../node_modules/underscore/modules/isSet.js"() {
    init_tagTester();
    init_stringTagBug();
    init_methodFingerprint();
    isSet_default = isIE11 ? ie11fingerprint(setMethods) : tagTester("Set");
  }
});

// ../node_modules/underscore/modules/isWeakSet.js
var isWeakSet_default;
var init_isWeakSet = __esm({
  "../node_modules/underscore/modules/isWeakSet.js"() {
    init_tagTester();
    isWeakSet_default = tagTester("WeakSet");
  }
});

// ../node_modules/underscore/modules/values.js
function values(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var values2 = Array(length);
  for (var i = 0; i < length; i++) {
    values2[i] = obj[_keys[i]];
  }
  return values2;
}
var init_values = __esm({
  "../node_modules/underscore/modules/values.js"() {
    init_keys();
  }
});

// ../node_modules/underscore/modules/pairs.js
function pairs(obj) {
  var _keys = keys(obj);
  var length = _keys.length;
  var pairs2 = Array(length);
  for (var i = 0; i < length; i++) {
    pairs2[i] = [_keys[i], obj[_keys[i]]];
  }
  return pairs2;
}
var init_pairs = __esm({
  "../node_modules/underscore/modules/pairs.js"() {
    init_keys();
  }
});

// ../node_modules/underscore/modules/invert.js
function invert(obj) {
  var result2 = {};
  var _keys = keys(obj);
  for (var i = 0, length = _keys.length; i < length; i++) {
    result2[obj[_keys[i]]] = _keys[i];
  }
  return result2;
}
var init_invert = __esm({
  "../node_modules/underscore/modules/invert.js"() {
    init_keys();
  }
});

// ../node_modules/underscore/modules/functions.js
function functions(obj) {
  var names = [];
  for (var key in obj) {
    if (isFunction_default(obj[key])) names.push(key);
  }
  return names.sort();
}
var init_functions = __esm({
  "../node_modules/underscore/modules/functions.js"() {
    init_isFunction();
  }
});

// ../node_modules/underscore/modules/_createAssigner.js
function createAssigner(keysFunc, defaults) {
  return function(obj) {
    var length = arguments.length;
    if (defaults) obj = Object(obj);
    if (length < 2 || obj == null) return obj;
    for (var index = 1; index < length; index++) {
      var source = arguments[index], keys2 = keysFunc(source), l = keys2.length;
      for (var i = 0; i < l; i++) {
        var key = keys2[i];
        if (!defaults || obj[key] === void 0) obj[key] = source[key];
      }
    }
    return obj;
  };
}
var init_createAssigner = __esm({
  "../node_modules/underscore/modules/_createAssigner.js"() {
  }
});

// ../node_modules/underscore/modules/extend.js
var extend_default;
var init_extend = __esm({
  "../node_modules/underscore/modules/extend.js"() {
    init_createAssigner();
    init_allKeys();
    extend_default = createAssigner(allKeys);
  }
});

// ../node_modules/underscore/modules/extendOwn.js
var extendOwn_default;
var init_extendOwn = __esm({
  "../node_modules/underscore/modules/extendOwn.js"() {
    init_createAssigner();
    init_keys();
    extendOwn_default = createAssigner(keys);
  }
});

// ../node_modules/underscore/modules/defaults.js
var defaults_default;
var init_defaults = __esm({
  "../node_modules/underscore/modules/defaults.js"() {
    init_createAssigner();
    init_allKeys();
    defaults_default = createAssigner(allKeys, true);
  }
});

// ../node_modules/underscore/modules/_baseCreate.js
function ctor() {
  return function() {
  };
}
function baseCreate(prototype) {
  if (!isObject(prototype)) return {};
  if (nativeCreate) return nativeCreate(prototype);
  var Ctor = ctor();
  Ctor.prototype = prototype;
  var result2 = new Ctor();
  Ctor.prototype = null;
  return result2;
}
var init_baseCreate = __esm({
  "../node_modules/underscore/modules/_baseCreate.js"() {
    init_isObject();
    init_setup();
  }
});

// ../node_modules/underscore/modules/create.js
function create(prototype, props) {
  var result2 = baseCreate(prototype);
  if (props) extendOwn_default(result2, props);
  return result2;
}
var init_create = __esm({
  "../node_modules/underscore/modules/create.js"() {
    init_baseCreate();
    init_extendOwn();
  }
});

// ../node_modules/underscore/modules/clone.js
function clone(obj) {
  if (!isObject(obj)) return obj;
  return isArray_default(obj) ? obj.slice() : extend_default({}, obj);
}
var init_clone = __esm({
  "../node_modules/underscore/modules/clone.js"() {
    init_isObject();
    init_isArray();
    init_extend();
  }
});

// ../node_modules/underscore/modules/tap.js
function tap(obj, interceptor) {
  interceptor(obj);
  return obj;
}
var init_tap = __esm({
  "../node_modules/underscore/modules/tap.js"() {
  }
});

// ../node_modules/underscore/modules/toPath.js
function toPath(path2) {
  return isArray_default(path2) ? path2 : [path2];
}
var init_toPath = __esm({
  "../node_modules/underscore/modules/toPath.js"() {
    init_underscore();
    init_isArray();
    _.toPath = toPath;
  }
});

// ../node_modules/underscore/modules/_toPath.js
function toPath2(path2) {
  return _.toPath(path2);
}
var init_toPath2 = __esm({
  "../node_modules/underscore/modules/_toPath.js"() {
    init_underscore();
    init_toPath();
  }
});

// ../node_modules/underscore/modules/_deepGet.js
function deepGet(obj, path2) {
  var length = path2.length;
  for (var i = 0; i < length; i++) {
    if (obj == null) return void 0;
    obj = obj[path2[i]];
  }
  return length ? obj : void 0;
}
var init_deepGet = __esm({
  "../node_modules/underscore/modules/_deepGet.js"() {
  }
});

// ../node_modules/underscore/modules/get.js
function get(object2, path2, defaultValue) {
  var value = deepGet(object2, toPath2(path2));
  return isUndefined(value) ? defaultValue : value;
}
var init_get = __esm({
  "../node_modules/underscore/modules/get.js"() {
    init_toPath2();
    init_deepGet();
    init_isUndefined();
  }
});

// ../node_modules/underscore/modules/has.js
function has2(obj, path2) {
  path2 = toPath2(path2);
  var length = path2.length;
  for (var i = 0; i < length; i++) {
    var key = path2[i];
    if (!has(obj, key)) return false;
    obj = obj[key];
  }
  return !!length;
}
var init_has2 = __esm({
  "../node_modules/underscore/modules/has.js"() {
    init_has();
    init_toPath2();
  }
});

// ../node_modules/underscore/modules/identity.js
function identity(value) {
  return value;
}
var init_identity = __esm({
  "../node_modules/underscore/modules/identity.js"() {
  }
});

// ../node_modules/underscore/modules/matcher.js
function matcher(attrs) {
  attrs = extendOwn_default({}, attrs);
  return function(obj) {
    return isMatch(obj, attrs);
  };
}
var init_matcher = __esm({
  "../node_modules/underscore/modules/matcher.js"() {
    init_extendOwn();
    init_isMatch();
  }
});

// ../node_modules/underscore/modules/property.js
function property(path2) {
  path2 = toPath2(path2);
  return function(obj) {
    return deepGet(obj, path2);
  };
}
var init_property = __esm({
  "../node_modules/underscore/modules/property.js"() {
    init_deepGet();
    init_toPath2();
  }
});

// ../node_modules/underscore/modules/_optimizeCb.js
function optimizeCb(func, context, argCount) {
  if (context === void 0) return func;
  switch (argCount == null ? 3 : argCount) {
    case 1:
      return function(value) {
        return func.call(context, value);
      };
    // The 2-argument case is omitted because we’re not using it.
    case 3:
      return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
    case 4:
      return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
  }
  return function() {
    return func.apply(context, arguments);
  };
}
var init_optimizeCb = __esm({
  "../node_modules/underscore/modules/_optimizeCb.js"() {
  }
});

// ../node_modules/underscore/modules/_baseIteratee.js
function baseIteratee(value, context, argCount) {
  if (value == null) return identity;
  if (isFunction_default(value)) return optimizeCb(value, context, argCount);
  if (isObject(value) && !isArray_default(value)) return matcher(value);
  return property(value);
}
var init_baseIteratee = __esm({
  "../node_modules/underscore/modules/_baseIteratee.js"() {
    init_identity();
    init_isFunction();
    init_isObject();
    init_isArray();
    init_matcher();
    init_property();
    init_optimizeCb();
  }
});

// ../node_modules/underscore/modules/iteratee.js
function iteratee(value, context) {
  return baseIteratee(value, context, Infinity);
}
var init_iteratee = __esm({
  "../node_modules/underscore/modules/iteratee.js"() {
    init_underscore();
    init_baseIteratee();
    _.iteratee = iteratee;
  }
});

// ../node_modules/underscore/modules/_cb.js
function cb(value, context, argCount) {
  if (_.iteratee !== iteratee) return _.iteratee(value, context);
  return baseIteratee(value, context, argCount);
}
var init_cb = __esm({
  "../node_modules/underscore/modules/_cb.js"() {
    init_underscore();
    init_baseIteratee();
    init_iteratee();
  }
});

// ../node_modules/underscore/modules/mapObject.js
function mapObject(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = keys(obj), length = _keys.length, results = {};
  for (var index = 0; index < length; index++) {
    var currentKey = _keys[index];
    results[currentKey] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}
var init_mapObject = __esm({
  "../node_modules/underscore/modules/mapObject.js"() {
    init_cb();
    init_keys();
  }
});

// ../node_modules/underscore/modules/noop.js
function noop() {
}
var init_noop = __esm({
  "../node_modules/underscore/modules/noop.js"() {
  }
});

// ../node_modules/underscore/modules/propertyOf.js
function propertyOf(obj) {
  if (obj == null) return noop;
  return function(path2) {
    return get(obj, path2);
  };
}
var init_propertyOf = __esm({
  "../node_modules/underscore/modules/propertyOf.js"() {
    init_noop();
    init_get();
  }
});

// ../node_modules/underscore/modules/times.js
function times(n, iteratee2, context) {
  var accum = Array(Math.max(0, n));
  iteratee2 = optimizeCb(iteratee2, context, 1);
  for (var i = 0; i < n; i++) accum[i] = iteratee2(i);
  return accum;
}
var init_times = __esm({
  "../node_modules/underscore/modules/times.js"() {
    init_optimizeCb();
  }
});

// ../node_modules/underscore/modules/random.js
function random(min2, max2) {
  if (max2 == null) {
    max2 = min2;
    min2 = 0;
  }
  return min2 + Math.floor(Math.random() * (max2 - min2 + 1));
}
var init_random = __esm({
  "../node_modules/underscore/modules/random.js"() {
  }
});

// ../node_modules/underscore/modules/now.js
var now_default;
var init_now = __esm({
  "../node_modules/underscore/modules/now.js"() {
    now_default = Date.now || function() {
      return (/* @__PURE__ */ new Date()).getTime();
    };
  }
});

// ../node_modules/underscore/modules/_createEscaper.js
function createEscaper(map2) {
  var escaper = function(match) {
    return map2[match];
  };
  var source = "(?:" + keys(map2).join("|") + ")";
  var testRegexp = RegExp(source);
  var replaceRegexp = RegExp(source, "g");
  return function(string) {
    string = string == null ? "" : "" + string;
    return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
  };
}
var init_createEscaper = __esm({
  "../node_modules/underscore/modules/_createEscaper.js"() {
    init_keys();
  }
});

// ../node_modules/underscore/modules/_escapeMap.js
var escapeMap_default;
var init_escapeMap = __esm({
  "../node_modules/underscore/modules/_escapeMap.js"() {
    escapeMap_default = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#x27;",
      "`": "&#x60;"
    };
  }
});

// ../node_modules/underscore/modules/escape.js
var escape_default;
var init_escape = __esm({
  "../node_modules/underscore/modules/escape.js"() {
    init_createEscaper();
    init_escapeMap();
    escape_default = createEscaper(escapeMap_default);
  }
});

// ../node_modules/underscore/modules/_unescapeMap.js
var unescapeMap_default;
var init_unescapeMap = __esm({
  "../node_modules/underscore/modules/_unescapeMap.js"() {
    init_invert();
    init_escapeMap();
    unescapeMap_default = invert(escapeMap_default);
  }
});

// ../node_modules/underscore/modules/unescape.js
var unescape_default;
var init_unescape = __esm({
  "../node_modules/underscore/modules/unescape.js"() {
    init_createEscaper();
    init_unescapeMap();
    unescape_default = createEscaper(unescapeMap_default);
  }
});

// ../node_modules/underscore/modules/templateSettings.js
var templateSettings_default;
var init_templateSettings = __esm({
  "../node_modules/underscore/modules/templateSettings.js"() {
    init_underscore();
    templateSettings_default = _.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    };
  }
});

// ../node_modules/underscore/modules/template.js
function escapeChar(match) {
  return "\\" + escapes[match];
}
function template(text, settings, oldSettings) {
  if (!settings && oldSettings) settings = oldSettings;
  settings = defaults_default({}, settings, _.templateSettings);
  var matcher2 = RegExp([
    (settings.escape || noMatch).source,
    (settings.interpolate || noMatch).source,
    (settings.evaluate || noMatch).source
  ].join("|") + "|$", "g");
  var index = 0;
  var source = "__p+='";
  text.replace(matcher2, function(match, escape2, interpolate, evaluate, offset) {
    source += text.slice(index, offset).replace(escapeRegExp, escapeChar);
    index = offset + match.length;
    if (escape2) {
      source += "'+\n((__t=(" + escape2 + "))==null?'':_.escape(__t))+\n'";
    } else if (interpolate) {
      source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
    } else if (evaluate) {
      source += "';\n" + evaluate + "\n__p+='";
    }
    return match;
  });
  source += "';\n";
  var argument = settings.variable;
  if (argument) {
    if (!bareIdentifier.test(argument)) throw new Error(
      "variable is not a bare identifier: " + argument
    );
  } else {
    source = "with(obj||{}){\n" + source + "}\n";
    argument = "obj";
  }
  source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
  var render;
  try {
    render = new Function(argument, "_", source);
  } catch (e) {
    e.source = source;
    throw e;
  }
  var template2 = function(data) {
    return render.call(this, data, _);
  };
  template2.source = "function(" + argument + "){\n" + source + "}";
  return template2;
}
var noMatch, escapes, escapeRegExp, bareIdentifier;
var init_template = __esm({
  "../node_modules/underscore/modules/template.js"() {
    init_defaults();
    init_underscore();
    init_templateSettings();
    noMatch = /(.)^/;
    escapes = {
      "'": "'",
      "\\": "\\",
      "\r": "r",
      "\n": "n",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    escapeRegExp = /\\|'|\r|\n|\u2028|\u2029/g;
    bareIdentifier = /^\s*(\w|\$)+\s*$/;
  }
});

// ../node_modules/underscore/modules/result.js
function result(obj, path2, fallback) {
  path2 = toPath2(path2);
  var length = path2.length;
  if (!length) {
    return isFunction_default(fallback) ? fallback.call(obj) : fallback;
  }
  for (var i = 0; i < length; i++) {
    var prop = obj == null ? void 0 : obj[path2[i]];
    if (prop === void 0) {
      prop = fallback;
      i = length;
    }
    obj = isFunction_default(prop) ? prop.call(obj) : prop;
  }
  return obj;
}
var init_result = __esm({
  "../node_modules/underscore/modules/result.js"() {
    init_isFunction();
    init_toPath2();
  }
});

// ../node_modules/underscore/modules/uniqueId.js
function uniqueId(prefix) {
  var id = ++idCounter + "";
  return prefix ? prefix + id : id;
}
var idCounter;
var init_uniqueId = __esm({
  "../node_modules/underscore/modules/uniqueId.js"() {
    idCounter = 0;
  }
});

// ../node_modules/underscore/modules/chain.js
function chain(obj) {
  var instance = _(obj);
  instance._chain = true;
  return instance;
}
var init_chain = __esm({
  "../node_modules/underscore/modules/chain.js"() {
    init_underscore();
  }
});

// ../node_modules/underscore/modules/_executeBound.js
function executeBound(sourceFunc, boundFunc, context, callingContext, args) {
  if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
  var self2 = baseCreate(sourceFunc.prototype);
  var result2 = sourceFunc.apply(self2, args);
  if (isObject(result2)) return result2;
  return self2;
}
var init_executeBound = __esm({
  "../node_modules/underscore/modules/_executeBound.js"() {
    init_baseCreate();
    init_isObject();
  }
});

// ../node_modules/underscore/modules/partial.js
var partial, partial_default;
var init_partial = __esm({
  "../node_modules/underscore/modules/partial.js"() {
    init_restArguments();
    init_executeBound();
    init_underscore();
    partial = restArguments(function(func, boundArgs) {
      var placeholder = partial.placeholder;
      var bound = function() {
        var position = 0, length = boundArgs.length;
        var args = Array(length);
        for (var i = 0; i < length; i++) {
          args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i];
        }
        while (position < arguments.length) args.push(arguments[position++]);
        return executeBound(func, bound, this, this, args);
      };
      return bound;
    });
    partial.placeholder = _;
    partial_default = partial;
  }
});

// ../node_modules/underscore/modules/bind.js
var bind_default;
var init_bind = __esm({
  "../node_modules/underscore/modules/bind.js"() {
    init_restArguments();
    init_isFunction();
    init_executeBound();
    bind_default = restArguments(function(func, context, args) {
      if (!isFunction_default(func)) throw new TypeError("Bind must be called on a function");
      var bound = restArguments(function(callArgs) {
        return executeBound(func, bound, context, this, args.concat(callArgs));
      });
      return bound;
    });
  }
});

// ../node_modules/underscore/modules/_isArrayLike.js
var isArrayLike_default;
var init_isArrayLike = __esm({
  "../node_modules/underscore/modules/_isArrayLike.js"() {
    init_createSizePropertyCheck();
    init_getLength();
    isArrayLike_default = createSizePropertyCheck(getLength_default);
  }
});

// ../node_modules/underscore/modules/_flatten.js
function flatten(input, depth, strict, output) {
  output = output || [];
  if (!depth && depth !== 0) {
    depth = Infinity;
  } else if (depth <= 0) {
    return output.concat(input);
  }
  var idx = output.length;
  for (var i = 0, length = getLength_default(input); i < length; i++) {
    var value = input[i];
    if (isArrayLike_default(value) && (isArray_default(value) || isArguments_default(value))) {
      if (depth > 1) {
        flatten(value, depth - 1, strict, output);
        idx = output.length;
      } else {
        var j = 0, len = value.length;
        while (j < len) output[idx++] = value[j++];
      }
    } else if (!strict) {
      output[idx++] = value;
    }
  }
  return output;
}
var init_flatten = __esm({
  "../node_modules/underscore/modules/_flatten.js"() {
    init_getLength();
    init_isArrayLike();
    init_isArray();
    init_isArguments();
  }
});

// ../node_modules/underscore/modules/bindAll.js
var bindAll_default;
var init_bindAll = __esm({
  "../node_modules/underscore/modules/bindAll.js"() {
    init_restArguments();
    init_flatten();
    init_bind();
    bindAll_default = restArguments(function(obj, keys2) {
      keys2 = flatten(keys2, false, false);
      var index = keys2.length;
      if (index < 1) throw new Error("bindAll must be passed function names");
      while (index--) {
        var key = keys2[index];
        obj[key] = bind_default(obj[key], obj);
      }
      return obj;
    });
  }
});

// ../node_modules/underscore/modules/memoize.js
function memoize(func, hasher) {
  var memoize2 = function(key) {
    var cache = memoize2.cache;
    var address = "" + (hasher ? hasher.apply(this, arguments) : key);
    if (!has(cache, address)) cache[address] = func.apply(this, arguments);
    return cache[address];
  };
  memoize2.cache = {};
  return memoize2;
}
var init_memoize = __esm({
  "../node_modules/underscore/modules/memoize.js"() {
    init_has();
  }
});

// ../node_modules/underscore/modules/delay.js
var delay_default;
var init_delay = __esm({
  "../node_modules/underscore/modules/delay.js"() {
    init_restArguments();
    delay_default = restArguments(function(func, wait, args) {
      return setTimeout(function() {
        return func.apply(null, args);
      }, wait);
    });
  }
});

// ../node_modules/underscore/modules/defer.js
var defer_default;
var init_defer = __esm({
  "../node_modules/underscore/modules/defer.js"() {
    init_partial();
    init_delay();
    init_underscore();
    defer_default = partial_default(delay_default, _, 1);
  }
});

// ../node_modules/underscore/modules/throttle.js
function throttle(func, wait, options) {
  var timeout, context, args, result2;
  var previous = 0;
  if (!options) options = {};
  var later = function() {
    previous = options.leading === false ? 0 : now_default();
    timeout = null;
    result2 = func.apply(context, args);
    if (!timeout) context = args = null;
  };
  var throttled = function() {
    var _now = now_default();
    if (!previous && options.leading === false) previous = _now;
    var remaining = wait - (_now - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout) {
        clearTimeout(timeout);
        timeout = null;
      }
      previous = _now;
      result2 = func.apply(context, args);
      if (!timeout) context = args = null;
    } else if (!timeout && options.trailing !== false) {
      timeout = setTimeout(later, remaining);
    }
    return result2;
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
    previous = 0;
    timeout = context = args = null;
  };
  return throttled;
}
var init_throttle = __esm({
  "../node_modules/underscore/modules/throttle.js"() {
    init_now();
  }
});

// ../node_modules/underscore/modules/debounce.js
function debounce(func, wait, immediate) {
  var timeout, previous, args, result2, context;
  var later = function() {
    var passed = now_default() - previous;
    if (wait > passed) {
      timeout = setTimeout(later, wait - passed);
    } else {
      timeout = null;
      if (!immediate) result2 = func.apply(context, args);
      if (!timeout) args = context = null;
    }
  };
  var debounced = restArguments(function(_args) {
    context = this;
    args = _args;
    previous = now_default();
    if (!timeout) {
      timeout = setTimeout(later, wait);
      if (immediate) result2 = func.apply(context, args);
    }
    return result2;
  });
  debounced.cancel = function() {
    clearTimeout(timeout);
    timeout = args = context = null;
  };
  return debounced;
}
var init_debounce = __esm({
  "../node_modules/underscore/modules/debounce.js"() {
    init_restArguments();
    init_now();
  }
});

// ../node_modules/underscore/modules/wrap.js
function wrap(func, wrapper) {
  return partial_default(wrapper, func);
}
var init_wrap = __esm({
  "../node_modules/underscore/modules/wrap.js"() {
    init_partial();
  }
});

// ../node_modules/underscore/modules/negate.js
function negate(predicate) {
  return function() {
    return !predicate.apply(this, arguments);
  };
}
var init_negate = __esm({
  "../node_modules/underscore/modules/negate.js"() {
  }
});

// ../node_modules/underscore/modules/compose.js
function compose() {
  var args = arguments;
  var start = args.length - 1;
  return function() {
    var i = start;
    var result2 = args[start].apply(this, arguments);
    while (i--) result2 = args[i].call(this, result2);
    return result2;
  };
}
var init_compose = __esm({
  "../node_modules/underscore/modules/compose.js"() {
  }
});

// ../node_modules/underscore/modules/after.js
function after(times2, func) {
  return function() {
    if (--times2 < 1) {
      return func.apply(this, arguments);
    }
  };
}
var init_after = __esm({
  "../node_modules/underscore/modules/after.js"() {
  }
});

// ../node_modules/underscore/modules/before.js
function before(times2, func) {
  var memo;
  return function() {
    if (--times2 > 0) {
      memo = func.apply(this, arguments);
    }
    if (times2 <= 1) func = null;
    return memo;
  };
}
var init_before = __esm({
  "../node_modules/underscore/modules/before.js"() {
  }
});

// ../node_modules/underscore/modules/once.js
var once_default;
var init_once = __esm({
  "../node_modules/underscore/modules/once.js"() {
    init_partial();
    init_before();
    once_default = partial_default(before, 2);
  }
});

// ../node_modules/underscore/modules/findKey.js
function findKey(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = keys(obj), key;
  for (var i = 0, length = _keys.length; i < length; i++) {
    key = _keys[i];
    if (predicate(obj[key], key, obj)) return key;
  }
}
var init_findKey = __esm({
  "../node_modules/underscore/modules/findKey.js"() {
    init_cb();
    init_keys();
  }
});

// ../node_modules/underscore/modules/_createPredicateIndexFinder.js
function createPredicateIndexFinder(dir) {
  return function(array, predicate, context) {
    predicate = cb(predicate, context);
    var length = getLength_default(array);
    var index = dir > 0 ? 0 : length - 1;
    for (; index >= 0 && index < length; index += dir) {
      if (predicate(array[index], index, array)) return index;
    }
    return -1;
  };
}
var init_createPredicateIndexFinder = __esm({
  "../node_modules/underscore/modules/_createPredicateIndexFinder.js"() {
    init_cb();
    init_getLength();
  }
});

// ../node_modules/underscore/modules/findIndex.js
var findIndex_default;
var init_findIndex = __esm({
  "../node_modules/underscore/modules/findIndex.js"() {
    init_createPredicateIndexFinder();
    findIndex_default = createPredicateIndexFinder(1);
  }
});

// ../node_modules/underscore/modules/findLastIndex.js
var findLastIndex_default;
var init_findLastIndex = __esm({
  "../node_modules/underscore/modules/findLastIndex.js"() {
    init_createPredicateIndexFinder();
    findLastIndex_default = createPredicateIndexFinder(-1);
  }
});

// ../node_modules/underscore/modules/sortedIndex.js
function sortedIndex(array, obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context, 1);
  var value = iteratee2(obj);
  var low = 0, high = getLength_default(array);
  while (low < high) {
    var mid = Math.floor((low + high) / 2);
    if (iteratee2(array[mid]) < value) low = mid + 1;
    else high = mid;
  }
  return low;
}
var init_sortedIndex = __esm({
  "../node_modules/underscore/modules/sortedIndex.js"() {
    init_cb();
    init_getLength();
  }
});

// ../node_modules/underscore/modules/_createIndexFinder.js
function createIndexFinder(dir, predicateFind, sortedIndex2) {
  return function(array, item, idx) {
    var i = 0, length = getLength_default(array);
    if (typeof idx == "number") {
      if (dir > 0) {
        i = idx >= 0 ? idx : Math.max(idx + length, i);
      } else {
        length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
      }
    } else if (sortedIndex2 && idx && length) {
      idx = sortedIndex2(array, item);
      return array[idx] === item ? idx : -1;
    }
    if (item !== item) {
      idx = predicateFind(slice.call(array, i, length), isNaN2);
      return idx >= 0 ? idx + i : -1;
    }
    for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
      if (array[idx] === item) return idx;
    }
    return -1;
  };
}
var init_createIndexFinder = __esm({
  "../node_modules/underscore/modules/_createIndexFinder.js"() {
    init_getLength();
    init_setup();
    init_isNaN();
  }
});

// ../node_modules/underscore/modules/indexOf.js
var indexOf_default;
var init_indexOf = __esm({
  "../node_modules/underscore/modules/indexOf.js"() {
    init_sortedIndex();
    init_findIndex();
    init_createIndexFinder();
    indexOf_default = createIndexFinder(1, findIndex_default, sortedIndex);
  }
});

// ../node_modules/underscore/modules/lastIndexOf.js
var lastIndexOf_default;
var init_lastIndexOf = __esm({
  "../node_modules/underscore/modules/lastIndexOf.js"() {
    init_findLastIndex();
    init_createIndexFinder();
    lastIndexOf_default = createIndexFinder(-1, findLastIndex_default);
  }
});

// ../node_modules/underscore/modules/find.js
function find(obj, predicate, context) {
  var keyFinder = isArrayLike_default(obj) ? findIndex_default : findKey;
  var key = keyFinder(obj, predicate, context);
  if (key !== void 0 && key !== -1) return obj[key];
}
var init_find = __esm({
  "../node_modules/underscore/modules/find.js"() {
    init_isArrayLike();
    init_findIndex();
    init_findKey();
  }
});

// ../node_modules/underscore/modules/findWhere.js
function findWhere(obj, attrs) {
  return find(obj, matcher(attrs));
}
var init_findWhere = __esm({
  "../node_modules/underscore/modules/findWhere.js"() {
    init_find();
    init_matcher();
  }
});

// ../node_modules/underscore/modules/each.js
function each(obj, iteratee2, context) {
  iteratee2 = optimizeCb(iteratee2, context);
  var i, length;
  if (isArrayLike_default(obj)) {
    for (i = 0, length = obj.length; i < length; i++) {
      iteratee2(obj[i], i, obj);
    }
  } else {
    var _keys = keys(obj);
    for (i = 0, length = _keys.length; i < length; i++) {
      iteratee2(obj[_keys[i]], _keys[i], obj);
    }
  }
  return obj;
}
var init_each = __esm({
  "../node_modules/underscore/modules/each.js"() {
    init_optimizeCb();
    init_isArrayLike();
    init_keys();
  }
});

// ../node_modules/underscore/modules/map.js
function map(obj, iteratee2, context) {
  iteratee2 = cb(iteratee2, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length, results = Array(length);
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    results[index] = iteratee2(obj[currentKey], currentKey, obj);
  }
  return results;
}
var init_map = __esm({
  "../node_modules/underscore/modules/map.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// ../node_modules/underscore/modules/_createReduce.js
function createReduce(dir) {
  var reducer = function(obj, iteratee2, memo, initial2) {
    var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length, index = dir > 0 ? 0 : length - 1;
    if (!initial2) {
      memo = obj[_keys ? _keys[index] : index];
      index += dir;
    }
    for (; index >= 0 && index < length; index += dir) {
      var currentKey = _keys ? _keys[index] : index;
      memo = iteratee2(memo, obj[currentKey], currentKey, obj);
    }
    return memo;
  };
  return function(obj, iteratee2, memo, context) {
    var initial2 = arguments.length >= 3;
    return reducer(obj, optimizeCb(iteratee2, context, 4), memo, initial2);
  };
}
var init_createReduce = __esm({
  "../node_modules/underscore/modules/_createReduce.js"() {
    init_isArrayLike();
    init_keys();
    init_optimizeCb();
  }
});

// ../node_modules/underscore/modules/reduce.js
var reduce_default;
var init_reduce = __esm({
  "../node_modules/underscore/modules/reduce.js"() {
    init_createReduce();
    reduce_default = createReduce(1);
  }
});

// ../node_modules/underscore/modules/reduceRight.js
var reduceRight_default;
var init_reduceRight = __esm({
  "../node_modules/underscore/modules/reduceRight.js"() {
    init_createReduce();
    reduceRight_default = createReduce(-1);
  }
});

// ../node_modules/underscore/modules/filter.js
function filter(obj, predicate, context) {
  var results = [];
  predicate = cb(predicate, context);
  each(obj, function(value, index, list) {
    if (predicate(value, index, list)) results.push(value);
  });
  return results;
}
var init_filter = __esm({
  "../node_modules/underscore/modules/filter.js"() {
    init_cb();
    init_each();
  }
});

// ../node_modules/underscore/modules/reject.js
function reject(obj, predicate, context) {
  return filter(obj, negate(cb(predicate)), context);
}
var init_reject = __esm({
  "../node_modules/underscore/modules/reject.js"() {
    init_filter();
    init_negate();
    init_cb();
  }
});

// ../node_modules/underscore/modules/every.js
function every(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (!predicate(obj[currentKey], currentKey, obj)) return false;
  }
  return true;
}
var init_every = __esm({
  "../node_modules/underscore/modules/every.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// ../node_modules/underscore/modules/some.js
function some(obj, predicate, context) {
  predicate = cb(predicate, context);
  var _keys = !isArrayLike_default(obj) && keys(obj), length = (_keys || obj).length;
  for (var index = 0; index < length; index++) {
    var currentKey = _keys ? _keys[index] : index;
    if (predicate(obj[currentKey], currentKey, obj)) return true;
  }
  return false;
}
var init_some = __esm({
  "../node_modules/underscore/modules/some.js"() {
    init_cb();
    init_isArrayLike();
    init_keys();
  }
});

// ../node_modules/underscore/modules/contains.js
function contains(obj, item, fromIndex, guard) {
  if (!isArrayLike_default(obj)) obj = values(obj);
  if (typeof fromIndex != "number" || guard) fromIndex = 0;
  return indexOf_default(obj, item, fromIndex) >= 0;
}
var init_contains = __esm({
  "../node_modules/underscore/modules/contains.js"() {
    init_isArrayLike();
    init_values();
    init_indexOf();
  }
});

// ../node_modules/underscore/modules/invoke.js
var invoke_default;
var init_invoke = __esm({
  "../node_modules/underscore/modules/invoke.js"() {
    init_restArguments();
    init_isFunction();
    init_map();
    init_deepGet();
    init_toPath2();
    invoke_default = restArguments(function(obj, path2, args) {
      var contextPath, func;
      if (isFunction_default(path2)) {
        func = path2;
      } else {
        path2 = toPath2(path2);
        contextPath = path2.slice(0, -1);
        path2 = path2[path2.length - 1];
      }
      return map(obj, function(context) {
        var method = func;
        if (!method) {
          if (contextPath && contextPath.length) {
            context = deepGet(context, contextPath);
          }
          if (context == null) return void 0;
          method = context[path2];
        }
        return method == null ? method : method.apply(context, args);
      });
    });
  }
});

// ../node_modules/underscore/modules/pluck.js
function pluck(obj, key) {
  return map(obj, property(key));
}
var init_pluck = __esm({
  "../node_modules/underscore/modules/pluck.js"() {
    init_map();
    init_property();
  }
});

// ../node_modules/underscore/modules/where.js
function where(obj, attrs) {
  return filter(obj, matcher(attrs));
}
var init_where = __esm({
  "../node_modules/underscore/modules/where.js"() {
    init_filter();
    init_matcher();
  }
});

// ../node_modules/underscore/modules/max.js
function max(obj, iteratee2, context) {
  var result2 = -Infinity, lastComputed = -Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike_default(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value > result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj, function(v, index, list) {
      computed = iteratee2(v, index, list);
      if (computed > lastComputed || computed === -Infinity && result2 === -Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
var init_max = __esm({
  "../node_modules/underscore/modules/max.js"() {
    init_isArrayLike();
    init_values();
    init_cb();
    init_each();
  }
});

// ../node_modules/underscore/modules/min.js
function min(obj, iteratee2, context) {
  var result2 = Infinity, lastComputed = Infinity, value, computed;
  if (iteratee2 == null || typeof iteratee2 == "number" && typeof obj[0] != "object" && obj != null) {
    obj = isArrayLike_default(obj) ? obj : values(obj);
    for (var i = 0, length = obj.length; i < length; i++) {
      value = obj[i];
      if (value != null && value < result2) {
        result2 = value;
      }
    }
  } else {
    iteratee2 = cb(iteratee2, context);
    each(obj, function(v, index, list) {
      computed = iteratee2(v, index, list);
      if (computed < lastComputed || computed === Infinity && result2 === Infinity) {
        result2 = v;
        lastComputed = computed;
      }
    });
  }
  return result2;
}
var init_min = __esm({
  "../node_modules/underscore/modules/min.js"() {
    init_isArrayLike();
    init_values();
    init_cb();
    init_each();
  }
});

// ../node_modules/underscore/modules/toArray.js
function toArray(obj) {
  if (!obj) return [];
  if (isArray_default(obj)) return slice.call(obj);
  if (isString_default(obj)) {
    return obj.match(reStrSymbol);
  }
  if (isArrayLike_default(obj)) return map(obj, identity);
  return values(obj);
}
var reStrSymbol;
var init_toArray = __esm({
  "../node_modules/underscore/modules/toArray.js"() {
    init_isArray();
    init_setup();
    init_isString();
    init_isArrayLike();
    init_map();
    init_identity();
    init_values();
    reStrSymbol = /[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;
  }
});

// ../node_modules/underscore/modules/sample.js
function sample(obj, n, guard) {
  if (n == null || guard) {
    if (!isArrayLike_default(obj)) obj = values(obj);
    return obj[random(obj.length - 1)];
  }
  var sample2 = toArray(obj);
  var length = getLength_default(sample2);
  n = Math.max(Math.min(n, length), 0);
  var last2 = length - 1;
  for (var index = 0; index < n; index++) {
    var rand = random(index, last2);
    var temp = sample2[index];
    sample2[index] = sample2[rand];
    sample2[rand] = temp;
  }
  return sample2.slice(0, n);
}
var init_sample = __esm({
  "../node_modules/underscore/modules/sample.js"() {
    init_isArrayLike();
    init_values();
    init_getLength();
    init_random();
    init_toArray();
  }
});

// ../node_modules/underscore/modules/shuffle.js
function shuffle(obj) {
  return sample(obj, Infinity);
}
var init_shuffle = __esm({
  "../node_modules/underscore/modules/shuffle.js"() {
    init_sample();
  }
});

// ../node_modules/underscore/modules/sortBy.js
function sortBy(obj, iteratee2, context) {
  var index = 0;
  iteratee2 = cb(iteratee2, context);
  return pluck(map(obj, function(value, key, list) {
    return {
      value,
      index: index++,
      criteria: iteratee2(value, key, list)
    };
  }).sort(function(left, right) {
    var a = left.criteria;
    var b = right.criteria;
    if (a !== b) {
      if (a > b || a === void 0) return 1;
      if (a < b || b === void 0) return -1;
    }
    return left.index - right.index;
  }), "value");
}
var init_sortBy = __esm({
  "../node_modules/underscore/modules/sortBy.js"() {
    init_cb();
    init_pluck();
    init_map();
  }
});

// ../node_modules/underscore/modules/_group.js
function group(behavior, partition) {
  return function(obj, iteratee2, context) {
    var result2 = partition ? [[], []] : {};
    iteratee2 = cb(iteratee2, context);
    each(obj, function(value, index) {
      var key = iteratee2(value, index, obj);
      behavior(result2, value, key);
    });
    return result2;
  };
}
var init_group = __esm({
  "../node_modules/underscore/modules/_group.js"() {
    init_cb();
    init_each();
  }
});

// ../node_modules/underscore/modules/groupBy.js
var groupBy_default;
var init_groupBy = __esm({
  "../node_modules/underscore/modules/groupBy.js"() {
    init_group();
    init_has();
    groupBy_default = group(function(result2, value, key) {
      if (has(result2, key)) result2[key].push(value);
      else result2[key] = [value];
    });
  }
});

// ../node_modules/underscore/modules/indexBy.js
var indexBy_default;
var init_indexBy = __esm({
  "../node_modules/underscore/modules/indexBy.js"() {
    init_group();
    indexBy_default = group(function(result2, value, key) {
      result2[key] = value;
    });
  }
});

// ../node_modules/underscore/modules/countBy.js
var countBy_default;
var init_countBy = __esm({
  "../node_modules/underscore/modules/countBy.js"() {
    init_group();
    init_has();
    countBy_default = group(function(result2, value, key) {
      if (has(result2, key)) result2[key]++;
      else result2[key] = 1;
    });
  }
});

// ../node_modules/underscore/modules/partition.js
var partition_default;
var init_partition = __esm({
  "../node_modules/underscore/modules/partition.js"() {
    init_group();
    partition_default = group(function(result2, value, pass) {
      result2[pass ? 0 : 1].push(value);
    }, true);
  }
});

// ../node_modules/underscore/modules/size.js
function size(obj) {
  if (obj == null) return 0;
  return isArrayLike_default(obj) ? obj.length : keys(obj).length;
}
var init_size = __esm({
  "../node_modules/underscore/modules/size.js"() {
    init_isArrayLike();
    init_keys();
  }
});

// ../node_modules/underscore/modules/_keyInObj.js
function keyInObj(value, key, obj) {
  return key in obj;
}
var init_keyInObj = __esm({
  "../node_modules/underscore/modules/_keyInObj.js"() {
  }
});

// ../node_modules/underscore/modules/pick.js
var pick_default;
var init_pick = __esm({
  "../node_modules/underscore/modules/pick.js"() {
    init_restArguments();
    init_isFunction();
    init_optimizeCb();
    init_allKeys();
    init_keyInObj();
    init_flatten();
    pick_default = restArguments(function(obj, keys2) {
      var result2 = {}, iteratee2 = keys2[0];
      if (obj == null) return result2;
      if (isFunction_default(iteratee2)) {
        if (keys2.length > 1) iteratee2 = optimizeCb(iteratee2, keys2[1]);
        keys2 = allKeys(obj);
      } else {
        iteratee2 = keyInObj;
        keys2 = flatten(keys2, false, false);
        obj = Object(obj);
      }
      for (var i = 0, length = keys2.length; i < length; i++) {
        var key = keys2[i];
        var value = obj[key];
        if (iteratee2(value, key, obj)) result2[key] = value;
      }
      return result2;
    });
  }
});

// ../node_modules/underscore/modules/omit.js
var omit_default;
var init_omit = __esm({
  "../node_modules/underscore/modules/omit.js"() {
    init_restArguments();
    init_isFunction();
    init_negate();
    init_map();
    init_flatten();
    init_contains();
    init_pick();
    omit_default = restArguments(function(obj, keys2) {
      var iteratee2 = keys2[0], context;
      if (isFunction_default(iteratee2)) {
        iteratee2 = negate(iteratee2);
        if (keys2.length > 1) context = keys2[1];
      } else {
        keys2 = map(flatten(keys2, false, false), String);
        iteratee2 = function(value, key) {
          return !contains(keys2, key);
        };
      }
      return pick_default(obj, iteratee2, context);
    });
  }
});

// ../node_modules/underscore/modules/initial.js
function initial(array, n, guard) {
  return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
}
var init_initial = __esm({
  "../node_modules/underscore/modules/initial.js"() {
    init_setup();
  }
});

// ../node_modules/underscore/modules/first.js
function first(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[0];
  return initial(array, array.length - n);
}
var init_first = __esm({
  "../node_modules/underscore/modules/first.js"() {
    init_initial();
  }
});

// ../node_modules/underscore/modules/rest.js
function rest(array, n, guard) {
  return slice.call(array, n == null || guard ? 1 : n);
}
var init_rest = __esm({
  "../node_modules/underscore/modules/rest.js"() {
    init_setup();
  }
});

// ../node_modules/underscore/modules/last.js
function last(array, n, guard) {
  if (array == null || array.length < 1) return n == null || guard ? void 0 : [];
  if (n == null || guard) return array[array.length - 1];
  return rest(array, Math.max(0, array.length - n));
}
var init_last = __esm({
  "../node_modules/underscore/modules/last.js"() {
    init_rest();
  }
});

// ../node_modules/underscore/modules/compact.js
function compact(array) {
  return filter(array, Boolean);
}
var init_compact = __esm({
  "../node_modules/underscore/modules/compact.js"() {
    init_filter();
  }
});

// ../node_modules/underscore/modules/flatten.js
function flatten2(array, depth) {
  return flatten(array, depth, false);
}
var init_flatten2 = __esm({
  "../node_modules/underscore/modules/flatten.js"() {
    init_flatten();
  }
});

// ../node_modules/underscore/modules/difference.js
var difference_default;
var init_difference = __esm({
  "../node_modules/underscore/modules/difference.js"() {
    init_restArguments();
    init_flatten();
    init_filter();
    init_contains();
    difference_default = restArguments(function(array, rest2) {
      rest2 = flatten(rest2, true, true);
      return filter(array, function(value) {
        return !contains(rest2, value);
      });
    });
  }
});

// ../node_modules/underscore/modules/without.js
var without_default;
var init_without = __esm({
  "../node_modules/underscore/modules/without.js"() {
    init_restArguments();
    init_difference();
    without_default = restArguments(function(array, otherArrays) {
      return difference_default(array, otherArrays);
    });
  }
});

// ../node_modules/underscore/modules/uniq.js
function uniq(array, isSorted, iteratee2, context) {
  if (!isBoolean(isSorted)) {
    context = iteratee2;
    iteratee2 = isSorted;
    isSorted = false;
  }
  if (iteratee2 != null) iteratee2 = cb(iteratee2, context);
  var result2 = [];
  var seen = [];
  for (var i = 0, length = getLength_default(array); i < length; i++) {
    var value = array[i], computed = iteratee2 ? iteratee2(value, i, array) : value;
    if (isSorted && !iteratee2) {
      if (!i || seen !== computed) result2.push(value);
      seen = computed;
    } else if (iteratee2) {
      if (!contains(seen, computed)) {
        seen.push(computed);
        result2.push(value);
      }
    } else if (!contains(result2, value)) {
      result2.push(value);
    }
  }
  return result2;
}
var init_uniq = __esm({
  "../node_modules/underscore/modules/uniq.js"() {
    init_isBoolean();
    init_cb();
    init_getLength();
    init_contains();
  }
});

// ../node_modules/underscore/modules/union.js
var union_default;
var init_union = __esm({
  "../node_modules/underscore/modules/union.js"() {
    init_restArguments();
    init_uniq();
    init_flatten();
    union_default = restArguments(function(arrays) {
      return uniq(flatten(arrays, true, true));
    });
  }
});

// ../node_modules/underscore/modules/intersection.js
function intersection(array) {
  var result2 = [];
  var argsLength = arguments.length;
  for (var i = 0, length = getLength_default(array); i < length; i++) {
    var item = array[i];
    if (contains(result2, item)) continue;
    var j;
    for (j = 1; j < argsLength; j++) {
      if (!contains(arguments[j], item)) break;
    }
    if (j === argsLength) result2.push(item);
  }
  return result2;
}
var init_intersection = __esm({
  "../node_modules/underscore/modules/intersection.js"() {
    init_getLength();
    init_contains();
  }
});

// ../node_modules/underscore/modules/unzip.js
function unzip(array) {
  var length = array && max(array, getLength_default).length || 0;
  var result2 = Array(length);
  for (var index = 0; index < length; index++) {
    result2[index] = pluck(array, index);
  }
  return result2;
}
var init_unzip = __esm({
  "../node_modules/underscore/modules/unzip.js"() {
    init_max();
    init_getLength();
    init_pluck();
  }
});

// ../node_modules/underscore/modules/zip.js
var zip_default;
var init_zip = __esm({
  "../node_modules/underscore/modules/zip.js"() {
    init_restArguments();
    init_unzip();
    zip_default = restArguments(unzip);
  }
});

// ../node_modules/underscore/modules/object.js
function object(list, values2) {
  var result2 = {};
  for (var i = 0, length = getLength_default(list); i < length; i++) {
    if (values2) {
      result2[list[i]] = values2[i];
    } else {
      result2[list[i][0]] = list[i][1];
    }
  }
  return result2;
}
var init_object = __esm({
  "../node_modules/underscore/modules/object.js"() {
    init_getLength();
  }
});

// ../node_modules/underscore/modules/range.js
function range(start, stop, step) {
  if (stop == null) {
    stop = start || 0;
    start = 0;
  }
  if (!step) {
    step = stop < start ? -1 : 1;
  }
  var length = Math.max(Math.ceil((stop - start) / step), 0);
  var range2 = Array(length);
  for (var idx = 0; idx < length; idx++, start += step) {
    range2[idx] = start;
  }
  return range2;
}
var init_range = __esm({
  "../node_modules/underscore/modules/range.js"() {
  }
});

// ../node_modules/underscore/modules/chunk.js
function chunk(array, count) {
  if (count == null || count < 1) return [];
  var result2 = [];
  var i = 0, length = array.length;
  while (i < length) {
    result2.push(slice.call(array, i, i += count));
  }
  return result2;
}
var init_chunk = __esm({
  "../node_modules/underscore/modules/chunk.js"() {
    init_setup();
  }
});

// ../node_modules/underscore/modules/_chainResult.js
function chainResult(instance, obj) {
  return instance._chain ? _(obj).chain() : obj;
}
var init_chainResult = __esm({
  "../node_modules/underscore/modules/_chainResult.js"() {
    init_underscore();
  }
});

// ../node_modules/underscore/modules/mixin.js
function mixin(obj) {
  each(functions(obj), function(name) {
    var func = _[name] = obj[name];
    _.prototype[name] = function() {
      var args = [this._wrapped];
      push.apply(args, arguments);
      return chainResult(this, func.apply(_, args));
    };
  });
  return _;
}
var init_mixin = __esm({
  "../node_modules/underscore/modules/mixin.js"() {
    init_underscore();
    init_each();
    init_functions();
    init_setup();
    init_chainResult();
  }
});

// ../node_modules/underscore/modules/underscore-array-methods.js
var underscore_array_methods_default;
var init_underscore_array_methods = __esm({
  "../node_modules/underscore/modules/underscore-array-methods.js"() {
    init_underscore();
    init_each();
    init_setup();
    init_chainResult();
    each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null) {
          method.apply(obj, arguments);
          if ((name === "shift" || name === "splice") && obj.length === 0) {
            delete obj[0];
          }
        }
        return chainResult(this, obj);
      };
    });
    each(["concat", "join", "slice"], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj = this._wrapped;
        if (obj != null) obj = method.apply(obj, arguments);
        return chainResult(this, obj);
      };
    });
    underscore_array_methods_default = _;
  }
});

// ../node_modules/underscore/modules/index.js
var modules_exports = {};
__export(modules_exports, {
  VERSION: () => VERSION2,
  after: () => after,
  all: () => every,
  allKeys: () => allKeys,
  any: () => some,
  assign: () => extendOwn_default,
  before: () => before,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  chain: () => chain,
  chunk: () => chunk,
  clone: () => clone,
  collect: () => map,
  compact: () => compact,
  compose: () => compose,
  constant: () => constant,
  contains: () => contains,
  countBy: () => countBy_default,
  create: () => create,
  debounce: () => debounce,
  default: () => underscore_array_methods_default,
  defaults: () => defaults_default,
  defer: () => defer_default,
  delay: () => delay_default,
  detect: () => find,
  difference: () => difference_default,
  drop: () => rest,
  each: () => each,
  escape: () => escape_default,
  every: () => every,
  extend: () => extend_default,
  extendOwn: () => extendOwn_default,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex_default,
  findKey: () => findKey,
  findLastIndex: () => findLastIndex_default,
  findWhere: () => findWhere,
  first: () => first,
  flatten: () => flatten2,
  foldl: () => reduce_default,
  foldr: () => reduceRight_default,
  forEach: () => each,
  functions: () => functions,
  get: () => get,
  groupBy: () => groupBy_default,
  has: () => has2,
  head: () => first,
  identity: () => identity,
  include: () => contains,
  includes: () => contains,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  initial: () => initial,
  inject: () => reduce_default,
  intersection: () => intersection,
  invert: () => invert,
  invoke: () => invoke_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isBoolean: () => isBoolean,
  isDataView: () => isDataView_default,
  isDate: () => isDate_default,
  isElement: () => isElement,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isError: () => isError_default,
  isFinite: () => isFinite2,
  isFunction: () => isFunction_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isNumber: () => isNumber_default,
  isObject: () => isObject,
  isRegExp: () => isRegExp_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee,
  keys: () => keys,
  last: () => last,
  lastIndexOf: () => lastIndexOf_default,
  map: () => map,
  mapObject: () => mapObject,
  matcher: () => matcher,
  matches: () => matcher,
  max: () => max,
  memoize: () => memoize,
  methods: () => functions,
  min: () => min,
  mixin: () => mixin,
  negate: () => negate,
  noop: () => noop,
  now: () => now_default,
  object: () => object,
  omit: () => omit_default,
  once: () => once_default,
  pairs: () => pairs,
  partial: () => partial_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pluck: () => pluck,
  property: () => property,
  propertyOf: () => propertyOf,
  random: () => random,
  range: () => range,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject,
  rest: () => rest,
  restArguments: () => restArguments,
  result: () => result,
  sample: () => sample,
  select: () => filter,
  shuffle: () => shuffle,
  size: () => size,
  some: () => some,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  tail: () => rest,
  take: () => first,
  tap: () => tap,
  template: () => template,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray,
  toPath: () => toPath,
  transpose: () => unzip,
  unescape: () => unescape_default,
  union: () => union_default,
  uniq: () => uniq,
  unique: () => uniq,
  uniqueId: () => uniqueId,
  unzip: () => unzip,
  values: () => values,
  where: () => where,
  without: () => without_default,
  wrap: () => wrap,
  zip: () => zip_default
});
var init_modules = __esm({
  "../node_modules/underscore/modules/index.js"() {
    init_setup();
    init_restArguments();
    init_isObject();
    init_isNull();
    init_isUndefined();
    init_isBoolean();
    init_isElement();
    init_isString();
    init_isNumber();
    init_isDate();
    init_isRegExp();
    init_isError();
    init_isSymbol();
    init_isArrayBuffer();
    init_isDataView();
    init_isArray();
    init_isFunction();
    init_isArguments();
    init_isFinite();
    init_isNaN();
    init_isTypedArray();
    init_isEmpty();
    init_isMatch();
    init_isEqual();
    init_isMap();
    init_isWeakMap();
    init_isSet();
    init_isWeakSet();
    init_keys();
    init_allKeys();
    init_values();
    init_pairs();
    init_invert();
    init_functions();
    init_extend();
    init_extendOwn();
    init_defaults();
    init_create();
    init_clone();
    init_tap();
    init_get();
    init_has2();
    init_mapObject();
    init_identity();
    init_constant();
    init_noop();
    init_toPath();
    init_property();
    init_propertyOf();
    init_matcher();
    init_times();
    init_random();
    init_now();
    init_escape();
    init_unescape();
    init_templateSettings();
    init_template();
    init_result();
    init_uniqueId();
    init_chain();
    init_iteratee();
    init_partial();
    init_bind();
    init_bindAll();
    init_memoize();
    init_delay();
    init_defer();
    init_throttle();
    init_debounce();
    init_wrap();
    init_negate();
    init_compose();
    init_after();
    init_before();
    init_once();
    init_findKey();
    init_findIndex();
    init_findLastIndex();
    init_sortedIndex();
    init_indexOf();
    init_lastIndexOf();
    init_find();
    init_findWhere();
    init_each();
    init_map();
    init_reduce();
    init_reduceRight();
    init_filter();
    init_reject();
    init_every();
    init_some();
    init_contains();
    init_invoke();
    init_pluck();
    init_where();
    init_max();
    init_min();
    init_shuffle();
    init_sample();
    init_sortBy();
    init_groupBy();
    init_indexBy();
    init_countBy();
    init_partition();
    init_toArray();
    init_size();
    init_pick();
    init_omit();
    init_first();
    init_initial();
    init_last();
    init_rest();
    init_compact();
    init_flatten2();
    init_without();
    init_uniq();
    init_union();
    init_intersection();
    init_difference();
    init_unzip();
    init_zip();
    init_object();
    init_range();
    init_chunk();
    init_mixin();
    init_underscore_array_methods();
  }
});

// ../node_modules/underscore/modules/index-default.js
var _2, index_default_default;
var init_index_default = __esm({
  "../node_modules/underscore/modules/index-default.js"() {
    init_modules();
    init_modules();
    _2 = mixin(modules_exports);
    _2._ = _2;
    index_default_default = _2;
  }
});

// ../node_modules/underscore/modules/index-all.js
var index_all_exports = {};
__export(index_all_exports, {
  VERSION: () => VERSION2,
  after: () => after,
  all: () => every,
  allKeys: () => allKeys,
  any: () => some,
  assign: () => extendOwn_default,
  before: () => before,
  bind: () => bind_default,
  bindAll: () => bindAll_default,
  chain: () => chain,
  chunk: () => chunk,
  clone: () => clone,
  collect: () => map,
  compact: () => compact,
  compose: () => compose,
  constant: () => constant,
  contains: () => contains,
  countBy: () => countBy_default,
  create: () => create,
  debounce: () => debounce,
  default: () => index_default_default,
  defaults: () => defaults_default,
  defer: () => defer_default,
  delay: () => delay_default,
  detect: () => find,
  difference: () => difference_default,
  drop: () => rest,
  each: () => each,
  escape: () => escape_default,
  every: () => every,
  extend: () => extend_default,
  extendOwn: () => extendOwn_default,
  filter: () => filter,
  find: () => find,
  findIndex: () => findIndex_default,
  findKey: () => findKey,
  findLastIndex: () => findLastIndex_default,
  findWhere: () => findWhere,
  first: () => first,
  flatten: () => flatten2,
  foldl: () => reduce_default,
  foldr: () => reduceRight_default,
  forEach: () => each,
  functions: () => functions,
  get: () => get,
  groupBy: () => groupBy_default,
  has: () => has2,
  head: () => first,
  identity: () => identity,
  include: () => contains,
  includes: () => contains,
  indexBy: () => indexBy_default,
  indexOf: () => indexOf_default,
  initial: () => initial,
  inject: () => reduce_default,
  intersection: () => intersection,
  invert: () => invert,
  invoke: () => invoke_default,
  isArguments: () => isArguments_default,
  isArray: () => isArray_default,
  isArrayBuffer: () => isArrayBuffer_default,
  isBoolean: () => isBoolean,
  isDataView: () => isDataView_default,
  isDate: () => isDate_default,
  isElement: () => isElement,
  isEmpty: () => isEmpty,
  isEqual: () => isEqual,
  isError: () => isError_default,
  isFinite: () => isFinite2,
  isFunction: () => isFunction_default,
  isMap: () => isMap_default,
  isMatch: () => isMatch,
  isNaN: () => isNaN2,
  isNull: () => isNull,
  isNumber: () => isNumber_default,
  isObject: () => isObject,
  isRegExp: () => isRegExp_default,
  isSet: () => isSet_default,
  isString: () => isString_default,
  isSymbol: () => isSymbol_default,
  isTypedArray: () => isTypedArray_default,
  isUndefined: () => isUndefined,
  isWeakMap: () => isWeakMap_default,
  isWeakSet: () => isWeakSet_default,
  iteratee: () => iteratee,
  keys: () => keys,
  last: () => last,
  lastIndexOf: () => lastIndexOf_default,
  map: () => map,
  mapObject: () => mapObject,
  matcher: () => matcher,
  matches: () => matcher,
  max: () => max,
  memoize: () => memoize,
  methods: () => functions,
  min: () => min,
  mixin: () => mixin,
  negate: () => negate,
  noop: () => noop,
  now: () => now_default,
  object: () => object,
  omit: () => omit_default,
  once: () => once_default,
  pairs: () => pairs,
  partial: () => partial_default,
  partition: () => partition_default,
  pick: () => pick_default,
  pluck: () => pluck,
  property: () => property,
  propertyOf: () => propertyOf,
  random: () => random,
  range: () => range,
  reduce: () => reduce_default,
  reduceRight: () => reduceRight_default,
  reject: () => reject,
  rest: () => rest,
  restArguments: () => restArguments,
  result: () => result,
  sample: () => sample,
  select: () => filter,
  shuffle: () => shuffle,
  size: () => size,
  some: () => some,
  sortBy: () => sortBy,
  sortedIndex: () => sortedIndex,
  tail: () => rest,
  take: () => first,
  tap: () => tap,
  template: () => template,
  templateSettings: () => templateSettings_default,
  throttle: () => throttle,
  times: () => times,
  toArray: () => toArray,
  toPath: () => toPath,
  transpose: () => unzip,
  unescape: () => unescape_default,
  union: () => union_default,
  uniq: () => uniq,
  unique: () => uniq,
  uniqueId: () => uniqueId,
  unzip: () => unzip,
  values: () => values,
  where: () => where,
  without: () => without_default,
  wrap: () => wrap,
  zip: () => zip_default
});
var init_index_all = __esm({
  "../node_modules/underscore/modules/index-all.js"() {
    init_index_default();
    init_modules();
  }
});

// ../node_modules/azure-devops-node-api/node_modules/typed-rest-client/opensource/Node-SMB/lib/common.js
var require_common2 = __commonJS({
  "../node_modules/azure-devops-node-api/node_modules/typed-rest-client/opensource/Node-SMB/lib/common.js"(exports2, module2) {
    var crypto = require("crypto");
    function zeroextend(str, len) {
      while (str.length < len)
        str = "0" + str;
      return str;
    }
    function oddpar(buf) {
      for (var j = 0; j < buf.length; j++) {
        var par = 1;
        for (var i = 1; i < 8; i++) {
          par = (par + (buf[j] >> i & 1)) % 2;
        }
        buf[j] |= par & 1;
      }
      return buf;
    }
    function expandkey(key56) {
      var key64 = Buffer.alloc(8);
      key64[0] = key56[0] & 254;
      key64[1] = key56[0] << 7 & 255 | key56[1] >> 1;
      key64[2] = key56[1] << 6 & 255 | key56[2] >> 2;
      key64[3] = key56[2] << 5 & 255 | key56[3] >> 3;
      key64[4] = key56[3] << 4 & 255 | key56[4] >> 4;
      key64[5] = key56[4] << 3 & 255 | key56[5] >> 5;
      key64[6] = key56[5] << 2 & 255 | key56[6] >> 6;
      key64[7] = key56[6] << 1 & 255;
      return key64;
    }
    function bintohex(bin) {
      var buf = Buffer.isBuffer(buf) ? buf : Buffer.from(bin, "binary");
      var str = buf.toString("hex").toUpperCase();
      return zeroextend(str, 32);
    }
    module2.exports.zeroextend = zeroextend;
    module2.exports.oddpar = oddpar;
    module2.exports.expandkey = expandkey;
    module2.exports.bintohex = bintohex;
  }
});

// ../node_modules/js-md4/src/md4.js
var require_md4 = __commonJS({
  "../node_modules/js-md4/src/md4.js"(exports2, module2) {
    (function() {
      "use strict";
      var root2 = typeof window === "object" ? window : {};
      var NODE_JS = !root2.JS_MD4_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
      if (NODE_JS) {
        root2 = global;
      }
      var COMMON_JS = !root2.JS_MD4_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
      var AMD = typeof define === "function" && define.amd;
      var ARRAY_BUFFER = !root2.JS_MD4_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
      var HEX_CHARS = "0123456789abcdef".split("");
      var EXTRA = [128, 32768, 8388608, -2147483648];
      var SHIFT = [0, 8, 16, 24];
      var OUTPUT_TYPES = ["hex", "array", "digest", "buffer", "arrayBuffer"];
      var blocks = [], buffer8;
      if (ARRAY_BUFFER) {
        var buffer = new ArrayBuffer(68);
        buffer8 = new Uint8Array(buffer);
        blocks = new Uint32Array(buffer);
      }
      var createOutputMethod = function(outputType) {
        return function(message) {
          return new Md4(true).update(message)[outputType]();
        };
      };
      var createMethod = function() {
        var method = createOutputMethod("hex");
        if (NODE_JS) {
          method = nodeWrap(method);
        }
        method.create = function() {
          return new Md4();
        };
        method.update = function(message) {
          return method.create().update(message);
        };
        for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
          var type = OUTPUT_TYPES[i];
          method[type] = createOutputMethod(type);
        }
        return method;
      };
      var nodeWrap = function(method) {
        var crypto = require("crypto");
        var Buffer2 = require("buffer").Buffer;
        var nodeMethod = function(message) {
          if (typeof message === "string") {
            return crypto.createHash("md4").update(message, "utf8").digest("hex");
          } else if (ARRAY_BUFFER && message instanceof ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (message.length === void 0) {
            return method(message);
          }
          return crypto.createHash("md4").update(new Buffer2(message)).digest("hex");
        };
        return nodeMethod;
      };
      function Md4(sharedMemory) {
        if (sharedMemory) {
          blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
          this.blocks = blocks;
          this.buffer8 = buffer8;
        } else {
          if (ARRAY_BUFFER) {
            var buffer2 = new ArrayBuffer(68);
            this.buffer8 = new Uint8Array(buffer2);
            this.blocks = new Uint32Array(buffer2);
          } else {
            this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
          }
        }
        this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = 0;
        this.finalized = this.hashed = false;
        this.first = true;
      }
      Md4.prototype.update = function(message) {
        if (this.finalized) {
          return;
        }
        var notString = typeof message !== "string";
        if (notString && ARRAY_BUFFER && message instanceof ArrayBuffer) {
          message = new Uint8Array(message);
        }
        var code, index = 0, i, length = message.length || 0, blocks2 = this.blocks;
        var buffer82 = this.buffer8;
        while (index < length) {
          if (this.hashed) {
            this.hashed = false;
            blocks2[0] = blocks2[16];
            blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
          }
          if (notString) {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length && i < 64; ++index) {
                buffer82[i++] = message[index];
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                blocks2[i >> 2] |= message[index] << SHIFT[i++ & 3];
              }
            }
          } else {
            if (ARRAY_BUFFER) {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  buffer82[i++] = code;
                } else if (code < 2048) {
                  buffer82[i++] = 192 | code >> 6;
                  buffer82[i++] = 128 | code & 63;
                } else if (code < 55296 || code >= 57344) {
                  buffer82[i++] = 224 | code >> 12;
                  buffer82[i++] = 128 | code >> 6 & 63;
                  buffer82[i++] = 128 | code & 63;
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  buffer82[i++] = 240 | code >> 18;
                  buffer82[i++] = 128 | code >> 12 & 63;
                  buffer82[i++] = 128 | code >> 6 & 63;
                  buffer82[i++] = 128 | code & 63;
                }
              }
            } else {
              for (i = this.start; index < length && i < 64; ++index) {
                code = message.charCodeAt(index);
                if (code < 128) {
                  blocks2[i >> 2] |= code << SHIFT[i++ & 3];
                } else if (code < 2048) {
                  blocks2[i >> 2] |= (192 | code >> 6) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else if (code < 55296 || code >= 57344) {
                  blocks2[i >> 2] |= (224 | code >> 12) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                } else {
                  code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
                  blocks2[i >> 2] |= (240 | code >> 18) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 12 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code >> 6 & 63) << SHIFT[i++ & 3];
                  blocks2[i >> 2] |= (128 | code & 63) << SHIFT[i++ & 3];
                }
              }
            }
          }
          this.lastByteIndex = i;
          this.bytes += i - this.start;
          if (i >= 64) {
            this.start = i - 64;
            this.hash();
            this.hashed = true;
          } else {
            this.start = i;
          }
        }
        return this;
      };
      Md4.prototype.finalize = function() {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        var blocks2 = this.blocks, i = this.lastByteIndex;
        blocks2[i >> 2] |= EXTRA[i & 3];
        if (i >= 56) {
          if (!this.hashed) {
            this.hash();
          }
          blocks2[0] = blocks2[16];
          blocks2[16] = blocks2[1] = blocks2[2] = blocks2[3] = blocks2[4] = blocks2[5] = blocks2[6] = blocks2[7] = blocks2[8] = blocks2[9] = blocks2[10] = blocks2[11] = blocks2[12] = blocks2[13] = blocks2[14] = blocks2[15] = 0;
        }
        blocks2[14] = this.bytes << 3;
        this.hash();
      };
      Md4.prototype.hash = function() {
        var a, b, c, d, ab, bc, cd, da, blocks2 = this.blocks;
        if (this.first) {
          a = blocks2[0] - 1;
          a = a << 3 | a >>> 29;
          d = (a & 4023233417 | ~a & 2562383102) + blocks2[1] + 271733878;
          d = d << 7 | d >>> 25;
          c = (d & a | ~d & 4023233417) + blocks2[2] - 1732584194;
          c = c << 11 | c >>> 21;
          b = (c & d | ~c & a) + blocks2[3] - 271733879;
          b = b << 19 | b >>> 13;
        } else {
          a = this.h0;
          b = this.h1;
          c = this.h2;
          d = this.h3;
          a += (b & c | ~b & d) + blocks2[0];
          a = a << 3 | a >>> 29;
          d += (a & b | ~a & c) + blocks2[1];
          d = d << 7 | d >>> 25;
          c += (d & a | ~d & b) + blocks2[2];
          c = c << 11 | c >>> 21;
          b += (c & d | ~c & a) + blocks2[3];
          b = b << 19 | b >>> 13;
        }
        a += (b & c | ~b & d) + blocks2[4];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[5];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[6];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[7];
        b = b << 19 | b >>> 13;
        a += (b & c | ~b & d) + blocks2[8];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[9];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[10];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[11];
        b = b << 19 | b >>> 13;
        a += (b & c | ~b & d) + blocks2[12];
        a = a << 3 | a >>> 29;
        d += (a & b | ~a & c) + blocks2[13];
        d = d << 7 | d >>> 25;
        c += (d & a | ~d & b) + blocks2[14];
        c = c << 11 | c >>> 21;
        b += (c & d | ~c & a) + blocks2[15];
        b = b << 19 | b >>> 13;
        bc = b & c;
        a += (bc | b & d | c & d) + blocks2[0] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[4] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[8] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[12] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[1] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[5] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[9] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[13] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[2] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[6] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[10] + 1518500249;
        c = c << 9 | c >>> 23;
        cd = c & d;
        b += (cd | c & a | da) + blocks2[14] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b & c;
        a += (bc | b & d | cd) + blocks2[3] + 1518500249;
        a = a << 3 | a >>> 29;
        ab = a & b;
        d += (ab | a & c | bc) + blocks2[7] + 1518500249;
        d = d << 5 | d >>> 27;
        da = d & a;
        c += (da | d & b | ab) + blocks2[11] + 1518500249;
        c = c << 9 | c >>> 23;
        b += (c & d | c & a | da) + blocks2[15] + 1518500249;
        b = b << 13 | b >>> 19;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[0] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[8] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[4] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[12] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[2] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[10] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[6] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[14] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[1] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[9] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[5] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[13] + 1859775393;
        b = b << 15 | b >>> 17;
        bc = b ^ c;
        a += (bc ^ d) + blocks2[3] + 1859775393;
        a = a << 3 | a >>> 29;
        d += (bc ^ a) + blocks2[11] + 1859775393;
        d = d << 9 | d >>> 23;
        da = d ^ a;
        c += (da ^ b) + blocks2[7] + 1859775393;
        c = c << 11 | c >>> 21;
        b += (da ^ c) + blocks2[15] + 1859775393;
        b = b << 15 | b >>> 17;
        if (this.first) {
          this.h0 = a + 1732584193 << 0;
          this.h1 = b - 271733879 << 0;
          this.h2 = c - 1732584194 << 0;
          this.h3 = d + 271733878 << 0;
          this.first = false;
        } else {
          this.h0 = this.h0 + a << 0;
          this.h1 = this.h1 + b << 0;
          this.h2 = this.h2 + c << 0;
          this.h3 = this.h3 + d << 0;
        }
      };
      Md4.prototype.hex = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return HEX_CHARS[h0 >> 4 & 15] + HEX_CHARS[h0 & 15] + HEX_CHARS[h0 >> 12 & 15] + HEX_CHARS[h0 >> 8 & 15] + HEX_CHARS[h0 >> 20 & 15] + HEX_CHARS[h0 >> 16 & 15] + HEX_CHARS[h0 >> 28 & 15] + HEX_CHARS[h0 >> 24 & 15] + HEX_CHARS[h1 >> 4 & 15] + HEX_CHARS[h1 & 15] + HEX_CHARS[h1 >> 12 & 15] + HEX_CHARS[h1 >> 8 & 15] + HEX_CHARS[h1 >> 20 & 15] + HEX_CHARS[h1 >> 16 & 15] + HEX_CHARS[h1 >> 28 & 15] + HEX_CHARS[h1 >> 24 & 15] + HEX_CHARS[h2 >> 4 & 15] + HEX_CHARS[h2 & 15] + HEX_CHARS[h2 >> 12 & 15] + HEX_CHARS[h2 >> 8 & 15] + HEX_CHARS[h2 >> 20 & 15] + HEX_CHARS[h2 >> 16 & 15] + HEX_CHARS[h2 >> 28 & 15] + HEX_CHARS[h2 >> 24 & 15] + HEX_CHARS[h3 >> 4 & 15] + HEX_CHARS[h3 & 15] + HEX_CHARS[h3 >> 12 & 15] + HEX_CHARS[h3 >> 8 & 15] + HEX_CHARS[h3 >> 20 & 15] + HEX_CHARS[h3 >> 16 & 15] + HEX_CHARS[h3 >> 28 & 15] + HEX_CHARS[h3 >> 24 & 15];
      };
      Md4.prototype.toString = Md4.prototype.hex;
      Md4.prototype.digest = function() {
        this.finalize();
        var h0 = this.h0, h1 = this.h1, h2 = this.h2, h3 = this.h3;
        return [
          h0 & 255,
          h0 >> 8 & 255,
          h0 >> 16 & 255,
          h0 >> 24 & 255,
          h1 & 255,
          h1 >> 8 & 255,
          h1 >> 16 & 255,
          h1 >> 24 & 255,
          h2 & 255,
          h2 >> 8 & 255,
          h2 >> 16 & 255,
          h2 >> 24 & 255,
          h3 & 255,
          h3 >> 8 & 255,
          h3 >> 16 & 255,
          h3 >> 24 & 255
        ];
      };
      Md4.prototype.array = Md4.prototype.digest;
      Md4.prototype.arrayBuffer = function() {
        this.finalize();
        var buffer2 = new ArrayBuffer(16);
        var blocks2 = new Uint32Array(buffer2);
        blocks2[0] = this.h0;
        blocks2[1] = this.h1;
        blocks2[2] = this.h2;
        blocks2[3] = this.h3;
        return buffer2;
      };
      Md4.prototype.buffer = Md4.prototype.arrayBuffer;
      var exports3 = createMethod();
      if (COMMON_JS) {
        module2.exports = exports3;
      } else {
        root2.md4 = exports3;
        if (AMD) {
          define(function() {
            return exports3;
          });
        }
      }
    })();
  }
});

// ../node_modules/des.js/lib/des/utils.js
var require_utils3 = __commonJS({
  "../node_modules/des.js/lib/des/utils.js"(exports2) {
    "use strict";
    exports2.readUInt32BE = function readUInt32BE(bytes, off) {
      var res = bytes[0 + off] << 24 | bytes[1 + off] << 16 | bytes[2 + off] << 8 | bytes[3 + off];
      return res >>> 0;
    };
    exports2.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
      bytes[0 + off] = value >>> 24;
      bytes[1 + off] = value >>> 16 & 255;
      bytes[2 + off] = value >>> 8 & 255;
      bytes[3 + off] = value & 255;
    };
    exports2.ip = function ip(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      for (var i = 6; i >= 0; i -= 2) {
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inR >>> j + i & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inL >>> j + i & 1;
        }
      }
      for (var i = 6; i >= 0; i -= 2) {
        for (var j = 1; j <= 25; j += 8) {
          outR <<= 1;
          outR |= inR >>> j + i & 1;
        }
        for (var j = 1; j <= 25; j += 8) {
          outR <<= 1;
          outR |= inL >>> j + i & 1;
        }
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    exports2.rip = function rip(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      for (var i = 0; i < 4; i++) {
        for (var j = 24; j >= 0; j -= 8) {
          outL <<= 1;
          outL |= inR >>> j + i & 1;
          outL <<= 1;
          outL |= inL >>> j + i & 1;
        }
      }
      for (var i = 4; i < 8; i++) {
        for (var j = 24; j >= 0; j -= 8) {
          outR <<= 1;
          outR |= inR >>> j + i & 1;
          outR <<= 1;
          outR |= inL >>> j + i & 1;
        }
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    exports2.pc1 = function pc1(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      for (var i = 7; i >= 5; i--) {
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inR >> j + i & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outL <<= 1;
          outL |= inL >> j + i & 1;
        }
      }
      for (var j = 0; j <= 24; j += 8) {
        outL <<= 1;
        outL |= inR >> j + i & 1;
      }
      for (var i = 1; i <= 3; i++) {
        for (var j = 0; j <= 24; j += 8) {
          outR <<= 1;
          outR |= inR >> j + i & 1;
        }
        for (var j = 0; j <= 24; j += 8) {
          outR <<= 1;
          outR |= inL >> j + i & 1;
        }
      }
      for (var j = 0; j <= 24; j += 8) {
        outR <<= 1;
        outR |= inL >> j + i & 1;
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    exports2.r28shl = function r28shl(num, shift) {
      return num << shift & 268435455 | num >>> 28 - shift;
    };
    var pc2table = [
      // inL => outL
      14,
      11,
      17,
      4,
      27,
      23,
      25,
      0,
      13,
      22,
      7,
      18,
      5,
      9,
      16,
      24,
      2,
      20,
      12,
      21,
      1,
      8,
      15,
      26,
      // inR => outR
      15,
      4,
      25,
      19,
      9,
      1,
      26,
      16,
      5,
      11,
      23,
      8,
      12,
      7,
      17,
      0,
      22,
      3,
      10,
      14,
      6,
      20,
      27,
      24
    ];
    exports2.pc2 = function pc2(inL, inR, out, off) {
      var outL = 0;
      var outR = 0;
      var len = pc2table.length >>> 1;
      for (var i = 0; i < len; i++) {
        outL <<= 1;
        outL |= inL >>> pc2table[i] & 1;
      }
      for (var i = len; i < pc2table.length; i++) {
        outR <<= 1;
        outR |= inR >>> pc2table[i] & 1;
      }
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    exports2.expand = function expand(r, out, off) {
      var outL = 0;
      var outR = 0;
      outL = (r & 1) << 5 | r >>> 27;
      for (var i = 23; i >= 15; i -= 4) {
        outL <<= 6;
        outL |= r >>> i & 63;
      }
      for (var i = 11; i >= 3; i -= 4) {
        outR |= r >>> i & 63;
        outR <<= 6;
      }
      outR |= (r & 31) << 1 | r >>> 31;
      out[off + 0] = outL >>> 0;
      out[off + 1] = outR >>> 0;
    };
    var sTable = [
      14,
      0,
      4,
      15,
      13,
      7,
      1,
      4,
      2,
      14,
      15,
      2,
      11,
      13,
      8,
      1,
      3,
      10,
      10,
      6,
      6,
      12,
      12,
      11,
      5,
      9,
      9,
      5,
      0,
      3,
      7,
      8,
      4,
      15,
      1,
      12,
      14,
      8,
      8,
      2,
      13,
      4,
      6,
      9,
      2,
      1,
      11,
      7,
      15,
      5,
      12,
      11,
      9,
      3,
      7,
      14,
      3,
      10,
      10,
      0,
      5,
      6,
      0,
      13,
      15,
      3,
      1,
      13,
      8,
      4,
      14,
      7,
      6,
      15,
      11,
      2,
      3,
      8,
      4,
      14,
      9,
      12,
      7,
      0,
      2,
      1,
      13,
      10,
      12,
      6,
      0,
      9,
      5,
      11,
      10,
      5,
      0,
      13,
      14,
      8,
      7,
      10,
      11,
      1,
      10,
      3,
      4,
      15,
      13,
      4,
      1,
      2,
      5,
      11,
      8,
      6,
      12,
      7,
      6,
      12,
      9,
      0,
      3,
      5,
      2,
      14,
      15,
      9,
      10,
      13,
      0,
      7,
      9,
      0,
      14,
      9,
      6,
      3,
      3,
      4,
      15,
      6,
      5,
      10,
      1,
      2,
      13,
      8,
      12,
      5,
      7,
      14,
      11,
      12,
      4,
      11,
      2,
      15,
      8,
      1,
      13,
      1,
      6,
      10,
      4,
      13,
      9,
      0,
      8,
      6,
      15,
      9,
      3,
      8,
      0,
      7,
      11,
      4,
      1,
      15,
      2,
      14,
      12,
      3,
      5,
      11,
      10,
      5,
      14,
      2,
      7,
      12,
      7,
      13,
      13,
      8,
      14,
      11,
      3,
      5,
      0,
      6,
      6,
      15,
      9,
      0,
      10,
      3,
      1,
      4,
      2,
      7,
      8,
      2,
      5,
      12,
      11,
      1,
      12,
      10,
      4,
      14,
      15,
      9,
      10,
      3,
      6,
      15,
      9,
      0,
      0,
      6,
      12,
      10,
      11,
      1,
      7,
      13,
      13,
      8,
      15,
      9,
      1,
      4,
      3,
      5,
      14,
      11,
      5,
      12,
      2,
      7,
      8,
      2,
      4,
      14,
      2,
      14,
      12,
      11,
      4,
      2,
      1,
      12,
      7,
      4,
      10,
      7,
      11,
      13,
      6,
      1,
      8,
      5,
      5,
      0,
      3,
      15,
      15,
      10,
      13,
      3,
      0,
      9,
      14,
      8,
      9,
      6,
      4,
      11,
      2,
      8,
      1,
      12,
      11,
      7,
      10,
      1,
      13,
      14,
      7,
      2,
      8,
      13,
      15,
      6,
      9,
      15,
      12,
      0,
      5,
      9,
      6,
      10,
      3,
      4,
      0,
      5,
      14,
      3,
      12,
      10,
      1,
      15,
      10,
      4,
      15,
      2,
      9,
      7,
      2,
      12,
      6,
      9,
      8,
      5,
      0,
      6,
      13,
      1,
      3,
      13,
      4,
      14,
      14,
      0,
      7,
      11,
      5,
      3,
      11,
      8,
      9,
      4,
      14,
      3,
      15,
      2,
      5,
      12,
      2,
      9,
      8,
      5,
      12,
      15,
      3,
      10,
      7,
      11,
      0,
      14,
      4,
      1,
      10,
      7,
      1,
      6,
      13,
      0,
      11,
      8,
      6,
      13,
      4,
      13,
      11,
      0,
      2,
      11,
      14,
      7,
      15,
      4,
      0,
      9,
      8,
      1,
      13,
      10,
      3,
      14,
      12,
      3,
      9,
      5,
      7,
      12,
      5,
      2,
      10,
      15,
      6,
      8,
      1,
      6,
      1,
      6,
      4,
      11,
      11,
      13,
      13,
      8,
      12,
      1,
      3,
      4,
      7,
      10,
      14,
      7,
      10,
      9,
      15,
      5,
      6,
      0,
      8,
      15,
      0,
      14,
      5,
      2,
      9,
      3,
      2,
      12,
      13,
      1,
      2,
      15,
      8,
      13,
      4,
      8,
      6,
      10,
      15,
      3,
      11,
      7,
      1,
      4,
      10,
      12,
      9,
      5,
      3,
      6,
      14,
      11,
      5,
      0,
      0,
      14,
      12,
      9,
      7,
      2,
      7,
      2,
      11,
      1,
      4,
      14,
      1,
      7,
      9,
      4,
      12,
      10,
      14,
      8,
      2,
      13,
      0,
      15,
      6,
      12,
      10,
      9,
      13,
      0,
      15,
      3,
      3,
      5,
      5,
      6,
      8,
      11
    ];
    exports2.substitute = function substitute(inL, inR) {
      var out = 0;
      for (var i = 0; i < 4; i++) {
        var b = inL >>> 18 - i * 6 & 63;
        var sb = sTable[i * 64 + b];
        out <<= 4;
        out |= sb;
      }
      for (var i = 0; i < 4; i++) {
        var b = inR >>> 18 - i * 6 & 63;
        var sb = sTable[4 * 64 + i * 64 + b];
        out <<= 4;
        out |= sb;
      }
      return out >>> 0;
    };
    var permuteTable = [
      16,
      25,
      12,
      11,
      3,
      20,
      4,
      15,
      31,
      17,
      9,
      6,
      27,
      14,
      1,
      22,
      30,
      24,
      8,
      18,
      0,
      5,
      29,
      23,
      13,
      19,
      2,
      26,
      10,
      21,
      28,
      7
    ];
    exports2.permute = function permute(num) {
      var out = 0;
      for (var i = 0; i < permuteTable.length; i++) {
        out <<= 1;
        out |= num >>> permuteTable[i] & 1;
      }
      return out >>> 0;
    };
    exports2.padSplit = function padSplit(num, size2, group2) {
      var str = num.toString(2);
      while (str.length < size2)
        str = "0" + str;
      var out = [];
      for (var i = 0; i < size2; i += group2)
        out.push(str.slice(i, i + group2));
      return out.join(" ");
    };
  }
});

// ../node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS({
  "../node_modules/minimalistic-assert/index.js"(exports2, module2) {
    module2.exports = assert;
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    assert.equal = function assertEqual(l, r, msg) {
      if (l != r)
        throw new Error(msg || "Assertion failed: " + l + " != " + r);
    };
  }
});

// ../node_modules/des.js/lib/des/cipher.js
var require_cipher = __commonJS({
  "../node_modules/des.js/lib/des/cipher.js"(exports2, module2) {
    "use strict";
    var assert = require_minimalistic_assert();
    function Cipher(options) {
      this.options = options;
      this.type = this.options.type;
      this.blockSize = 8;
      this._init();
      this.buffer = new Array(this.blockSize);
      this.bufferOff = 0;
      this.padding = options.padding !== false;
    }
    module2.exports = Cipher;
    Cipher.prototype._init = function _init() {
    };
    Cipher.prototype.update = function update(data) {
      if (data.length === 0)
        return [];
      if (this.type === "decrypt")
        return this._updateDecrypt(data);
      else
        return this._updateEncrypt(data);
    };
    Cipher.prototype._buffer = function _buffer(data, off) {
      var min2 = Math.min(this.buffer.length - this.bufferOff, data.length - off);
      for (var i = 0; i < min2; i++)
        this.buffer[this.bufferOff + i] = data[off + i];
      this.bufferOff += min2;
      return min2;
    };
    Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
      this._update(this.buffer, 0, out, off);
      this.bufferOff = 0;
      return this.blockSize;
    };
    Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count = (this.bufferOff + data.length) / this.blockSize | 0;
      var out = new Array(count * this.blockSize);
      if (this.bufferOff !== 0) {
        inputOff += this._buffer(data, inputOff);
        if (this.bufferOff === this.buffer.length)
          outputOff += this._flushBuffer(out, outputOff);
      }
      var max2 = data.length - (data.length - inputOff) % this.blockSize;
      for (; inputOff < max2; inputOff += this.blockSize) {
        this._update(data, inputOff, out, outputOff);
        outputOff += this.blockSize;
      }
      for (; inputOff < data.length; inputOff++, this.bufferOff++)
        this.buffer[this.bufferOff] = data[inputOff];
      return out;
    };
    Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
      var inputOff = 0;
      var outputOff = 0;
      var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
      var out = new Array(count * this.blockSize);
      for (; count > 0; count--) {
        inputOff += this._buffer(data, inputOff);
        outputOff += this._flushBuffer(out, outputOff);
      }
      inputOff += this._buffer(data, inputOff);
      return out;
    };
    Cipher.prototype.final = function final(buffer) {
      var first2;
      if (buffer)
        first2 = this.update(buffer);
      var last2;
      if (this.type === "encrypt")
        last2 = this._finalEncrypt();
      else
        last2 = this._finalDecrypt();
      if (first2)
        return first2.concat(last2);
      else
        return last2;
    };
    Cipher.prototype._pad = function _pad(buffer, off) {
      if (off === 0)
        return false;
      while (off < buffer.length)
        buffer[off++] = 0;
      return true;
    };
    Cipher.prototype._finalEncrypt = function _finalEncrypt() {
      if (!this._pad(this.buffer, this.bufferOff))
        return [];
      var out = new Array(this.blockSize);
      this._update(this.buffer, 0, out, 0);
      return out;
    };
    Cipher.prototype._unpad = function _unpad(buffer) {
      return buffer;
    };
    Cipher.prototype._finalDecrypt = function _finalDecrypt() {
      assert.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
      var out = new Array(this.blockSize);
      this._flushBuffer(out, 0);
      return this._unpad(out);
    };
  }
});

// ../node_modules/des.js/lib/des/des.js
var require_des = __commonJS({
  "../node_modules/des.js/lib/des/des.js"(exports2, module2) {
    "use strict";
    var assert = require_minimalistic_assert();
    var inherits = require_inherits();
    var utils = require_utils3();
    var Cipher = require_cipher();
    function DESState() {
      this.tmp = new Array(2);
      this.keys = null;
    }
    function DES(options) {
      Cipher.call(this, options);
      var state = new DESState();
      this._desState = state;
      this.deriveKeys(state, options.key);
    }
    inherits(DES, Cipher);
    module2.exports = DES;
    DES.create = function create2(options) {
      return new DES(options);
    };
    var shiftTable = [
      1,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      1,
      2,
      2,
      2,
      2,
      2,
      2,
      1
    ];
    DES.prototype.deriveKeys = function deriveKeys(state, key) {
      state.keys = new Array(16 * 2);
      assert.equal(key.length, this.blockSize, "Invalid key length");
      var kL = utils.readUInt32BE(key, 0);
      var kR = utils.readUInt32BE(key, 4);
      utils.pc1(kL, kR, state.tmp, 0);
      kL = state.tmp[0];
      kR = state.tmp[1];
      for (var i = 0; i < state.keys.length; i += 2) {
        var shift = shiftTable[i >>> 1];
        kL = utils.r28shl(kL, shift);
        kR = utils.r28shl(kR, shift);
        utils.pc2(kL, kR, state.keys, i);
      }
    };
    DES.prototype._update = function _update(inp, inOff, out, outOff) {
      var state = this._desState;
      var l = utils.readUInt32BE(inp, inOff);
      var r = utils.readUInt32BE(inp, inOff + 4);
      utils.ip(l, r, state.tmp, 0);
      l = state.tmp[0];
      r = state.tmp[1];
      if (this.type === "encrypt")
        this._encrypt(state, l, r, state.tmp, 0);
      else
        this._decrypt(state, l, r, state.tmp, 0);
      l = state.tmp[0];
      r = state.tmp[1];
      utils.writeUInt32BE(out, l, outOff);
      utils.writeUInt32BE(out, r, outOff + 4);
    };
    DES.prototype._pad = function _pad(buffer, off) {
      if (this.padding === false) {
        return false;
      }
      var value = buffer.length - off;
      for (var i = off; i < buffer.length; i++)
        buffer[i] = value;
      return true;
    };
    DES.prototype._unpad = function _unpad(buffer) {
      if (this.padding === false) {
        return buffer;
      }
      var pad = buffer[buffer.length - 1];
      for (var i = buffer.length - pad; i < buffer.length; i++)
        assert.equal(buffer[i], pad);
      return buffer.slice(0, buffer.length - pad);
    };
    DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
      var l = lStart;
      var r = rStart;
      for (var i = 0; i < state.keys.length; i += 2) {
        var keyL = state.keys[i];
        var keyR = state.keys[i + 1];
        utils.expand(r, state.tmp, 0);
        keyL ^= state.tmp[0];
        keyR ^= state.tmp[1];
        var s = utils.substitute(keyL, keyR);
        var f = utils.permute(s);
        var t = r;
        r = (l ^ f) >>> 0;
        l = t;
      }
      utils.rip(r, l, out, off);
    };
    DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
      var l = rStart;
      var r = lStart;
      for (var i = state.keys.length - 2; i >= 0; i -= 2) {
        var keyL = state.keys[i];
        var keyR = state.keys[i + 1];
        utils.expand(l, state.tmp, 0);
        keyL ^= state.tmp[0];
        keyR ^= state.tmp[1];
        var s = utils.substitute(keyL, keyR);
        var f = utils.permute(s);
        var t = l;
        l = (r ^ f) >>> 0;
        r = t;
      }
      utils.rip(l, r, out, off);
    };
  }
});

// ../node_modules/des.js/lib/des/cbc.js
var require_cbc = __commonJS({
  "../node_modules/des.js/lib/des/cbc.js"(exports2) {
    "use strict";
    var assert = require_minimalistic_assert();
    var inherits = require_inherits();
    var proto = {};
    function CBCState(iv) {
      assert.equal(iv.length, 8, "Invalid IV length");
      this.iv = new Array(8);
      for (var i = 0; i < this.iv.length; i++)
        this.iv[i] = iv[i];
    }
    function instantiate(Base) {
      function CBC(options) {
        Base.call(this, options);
        this._cbcInit();
      }
      inherits(CBC, Base);
      var keys2 = Object.keys(proto);
      for (var i = 0; i < keys2.length; i++) {
        var key = keys2[i];
        CBC.prototype[key] = proto[key];
      }
      CBC.create = function create2(options) {
        return new CBC(options);
      };
      return CBC;
    }
    exports2.instantiate = instantiate;
    proto._cbcInit = function _cbcInit() {
      var state = new CBCState(this.options.iv);
      this._cbcState = state;
    };
    proto._update = function _update(inp, inOff, out, outOff) {
      var state = this._cbcState;
      var superProto = this.constructor.super_.prototype;
      var iv = state.iv;
      if (this.type === "encrypt") {
        for (var i = 0; i < this.blockSize; i++)
          iv[i] ^= inp[inOff + i];
        superProto._update.call(this, iv, 0, out, outOff);
        for (var i = 0; i < this.blockSize; i++)
          iv[i] = out[outOff + i];
      } else {
        superProto._update.call(this, inp, inOff, out, outOff);
        for (var i = 0; i < this.blockSize; i++)
          out[outOff + i] ^= iv[i];
        for (var i = 0; i < this.blockSize; i++)
          iv[i] = inp[inOff + i];
      }
    };
  }
});

// ../node_modules/des.js/lib/des/ede.js
var require_ede = __commonJS({
  "../node_modules/des.js/lib/des/ede.js"(exports2, module2) {
    "use strict";
    var assert = require_minimalistic_assert();
    var inherits = require_inherits();
    var Cipher = require_cipher();
    var DES = require_des();
    function EDEState(type, key) {
      assert.equal(key.length, 24, "Invalid key length");
      var k1 = key.slice(0, 8);
      var k2 = key.slice(8, 16);
      var k3 = key.slice(16, 24);
      if (type === "encrypt") {
        this.ciphers = [
          DES.create({ type: "encrypt", key: k1 }),
          DES.create({ type: "decrypt", key: k2 }),
          DES.create({ type: "encrypt", key: k3 })
        ];
      } else {
        this.ciphers = [
          DES.create({ type: "decrypt", key: k3 }),
          DES.create({ type: "encrypt", key: k2 }),
          DES.create({ type: "decrypt", key: k1 })
        ];
      }
    }
    function EDE(options) {
      Cipher.call(this, options);
      var state = new EDEState(this.type, this.options.key);
      this._edeState = state;
    }
    inherits(EDE, Cipher);
    module2.exports = EDE;
    EDE.create = function create2(options) {
      return new EDE(options);
    };
    EDE.prototype._update = function _update(inp, inOff, out, outOff) {
      var state = this._edeState;
      state.ciphers[0]._update(inp, inOff, out, outOff);
      state.ciphers[1]._update(out, outOff, out, outOff);
      state.ciphers[2]._update(out, outOff, out, outOff);
    };
    EDE.prototype._pad = DES.prototype._pad;
    EDE.prototype._unpad = DES.prototype._unpad;
  }
});

// ../node_modules/des.js/lib/des.js
var require_des2 = __commonJS({
  "../node_modules/des.js/lib/des.js"(exports2) {
    "use strict";
    exports2.utils = require_utils3();
    exports2.Cipher = require_cipher();
    exports2.DES = require_des();
    exports2.CBC = require_cbc();
    exports2.EDE = require_ede();
  }
});

// ../node_modules/azure-devops-node-api/node_modules/typed-rest-client/opensource/Node-SMB/lib/smbhash.js
var require_smbhash = __commonJS({
  "../node_modules/azure-devops-node-api/node_modules/typed-rest-client/opensource/Node-SMB/lib/smbhash.js"(exports2, module2) {
    var $ = require_common2();
    var jsmd4 = require_md4();
    var desjs = require_des2();
    function lmhashbuf(inputstr) {
      var x = inputstr.substring(0, 14).toUpperCase();
      var xl = Buffer.byteLength(x, "ascii");
      var y = Buffer.alloc(14);
      y.write(x, 0, xl, "ascii");
      y.fill(0, xl);
      var halves = [
        $.oddpar($.expandkey(y.slice(0, 7))),
        $.oddpar($.expandkey(y.slice(7, 14)))
      ];
      var buf = Buffer.alloc(16);
      var pos = 0;
      var cts = halves.forEach(function(z) {
        var des = desjs.DES.create({ type: "encrypt", key: z });
        var magicKey = Buffer.from("KGS!@#$%", "ascii");
        var insertBuff = Buffer.from(des.update(magicKey));
        buf.fill(insertBuff, pos, pos + 8, "binary");
        pos += 8;
      });
      return buf;
    }
    function nthashbuf(str) {
      var ucs2 = Buffer.from(str, "ucs2");
      var md4 = jsmd4.create();
      md4.update(ucs2);
      return Buffer.from(md4.digest("binary"), "binary");
    }
    function lmhash(is) {
      return $.bintohex(lmhashbuf(is));
    }
    function nthash(is) {
      return $.bintohex(nthashbuf(is));
    }
    module2.exports.nthashbuf = nthashbuf;
    module2.exports.lmhashbuf = lmhashbuf;
    module2.exports.nthash = nthash;
    module2.exports.lmhash = lmhash;
  }
});

// ../node_modules/azure-devops-node-api/node_modules/typed-rest-client/opensource/Node-SMB/lib/ntlm.js
var require_ntlm = __commonJS({
  "../node_modules/azure-devops-node-api/node_modules/typed-rest-client/opensource/Node-SMB/lib/ntlm.js"(exports2) {
    var crypto = require("crypto");
    var $ = require_common2();
    var lmhashbuf = require_smbhash().lmhashbuf;
    var nthashbuf = require_smbhash().nthashbuf;
    var desjs = require_des2();
    function encodeType1(hostname, ntdomain) {
      hostname = hostname.toUpperCase();
      ntdomain = ntdomain.toUpperCase();
      var hostnamelen = Buffer.byteLength(hostname, "ascii");
      var ntdomainlen = Buffer.byteLength(ntdomain, "ascii");
      var pos = 0;
      var buf = Buffer.alloc(32 + hostnamelen + ntdomainlen);
      buf.write("NTLMSSP", pos, 7, "ascii");
      pos += 7;
      buf.writeUInt8(0, pos);
      pos++;
      buf.writeUInt8(1, pos);
      pos++;
      buf.fill(0, pos, pos + 3);
      pos += 3;
      buf.writeUInt16LE(45571, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.writeUInt16LE(ntdomainlen, pos);
      pos += 2;
      buf.writeUInt16LE(ntdomainlen, pos);
      pos += 2;
      var ntdomainoff = 32 + hostnamelen;
      buf.writeUInt16LE(ntdomainoff, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.writeUInt16LE(hostnamelen, pos);
      pos += 2;
      buf.writeUInt16LE(hostnamelen, pos);
      pos += 2;
      buf.writeUInt16LE(32, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.write(hostname, 32, hostnamelen, "ascii");
      buf.write(ntdomain, ntdomainoff, ntdomainlen, "ascii");
      return buf;
    }
    function decodeType2(buf) {
      var proto = buf.toString("ascii", 0, 7);
      if (buf[7] !== 0 || proto !== "NTLMSSP")
        throw new Error("magic was not NTLMSSP");
      var type = buf.readUInt8(8);
      if (type !== 2)
        throw new Error("message was not NTLMSSP type 0x02");
      var nonce = buf.slice(24, 32);
      return nonce;
    }
    function encodeType3(username, hostname, ntdomain, nonce, password) {
      hostname = hostname.toUpperCase();
      ntdomain = ntdomain.toUpperCase();
      var lmh = Buffer.alloc(21);
      lmhashbuf(password).copy(lmh);
      lmh.fill(0, 16);
      var nth = Buffer.alloc(21);
      nthashbuf(password).copy(nth);
      nth.fill(0, 16);
      var lmr = makeResponse(lmh, nonce);
      var ntr = makeResponse(nth, nonce);
      var usernamelen = Buffer.byteLength(username, "ucs2");
      var hostnamelen = Buffer.byteLength(hostname, "ucs2");
      var ntdomainlen = Buffer.byteLength(ntdomain, "ucs2");
      var lmrlen = 24;
      var ntrlen = 24;
      var ntdomainoff = 64;
      var usernameoff = ntdomainoff + ntdomainlen;
      var hostnameoff = usernameoff + usernamelen;
      var lmroff = hostnameoff + hostnamelen;
      var ntroff = lmroff + lmrlen;
      var pos = 0;
      var msg_len = 64 + ntdomainlen + usernamelen + hostnamelen + lmrlen + ntrlen;
      var buf = Buffer.alloc(msg_len);
      buf.write("NTLMSSP", pos, 7, "ascii");
      pos += 7;
      buf.writeUInt8(0, pos);
      pos++;
      buf.writeUInt8(3, pos);
      pos++;
      buf.fill(0, pos, pos + 3);
      pos += 3;
      buf.writeUInt16LE(lmrlen, pos);
      pos += 2;
      buf.writeUInt16LE(lmrlen, pos);
      pos += 2;
      buf.writeUInt16LE(lmroff, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.writeUInt16LE(ntrlen, pos);
      pos += 2;
      buf.writeUInt16LE(ntrlen, pos);
      pos += 2;
      buf.writeUInt16LE(ntroff, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.writeUInt16LE(ntdomainlen, pos);
      pos += 2;
      buf.writeUInt16LE(ntdomainlen, pos);
      pos += 2;
      buf.writeUInt16LE(ntdomainoff, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.writeUInt16LE(usernamelen, pos);
      pos += 2;
      buf.writeUInt16LE(usernamelen, pos);
      pos += 2;
      buf.writeUInt16LE(usernameoff, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.writeUInt16LE(hostnamelen, pos);
      pos += 2;
      buf.writeUInt16LE(hostnamelen, pos);
      pos += 2;
      buf.writeUInt16LE(hostnameoff, pos);
      pos += 2;
      buf.fill(0, pos, pos + 6);
      pos += 6;
      buf.writeUInt16LE(msg_len, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.writeUInt16LE(33281, pos);
      pos += 2;
      buf.fill(0, pos, pos + 2);
      pos += 2;
      buf.write(ntdomain, ntdomainoff, ntdomainlen, "ucs2");
      buf.write(username, usernameoff, usernamelen, "ucs2");
      buf.write(hostname, hostnameoff, hostnamelen, "ucs2");
      lmr.copy(buf, lmroff, 0, lmrlen);
      ntr.copy(buf, ntroff, 0, ntrlen);
      return buf;
    }
    function makeResponse(hash, nonce) {
      var out = Buffer.alloc(24);
      for (var i = 0; i < 3; i++) {
        var keybuf = $.oddpar($.expandkey(hash.slice(i * 7, i * 7 + 7)));
        var des = desjs.DES.create({ type: "encrypt", key: keybuf });
        var magicKey = Buffer.from(nonce.toString("binary"));
        var insertBuff = Buffer.from(des.update(magicKey));
        out.fill(insertBuff, i * 8, i * 8 + 8, "binary");
      }
      return out;
    }
    exports2.encodeType1 = encodeType1;
    exports2.decodeType2 = decodeType2;
    exports2.encodeType3 = encodeType3;
    exports2.challengeHeader = function(hostname, domain) {
      return "NTLM " + exports2.encodeType1(hostname, domain).toString("base64");
    };
    exports2.responseHeader = function(res, url, domain, username, password) {
      var serverNonce = Buffer.from((res.headers["www-authenticate"].match(/^NTLM\s+(.+?)(,|\s+|$)/) || [])[1], "base64");
      var hostname = require("url").parse(url).hostname;
      return "NTLM " + exports2.encodeType3(username, hostname, domain, exports2.decodeType2(serverNonce), password).toString("base64");
    };
    exports2.smbhash = require_smbhash();
  }
});

// ../node_modules/azure-devops-node-api/node_modules/typed-rest-client/handlers/ntlm.js
var require_ntlm2 = __commonJS({
  "../node_modules/azure-devops-node-api/node_modules/typed-rest-client/handlers/ntlm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NtlmCredentialHandler = void 0;
    var http = require("http");
    var https = require("https");
    var _3 = (init_index_all(), __toCommonJS(index_all_exports));
    var ntlm = require_ntlm();
    var NtlmCredentialHandler = class {
      constructor(username, password, workstation, domain) {
        this._ntlmOptions = {};
        this._ntlmOptions.username = username;
        this._ntlmOptions.password = password;
        this._ntlmOptions.domain = domain || "";
        this._ntlmOptions.workstation = workstation || "";
      }
      prepareRequest(options) {
        if (options.agent) {
          delete options.agent;
        }
      }
      canHandleAuthentication(response) {
        if (response && response.message && response.message.statusCode === 401) {
          const wwwAuthenticate = response.message.headers["www-authenticate"];
          return wwwAuthenticate && wwwAuthenticate.split(", ").indexOf("NTLM") >= 0;
        }
        return false;
      }
      handleAuthentication(httpClient, requestInfo, objs) {
        return new Promise((resolve, reject2) => {
          const callbackForResult = function(err, res) {
            if (err) {
              reject2(err);
              return;
            }
            res.readBody().then(() => {
              resolve(res);
            });
          };
          this.handleAuthenticationPrivate(httpClient, requestInfo, objs, callbackForResult);
        });
      }
      handleAuthenticationPrivate(httpClient, requestInfo, objs, finalCallback) {
        requestInfo.options = _3.extend(requestInfo.options, {
          username: this._ntlmOptions.username,
          password: this._ntlmOptions.password,
          domain: this._ntlmOptions.domain,
          workstation: this._ntlmOptions.workstation
        });
        requestInfo.options.agent = httpClient.isSsl ? new https.Agent({ keepAlive: true }) : new http.Agent({ keepAlive: true });
        let self2 = this;
        this.sendType1Message(httpClient, requestInfo, objs, function(err, res) {
          if (err) {
            return finalCallback(err, null, null);
          }
          res.readBody().then(() => {
            setImmediate(function() {
              self2.sendType3Message(httpClient, requestInfo, objs, res, finalCallback);
            });
          });
        });
      }
      // The following method is an adaptation of code found at https://github.com/SamDecrock/node-http-ntlm/blob/master/httpntlm.js
      sendType1Message(httpClient, requestInfo, objs, finalCallback) {
        const type1HexBuffer = ntlm.encodeType1(this._ntlmOptions.workstation, this._ntlmOptions.domain);
        const type1msg = `NTLM ${type1HexBuffer.toString("base64")}`;
        const type1options = {
          headers: {
            "Connection": "keep-alive",
            "Authorization": type1msg
          },
          timeout: requestInfo.options.timeout || 0,
          agent: requestInfo.httpModule
        };
        const type1info = {};
        type1info.httpModule = requestInfo.httpModule;
        type1info.parsedUrl = requestInfo.parsedUrl;
        type1info.options = _3.extend(type1options, _3.omit(requestInfo.options, "headers"));
        return httpClient.requestRawWithCallback(type1info, objs, finalCallback);
      }
      // The following method is an adaptation of code found at https://github.com/SamDecrock/node-http-ntlm/blob/master/httpntlm.js
      sendType3Message(httpClient, requestInfo, objs, res, callback) {
        if (!res.message.headers && !res.message.headers["www-authenticate"]) {
          throw new Error("www-authenticate not found on response of second request");
        }
        const serverNonceRegex = /^NTLM\s+(.+?)(,|\s+|$)/;
        const serverNonce = Buffer.from((res.message.headers["www-authenticate"].match(serverNonceRegex) || [])[1], "base64");
        let type2msg;
        try {
          type2msg = ntlm.decodeType2(serverNonce);
        } catch (error) {
          throw new Error(`Decoding Server's Challenge to Obtain Type2Message failed with error: ${error.message}`);
        }
        const type3msg = ntlm.encodeType3(this._ntlmOptions.username, this._ntlmOptions.workstation, this._ntlmOptions.domain, type2msg, this._ntlmOptions.password).toString("base64");
        const type3options = {
          headers: {
            "Authorization": `NTLM ${type3msg}`,
            "Connection": "Close"
          },
          agent: requestInfo.httpModule
        };
        const type3info = {};
        type3info.httpModule = requestInfo.httpModule;
        type3info.parsedUrl = requestInfo.parsedUrl;
        type3options.headers = _3.extend(type3options.headers, requestInfo.options.headers);
        type3info.options = _3.extend(type3options, _3.omit(requestInfo.options, "headers"));
        return httpClient.requestRawWithCallback(type3info, objs, callback);
      }
    };
    exports2.NtlmCredentialHandler = NtlmCredentialHandler;
  }
});

// ../node_modules/azure-devops-node-api/node_modules/typed-rest-client/handlers/personalaccesstoken.js
var require_personalaccesstoken = __commonJS({
  "../node_modules/azure-devops-node-api/node_modules/typed-rest-client/handlers/personalaccesstoken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PersonalAccessTokenCredentialHandler = void 0;
    var PersonalAccessTokenCredentialHandler = class {
      constructor(token, allowCrossOriginAuthentication) {
        this.token = token;
        this.allowCrossOriginAuthentication = allowCrossOriginAuthentication;
      }
      // currently implements pre-authorization
      // TODO: support preAuth = false where it hooks on 401
      prepareRequest(options) {
        if (!this.origin) {
          this.origin = options.host;
        }
        if (this.origin === options.host || this.allowCrossOriginAuthentication) {
          options.headers["Authorization"] = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
        }
        options.headers["X-TFS-FedAuthRedirect"] = "Suppress";
      }
      // This handler cannot handle 401
      canHandleAuthentication(response) {
        return false;
      }
      handleAuthentication(httpClient, requestInfo, objs) {
        return null;
      }
    };
    exports2.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  }
});

// ../node_modules/azure-devops-node-api/node_modules/typed-rest-client/Handlers.js
var require_Handlers = __commonJS({
  "../node_modules/azure-devops-node-api/node_modules/typed-rest-client/Handlers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PersonalAccessTokenCredentialHandler = exports2.NtlmCredentialHandler = exports2.BearerCredentialHandler = exports2.BasicCredentialHandler = void 0;
    var basiccreds_1 = require_basiccreds();
    Object.defineProperty(exports2, "BasicCredentialHandler", { enumerable: true, get: function() {
      return basiccreds_1.BasicCredentialHandler;
    } });
    var bearertoken_1 = require_bearertoken();
    Object.defineProperty(exports2, "BearerCredentialHandler", { enumerable: true, get: function() {
      return bearertoken_1.BearerCredentialHandler;
    } });
    var ntlm_1 = require_ntlm2();
    Object.defineProperty(exports2, "NtlmCredentialHandler", { enumerable: true, get: function() {
      return ntlm_1.NtlmCredentialHandler;
    } });
    var personalaccesstoken_1 = require_personalaccesstoken();
    Object.defineProperty(exports2, "PersonalAccessTokenCredentialHandler", { enumerable: true, get: function() {
      return personalaccesstoken_1.PersonalAccessTokenCredentialHandler;
    } });
  }
});

// ../node_modules/azure-devops-node-api/handlers/basiccreds.js
var require_basiccreds2 = __commonJS({
  "../node_modules/azure-devops-node-api/handlers/basiccreds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BasicCredentialHandler = void 0;
    var resthandlers = require_Handlers();
    var BasicCredentialHandler = class extends resthandlers.BasicCredentialHandler {
      constructor(username, password, allowCrossOriginAuthentication = true) {
        super(username, password, allowCrossOriginAuthentication);
      }
    };
    exports2.BasicCredentialHandler = BasicCredentialHandler;
  }
});

// ../node_modules/azure-devops-node-api/handlers/bearertoken.js
var require_bearertoken2 = __commonJS({
  "../node_modules/azure-devops-node-api/handlers/bearertoken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.BearerCredentialHandler = void 0;
    var resthandlers = require_Handlers();
    var BearerCredentialHandler = class extends resthandlers.BearerCredentialHandler {
      constructor(token, allowCrossOriginAuthentication = true) {
        super(token, allowCrossOriginAuthentication);
      }
    };
    exports2.BearerCredentialHandler = BearerCredentialHandler;
  }
});

// ../node_modules/azure-devops-node-api/handlers/ntlm.js
var require_ntlm3 = __commonJS({
  "../node_modules/azure-devops-node-api/handlers/ntlm.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.NtlmCredentialHandler = void 0;
    var resthandlers = require_Handlers();
    var NtlmCredentialHandler = class extends resthandlers.NtlmCredentialHandler {
      constructor(username, password, workstation, domain) {
        super(username, password, workstation, domain);
      }
    };
    exports2.NtlmCredentialHandler = NtlmCredentialHandler;
  }
});

// ../node_modules/azure-devops-node-api/handlers/personalaccesstoken.js
var require_personalaccesstoken2 = __commonJS({
  "../node_modules/azure-devops-node-api/handlers/personalaccesstoken.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.PersonalAccessTokenCredentialHandler = void 0;
    var resthandlers = require_Handlers();
    var PersonalAccessTokenCredentialHandler = class extends resthandlers.PersonalAccessTokenCredentialHandler {
      constructor(token, allowCrossOriginAuthentication = true) {
        super(token, allowCrossOriginAuthentication);
      }
    };
    exports2.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;
  }
});

// ../node_modules/azure-devops-node-api/WebApi.js
var require_WebApi = __commonJS({
  "../node_modules/azure-devops-node-api/WebApi.js"(exports2) {
    "use strict";
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.WebApi = exports2.getHandlerFromToken = exports2.getPersonalAccessTokenHandler = exports2.getBearerHandler = exports2.getNtlmHandler = exports2.getBasicHandler = void 0;
    var alertm = require_AlertApi();
    var buildm = require_BuildApi();
    var corem = require_CoreApi();
    var dashboardm = require_DashboardApi();
    var extmgmtm = require_ExtensionManagementApi();
    var featuremgmtm = require_FeatureManagementApi();
    var filecontainerm = require_FileContainerApi();
    var gallerym = require_GalleryApi();
    var gitm = require_GitApi();
    var locationsm = require_LocationsApi();
    var managementm = require_ManagementApi();
    var notificationm = require_NotificationApi();
    var policym = require_PolicyApi();
    var profilem = require_ProfileApi();
    var projectm = require_ProjectAnalysisApi();
    var releasem = require_ReleaseApi();
    var securityrolesm = require_SecurityRolesApi();
    var taskagentm = require_TaskAgentApi();
    var taskm = require_TaskApi();
    var testm = require_TestApi();
    var testplanm = require_TestPlanApi();
    var testresultsm = require_TestResultsApi();
    var tfvcm = require_TfvcApi();
    var wikim = require_WikiApi();
    var workm = require_WorkApi();
    var pipelinesm = require_PipelinesApi();
    var cixm = require_CIXApi();
    var workitemtrackingm = require_WorkItemTrackingApi();
    var workitemtrackingprocessm = require_WorkItemTrackingProcessApi();
    var workitemtrackingprocessdefinitionm = require_WorkItemTrackingProcessDefinitionsApi();
    var basicm = require_basiccreds2();
    var bearm = require_bearertoken2();
    var ntlmm = require_ntlm3();
    var patm = require_personalaccesstoken2();
    var rm = require_RestClient();
    var vsom = require_VsoClient();
    var crypto = require("crypto");
    var fs3 = require("fs");
    var os = require("os");
    var url = require("url");
    var path2 = require("path");
    var isBrowser = typeof window !== "undefined";
    var personalAccessTokenRegex = new RegExp("^.{76}AZDO.{4}$");
    function getBasicHandler(username, password, allowCrossOriginAuthentication) {
      return new basicm.BasicCredentialHandler(username, password, allowCrossOriginAuthentication);
    }
    exports2.getBasicHandler = getBasicHandler;
    function getNtlmHandler(username, password, workstation, domain) {
      return new ntlmm.NtlmCredentialHandler(username, password, workstation, domain);
    }
    exports2.getNtlmHandler = getNtlmHandler;
    function getBearerHandler(token, allowCrossOriginAuthentication) {
      return new bearm.BearerCredentialHandler(token, allowCrossOriginAuthentication);
    }
    exports2.getBearerHandler = getBearerHandler;
    function getPersonalAccessTokenHandler(token, allowCrossOriginAuthentication) {
      return new patm.PersonalAccessTokenCredentialHandler(token, allowCrossOriginAuthentication);
    }
    exports2.getPersonalAccessTokenHandler = getPersonalAccessTokenHandler;
    function getHandlerFromToken(token, allowCrossOriginAuthentication) {
      if (token.length === 52 || personalAccessTokenRegex.test(token)) {
        return getPersonalAccessTokenHandler(token, allowCrossOriginAuthentication);
      } else {
        return getBearerHandler(token, allowCrossOriginAuthentication);
      }
    }
    exports2.getHandlerFromToken = getHandlerFromToken;
    var WebApi = class {
      /*
       * Factory to return client apis and handlers
       * @param defaultUrl default server url to use when creating new apis from factory methods
       * @param authHandler default authentication credentials to use when creating new apis from factory methods
       */
      constructor(defaultUrl, authHandler, options, requestSettings) {
        this.isNoProxyHost = function(_url) {
          if (!process.env.no_proxy) {
            return false;
          }
          const noProxyDomains = (process.env.no_proxy || "").split(",").map((v) => v.toLowerCase());
          const serverUrl = url.parse(_url).host.toLowerCase();
          return noProxyDomains.indexOf(serverUrl) !== -1;
        };
        this.serverUrl = defaultUrl;
        this.authHandler = authHandler;
        this.options = options || {};
        if (!this.isNoProxyHost(this.serverUrl)) {
          if (!this.options.proxy || !this.options.proxy.proxyUrl) {
            if (global["_vsts_task_lib_proxy"]) {
              let proxyFromEnv = {
                proxyUrl: global["_vsts_task_lib_proxy_url"],
                proxyUsername: global["_vsts_task_lib_proxy_username"],
                proxyPassword: this._readTaskLibSecrets(global["_vsts_task_lib_proxy_password"]),
                proxyBypassHosts: JSON.parse(global["_vsts_task_lib_proxy_bypass"] || "[]")
              };
              this.options.proxy = proxyFromEnv;
            }
          }
        }
        if (!this.options.cert) {
          if (global["_vsts_task_lib_cert"]) {
            let certFromEnv = {
              caFile: global["_vsts_task_lib_cert_ca"],
              certFile: global["_vsts_task_lib_cert_clientcert"],
              keyFile: global["_vsts_task_lib_cert_key"],
              passphrase: this._readTaskLibSecrets(global["_vsts_task_lib_cert_passphrase"])
            };
            this.options.cert = certFromEnv;
          }
        }
        if (!this.options.ignoreSslError) {
          this.options.ignoreSslError = !!global["_vsts_task_lib_skip_cert_validation"];
        }
        let userAgent;
        const nodeApiName = "azure-devops-node-api";
        if (isBrowser) {
          if (requestSettings) {
            userAgent = `${requestSettings.productName}/${requestSettings.productVersion} (${nodeApiName}; ${window.navigator.userAgent})`;
          } else {
            userAgent = `${nodeApiName} (${window.navigator.userAgent})`;
          }
        } else {
          let nodeApiVersion = "unknown";
          const packageJsonPath = path2.resolve(__dirname, "package.json");
          if (fs3.existsSync(packageJsonPath)) {
            nodeApiVersion = JSON.parse(fs3.readFileSync(packageJsonPath, "utf8")).version;
          }
          const osName = os.platform();
          const osVersion = os.release();
          if (requestSettings) {
            userAgent = `${requestSettings.productName}/${requestSettings.productVersion} (${nodeApiName} ${nodeApiVersion}; ${osName} ${osVersion})`;
          } else {
            userAgent = `${nodeApiName}/${nodeApiVersion} (${osName} ${osVersion})`;
          }
        }
        this.rest = new rm.RestClient(userAgent, null, [this.authHandler], this.options);
        this.vsoClient = new vsom.VsoClient(defaultUrl, this.rest);
      }
      /**
       *  Convenience factory to create with a bearer token.
       * @param defaultServerUrl default server url to use when creating new apis from factory methods
       * @param defaultAuthHandler default authentication credentials to use when creating new apis from factory methods
       */
      static createWithBearerToken(defaultUrl, token, options) {
        let bearerHandler = getBearerHandler(token);
        return new this(defaultUrl, bearerHandler, options);
      }
      connect() {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject2) => __awaiter2(this, void 0, void 0, function* () {
            try {
              let res;
              res = yield this.rest.get(this.vsoClient.resolveUrl("/_apis/connectionData"));
              resolve(res.result);
            } catch (err) {
              reject2(err);
            }
          }));
        });
      }
      /**
       * Each factory method can take a serverUrl and a list of handlers
       * if these aren't provided, the default url and auth handler given to the constructor for this class will be used
       */
      getAlertApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "0f2ca920-f269-4545-b1f4-5b4173aa784e");
          handlers = handlers || [this.authHandler];
          return new alertm.AlertApi(serverUrl, handlers, this.options);
        });
      }
      getBuildApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, buildm.BuildApi.RESOURCE_AREA_ID);
          handlers = handlers || [this.authHandler];
          return new buildm.BuildApi(serverUrl, handlers, this.options);
        });
      }
      getCoreApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "79134c72-4a58-4b42-976c-04e7115f32bf");
          handlers = handlers || [this.authHandler];
          return new corem.CoreApi(serverUrl, handlers, this.options);
        });
      }
      getDashboardApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "31c84e0a-3ece-48fd-a29d-100849af99ba");
          handlers = handlers || [this.authHandler];
          return new dashboardm.DashboardApi(serverUrl, handlers, this.options);
        });
      }
      getExtensionManagementApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "6c2b0933-3600-42ae-bf8b-93d4f7e83594");
          handlers = handlers || [this.authHandler];
          return new extmgmtm.ExtensionManagementApi(serverUrl, handlers, this.options);
        });
      }
      getFeatureManagementApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "");
          handlers = handlers || [this.authHandler];
          return new featuremgmtm.FeatureManagementApi(serverUrl, handlers, this.options);
        });
      }
      getFileContainerApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "");
          handlers = handlers || [this.authHandler];
          return new filecontainerm.FileContainerApi(serverUrl, handlers, this.options);
        });
      }
      getGalleryApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, gallerym.GalleryApi.RESOURCE_AREA_ID);
          handlers = handlers || [this.authHandler];
          return new gallerym.GalleryApi(serverUrl, handlers, this.options);
        });
      }
      getGitApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, gitm.GitApi.RESOURCE_AREA_ID);
          handlers = handlers || [this.authHandler];
          return new gitm.GitApi(serverUrl, handlers, this.options);
        });
      }
      // TODO: Don't call resource area here? Will cause infinite loop?
      getLocationsApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          let optionsClone = Object.assign({}, this.options);
          optionsClone.allowRetries = true;
          optionsClone.maxRetries = 5;
          serverUrl = (yield serverUrl) || this.serverUrl;
          handlers = handlers || [this.authHandler];
          return new locationsm.LocationsApi(serverUrl, handlers, optionsClone);
        });
      }
      getManagementApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "f101720c-9790-45a6-9fb3-494a09fddeeb");
          handlers = handlers || [this.authHandler];
          return new managementm.ManagementApi(serverUrl, handlers, this.options);
        });
      }
      getNotificationApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "");
          handlers = handlers || [this.authHandler];
          return new notificationm.NotificationApi(serverUrl, handlers, this.options);
        });
      }
      getPolicyApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "fb13a388-40dd-4a04-b530-013a739c72ef");
          handlers = handlers || [this.authHandler];
          return new policym.PolicyApi(serverUrl, handlers, this.options);
        });
      }
      getProfileApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "8ccfef3d-2b87-4e99-8ccb-66e343d2daa8");
          handlers = handlers || [this.authHandler];
          return new profilem.ProfileApi(serverUrl, handlers, this.options);
        });
      }
      getProjectAnalysisApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "7658fa33-b1bf-4580-990f-fac5896773d3");
          handlers = handlers || [this.authHandler];
          return new projectm.ProjectAnalysisApi(serverUrl, handlers, this.options);
        });
      }
      getSecurityRolesApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "");
          handlers = handlers || [this.authHandler];
          return new securityrolesm.SecurityRolesApi(serverUrl, handlers, this.options);
        });
      }
      getReleaseApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "efc2f575-36ef-48e9-b672-0c6fb4a48ac5");
          handlers = handlers || [this.authHandler];
          return new releasem.ReleaseApi(serverUrl, handlers, this.options);
        });
      }
      getTaskApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "");
          handlers = handlers || [this.authHandler];
          return new taskm.TaskApi(serverUrl, handlers, this.options);
        });
      }
      getTaskAgentApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "a85b8835-c1a1-4aac-ae97-1c3d0ba72dbd");
          handlers = handlers || [this.authHandler];
          return new taskagentm.TaskAgentApi(serverUrl, handlers, this.options);
        });
      }
      getTestApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "c2aa639c-3ccc-4740-b3b6-ce2a1e1d984e");
          handlers = handlers || [this.authHandler];
          return new testm.TestApi(serverUrl, handlers, this.options);
        });
      }
      getTestPlanApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "e4c27205-9d23-4c98-b958-d798bc3f9cd4");
          handlers = handlers || [this.authHandler];
          return new testplanm.TestPlanApi(serverUrl, handlers, this.options);
        });
      }
      getTestResultsApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "c83eaf52-edf3-4034-ae11-17d38f25404c");
          handlers = handlers || [this.authHandler];
          return new testresultsm.TestResultsApi(serverUrl, handlers, this.options);
        });
      }
      getTfvcApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "8aa40520-446d-40e6-89f6-9c9f9ce44c48");
          handlers = handlers || [this.authHandler];
          return new tfvcm.TfvcApi(serverUrl, handlers, this.options);
        });
      }
      getWikiApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "bf7d82a0-8aa5-4613-94ef-6172a5ea01f3");
          handlers = handlers || [this.authHandler];
          return new wikim.WikiApi(serverUrl, handlers, this.options);
        });
      }
      getWorkApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "1d4f49f9-02b9-4e26-b826-2cdb6195f2a9");
          handlers = handlers || [this.authHandler];
          return new workm.WorkApi(serverUrl, handlers, this.options);
        });
      }
      getWorkItemTrackingApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, workitemtrackingm.WorkItemTrackingApi.RESOURCE_AREA_ID);
          handlers = handlers || [this.authHandler];
          return new workitemtrackingm.WorkItemTrackingApi(serverUrl, handlers, this.options);
        });
      }
      getWorkItemTrackingProcessApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "5264459e-e5e0-4bd8-b118-0985e68a4ec5");
          handlers = handlers || [this.authHandler];
          return new workitemtrackingprocessm.WorkItemTrackingProcessApi(serverUrl, handlers, this.options);
        });
      }
      getWorkItemTrackingProcessDefinitionApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "5264459e-e5e0-4bd8-b118-0985e68a4ec5");
          handlers = handlers || [this.authHandler];
          return new workitemtrackingprocessdefinitionm.WorkItemTrackingProcessDefinitionsApi(serverUrl, handlers, this.options);
        });
      }
      getPipelinesApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "5264459e-e5e0-4bd8-b118-0985e68a4ec5");
          handlers = handlers || [this.authHandler];
          return new pipelinesm.PipelinesApi(serverUrl, handlers, this.options);
        });
      }
      getCixApi(serverUrl, handlers) {
        return __awaiter2(this, void 0, void 0, function* () {
          serverUrl = yield this._getResourceAreaUrl(serverUrl || this.serverUrl, "5264459e-e5e0-4bd8-b118-0985e68a4ec5");
          handlers = handlers || [this.authHandler];
          return new cixm.CixApi(serverUrl, handlers, this.options);
        });
      }
      _getResourceAreaUrl(serverUrl, resourceId) {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!resourceId) {
            return serverUrl;
          }
          const resourceAreas = yield this._getResourceAreas();
          if (resourceAreas === void 0) {
            throw new Error(`Failed to retrieve resource areas ' + 'from server: ${serverUrl}`);
          }
          if (!resourceAreas || resourceAreas.length === 0 || resourceAreas.count === 0) {
            return serverUrl;
          }
          for (var resourceArea of resourceAreas) {
            if (resourceArea.id.toLowerCase() === resourceId.toLowerCase()) {
              return resourceArea.locationUrl;
            }
          }
          throw new Error(`Could not find information for resource area ${resourceId} ' + 'from server: ${serverUrl}`);
        });
      }
      _getResourceAreas() {
        return __awaiter2(this, void 0, void 0, function* () {
          if (!this._resourceAreas) {
            const locationClient = yield this.getLocationsApi();
            this._resourceAreas = yield locationClient.getResourceAreas();
          }
          return this._resourceAreas;
        });
      }
      _readTaskLibSecrets(lookupKey) {
        if (isBrowser) {
          throw new Error("Browsers can't securely keep secrets");
        }
        if (lookupKey && lookupKey.indexOf(":") > 0) {
          let lookupInfo = lookupKey.split(":", 2);
          let keyFile = new Buffer(lookupInfo[0], "base64").toString("utf8");
          let encryptKey = new Buffer(fs3.readFileSync(keyFile, "utf8"), "base64");
          let encryptedContent = new Buffer(lookupInfo[1], "base64").toString("utf8");
          let decipher = crypto.createDecipher("aes-256-ctr", encryptKey);
          let decryptedContent = decipher.update(encryptedContent, "hex", "utf8");
          decryptedContent += decipher.final("utf8");
          return decryptedContent;
        }
      }
    };
    exports2.WebApi = WebApi;
  }
});

// lib/gitApiProvider.js
var require_gitApiProvider = __commonJS({
  "lib/gitApiProvider.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result2 = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding2(result2, mod, k[i]);
        }
        __setModuleDefault2(result2, mod);
        return result2;
      };
    }();
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getGitApi = getGitApi;
    var azdev = __importStar2(require_WebApi());
    var utils_12 = require_utils4();
    var gitApi = null;
    function initApi() {
      return __awaiter2(this, void 0, void 0, function* () {
        const orgUrl = (0, utils_12.getVariable)("System.TeamFoundationCollectionUri");
        const token = (0, utils_12.getVariable)("System.AccessToken");
        const authHandler = azdev.getPersonalAccessTokenHandler(token);
        const webApi = new azdev.WebApi(orgUrl, authHandler);
        const api = yield webApi.getGitApi();
        gitApi = api;
        return api;
      });
    }
    function getGitApi() {
      return __awaiter2(this, void 0, void 0, function* () {
        const api = gitApi;
        if (!api) {
          return yield initApi();
        } else {
          return api;
        }
      });
    }
  }
});

// lib/output.js
var require_output = __commonJS({
  "lib/output.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result2 = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding2(result2, mod, k[i]);
        }
        __setModuleDefault2(result2, mod);
        return result2;
      };
    }();
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.VIEW_REPORT_OPTIONS = exports2.DEPENDENCY_CHARS_LIMIT = void 0;
    exports2.publishOutput = publishOutput;
    exports2.prFixesBody = prFixesBody;
    var tl2 = __importStar2(require("azure-pipelines-task-lib/task"));
    var qodana_12 = (init_qodana(), __toCommonJS(qodana_exports));
    var utils_12 = require_utils4();
    var output_12 = (init_output(), __toCommonJS(output_exports));
    exports2.DEPENDENCY_CHARS_LIMIT = 15e4;
    exports2.VIEW_REPORT_OPTIONS = `To be able to view the detailed Qodana report, you can either:
  - Register at [Qodana Cloud](https://qodana.cloud/) and [configure the task](https://www.jetbrains.com/help/qodana/qodana-azure-pipelines.html#Qodana+Cloud)
  - Use [SARIF SAST Scans Tab](https://marketplace.visualstudio.com/items?itemName=sariftools.scans) extension to display report summary in Azure DevOps UI in 'Scans' tab
  - Inspect and use \`qodana.sarif.json\` (see [the Qodana SARIF format](https://www.jetbrains.com/help/qodana/qodana-sarif-output.html#Report+structure) for details)

To get \`*.log\` files or any other Qodana artifacts, run the task with \`uploadResult\` option set to \`true\`, 
so that the action will upload the files as the job artifacts:
\`\`\`yaml
        - task: QodanaScan@${qodana_12.VERSION}
          inputs:
            uploadResult: true
\`\`\`
`;
    function publishOutput(projectDir, sourceDir, resultsDir, postComment, isPrMode, execute) {
      return __awaiter2(this, void 0, void 0, function* () {
        var _a, _b;
        if (!execute) {
          return;
        }
        try {
          const problems = (0, utils_12.parseSarif)(`${resultsDir}/${qodana_12.QODANA_SARIF_NAME}`);
          const reportUrl = (0, output_12.getReportURL)(resultsDir);
          const coverageInfo = (0, output_12.getCoverageStats)((0, qodana_12.getCoverageFromSarif)(`${resultsDir}/${qodana_12.QODANA_SHORT_SARIF_NAME}`));
          const licensesInfo = (0, output_12.getLicenseInfo)(resultsDir);
          const problemsDescriptions = (_a = problems.problemDescriptions) !== null && _a !== void 0 ? _a : [];
          const toolName = (_b = problems.title.split("found by ")[1]) !== null && _b !== void 0 ? _b : output_12.QODANA_CHECK_NAME;
          problems.summary = (0, output_12.getSummary)(toolName, projectDir, sourceDir, problemsDescriptions, coverageInfo, licensesInfo.packages, licensesInfo.licenses, reportUrl, isPrMode, exports2.DEPENDENCY_CHARS_LIMIT, exports2.VIEW_REPORT_OPTIONS);
          (0, utils_12.postSummary)(problems.summary);
          yield (0, utils_12.postResultsToPRComments)(toolName, sourceDir, problems.summary, problemsDescriptions.length != 0, postComment);
        } catch (error) {
          tl2.warning(`Qodana has problems with publishing results to Azure \u2013 ${error.message}`);
        }
      });
    }
    function prFixesBody(jobUrl) {
      return ` \u{1F590} Hey there!

This pull request has been auto-generated by the [Qodana Scan task](<${jobUrl}>) configured in your repository.
It has performed code analysis and applied some suggested fixes to improve your code quality \u{1F9F9}\u2728

> **Warning**
>  It's crucial to review these changes to ensure everything shipshape manually. Please take a moment to examine the changes here. Remember to run your integration tests against this PR to validate the fixes and ensure everything's functioning as expected.

_\u{1F4BB}\u{1F50D} Happy reviewing and testing!
Best,
[Qodana Scan \u{1F916}](https://marketplace.visualstudio.com/items?itemName=JetBrains.qodana)_`;
    }
  }
});

// lib/utils.js
var require_utils4 = __commonJS({
  "lib/utils.js"(exports2) {
    "use strict";
    var __createBinding2 = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault2 = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = exports2 && exports2.__importStar || /* @__PURE__ */ function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result2 = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding2(result2, mod, k[i]);
        }
        __setModuleDefault2(result2, mod);
        return result2;
      };
    }();
    var __awaiter2 = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject2) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject2(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject2(e);
          }
        }
        function step(result2) {
          result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.setFailed = setFailed;
    exports2.getInputs = getInputs;
    exports2.qodana = qodana;
    exports2.prepareAgent = prepareAgent;
    exports2.uploadArtifacts = uploadArtifacts;
    exports2.uploadSarif = uploadSarif;
    exports2.parseSarif = parseSarif;
    exports2.getWorkflowRunUrl = getWorkflowRunUrl;
    exports2.postResultsToPRComments = postResultsToPRComments;
    exports2.findCommentByTag = findCommentByTag;
    exports2.getVariable = getVariable;
    exports2.postSummary = postSummary;
    exports2.pushQuickFixes = pushQuickFixes;
    var tl2 = __importStar2(require("azure-pipelines-task-lib/task"));
    var tool = __importStar2(require_tool());
    var node_stream_1 = require("node:stream");
    var fs_1 = __importDefault(require("fs"));
    var path_1 = __importDefault(require("path"));
    var GitInterfaces = __importStar2(require_GitInterfaces());
    var qodana_12 = (init_qodana(), __toCommonJS(qodana_exports));
    var output_12 = (init_output(), __toCommonJS(output_exports));
    var utils_12 = (init_utils(), __toCommonJS(utils_exports));
    var gitApiProvider_1 = require_gitApiProvider();
    var output_2 = require_output();
    function setFailed(message) {
      tl2.setResult(tl2.TaskResult.Failed, message);
    }
    function getInputs() {
      const home = path_1.default.join(process.env["AGENT_TEMPDIRECTORY"], "qodana");
      return {
        args: (tl2.getInput("args", false) || "").split(",").map((arg) => arg.trim()),
        resultsDir: tl2.getInput("resultsDir", false) || path_1.default.join(home, "results"),
        cacheDir: tl2.getInput("cacheDir", false) || path_1.default.join(home, "cache"),
        uploadResult: tl2.getBoolInput("uploadResult", false),
        uploadSarif: tl2.getBoolInput("uploadSarif", false),
        artifactName: tl2.getInput("artifactName", false) || "qodana-report",
        useNightly: tl2.getBoolInput("useNightly", false),
        prMode: tl2.getBoolInput("prMode", true),
        postComment: tl2.getBoolInput("postPrComment", false),
        pushFixes: tl2.getInput("pushFixes", false) || "none",
        commitMessage: tl2.getInput("commitMessage", false) || "\u{1F916} Apply quick-fixes by Qodana",
        // Not used by the Azure task
        additionalCacheKey: "",
        primaryCacheKey: "",
        useAnnotations: false,
        useCaches: false,
        cacheDefaultBranchOnly: false,
        githubToken: ""
      };
    }
    function qodana() {
      return __awaiter2(this, arguments, void 0, function* (args = []) {
        const env = Object.assign(Object.assign({}, process.env), { NONINTERACTIVE: "1" });
        if (args.length === 0) {
          const inputs = getInputs();
          args = (0, qodana_12.getQodanaScanArgs)(inputs.args, inputs.resultsDir, inputs.cacheDir);
          if (inputs.prMode && tl2.getVariable("Build.Reason") === "PullRequest") {
            const sha = yield getPrSha();
            if (sha !== "") {
              args.push("--commit", sha);
              const sourceBranch = process.env.QODANA_BRANCH || getSourceAndTargetBranches().sourceBranch;
              if (sourceBranch) {
                env.QODANA_BRANCH = sourceBranch;
              }
            }
          }
        }
        return yield tl2.execAsync(qodana_12.EXECUTABLE, args, {
          ignoreReturnCode: true,
          env
        });
      });
    }
    function prepareAgent(args_1) {
      return __awaiter2(this, arguments, void 0, function* (args, useNightly = false) {
        const arch = (0, qodana_12.getProcessArchName)();
        const platform = (0, qodana_12.getProcessPlatformName)();
        const temp = yield tool.downloadTool((0, qodana_12.getQodanaUrl)(arch, platform, useNightly));
        if (!useNightly) {
          const expectedChecksum = (0, qodana_12.getQodanaSha256)(arch, platform);
          const actualChecksum = (0, qodana_12.sha256sum)(temp);
          if (expectedChecksum !== actualChecksum) {
            setFailed((0, qodana_12.getQodanaSha256MismatchMessage)(expectedChecksum, actualChecksum));
          }
        }
        let extractRoot;
        if (process.platform === "win32") {
          extractRoot = yield tool.extractZip(temp);
        } else {
          extractRoot = yield tool.extractTar(temp);
        }
        tool.prependPath(yield tool.cacheDir(extractRoot, qodana_12.EXECUTABLE, qodana_12.VERSION));
        if (!(0, qodana_12.isNativeMode)(args)) {
          const pull = yield qodana((0, qodana_12.getQodanaPullArgs)(args));
          if (pull !== 0) {
            setFailed("Unable to run 'qodana pull'");
          }
        }
      });
    }
    function uploadArtifacts(resultsDir, artifactName, execute) {
      return __awaiter2(this, void 0, void 0, function* () {
        if (!execute) {
          return;
        }
        try {
          const workingDir = path_1.default.dirname(resultsDir);
          const archivePath = path_1.default.join(workingDir, `${artifactName}.zip`);
          yield (0, qodana_12.compressFolder)(resultsDir, archivePath);
          tl2.uploadArtifact("Qodana", archivePath, artifactName);
        } catch (error) {
          tl2.warning(`Failed to upload report \u2013 ${error.message}`);
        }
      });
    }
    function uploadSarif(resultsDir, execute) {
      if (!execute) {
        return;
      }
      try {
        const parentDir = path_1.default.dirname(resultsDir);
        const qodanaSarif = path_1.default.join(parentDir, "qodana.sarif");
        tl2.cp(path_1.default.join(resultsDir, "qodana.sarif.json"), qodanaSarif);
        tl2.uploadArtifact("CodeAnalysisLogs", qodanaSarif, "CodeAnalysisLogs");
      } catch (error) {
        tl2.warning(`Failed to upload SARIF \u2013 ${error.message}`);
      }
    }
    function getSourceAndTargetBranches() {
      var _a, _b;
      const sourceBranch = (_a = tl2.getVariable("System.PullRequest.SourceBranch")) === null || _a === void 0 ? void 0 : _a.replace("refs/heads/", "");
      const targetBranch = (_b = tl2.getVariable("System.PullRequest.TargetBranch")) === null || _b === void 0 ? void 0 : _b.replace("refs/heads/", "");
      return { sourceBranch, targetBranch };
    }
    function getPrSha() {
      return __awaiter2(this, void 0, void 0, function* () {
        if (process.env.QODANA_PR_SHA) {
          return process.env.QODANA_PR_SHA;
        }
        const { sourceBranch, targetBranch } = getSourceAndTargetBranches();
        if (sourceBranch && targetBranch) {
          yield git(["fetch", "origin"]);
          const output = yield gitOutput(["merge-base", "origin/" + sourceBranch, "origin/" + targetBranch], {
            ignoreReturnCode: true
          });
          if (output.exitCode === 0) {
            return output.stdout.trim();
          }
        }
        return "";
      });
    }
    function git(args_1) {
      return __awaiter2(this, arguments, void 0, function* (args, options = {}) {
        return (yield gitOutput(args, options)).exitCode;
      });
    }
    function gitOutput(args_1) {
      return __awaiter2(this, arguments, void 0, function* (args, options = {}) {
        const result2 = {
          exitCode: 0,
          stdout: "",
          stderr: ""
        };
        const outStream = new node_stream_1.Writable({
          write(chunk2, _3, callback) {
            result2.stdout += chunk2.toString("utf8");
            callback();
          }
        });
        const errStream = new node_stream_1.Writable({
          write(chunk2, _3, callback) {
            result2.stderr += chunk2.toString("utf8");
            callback();
          }
        });
        options.outStream = outStream;
        options.errStream = errStream;
        result2.exitCode = yield tl2.execAsync("git", args, options).catch((error) => {
          tl2.warning(`Failed to run git command with arguments: ${args.join(" ")}`);
          throw error;
        });
        result2.stdout = result2.stdout.replace("[command]/usr/bin/git " + args.join(" "), "").trim();
        return result2;
      });
    }
    function getQodanaHelpString() {
      return `This result was published with [Qodana Task](<${getWorkflowRunUrl()}>)`;
    }
    function parseSarif(path2) {
      var _a;
      const sarif = JSON.parse(fs_1.default.readFileSync(path2, { encoding: "utf8" }));
      const run = sarif.runs[0];
      const rules = (0, utils_12.parseRules)(run.tool);
      let title = "No new problems found by ";
      let problemDescriptions = [];
      if ((_a = run.results) === null || _a === void 0 ? void 0 : _a.length) {
        title = `${run.results.length} ${(0, output_12.getProblemPlural)(run.results.length)} found by `;
        problemDescriptions = run.results.filter((result2) => result2.baselineState !== "unchanged" && result2.baselineState !== "absent").map((result2) => (0, output_12.parseResult)(result2, rules)).filter((a) => a !== null && a !== void 0);
      }
      const name = run.tool.driver.fullName || "Qodana";
      title += name;
      return {
        title,
        text: getQodanaHelpString(),
        summary: title,
        problemDescriptions
      };
    }
    function getWorkflowRunUrl() {
      const serverUri = process.env.SYSTEM_TEAMFOUNDATIONSERVERURI;
      const projectName = process.env.SYSTEM_TEAMPROJECT;
      const buildId = process.env.BUILD_BUILDID;
      return `${serverUri}${projectName}/_build/results?buildId=${buildId}`;
    }
    function postResultsToPRComments(toolName, sourceDir, content, hasIssues, postComment) {
      return __awaiter2(this, void 0, void 0, function* () {
        try {
          if (!postComment) {
            return;
          }
          const comment_tag_pattern = `<!-- JetBrains/qodana-action@v${qodana_12.VERSION} : ${toolName}, ${sourceDir} -->`;
          const body = `${content}
${comment_tag_pattern}`;
          const pullRequestId = parseInt(getVariable("System.PullRequest.PullRequestId"), 10);
          const project = getVariable("System.TeamProject");
          const repoId = getVariable("Build.Repository.Id");
          const gitApi = yield (0, gitApiProvider_1.getGitApi)();
          const { thread, comment } = yield findCommentByTag(comment_tag_pattern);
          const newComment = {
            content: body
          };
          if ((comment === null || comment === void 0 ? void 0 : comment.id) === void 0 || (thread === null || thread === void 0 ? void 0 : thread.id) === void 0) {
            const thread2 = {
              comments: [newComment],
              status: hasIssues ? GitInterfaces.CommentThreadStatus.Active : GitInterfaces.CommentThreadStatus.ByDesign
            };
            yield gitApi.createThread(thread2, repoId, pullRequestId, project);
          } else {
            const threadStatusUpdated = {
              status: hasIssues ? GitInterfaces.CommentThreadStatus.Active : GitInterfaces.CommentThreadStatus.ByDesign
            };
            yield gitApi.updateThread(threadStatusUpdated, repoId, pullRequestId, thread.id, project);
            yield gitApi.updateComment(newComment, repoId, pullRequestId, thread.id, comment.id, project);
          }
        } catch (error) {
          tl2.warning(`Failed to post results to comment: ${error.message}`);
        }
      });
    }
    function findCommentByTag(tag) {
      return __awaiter2(this, void 0, void 0, function* () {
        var _a;
        try {
          const gitApi = yield (0, gitApiProvider_1.getGitApi)();
          const project = getVariable("System.TeamProject");
          const repoId = getVariable("Build.Repository.Id");
          const pullRequestId = parseInt(getVariable("System.PullRequest.PullRequestId"), 10);
          const threads = yield gitApi.getThreads(repoId, pullRequestId, project);
          for (const thread of threads) {
            const comment = (_a = thread.comments) === null || _a === void 0 ? void 0 : _a.find((comment2) => {
              var _a2;
              return (_a2 = comment2.content) === null || _a2 === void 0 ? void 0 : _a2.includes(tag);
            });
            if (comment != void 0) {
              return { thread, comment };
            }
          }
          return { thread: void 0, comment: void 0 };
        } catch (error) {
          tl2.debug(`Failed to find comment by tag \u2013 ${error.message}`);
          return { thread: void 0, comment: void 0 };
        }
      });
    }
    function getVariable(name) {
      const result2 = tl2.getVariable(name);
      if (!result2) {
        throw new Error(`Variable ${name} is not set`);
      }
      return result2;
    }
    function postSummary(summary) {
      const tempDir = getVariable("Agent.TempDirectory");
      const filePath = path_1.default.join(tempDir, "Qodana Task Summary.md");
      fs_1.default.writeFileSync(filePath, summary);
      tl2.uploadSummary(filePath);
    }
    function pushQuickFixes(mode, commitMessage) {
      return __awaiter2(this, void 0, void 0, function* () {
        if (mode === qodana_12.NONE) {
          return;
        }
        try {
          const pullRequest = tl2.getVariable("Build.Reason") === "PullRequest";
          let currentBranch;
          if (pullRequest) {
            currentBranch = getVariable("System.PullRequest.SourceBranch");
          } else {
            currentBranch = getVariable("Build.SourceBranch");
          }
          currentBranch = currentBranch.replace("refs/heads/", "");
          currentBranch = (0, qodana_12.validateBranchName)(currentBranch);
          const currentCommit = (yield gitOutput(["rev-parse", "HEAD"])).stdout.trim();
          yield git(["config", "user.name", output_12.COMMIT_USER]);
          yield git(["config", "user.email", output_12.COMMIT_EMAIL]);
          yield git(["add", "."]);
          let exitCode = yield git(["commit", "-m", commitMessage], {
            ignoreReturnCode: true
          });
          if (exitCode !== 0) {
            return;
          }
          exitCode = yield git(["pull", "--rebase", "origin", currentBranch]);
          if (exitCode !== 0) {
            return;
          }
          if (mode === qodana_12.BRANCH) {
            if (pullRequest) {
              const commitToCherryPick = (yield gitOutput(["rev-parse", "HEAD"])).stdout.trim();
              yield git(["checkout", currentBranch]);
              yield git(["cherry-pick", commitToCherryPick]);
            }
            yield gitPush(currentBranch);
          } else if (mode === qodana_12.PULL_REQUEST) {
            const newBranch = `qodana/quick-fixes-${currentCommit.slice(0, 7)}`;
            yield git(["checkout", "-b", newBranch]);
            yield gitPush(newBranch);
            yield createPr(commitMessage, currentBranch, newBranch);
          }
        } catch (error) {
          tl2.warning(`Failed to push quick fixes \u2013 ${error.message}`);
        }
      });
    }
    function gitPush(branch) {
      return __awaiter2(this, void 0, void 0, function* () {
        const output = yield gitOutput(["push", "origin", branch], {
          ignoreReturnCode: true
        });
        if (output.exitCode == 1) {
          tl2.warning(`Branch ${branch} already exists. Push of quick-fixes was skipped.`);
        } else if (output.exitCode !== 0) {
          tl2.warning(`Failed to push branch ${branch}: ${output.stderr}`);
        }
      });
    }
    function createPr(title, base, head) {
      return __awaiter2(this, void 0, void 0, function* () {
        if (!head.startsWith("refs/heads/")) {
          head = "refs/heads/" + head;
        }
        if (!base.startsWith("refs/heads/")) {
          base = "refs/heads/" + base;
        }
        const description = (0, output_2.prFixesBody)(getWorkflowRunUrl());
        const gitApi = yield (0, gitApiProvider_1.getGitApi)();
        const project = getVariable("System.TeamProject");
        const repoId = getVariable("Build.Repository.Id");
        const pr = {
          sourceRefName: head,
          targetRefName: base,
          title,
          description
        };
        try {
          yield gitApi.createPullRequest(pr, repoId, project);
        } catch (error) {
          tl2.warning(`Failed to create pull request ${head} -> ${base}: ${error.message}`);
        }
      });
    }
  }
});

// lib/main.js
var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc = Object.getOwnPropertyDescriptor(m, k);
  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
    desc = { enumerable: true, get: function() {
      return m[k];
    } };
  }
  Object.defineProperty(o, k2, desc);
} : function(o, m, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m[k];
});
var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar = exports && exports.__importStar || /* @__PURE__ */ function() {
  var ownKeys = function(o) {
    ownKeys = Object.getOwnPropertyNames || function(o2) {
      var ar = [];
      for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
      return ar;
    };
    return ownKeys(o);
  };
  return function(mod) {
    if (mod && mod.__esModule) return mod;
    var result2 = {};
    if (mod != null) {
      for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result2, mod, k[i]);
    }
    __setModuleDefault(result2, mod);
    return result2;
  };
}();
var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject2) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject2(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject2(e);
      }
    }
    function step(result2) {
      result2.done ? resolve(result2.value) : adopt(result2.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
Object.defineProperty(exports, "__esModule", { value: true });
var tl = __importStar(require("azure-pipelines-task-lib/task"));
var qodana_1 = (init_qodana(), __toCommonJS(qodana_exports));
var utils_1 = require_utils4();
var output_1 = require_output();
process.on("uncaughtException", (e) => tl.warning(e.message));
function main() {
  return __awaiter(this, void 0, void 0, function* () {
    try {
      const inputs = (0, utils_1.getInputs)();
      tl.mkdirP(inputs.resultsDir);
      tl.mkdirP(inputs.cacheDir);
      yield (0, utils_1.prepareAgent)(inputs.args, inputs.useNightly);
      const exitCode = yield (0, utils_1.qodana)();
      yield Promise.all([
        (0, utils_1.pushQuickFixes)(inputs.pushFixes, inputs.commitMessage),
        (0, utils_1.uploadArtifacts)(inputs.resultsDir, inputs.artifactName, inputs.uploadResult),
        (0, output_1.publishOutput)((0, qodana_1.extractArg)("-i", "--project-dir", inputs.args), (0, qodana_1.extractArg)("-d", "--source-directory", inputs.args), inputs.resultsDir, inputs.postComment, inputs.prMode, (0, qodana_1.isExecutionSuccessful)(exitCode))
      ]);
      (0, utils_1.uploadSarif)(inputs.resultsDir, inputs.uploadSarif);
      if (!(0, qodana_1.isExecutionSuccessful)(exitCode)) {
        (0, utils_1.setFailed)(`qodana scan failed with exit code ${exitCode}`);
      } else if (exitCode === qodana_1.QodanaExitCode.FailThreshold) {
        (0, utils_1.setFailed)(qodana_1.FAIL_THRESHOLD_OUTPUT);
      }
    } catch (error) {
      (0, utils_1.setFailed)(error.message);
    }
  });
}
void main();
/*! Bundled license information:

js-md4/src/md4.js:
  (**
   * [js-md4]{@link https://github.com/emn178/js-md4}
   *
   * @namespace md4
   * @version 0.3.2
   * @author Yi-Cyuan Chen [emn178@gmail.com]
   * @copyright Yi-Cyuan Chen 2015-2027
   * @license MIT
   *)
*/
